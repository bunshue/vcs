// *****************************************************
// Dependencies
// *****************************************************
#include "xil_cache.h"
#include "platform.h"
#include "main.h"
#include "xuartps_hw.h"
#include "periphs.h"
#include "mixer.h"
#include "gpio.h"
#include "ulpi.h"
#include "sleep.h"

void pixmap_draw(GDisplay* pixmap, pixel_t* surface, coord_t pm_width, coord_t pm_height, gdispImage *p_Image, uint32_t pm_sx, uint32_t pm_sy, uint32_t img_sx, uint32_t img_sy);

volatile uint32_t g_ms_tick = 0;

static GDisplay* pixmap_1;
static pixel_t* surface_1;

// *****************************************************
// Main program entry point
// *****************************************************
int main()
{
	// Local variables
	int status = 0;

	// Setup UART and caches
    init_platform();

    xil_printf("Aries Main Program\n\r");

    // Initialize peripherals
    status = periphs_init
    (
    	&periphs_inst,
		XPAR_PS7_GPIO_0_DEVICE_ID,
		XPAR_VIDEO_PATH_VIDEO_OUT_VIDEO_LOCK_MONITOR_VS_MIXER_SW_RST_DEVICE_ID,
		XPAR_PS7_SCUGIC_0_DEVICE_ID,
		XPAR_PS7_SCUTIMER_0_DEVICE_ID,
		XPAR_PS7_UART_0_DEVICE_ID,
		XPAR_VIDEO_PATH_V_TPG_0_DEVICE_ID,
		XPAR_VIDEO_PATH_CAMERA_SCALER_FREEZE_V_PROC_SS_1_DEVICE_ID,
		XPAR_VIDEO_PATH_FRAMEBUFFER_AXI_VDMA_CAMERA_DEVICE_ID,
		XPAR_VIDEO_PATH_FRAMEBUFFER_AXI_VDMA_CAMERA_FREEZE_DEVICE_ID,
		XPAR_VIDEO_PATH_OUTPUT_MIXER_V_MIX_0_DEVICE_ID,
		XPAR_VIDEO_PATH_VIDEO_OUT_V_TC_TFP410_DEVICE_ID,
		XPAR_VIDEO_PATH_VIDEO_OUT_V_TC_CH7038_DEVICE_ID,
		XPAR_PS7_USB_0_DEVICE_ID,
    	FRAMEBUFFER_CAMERA_START_ADDR,
		FRAMEBUFFER_CAMERA_FREEZE_START_ADDR,
		FRAMEBUFFER_GUI_START_ADDR
    );
	if (status != 0)
    {
		xil_printf("Initialization failed.\n\r");
		return -1;
    }

	Xil_DCacheEnable();

    // Initialize uGFX
    gfxInit();
    xil_printf("gfxInit() complete\r\n");
	// Background process
	xil_printf("Initialization complete. Switching to background process.\n\r");

	// Set up pixmap for layer 1
    pixmap_1 = gdispPixmapCreate(LAYER1_WIDTH, LAYER1_HEIGHT);
    surface_1 = gdispPixmapGetBits(pixmap_1);
    // Draw transparency required on layer 1
    pixmap_draw(pixmap_1, surface_1, LAYER1_WIDTH, LAYER1_HEIGHT, NULL, 0, 0, 0, 0);

	Xil_DCacheFlush();

	// Set up Mixer Layers
	RunMixer(periphs_inst.p_vid_output_mixer_l2_inst);

	//pixmap_draw(pixmap_1, surface_1, LAYER1_WIDTH, LAYER1_HEIGHT, NULL, 0, 0, 0, 0);
	gdispBlitArea(LAYER0_WIDTH-LAYER1_WIDTH-BORDER_X, BORDER_Y, LAYER1_WIDTH, LAYER1_HEIGHT, surface_1);
	Xil_DCacheFlush();

	XVMix_LayerEnable(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_1);

	Xil_DCacheFlush();

	Xil_DCacheDisable();

	psuart0_exposure(3);

	while(1)
	{
		usleep(200);
	}

    cleanup_platform();
    return 0;
}

void pixmap_draw(GDisplay* pixmap, pixel_t* surface, coord_t pm_width, coord_t pm_height, gdispImage *p_Image, uint32_t pm_sx, uint32_t pm_sy, uint32_t img_sx, uint32_t img_sy)
{
	uint32_t i, j, status;
	//color_t color = 0;

	//xil_printf("enter pixmap_draw\r\n");
	// Clear pixmap with 0
	memset(surface, 0, pm_width*pm_height*4); // Clear buffer

	// Overlay file is necessary
	if(p_Image != NULL) {
		// Load image
		status = gdispGImageDraw(pixmap, p_Image, (pm_width-p_Image->width) >> 1, (pm_height-p_Image->height) >> 1, p_Image->width, p_Image->height, 0, 0);
		//xil_printf("status draw: %d\r\n", status);
	}

    // Draw transparency required on layer 1
    for(j = 0; j < pm_height; j++) {
    	for(i = 0; i < pm_width; i++) {

    		if((j > (1.5*(pm_height >> 3)-1)) && (j < (pm_height-1.5*(pm_height >> 3)))) {
    			//color = gdisp_lld_get_pixel_color(pixmap);
    			//xil_printf("color: %x\r\n", color);
    			if(surface[j*pm_width + i] == 0) {
    				surface[j*pm_width + i] = ABGR2COLOR(0x00, 0x00, 0x00, 0x00);
    			}
//    			else {
    				//surface[j*pm_width + i] = ABGR2COLOR(0x00, 0x00, 0x00, 0x00);
    			//}

    		}
    		else {

				if(j < 1.5*(pm_height >> 3)) { // Top lines

					if (  (i < (1.5*(pm_height >> 3)-j)) || (i > ((pm_width-1.5*(pm_height >> 3))-1+j)    )  ) {
    					surface[j*pm_width + i] = ABGR2COLOR(0x80, 0xff, 0xff, 0xff);
    					//xil_printf("c: %x\r\n", surface_1[j*PIXMAP_WIDTH_1 + i]);
    				}
    				else {
    	    			//if(surface[j*pm_width + i] == 0) {
    	    				surface[j*pm_width + i] = ABGR2COLOR(0x00, 0x00, 0x00, 0x00);
    	    			//}
    				}

				}
				else { // Bottom lines

					if( (i < (j+1.5*(pm_height >> 3)-pm_height) ) || i > ((pm_width-(1.5*(pm_height >> 3)-(pm_height-j)))-1) ){
						surface[j*pm_width + i] = ABGR2COLOR(0x80, 0xff, 0xff, 0xff);
					}
					else {
    	    			if(surface[j*pm_width + i] == 0) {
    	    				surface[j*pm_width + i] = ABGR2COLOR(0x00, 0x00, 0x00, 0x00);
    	    			}
					}
				}
     		}
    	}
    }
}

// uGFX SystemTick
systemticks_t gfxSystemTicks(void)
{
	return g_ms_tick;
}

systemticks_t gfxMillisecondsToTicks(delaytime_t ms)
{
	return ms;
}
/////////////////////////////////////

uint32_t tusb_tick_get(void)
{
  //return system_ticks;
  return g_ms_tick;
}






