
// *****************************************************
// Dependencies
// *****************************************************
#include "gpio.h"
#include "psuart0.h"
#include "main.h"

uint32_t g_metering_mode = 0; // Auto = 0, Center = 1, Average = 2;
volatile uint32_t g_updated = 0;

// *****************************************************
// Private functions
// *****************************************************

/****************************************************************************/
/**
* This function is the user layer callback function for the bank 2 interrupts of
* the GPIO device. It checks if all the switches have been pressed to stop the
* interrupt processing and exit from the example.
*
* @param	CallBackRef is a pointer to the upper layer callback reference.
* @param	Status is the Interrupt status of the GPIO bank.
*
* @return	None.
*
* @note		None.
*
******************************************************************************/
void ps_gpio_IntrHandler(void *CallBackRef, u32 Bank, u32 Status)
{
	XGpioPs *Gpio = (XGpioPs *)CallBackRef;
	u32 DataRead;
	// Clear interrupt
	//xil_printf("Bank: %x\r\n", Bank);
	int do_usb_reset = 0;

	//xil_printf("david1206: %s:%s(%d) ST xxxxxxxxxxxxxxxxxx\r\n", __FILE__, __func__, __LINE__);

	// Block Bank0 and Bank1 interrupts, this might be a SDK bug, do not take away until verified
	if(Bank != XGPIOPS_BANK2) {
		return;
	}

	DataRead = XGpioPs_Read(Gpio, XGPIOPS_BANK2);

	if(Status & SW_SMART)
	{
		unsigned int status;

//		//xil_printf("SMART\r\n");
//		// Return to Auto Mode
//		// Initial Sensor/FPGA
//		// Turn on AUTO LIGHT
//		XGpioPs_WritePin(Gpio, GPIO_LED_CEN, 0);
//		XGpioPs_WritePin(Gpio, GPIO_LED_AVG, 0);
//		XGpioPs_WritePin(Gpio, GPIO_LED_AUTO, 1);
//		XGpioPs_WritePin(Gpio, GPIO_LED_1, 0);
//		XGpioPs_WritePin(Gpio, GPIO_LED_2, 0);
//		XGpioPs_WritePin(Gpio, GPIO_LED_3, 1);
//		XGpioPs_WritePin(Gpio, GPIO_LED_4, 0);
//		XGpioPs_WritePin(Gpio, GPIO_LED_5, 0);
//		g_metering_mode = 0;
//		g_exposure = 3;
		if(g_procedure_started){
			status = XVMix_IsLayerEnabled(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_1);
			if(status) { // Enabled
				periphs_toggle_camera_freeze_vdma(&periphs_inst);
				// Determine if we're in TPG or passthrough mode
				if (periphs_inst.enable_camera_freeze_vdma == PERIPHS_SEL_ENABLE_PARK)
				{
					XVMix_LayerEnable(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_2);
					// Turn on Red light
					XGpioPs_WritePin(Gpio, GPIO_LED_RED, 1);
				}
				else
				{
					XVMix_LayerDisable(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_2);
					// Turn off red light
					XGpioPs_WritePin(Gpio, GPIO_LED_RED, 0);
				}
			}
		}

	}
	else if (Status & SW_START) {
		/*
		uint32_t status = 0;

		// Check if we are in a active session
		if(g_procedure_started) { // We are in a active session
			xil_printf("turn off\r\n");
			g_updated = 1;
			g_procedure_started = 0;
		}
		else {
			xil_printf("turn on\r\n");
			g_updated = 1;
			g_procedure_started = 1;
			// We are not in a active session, start session
		//	XVMix_LayerEnable(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_1);

		}
		*/

//		status = XVMix_IsLayerEnabled(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_1);
//		if(status) { // Enabled
//
//			status = XVMix_IsLayerEnabled(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_2);
//			if(status ) {
//				XVMix_LayerDisable(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_2);
//				periphs_toggle_camera_freeze_vdma(&periphs_inst);
//				XGpioPs_WritePin(Gpio, GPIO_LED_RED, 0);
//			}
//
//		}

	}
	else if (Status & SW_METER) {
		xil_printf("METER\r\n");

		/*
		if(flag_updateConsoleWidgets == 0)
			flag_updateConsoleWidgets = 1;
		else
			flag_updateConsoleWidgets = 0;
		*/
		do_usb_reset = 1;

		switch(g_metering_mode) {

			case 0:
				g_metering_mode = 1;
				XGpioPs_WritePin(Gpio, GPIO_LED_CEN, 1);
				XGpioPs_WritePin(Gpio, GPIO_LED_AVG, 0);
				XGpioPs_WritePin(Gpio, GPIO_LED_AUTO, 0);
				xil_printf("Center\r\n");
				break;
			case 1:
				g_metering_mode = 2;
				XGpioPs_WritePin(Gpio, GPIO_LED_CEN, 0);
				XGpioPs_WritePin(Gpio, GPIO_LED_AVG, 1);
				XGpioPs_WritePin(Gpio, GPIO_LED_AUTO, 0);
				xil_printf("Average\r\n");
				break;

			case 2:
				g_metering_mode = 0;
				XGpioPs_WritePin(Gpio, GPIO_LED_CEN, 0);
				XGpioPs_WritePin(Gpio, GPIO_LED_AVG, 0);
				XGpioPs_WritePin(Gpio, GPIO_LED_AUTO, 1);
				xil_printf("Auto\r\n");
				break;

			default:
				xil_printf("METER Function Error\r\n");
				break;
		}

	}
	else if (Status & SW_DARKEN) {
		xil_printf("DARKEN %d\r\n", going_to_engineering_mode_cnt);

		if(going_to_engineering_mode_cnt > 3)
		{
			flag_engineering_mode = 1;
			xil_printf("Engineering Mode...........\r\n");
			xil_printf("Engineering Mode...........\r\n");
			xil_printf("Engineering Mode...........\r\n");
			xil_printf("Engineering Mode...........\r\n");

		}

		// Only lower exposure if at values above 1
		if(g_exposure > 1) {
			g_exposure--;
			flag_setup_exposure = 1;
			//psuart0_exposure(g_exposure);	//moved to main
			switch(g_exposure) {

				case 1:
					XGpioPs_WritePin(Gpio, GPIO_LED_1, 1);
					XGpioPs_WritePin(Gpio, GPIO_LED_2, 0);
					XGpioPs_WritePin(Gpio, GPIO_LED_3, 0);
					XGpioPs_WritePin(Gpio, GPIO_LED_4, 0);
					XGpioPs_WritePin(Gpio, GPIO_LED_5, 0);
					xil_printf("LED_1\r\n");
					break;
				case 2:
					XGpioPs_WritePin(Gpio, GPIO_LED_1, 0);
					XGpioPs_WritePin(Gpio, GPIO_LED_2, 1);
					XGpioPs_WritePin(Gpio, GPIO_LED_3, 0);
					XGpioPs_WritePin(Gpio, GPIO_LED_4, 0);
					XGpioPs_WritePin(Gpio, GPIO_LED_5, 0);
					xil_printf("LED_2\r\n");
					break;

				case 3:
					XGpioPs_WritePin(Gpio, GPIO_LED_1, 0);
					XGpioPs_WritePin(Gpio, GPIO_LED_2, 0);
					XGpioPs_WritePin(Gpio, GPIO_LED_3, 1);
					XGpioPs_WritePin(Gpio, GPIO_LED_4, 0);
					XGpioPs_WritePin(Gpio, GPIO_LED_5, 0);
					xil_printf("LED_3\r\n");
					break;

				case 4:
					XGpioPs_WritePin(Gpio, GPIO_LED_1, 0);
					XGpioPs_WritePin(Gpio, GPIO_LED_2, 0);
					XGpioPs_WritePin(Gpio, GPIO_LED_3, 0);
					XGpioPs_WritePin(Gpio, GPIO_LED_4, 1);
					XGpioPs_WritePin(Gpio, GPIO_LED_5, 0);
					xil_printf("LED_4\r\n");
					break;

				case 5:
					XGpioPs_WritePin(Gpio, GPIO_LED_1, 0);
					XGpioPs_WritePin(Gpio, GPIO_LED_2, 0);
					XGpioPs_WritePin(Gpio, GPIO_LED_3, 0);
					XGpioPs_WritePin(Gpio, GPIO_LED_4, 0);
					XGpioPs_WritePin(Gpio, GPIO_LED_5, 1);
					xil_printf("LED_5\r\n");
					break;
				default:
					xil_printf("Darken Function Error\r\n");
					break;
			}
		}

	}
	else if (Status & SW_BRIGHT) {
	/*
		xil_printf("BRIGHT\r\n");
		// Only lower exposure if at values above 1
		if(g_exposure < 5) {
			g_exposure++;
			switch(g_exposure) {

				case 1:
					XGpioPs_WritePin(Gpio, GPIO_LED_1, 1);
					XGpioPs_WritePin(Gpio, GPIO_LED_2, 0);
					XGpioPs_WritePin(Gpio, GPIO_LED_3, 0);
					XGpioPs_WritePin(Gpio, GPIO_LED_4, 0);
					XGpioPs_WritePin(Gpio, GPIO_LED_5, 0);
					xil_printf("LED_1\r\n");
					break;
				case 2:
					XGpioPs_WritePin(Gpio, GPIO_LED_1, 0);
					XGpioPs_WritePin(Gpio, GPIO_LED_2, 1);
					XGpioPs_WritePin(Gpio, GPIO_LED_3, 0);
					XGpioPs_WritePin(Gpio, GPIO_LED_4, 0);
					XGpioPs_WritePin(Gpio, GPIO_LED_5, 0);
					xil_printf("LED_2\r\n");
					break;

				case 3:
					XGpioPs_WritePin(Gpio, GPIO_LED_1, 0);
					XGpioPs_WritePin(Gpio, GPIO_LED_2, 0);
					XGpioPs_WritePin(Gpio, GPIO_LED_3, 1);
					XGpioPs_WritePin(Gpio, GPIO_LED_4, 0);
					XGpioPs_WritePin(Gpio, GPIO_LED_5, 0);
					xil_printf("LED_3\r\n");
					break;

				case 4:
					XGpioPs_WritePin(Gpio, GPIO_LED_1, 0);
					XGpioPs_WritePin(Gpio, GPIO_LED_2, 0);
					XGpioPs_WritePin(Gpio, GPIO_LED_3, 0);
					XGpioPs_WritePin(Gpio, GPIO_LED_4, 1);
					XGpioPs_WritePin(Gpio, GPIO_LED_5, 0);
					xil_printf("LED_4\r\n");
					break;

				case 5:
					XGpioPs_WritePin(Gpio, GPIO_LED_1, 0);
					XGpioPs_WritePin(Gpio, GPIO_LED_2, 0);
					XGpioPs_WritePin(Gpio, GPIO_LED_3, 0);
					XGpioPs_WritePin(Gpio, GPIO_LED_4, 0);
					XGpioPs_WritePin(Gpio, GPIO_LED_5, 1);
					xil_printf("LED_5\r\n");
					break;
				default:
					xil_printf("Bright Function Error\r\n");
					break;
			}
		}
		*/
	}

	//xil_printf("Status_in: %x\r\n", Status);
	/* Push the switch button */
	//DataRead = XGpioPs_ReadPin(Gpio, Input_Pin);

	//xil_printf("data: %x\r\n", DataRead);

//	if (DataRead != 0) {
		//XGpioPs_SetDirectionPin(Gpio, Output_Pin, 1);
		//XGpioPs_SetOutputEnablePin(Gpio, Output_Pin, 1);
		//XGpioPs_WritePin(Gpio, Output_Pin, DataRead);
		//AllButtonsPressed = TRUE;
//	}
	XGpioPs_IntrClear(Gpio, XGPIOPS_BANK2, 0xffffffff);
	//xil_printf("Status_out: %x\r\n", Status);

	if(do_usb_reset ==1)
	{
		xil_printf("usb HW reset\n\r");
		reset_usb();
	}

	/*
	if((Status & SW_SMART) || (Status & SW_METER) || (Status & SW_DARKEN))
		g_updated = 1; // Set updated flag for any keypress
	*/
}

/******************************************************************************/
/**
*
* This is the interrupt handler routine for the video lock monitor
*
* @param	CallbackRef is the Callback reference for the handler.
*
* @return	None.
*
* @note		None.
*
******************************************************************************/

//volatile uint32_t g_ms_tick_tmp = 0;
//int aaa = 0;
void lock_monitor_IntrHandler(void *CallbackRef)
{
	XGpio *lock_mon_Ptr = (XGpio *)CallbackRef;
	unsigned int status;

	//status = XGpio_DiscreteRead(lock_mon_Ptr,  XGPIO_CHANNEL1);
	status = XGpio_DiscreteRead(lock_mon_Ptr,  XGPIO_CHANNEL2);

	// Got Interrupt, Check which interrupt was signaled
	//xil_printf("xxxxxxxxxxxxxxxx    david0906: %s:%s(%d) status = 0x%08x\r\n",__FILE__,__func__,__LINE__, status);
	//xil_printf("lock interrupt!: %x\r\n", status);

	// Clear the Interrupt on XGPIO Channel 1
	XGpio_InterruptClear(lock_mon_Ptr, XGPIO_CHANNEL1);

	/*
	aaa++;
	if((g_ms_tick - g_ms_tick_tmp) >= 10000)
	{
		g_ms_tick_tmp = g_ms_tick;
		xil_printf("%d ", aaa);
		aaa = 0;
	}
	*/

}

