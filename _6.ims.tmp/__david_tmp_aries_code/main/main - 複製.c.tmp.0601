// *****************************************************
// Dependencies
// *****************************************************
//#include <time.h>		//for struct tm
#include "stdlib.h"
#include "sleep.h"
#include "xil_cache.h"
#include "platform.h"
#include "main.h"
#include "xuartps_hw.h"
#include "periphs.h"
#include "mixer.h"
#include "gpio.h"
#include "ulpi.h"
#include "gfx.h"
#include "gdisp_lld_framebuffer.h"	//for gdisp_lld_control test
#include "xdmaps.h"
#include "xadcps.h"
#include "xv_csc_l2.h"//JACKY
//----------------------------------JACKY ADD-------------------------------
/***************************** Include Files ********************************/

#include "xparameters.h"
#include "xgpio.h"
#include "xstatus.h"
#include "xil_printf.h"
//---------------------------------------------------------------------------

#define COLUMN1	320
#define COLUMN2	720 - 100
#define COLUMN3	1120
#define COLUMN4	1620
#define ROW_OFFSET	70
#define ROW0	150
#define ROW1	ROW0 + ROW_OFFSET * 1
#define ROW2	ROW0 + ROW_OFFSET * 2
#define ROW3	ROW0 + ROW_OFFSET * 3
#define ROW4	ROW0 + ROW_OFFSET * 4
#define ROW5	ROW0 + ROW_OFFSET * 5
#define ROW6	ROW0 + ROW_OFFSET * 6
#define ROW7	ROW0 + ROW_OFFSET * 7
#define ROW8	ROW0 + ROW_OFFSET * 8
#define ROW9	ROW0 + ROW_OFFSET * 9
#define ROW10	ROW0 + ROW_OFFSET * 10
#define ROW11	ROW0 + ROW_OFFSET * 11
#define ROW12	ROW0 + ROW_OFFSET * 12

#define LSW 100 //% of 640x480
#define SSW 50  //% of 640x480
#define CENTER 0x014000F0

#define SW_RELEASE

//#define USE_DEBUG_CONSOLE
#define USE_RTC
//#define USE_ANALOG_CLOCK
#define USE_DATA_INPUT		//key in id no, name, sex, age, birthday
#define USE_BARCODE_SCANNER
//#define USE_DEBUG_MESSAGE		//compile count, compile time, temperature....
//#define USE_DEBUG_PICTURE		//camera, recorder
//#define USE_DEBUG_VIDEO_OUTPUT
//#define FREEZE_WHEN_STOP
//#define USE_PREVENT_REUSE
//#define USE_COLOR_DEBUG
//#define USE_AUTO_LIGHT
#define USE_CORRECT_TIME
#define USE_IMS_LINK

//default setup
#define FAN_ON
#define START_STATUS	STOP	//START or STOP

#define USE_Z7020
//#define USE_Z7015
#define USE_CARRIER_BLACK
//#define USE_CARRIER_RED

//#define TEMPERATURE_DEBUG
#define DEBUG_LENGTH		123

#ifdef SW_RELEASE
	#define USE_RTC
	#undef USE_DEBUG_CONSOLE
	#undef USE_DEBUG_PICTURE
	#undef USE_DEBUG_VIDEO_OUTPUT
	#undef USE_DEBUG_MESSAGE
	//#undef USE_DATA_INPUT
	#undef FAN_OFF
	#undef START_STATUS
	#define START_STATUS	STOP
	#undef TEMPERATURE_DEBUG
	#undef USE_PREVENT_REUSE
	#define USE_PREVENT_REUSE
#endif

#ifdef USE_PREVENT_REUSE
	#define USE_RTC
#endif

#define XPS_SYS_CTRL_BASEADDR	0xF8000000U	/* AKA SLCR */
#define BOOT_MODE_REG			(XPS_SYS_CTRL_BASEADDR + 0x25C)
#define BOOT_MODES_MASK			0x00000007 /**< FLASH types */

#define ZOOM_CUT			0			//pixel
#define CUT_PIXEL1			171			//cut = 1.5*(H >> 3) H = 912, cut1 = 171
#define CUT_PIXEL2			90			//cut = 1.5*(H >> 3) H = 480, cut1 =  90

#define MODEL_PAGE			0x07		//model
#define SN_PAGE				0x09		//serial
#define SN_PAGE1			0x08		//serial1 Opal
#define SN_PAGE2			0x09		//serial2 ims
#define DATE_PAGE0			0x0A		//serial date, product time
#define DATE_PAGE1			0x0B		//use 1 minute
#define DATE_PAGE3			0x0D		//use 2 hrs
#define ERROR_PAGE			0x0E		//error code
#define ERROR_DATE			0x0F		//error date
#define AWB_PAGE0			0x10		//awb data, old method
#define AWB_PAGE1			0x11		//awb data, new method
#define USER_PAGE1			0x12		//UFM data page 1, WPT, BPT, saturation
#define USER_PAGE2			0x13		//UFM data page 2, brightness

#define CAMERA_INFO_POS_X1	670
#define CAMERA_INFO_POS_X2	CAMERA_INFO_POS_X1 + 550
#define CAMERA_INFO_POS_X3	CAMERA_INFO_POS_X1 + 740
#define CAMERA_INFO_POS_Y1	950 - 11
#define CAMERA_INFO_POS_Y2	950 - 11 + 34
#define CAMERA_INFO_POS_Y3	950 - 11 + 68
#define CAMERA_INFO_POS_Y4	950 - 11 + 102
#define CAMERA_INFO_POS_OFFSET1	140
#define CAMERA_INFO_POS_OFFSET2	80
#define CAMERA_INFO_POS_OFFSET3	100
#define CAMERA_INFO_WIDTH1	130
#define CAMERA_INFO_WIDTH1A	400
#define CAMERA_INFO_WIDTH2	130
#define CAMERA_INFO_WIDTH2A	100
#define CAMERA_INFO_WIDTH3	230

#define WIDTH1		150		//for ID NO, NAME
#define WIDTH2		370		//for Doraemon, 9/3/2112
#define WIDTH3		460		//for S/N : 2DCF-XXXXXX
#define WIDTH4		180
#define WIDTH5		80		//for Sun, Mon...
#define WIDTH6		350		//for secial size
#define THICK1		40

#define OFFSET_X	70

#ifndef XV_VPROCSS_LOG_ENABLE//JACKY
#define XV_VPROCSS_LOG_ENABLE
#endif

//for SD card
#include "xsdps.h"

#define SD_DEVICE_ID        XPAR_XSDPS_1_DEVICE_ID //or XAPR_XSDPS_0_DEVICE_ID

// for I2C ST
#include "xparameters.h"
#include "xiicps.h"
#include "xil_printf.h"


#include "xstatus.h"
#include "ff.h"

#define IIC_DEVICE_ID		XPAR_XIICPS_1_DEVICE_ID

//#define IIC_SLAVE_ADDR	0xE0	//TCA9546A
#define IIC_SLAVE_ADDR		0x68	//RTC DS1308
#define IIC_SCLK_RATE		100000

#define EEPROM_IIC_SLAVE_ADDR		0x53	//EEPROM 24C256

#define I2C_BUFFER_SIZE		8
#define INFO_BUFFER_SIZE	1024

#define RTC_SS		0		//second
#define RTC_MM		1		//minute
#define RTC_HH		2		//hour
#define RTC_WD		3		//weekday
#define RTC_MD		4		//monthday
#define RTC_MON		5		//month
#define RTC_YEAR	6		//year
#define RTC_CONTROL	7		//control data
#define abs(a, b)	(((a) > (b)) ? (a - b) : (b - a))
#define abs_sec(a, b)	(((a) > (b)) ? (a - b) : (a + 60 - b))

//#ifdef USE_PREVENT_REUSE
#define TWO_HOURS							5	//120 minutes
#define VIDEO_OK							0
#define VIDEO_FORBID_ALL					1
#define VIDEO_FORBID_USE_2HR				2
#define VIDEO_FORBID_RTC_FAIL				3

int flag_forbid_video = FALSE;
int flag_forbid_video_old = FALSE;
int flag_video_status = VIDEO_OK;
int forbid_camera_cnt = 0;
int flag_battery_fail = FALSE;
int flag_show_print_time = FALSE;

#define CAMERA_NEW		0
#define CAMERA_1M		1
#define CAMERA_2HR		2
#define CAMERA_USED		3

int flag_camera_status = CAMERA_NEW;
int flag_same_camera = FALSE;
int flag_camera_invalid = FALSE;
//#endif

#define MODE_PUTTY			0
#define MODE_IMS_LINK		1
#ifdef USE_IMS_LINK
int flag_operation_mode = MODE_IMS_LINK;
#else
int flag_operation_mode = MODE_PUTTY;
#endif
int flag_going_to_putty_mode = 0;
int flag_ask_operation_mode = 0;

int flag_enable_debug_console = TRUE;
int flag_camera_access = 0;

int IicPsMasterInit(u16 DeviceId);
XIicPs Iic;							/**< Instance of the IIC Device */

//u8 SendBuffer[I2C_BUFFER_SIZE];		/**< Buffer for Transmitting Data */
//u8 RecvBuffer[I2C_BUFFER_SIZE];		/**< Buffer for Receiving Data */

u8 SetInfoBuffer[INFO_BUFFER_SIZE + 2];	//data and offset
u8 GetInfoBuffer[INFO_BUFFER_SIZE];

u8 eeprom_page_buffer[1024];

#define DRAW_CMD_LEN	10
int draw_command[DRAW_CMD_LEN];
int draw_command_index = 0;
//int draw_command_pic = 0;

int XIicPs_SetDate(XIicPs *InstancePtr, u32 year, u8 month, u8 date, u8 day, u8 hour, u8 minutes, u8 seconds);
int XIicPs_SetData(XIicPs *InstancePtr, u8 addr, u8 data);
void ShowDateInfo(u8 *RecvBuffer);
int XIicPs_SetInfo();
int XIicPs_GetInfo();
void get_RTC_data();
int update_RTC_data();
void check_draw_command(void);
void add_draw_command(int cmd, int pic);
void update_widget_data(u8 *RecvBuffer);
int XIicPs_ReadEepromData(uint16_t page, uint16_t addr, uint16_t len, u8 *Buffer);
int XIicPs_WriteEepromData(uint16_t page, uint16_t addr, uint16_t len, u8 *Buffer);
int XIicPs_ReadEepromPage(uint16_t page, u8 *eeprom_page_buffer);
int XIicPs_EraseEepromPage(uint16_t page);
int XIicPs_EraseEeprom(uint16_t page, uint16_t addr0, uint16_t len);
int XIicPs_WriteEepromPage(uint16_t page);
int XIicPs_EraseEepromAll(void);
int XIicPs_ReadEepromAll(void);
int XIicPs_WriteEepromAll(void);
uint32_t check_dongle_usage_count(void);
void XIicPs_PrintPageData(int page, u8 *eeprom_page_buffer);
void XIicPs_PrintPageDataRaw(int page, u8 *eeprom_page_buffer);
void increase_dongle_usage_count(void);
void show_dongle_usage_count(uint32_t dongle_usage_count);
void show_dongle_usage_count_eng(uint32_t dongle_usage_count);
void increase_power_on_count(void);
void show_fw_write_count(uint32_t fw_write_count);
int read_RTC_data();
int XIicPs_SetRTCData(XIicPs *InstancePtr, u8 type, u8 data);
// for I2C SP

// for DMA ST
#define DMA_DEVICE_ID 			XPAR_XDMAPS_1_DEVICE_ID
#define DMA_DONE_INTR_0			XPAR_XDMAPS_0_DONE_INTR_0
#define DMA_DONE_INTR_1			XPAR_XDMAPS_0_DONE_INTR_1
#define DMA_DONE_INTR_2			XPAR_XDMAPS_0_DONE_INTR_2
#define DMA_DONE_INTR_3			XPAR_XDMAPS_0_DONE_INTR_3
#define DMA_DONE_INTR_4			XPAR_XDMAPS_0_DONE_INTR_4
#define DMA_DONE_INTR_5			XPAR_XDMAPS_0_DONE_INTR_5
#define DMA_DONE_INTR_6			XPAR_XDMAPS_0_DONE_INTR_6
#define DMA_DONE_INTR_7			XPAR_XDMAPS_0_DONE_INTR_7
#define DMA_FAULT_INTR			XPAR_XDMAPS_0_FAULT_INTR

#define DMA_LENGTH		8192*30		//Length of the Dma Transfers 2048 * 4 * 30
#define TIMEOUT_LIMIT 	0x20000		//Loop count for timeout

static u32 DMA_src[DMA_LENGTH] = {0};
static u32 DMA_dst[DMA_LENGTH] = {0};

int SetupInterruptSystem(XScuGic *GicPtr, XDmaPs *DmaPtr);
void DmaDoneHandler(unsigned int Channel, XDmaPs_Cmd *DmaCmd, void *CallbackRef);
int dma_copy(u32 SrcAddr, u32 DstAddr, int length);

void print_screen_data(int frame);
void print_layer0_data(int frame);
void print_surface_1_data();
void print_surface_1c_data();

uint32_t empty_pic[1216 * 4];
uint32_t tmp_pic[400 * 4];
uint32_t addr_empty_pic;
uint32_t addr_tmp_pic;



//reserve picture position info
coord_t pic_dx = 228;			//destination canvas start position x
coord_t pic_dy = 264;			//destination canvas start position y
coord_t pic_width = 760;		//destination canvas start position x
coord_t pic_height = 384;		//destination canvas start position y

struct pic_size
{
	coord_t w;
	coord_t h;
	coord_t dx;
	coord_t dy;
};

#define	TOTAL_PICTURES	4
struct pic_size pic_sizes[TOTAL_PICTURES];

// for DMA SP

// for ADC ST
#define XADC_DEVICE_ID 		XPAR_XADCPS_0_DEVICE_ID
int XAdcInit(u16 DeviceId);
int XAdcGetData();
int XAdcGetCurrentTemperature();
static int XAdcFractionToInt(float FloatNum);
static XAdcPs XAdcInst;      /* XADC driver instance */

u32 temperature_array_index = 0;
u32 temperature_array[DEBUG_LENGTH] = {0};

u32 temperature_current = 0;

// for ADC SP

u8 mb_model_new[50] = {0};
u8 camera_data_model[16] = {0};	//Camera model
u8 camera_data_serial1[16] = {0};
u8 camera_data_serial2[16] = {0};

u8 camera_data_tmp[16] = {0};
u8 camera_data_tmp2[16] = {0};

/* global timer registers*/
#define SCU_GLOBAL_TIMER_COUNT_L32	(XPAR_PS7_GLOBALTIMER_0_S_AXI_BASEADDR)
#define SCU_GLOBAL_TIMER_COUNT_U32	(XPAR_PS7_GLOBALTIMER_0_S_AXI_BASEADDR+0x04)
#define SCU_GLOBAL_TIMER_CONTROL	(XPAR_PS7_GLOBALTIMER_0_S_AXI_BASEADDR+0x08)
#define SCU_GLOBAL_TIMER_ISR		(XPAR_PS7_GLOBALTIMER_0_S_AXI_BASEADDR+0x0C)
#define SCU_GLOBAL_TIMER_COMP_L32	(XPAR_PS7_GLOBALTIMER_0_S_AXI_BASEADDR+0x10)
#define SCU_GLOBAL_TIMER_COMP_U32	(XPAR_PS7_GLOBALTIMER_0_S_AXI_BASEADDR+0x14)
#define SCU_GLOBAL_TIMER_AUTO_INC	(XPAR_PS7_GLOBALTIMER_0_S_AXI_BASEADDR+0x18)
static const char ims_logo[] = "ims-small-logo.png";
static const char step_1[] = "step1.png";
static const char step_2[] = "step2.png";
static const char step_3[] = "step3.png";
#ifdef USE_PREVENT_REUSE
static const char forbid_1[] = "forbid1.png";
static const char forbid_8[] = "forbid8.png";
static const char forbid_9[] = "forbid9.png";
#endif


//static const char name1a[] = "name1.png";
//static const char name1aa[] = "name1a.png";
//static const char name1ba[] = "name1b.png";
//static const char name2a[] = "name2.png";


#ifdef USE_DEBUG_PICTURE
static const char cameraa[] = "camera.png";
static const char recorder_oka[] = "recorder_ok.png";
static const char recorder_nonea[] = "recorder_none.png";
static const char recorder_faila[] = "recorder_fail.png";
static const char recorder_sensor_faila[] = "recorder_sensor_fail.png";
#endif

void pixmap_draw(GDisplay* pixmap, pixel_t* surface, coord_t pm_width, coord_t pm_height, gdispImage *p_Image, uint32_t s_x, uint32_t s_y, uint32_t d_x, uint32_t d_y, u8 alpha, u8 position);
void clear_layer1_all(int frame, int enable);
void clear_layer1(int frame);
void layer1_blit(struct pic_size s, int frame);
void layer1_blit_corners(int frame);
void preload_picture_to_memory(void);
void preload_forbid_picture_to_memory(int pic);
void dma_restore_picture(int pic);
void dma_backup_picture(void);
void draw_layer_boundary(void);
void update_framebuffer(void);
void switch_to_framebuffer(int frame);
void RequestShowPicture(int pic);
void RequestShowPicture2(int pic);
void init_system();
uint8_t keycode_to_ascii2(uint8_t modifier, uint8_t keycode);
int process_function_key(uint8_t keycode);
int process_arrow_key(uint8_t keycode);
int usb_keyboard_send_keycode(uint8_t modifier, uint8_t keycode);
void confirm_enter_key(int flag_modify_pinfo_mode);
void backup_old_data(int flag_modify_pinfo_mode);
void restore_old_data0(int flag_modify_pinfo_mode);
void restore_old_data(int flag_modify_pinfo_mode);
void update_user_data(uint8_t keycode);
void update_pinfo_on_widget(uint8_t ch);
int read_data_from_camera_page0(void);
int read_model_from_camera(void);
void write_model_to_camera(void);
int read_serial_from_camera(void);
void write_user_data_to_camera0(void);
void write_serial_to_camera(void);
void write_user_model_to_camera(void);
void write_user_serial_to_camera(void);
int read_date_from_camera(uint16_t page);
int read_data_from_camera(uint16_t page);
void write_date_to_camera(uint16_t page);
void write_error_code_to_camera(int error);
int read_error_code_from_camera(void);
void show_camera_serial(int enable);
void show_camera_date(int enable);
void read_camera_info_from_camera_eng(void);
void show_camera_info_eng(void);
void keep_current_setup_value(int item);
void modify_current_setup_value(int add);
void refresh_current_setup_value0(void);
void refresh_current_setup_value(void);
void apply_current_setting(void);
void confirm_language_item(void);
void draw_color(void);
void show_environment_parameters(void);
u32 InitSD(const char *filename);
u32 SDAccess( u32 SourceAddress, u32 DestinationAddress, u32 LengthBytes);
void ReleaseSD(void);
u32 loadFileFromSD(char filename[], u32 *dst);
int SD_Init(void);
int SD_Transfer_write(char *FileName,u32 SourceAddress,u32 ByteLength);
void yuv2rgb(u8 Y, u8 U, u8 V);
void Save_Image_To_SD(void);
void draw_layer2_boundary(void);
int gray_monitor(u32 LSW_axisx, u32 LSW_axisy, u32 SSW_axisx, u32 SSW_axisy);//JACKY2020
int get_gray_value(u32 x_st, u32 y_st, u32 W, u32 H);
int get_average_gray_value();
void print_cs_data(unsigned int DongleAddr);
void gpio_test(void);
void print_time_eng(unsigned long s);
void print_time_s2hms(unsigned long s);

int birth_mm = 0;
int birth_dd = 0;
int birth_yyyy = 0;
int birth_age = 0;

int flag_id_ok = FALSE;
int flag_birth_mm_ok = FALSE;
int flag_birth_dd_ok = FALSE;
int flag_birth_yyyy_ok = FALSE;

int flag_use_barcode_scanner = FALSE;

int scanner_index = 0;
unsigned char scanner_data[20];

#define ALPHA 0xcf

volatile uint32_t g_ms_uptime = 0;
volatile uint32_t g_ms_tick = 0;
volatile uint32_t g_ms_tick_wait = 0;
volatile uint32_t g_ms_tick_start = 0;

uint32_t g_dongle_plugged = 0;
uint32_t g_camera_plugged = 0;
uint32_t g_conn_status = DONGLE_NONE;
uint32_t g_conn_status_old = DONGLE_NONE;
u8 alpha = ALPHA;

GHandle		ghLabel1, ghLabel2, ghLabel3, ghLabel4, ghLabel5, ghLabel6, ghLabel7, ghLabel8;

uint32_t esc_mode = 0;

static gdispImage myImage;
static GDisplay* pixmap_1;
static pixel_t* surface_1;
static GDisplay* pixmap_2;
static pixel_t* surface_2;
//static GDisplay* pixmap_3;
//static pixel_t* surface_3;

static pixel_t* surface_10;			//surface_1 empty
static pixel_t* surface_1a;			//surface_1 + step_1
static pixel_t* surface_1b;			//surface_1 + step_2
static pixel_t* surface_1c;			//surface_1 + step_3
static pixel_t* surface_1d;			//surface_1 + forbid

// The handle for our console
#ifdef USE_DEBUG_CONSOLE
static GHandle	GW0a;	//for debug message
static GHandle	GW1a;
#endif
static GHandle	GW0b;	//for usb debug message
static GHandle	GW1b;
GWindowInit		wic;

static void updateWidgets_age_data(void);
static void createWidgets(void);
static void createWidgets2(void);
static void updateConsoleWidgets(void);
void main_loop(void);
void get_usb_descriptor(void);
void read_usb_registers(void);
void parse_uart_command(void);
void parse_uart_esc_command(void);
void get_system_up_time(void);
void set_time(void);
void get_time(void);
void show_engineering_mode0(void);
void show_engineering_mode(void);
void clear_engineering_mode(void);
void clear_engineering_mode0(void);
void setup_camera_exposure(int setup);
void my_XTime_GetTime(XTime *Xtime_Global);
void XTime_GetStartTime();
uint32_t check_camera_status();
void show_systeminfo(void);
void show_help_menu(void);
void show_help2_menu(void);
void read_color_matrix(void);
void write_color_matrix(void);
void ps_gpio_setup(periphs_t* p_periphs_inst, u32 Pin, u32 Data);
void draw_picture(int pic);
void draw_picture0(int pic);
u32 ReadRegister(u32 reg);
u32 WriteRegister(u32 reg, u32 value);
void pirnt_mixer_data(void);
void GetScuInfo(XScuGic *InstancePtr);
void SetDongleLedRedStatus(int status);
void SetDongleLedGreenStatus(int status);
int GpioOutput_graylevel_axis_Write(u16 DeviceId, u32 graylevel_axis_Write_left_top, u32 graylevel_axis_Write_right_down);//JACKY2020

static char last_command[100] = "help";
static int last_command_length = 0;
int SelectedLanguage = 0;	// 0: TC,	1: SC,	2: English
int SelectedLanguage_eng = 0;

int flag_get_usb_descriptor_done = 0;

#define REGISTER_BOOT_MODE		0xF800025C
#define REGISTER_PSS_IDCODE		0xF8000530

int flag_check_camera_reuse = CHECK_CAMERA_REUSE_NONE;
#ifdef USE_DEBUG_VIDEO_OUTPUT
int flag_use_2_framebuffers = FALSE;
#else
int flag_use_2_framebuffers = TRUE;
#endif
int current_framebuffer = 0;
int next_framebuffer = 1;
#define FRAMEBUFFER0	0
#define FRAMEBUFFER1	1

int flag_check_engineering_mode = 0;
int engineering_mode_setup_item = 0;
int cut_pixel = CUT_PIXEL1;

struct patient_info
{
	unsigned char id_no[10];
	unsigned char name[20];
	char sex;
	int age;
	unsigned char birthday[12];
};

struct patient_info p_info = {"D021120903", "Doraemon", 1, -92, "9/3/2112"};
//struct patient_info p_info = {"D021141202", "Dorami", 2, -94, "12/2/2114"};

#define P_INFO_LEN			6
struct patient_info p_infos[P_INFO_LEN] = {
		{"", "", 0, 0, ""},
		{"D021120903", "Doraemon", 1, -92, "9/3/2112"},
		{"D021141202", "Dorami", 2, -94, "12/2/2114"},
		{"M019281118", "Mickey", 1, 92, "11/18/1928"},
		{"B020000814", "Benny", 1, 20, "8/14/2000"},
		{"C020130417", "Cony", 2, 7, "4/17/2013"}
};
int p_info_index = 0;

#define KEY_F0				0xF1	//used for reference
#define KEY_F1				0xF1
#define KEY_F2				0xF2
#define KEY_F3				0xF3
#define KEY_F4				0xF4
#define KEY_F5				0xF5
#define KEY_TAB				0xA0
#define KEY_RIGHT			79
#define KEY_LEFT			80
#define KEY_DOWN			81
#define KEY_UP				82

#define DATA_LENGTH			20
uint8_t p_info_data[DATA_LENGTH];
uint8_t p_info_data_old[DATA_LENGTH];
int p_info_data_index = 0;

int flag_modify_pinfo_mode = 0;

#define ReadDeviceID	 	0xE0
#define ReadUSERCODE		0xC0
#define ReadStatusRegister 	0x3C
#define ReadBusyFlag		0xF0

int power_on_count = 0;
uint32_t check_fw_write_count(void);
void write_compile_time_count(void);
uint32_t read_compile_time_count(void);
char compile_time[8] = {0};

#define CAMERA_RUN			0
#define CAMERA_FREEZE		1
#define CAMERA_FORBID		2

#define CAMERA_EXPO_DEFAULT_VALUE 40

void forbid_video(int forbid_id);
void show_forbid_message(int forbid_id);
void enable_camera(int enable);
void read_camera_fpga(uint16_t page);

void ims_printf0( const char8 *ctrl1);
void ims_printf( const char8 *ctrl1);

void debug_console_init(void);
void debug_console_print(const char8 *ctrl1);
void debug_console_close(void);

unsigned long get_total_sec(struct tm t);
int diff_time(struct tm t1, struct tm t2);

#define CAMERA_1MIN		0
#define CAMERA_2HOUR	2
#define CURRENT_TIME	5
void print_time(unsigned long s);
void print_time_clear(void);
void print_time0(unsigned long s);
unsigned long get_camera_use_time(void);
unsigned long camera_use_time = 0;
unsigned long camera_use_time_this = 0;
int check_use_time_seconds = 0;
int get_camera_status(void);
int tick_cnt = 1;
int flag_updateShowCameraDate = 0;
void updateShowCameraDate(void);
int check_camera_reuse(void);
void check_camera_reuse_clear(void);

#ifdef USE_ANALOG_CLOCK
int  ss_coord[60][2] =
{
{0, -93}, {9, -92}, {19, -90}, {28, -88}, {37, -84}, {46, -80}, {54, -75}, {62, -69}, {69, -62}, {75, -54}, {80, -46}, {84, -37}, {88, -28}, {90, -19}, {92, -9}, {93, 0}, {92, 9}, {90, 19}, {88, 28}, {84, 37}, {80, 46}, {75, 54}, {69, 62}, {62, 69}, {54, 75}, {46, 80}, {37, 84}, {28, 88}, {19, 90}, {9, 92}, {0, 93}, {-9, 92}, {-19, 90}, {-28, 88}, {-37, 84}, {-46, 80}, {-54, 75}, {-62, 69}, {-69, 62}, {-75, 54}, {-80, 46}, {-84, 37}, {-88, 28}, {-90, 19}, {-92, 9}, {-93, 0}, {-92, -9}, {-90, -19}, {-88, -28}, {-84, -37}, {-80, -46}, {-75, -54}, {-69, -62}, {-62, -69}, {-54, -75}, {-46, -80}, {-37, -84}, {-28, -88}, {-19, -90}, {-9, -92}
};

int  mm_coord[60][2] =
{
{0, -73}, {7, -72}, {15, -71}, {22, -69}, {29, -66}, {36, -63}, {42, -59}, {48, -54}, {54, -48}, {59, -42}, {63, -36}, {66, -29}, {69, -22}, {71, -15}, {72, -7}, {73, 0}, {72, 7}, {71, 15}, {69, 22}, {66, 29}, {63, 36}, {59, 42}, {54, 48}, {48, 54}, {42, 59}, {36, 63}, {29, 66}, {22, 69}, {15, 71}, {7, 72}, {0, 73}, {-7, 72}, {-15, 71}, {-22, 69}, {-29, 66}, {-36, 63}, {-42, 59}, {-48, 54}, {-54, 48}, {-59, 42}, {-63, 36}, {-66, 29}, {-69, 22}, {-71, 15}, {-72, 7}, {-73, 0}, {-72, -7}, {-71, -15}, {-69, -22}, {-66, -29}, {-63, -36}, {-59, -42}, {-54, -48}, {-48, -54}, {-42, -59}, {-36, -63}, {-29, -66}, {-22, -69}, {-15, -71}, {-7, -72}
};

int  hh_coord[24][2] =
{
{0, -53}, {26, -45}, {45, -26}, {53, 0}, {45, 26}, {26, 45}, {0, 53}, {-26, 45}, {-45, 26}, {-53, 0}, {-45, -26}, {-26, -45}
};
#endif

//R=180;y=0:1:(R-1);x=R*(1-sind(acosd((R-y)/R)));plot(floor(x),y,'r');hold on;plot(round(x),y,'g');hold on;
/*
u8 cuts[180] =
{
180, 161, 153, 147, 142, 138, 134, 130, 127, 124, 121, 118, 115, 113, 110, 108, 106, 104, 102, 100, 98, 96, 94, 92, 90, 88, 87,
85, 84, 82, 81, 79, 78, 76, 75, 73, 72, 71, 69, 68, 67, 66, 64, 63, 62, 61, 60, 59, 58, 57, 56, 54, 53, 52,
51, 50, 50, 49, 48, 47, 46, 45, 44, 43, 42, 42, 41, 40, 39, 38, 38, 37, 36, 35, 35, 34, 33, 32, 32, 31, 30,
30, 29, 28, 28, 27, 26, 26, 25, 25, 24, 24, 23, 22, 22, 21, 21, 20, 20, 19, 19, 18, 18, 17, 17, 16, 16, 15,
15, 15, 14, 14, 13, 13, 13, 12, 12, 11, 11, 11, 10, 10, 10, 9, 9, 9, 8, 8, 8, 7, 7, 7, 7, 6, 6,
6, 5, 5, 5, 5, 5, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1,
1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
*/

u8 cuts[250] =
{
250, 228, 218, 211, 205, 200, 196, 191, 187, 184, 180, 177, 173, 170, 168, 165, 162, 159, 157, 154, 152, 150, 147, 145, 143, 141, 139,
137, 135, 133, 131, 129, 128, 126, 124, 122, 121, 119, 118, 116, 114, 113, 111, 110, 108, 107, 105, 104, 103, 101, 100, 99, 97, 96,
95, 94, 92, 91, 90, 89, 88, 86, 85, 84, 83, 82, 81, 80, 79, 78, 77, 75, 74, 73, 72, 71, 70, 70, 69, 68, 67,
66, 65, 64, 63, 62, 61, 60, 60, 59, 58, 57, 56, 55, 55, 54, 53, 52, 52, 51, 50, 49, 49, 48, 47, 46, 46, 45,
44, 44, 43, 42, 42, 41, 40, 40, 39, 38, 38, 37, 36, 36, 35, 35, 34, 33, 33, 32, 32, 31, 31, 30, 30, 29, 29,
28, 28, 27, 26, 26, 26, 25, 25, 24, 24, 23, 23, 22, 22, 21, 21, 20, 20, 20, 19, 19, 18, 18, 18, 17, 17, 16,
16, 16, 15, 15, 15, 14, 14, 13, 13, 13, 12, 12, 12, 12, 11, 11, 11, 10, 10, 10, 9, 9, 9, 9, 8, 8, 8,
8, 7, 7, 7, 7, 6, 6, 6, 6, 5, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 2,
2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0, 0};

/*
int cuts[360] =
{
360, 333, 322, 314, 306, 300, 295, 289, 285, 280, 276, 272, 268, 264, 261, 257, 254, 251, 248, 245, 242, 239, 236, 233, 231, 228, 226,
223, 221, 218, 216, 214, 212, 209, 207, 205, 203, 201, 199, 197, 195, 193, 191, 189, 188, 186, 184, 182, 180, 179, 177, 175, 174, 172,
170, 169, 167, 166, 164, 163, 161, 160, 158, 157, 155, 154, 152, 151, 149, 148, 147, 145, 144, 143, 141, 140, 139, 137, 136, 135, 134,
132, 131, 130, 129, 128, 126, 125, 124, 123, 122, 121, 120, 119, 117, 116, 115, 114, 113, 112, 111, 110, 109, 108, 107, 106, 105, 104,
103, 102, 101, 100, 99, 98, 97, 96, 95, 94, 93, 93, 92, 91, 90, 89, 88, 87, 86, 86, 85, 84, 83, 82, 81, 81, 80,
79, 78, 77, 77, 76, 75, 74, 74, 73, 72, 71, 71, 70, 69, 68, 68, 67, 66, 65, 65, 64, 63, 63, 62, 61, 61, 60,
59, 59, 58, 57, 57, 56, 55, 55, 54, 54, 53, 52, 52, 51, 51, 50, 49, 49, 48, 48, 47, 47, 46, 45, 45, 44, 44,
43, 43, 42, 42, 41, 41, 40, 40, 39, 39, 38, 38, 37, 37, 36, 36, 35, 35, 34, 34, 33, 33, 32, 32, 31, 31, 30,
30, 30, 29, 29, 28, 28, 28, 27, 27, 26, 26, 25, 25, 25, 24, 24, 24, 23, 23, 22, 22, 22, 21, 21, 21, 20, 20,
20, 19, 19, 19, 18, 18, 18, 17, 17, 17, 16, 16, 16, 15, 15, 15, 14, 14, 14, 14, 13, 13, 13, 12, 12, 12, 12,
11, 11, 11, 11, 10, 10, 10, 10, 9, 9, 9, 9, 9, 8, 8, 8, 8, 7, 7, 7, 7, 7, 6, 6, 6, 6, 6,
6, 5, 5, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2,
2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0, 0, 0, 0};
*/

//#ifdef USE_IMS_LINK
u8 gui_cmd[5] = {0};
u8 gui_cmd_index = 0;
u8 start_data = 0;
u8 flag_receive_camera_serial = 0;
u8 flag_receive_camera_model = 0;
u8 flag_receive_camera_awb_data = 0;
int ufm_write_page = 0;
u8 flag_receive_camera_raw_data = 0;
u8 received_camera_raw_data[16] = {0};
u8 received_camera_raw_data_index = 0;
u8 received_camera_data[21] = {0};
u8 received_camera_data_index = 0;
u8 flag_receive_mb_model = 0;
u8 received_mb_data[50] = {0};
u8 received_mb_data_index = 0;
u8 flag_receive_rtc_data = 0;
u8 received_rtc_data[16] = {0};
u8 received_rtc_data_index = 0;
struct tm rtc_bootup;

u16 CalcCheckSum(u8 *pData, u16 len);
void Send_IMS_Data_Cmd(u8 cmd1, u8 cmd2, u8 cmd3);
void check_awb_data(void);
void apply_camera_ufm_data(void);
void apply_gamma_data(void);
int total_camera_count = 1;

//#endif

// *****************************************************
// Main program entry point
// *****************************************************
int main()
{
	// Local variables
	int status = 0;
	coord_t swidth, sheight;
	gdispImage *p_Image;
	//uint8_t *p_byte, byte;
	//uint32_t i;
	//uint32_t j;
	//uint32_t Index;
	uint32_t g_ms_tick_tmp;

	p_Image = &myImage;

	// Setup UART and caches
    init_platform();

    init_system();

    // Initialize peripherals
    status = periphs_init
    (
    	&periphs_inst,
    	//XPAR_CONTROL_PATH_AXI_GPIO_0_DEVICE_ID,
    	//XPAR_CONTROL_PATH_AXI_IIC_0_BASEADDR,
		//XPAR_XIICPS_0_DEVICE_ID,
		XPAR_PS7_GPIO_0_DEVICE_ID,
#ifdef USE_Z7020
		XPAR_VIDEO_PATH_VIDEO_OUT_VIDEO_LOCK_MONITOR_VS_MIXER_SW_RST_DEVICE_ID,	//7020
#else
		XPAR_VIDEO_PATH_VIDEO_OUT_VIDEO_LOCK_MONITOR_DEVICE_ID,	//7015
#endif
		XPAR_PS7_SCUGIC_0_DEVICE_ID,
		XPAR_PS7_SCUTIMER_0_DEVICE_ID,
		XPAR_VIDEO_PATH_CAMERA_IN_CDR_VIDEO_IN_AXI4_RDY_CDR_REGISTERS_AXI_GPIO_NFRAMESREADY_DEVICE_ID, //JACKY1212
		XPAR_PS7_UART_0_DEVICE_ID,
		//XPAR_VIDEO_PATH_CAMERA_IN_V_TC_VTD_DEVICE_ID,
    	//XPAR_VIDEO_PATH_TPG_OLD_TPG_OLD_DEVICE_ID,
		XPAR_VIDEO_PATH_V_TPG_0_DEVICE_ID,
		//XPAR_VIDEO_PATH_CAMERA_SCALER_V_PROC_SS_1_DEVICE_ID,
		XPAR_XVPROCSS_0_DEVICE_ID,//From xparameters.h JACKY
		XPAR_VIDEO_PATH_CAMERA_SCALER_FREEZE_V_PROC_SS_1_DEVICE_ID,
		XPAR_VIDEO_PATH_FRAMEBUFFER_AXI_VDMA_CAMERA_DEVICE_ID,
		XPAR_VIDEO_PATH_FRAMEBUFFER_AXI_VDMA_CAMERA_FREEZE_DEVICE_ID,
		//XPAR_VIDEO_PATH_FRAMEBUFFER_OUTPUT_AXI_VDMA_GUI_DEVICE_ID,
		XPAR_VIDEO_PATH_OUTPUT_MIXER_V_MIX_0_DEVICE_ID,
		XPAR_VIDEO_PATH_VIDEO_OUT_V_TC_TFP410_DEVICE_ID,
		XPAR_VIDEO_PATH_VIDEO_OUT_V_TC_CH7038_DEVICE_ID,
		XPAR_PS7_USB_0_DEVICE_ID,
    	FRAMEBUFFER_CAMERA_START_ADDR,
		FRAMEBUFFER_CAMERA_FREEZE_START_ADDR,
		FRAMEBUFFER_GUI_START_ADDR
    );
	if (status != PERIPHS_SUCCESS)
	{
		xil_printf("Initialization failed.\n\r");
		return -1;
	}
	xil_printf("tick(%d) = %d;\t%%%s:%s(%d)\r\n", tick_cnt++, g_ms_tick, __FILE__,__func__,__LINE__);

	////JACKY VPSS BKBK
	/*xil_printf("JACKY0924+++++: %s:%s(%d) -------- main/XV_CscInitialize\r\n",__FILE__,__func__,__LINE__);
	//Template: XV_CscInitialize(XV_Csc_l2 *InstancePtr, u16 DeviceId);//JACKYJACKY  periphs_inst.p_scaler_camera_inst
	XV_CscInitialize(periphs_inst.p_scaler_camera_freeze_inst->CscPtr, XPAR_VIDEO_PATH_FRAMEBUFFER_AXI_VDMA_CAMERA_FREEZE_DEVICE_ID);//JACKYJACKY
	xil_printf("JACKY0924+++++: %s:%s(%d) -------- main/XV_CscInitialize\r\n",__FILE__,__func__,__LINE__);*/

	//void XVprocSs_LogDisplay(XVprocSs *InstancePtr)
	xil_printf("JACKY0925+++++: %s:%s(%d) -------- main/XVprocSs_LogDisplay\r\n",__FILE__,__func__,__LINE__);
	XVprocSs_LogDisplay(periphs_inst.p_scaler_camera_freeze_inst);

	SetDongleLedRedStatus(0);		//ensure turn off red led on dongle
	SetDongleLedGreenStatus(0);		//ensure turn off green led on dongle

	xil_printf("\n\rTurn off camera LED a\n\r");
	ps_gpio_setup(&periphs_inst, GPIO_CAM_LED, 0);
	flag_camera_led_status = 0;

    // Initialize uGFX
	xil_printf("tick(%d) = %d;\t%%%s:%s(%d) call gfxInit ST\r\n", tick_cnt++, g_ms_tick, __FILE__, __func__, __LINE__);
	g_ms_tick_tmp = g_ms_tick;
    gfxInit();	//use 2.2 sec
    xil_printf("tick(%d) = %d;\t%%%s:%s(%d) call gfxInit SP, spend %d msec\r\n", tick_cnt++, g_ms_tick, __FILE__, __func__, __LINE__, (g_ms_tick - g_ms_tick_tmp) * 1);

	// Set up pixmap for layer 1
	xil_printf("setup layer 1 create W = %d H = %d\n\r", LAYER1_WIDTH, LAYER1_HEIGHT);
    pixmap_1 = gdispPixmapCreate(LAYER1_WIDTH, LAYER1_HEIGHT);
    surface_1 = gdispPixmapGetBits(pixmap_1);

    surface_10 = gfxAlloc(LAYER1_WIDTH * LAYER1_HEIGHT * 4);
    surface_1a = gfxAlloc(LAYER1_WIDTH * LAYER1_HEIGHT * 4);
    surface_1b = gfxAlloc(LAYER1_WIDTH * LAYER1_HEIGHT * 4);
    surface_1c = gfxAlloc(LAYER1_WIDTH * LAYER1_HEIGHT * 4);
    surface_1d = gfxAlloc(LAYER1_WIDTH * LAYER1_HEIGHT * 4);

    xil_printf("Addr of surface_1  is 0x%08x\n\r", surface_1);
    xil_printf("Addr of surface_10 is 0x%08x\n\r", surface_10);
    xil_printf("Addr of surface_1a is 0x%08x\n\r", surface_1a);
    xil_printf("Addr of surface_1b is 0x%08x\n\r", surface_1b);
    xil_printf("Addr of surface_1c is 0x%08x\n\r", surface_1c);
    xil_printf("Addr of surface_1d is 0x%08x\n\r", surface_1d);

    // Draw transparency required on layer 1
	// Set up pixmap for layer 2
    xil_printf("setup layer 2 create W = %d H = %d\n\r", LAYER2_WIDTH, LAYER2_HEIGHT);
    pixmap_2 = gdispPixmapCreate(LAYER2_WIDTH, LAYER2_HEIGHT);
    surface_2 = gdispPixmapGetBits(pixmap_2);
    // Draw transparency required on layer 2
    pixmap_draw(pixmap_2, surface_2, LAYER2_WIDTH, LAYER2_HEIGHT, NULL, 0, 0, 0, 0, 0, POSITION_MIDDLE_CENTER);

	// Open image for layer 3
	// Get the display dimensions
	swidth = gdispGetWidth();
	xil_printf("swidth: %d\r\n", swidth);
	sheight = gdispGetHeight();
	xil_printf("sheight: %d\r\n", sheight);

	// Set up IO for our image
	status = gdispImageOpenFile(p_Image, ims_logo);
	//xil_printf("status mainopen: %d\r\n", status);
//	p_byte = (uint8_t *)p_Image->priv;
//	xil_printf("status: %d\r\n", status);
//	xil_printf("p_Image->type: %d\r\n", p_Image->type);
//	xil_printf("p_Image->flags: %x\r\n", p_Image->flags);
//	xil_printf("p_Image->bgcolor: %x\r\n", p_Image->bgcolor);
//	xil_printf("p_Image->memused: %d\r\n", p_Image->memused);
//	xil_printf("p_Image->maxmemused: %d\r\n", p_Image->maxmemused);
//
//	xil_printf("p_Image->priv->flags: %x\r\n", p_byte[0]);
//	xil_printf("p_Image->priv->bitdepth: %x\r\n", p_byte[1]);
//	xil_printf("p_Image->priv->mode: %x\r\n", p_byte[2]);
//	xil_printf("p_Image->priv->bpp: %x\r\n", p_byte[3]);

	status = gdispImageDraw(p_Image, swidth - p_Image->width - BORDER_X * 1, sheight - p_Image->height - BORDER_Y * 2, p_Image->width, p_Image->height, 0, 0);
	//xil_printf("status maindraw: %d\r\n", status);
	gdispImageClose(p_Image);

	//clear_layer1(FRAMEBUFFER0);
	clear_layer1_all(current_framebuffer, TRUE);
	if(flag_use_2_framebuffers == TRUE)
		clear_layer1_all(next_framebuffer, TRUE);
	layer1_blit_corners(current_framebuffer);
	if(flag_use_2_framebuffers == TRUE)
		layer1_blit_corners(next_framebuffer);

	// Blit surface_2 to the real display at the new position
	gdispBlitArea(BORDER_X, LAYER0_HEIGHT - LAYER2_HEIGHT - BORDER_Y, LAYER2_WIDTH, LAYER2_HEIGHT, surface_2);

	xil_printf("tick(%d) = %d;\t%%%s:%s(%d) preload ST\r\n", tick_cnt++, g_ms_tick, __FILE__, __func__, __LINE__);
	g_ms_tick_tmp = g_ms_tick;
	preload_picture_to_memory();
    xil_printf("tick(%d) = %d;\t%%%s:%s(%d) preload SP, spend %d msec\r\n", tick_cnt++, g_ms_tick, __FILE__, __func__, __LINE__, (g_ms_tick - g_ms_tick_tmp) * 1);

	Xil_DCacheFlush();

	// Set up Mixer Layers
	RunMixer(periphs_inst.p_vid_output_mixer_l2_inst);

	XVMix_LayerEnable(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_1);
	xil_printf("tick(%d) = %d;\t%%%s:%s(%d) video output OK\r\n", tick_cnt++, g_ms_tick, __FILE__, __func__, __LINE__);

	/*
	 * Run the Iic polled example in master mode, specify the Device
	 * ID that is specified in xparameters.h.
	 */
	status = IicPsMasterInit(IIC_DEVICE_ID);
	if (status != XST_SUCCESS) {
		xil_printf("IicPsMasterInit Failed\r\n");
		return XST_FAILURE;
	}
	xil_printf("Successfully ran IicPsMasterInit\r\n");
	xil_printf("tick(%d) = %d;\t%%%s:%s(%d)\r\n", tick_cnt++, g_ms_tick, __FILE__,__func__,__LINE__);

	#ifdef USE_RTC
	get_RTC_data();
	#endif

	/*
	 * Run the polled example, specify the Device ID that is
	 * generated in xparameters.h.
	 */
	status = XAdcInit(XADC_DEVICE_ID);
	if (status != XST_SUCCESS) {
		xil_printf("XAdcInit Failed\r\n");
		return XST_FAILURE;
	}
	xil_printf("Successfully ran XAdcInit\r\n");

	dongle_usage_count = check_dongle_usage_count();
	xil_printf("dongle_usage_count = %d\r\n", dongle_usage_count);

	#ifdef USE_DEBUG_MESSAGE
	fw_write_count = check_fw_write_count();
	xil_printf("fw_write_count = %d\n\r", fw_write_count);
	#endif

    print("\r\nRunning GpioOutputExample() for video_path_camera_in_CDR_VIdeo_In_AXI4_rdy_CDR_Registers_axi_gpio_SDK_NFrames...\r\n");
    status = GpioOutputExample(XPAR_VIDEO_PATH_CAMERA_IN_CDR_VIDEO_IN_AXI4_RDY_CDR_REGISTERS_AXI_GPIO_SDK_NFRAMES_DEVICE_ID,8, 60);
    if (status == 0) {
       print("GpioOutputExample PASSED.\r\n");
    }
    else {
       print("GpioOutputExample FAILED.\r\n");
    }

	// Set the widget defaults
	//gwinSetDefaultFont(gdispOpenFont("*"));
	gwinSetDefaultFont(gdispOpenFont("iskpota232"));
	gwinSetDefaultStyle(&BlackWidgetStyle, FALSE);
	//gdispClear(White);

	// create the widget
#ifdef USE_DATA_INPUT
	createWidgets();
#endif

#ifdef USE_CORRECT_TIME
#ifdef USE_PREVENT_REUSE
	if(flag_battery_fail == TRUE)
	{
		xil_printf("VIDEO_FORBID_RTC_FAIL\n\r");
		flag_video_status = VIDEO_FORBID_RTC_FAIL;
		flag_forbid_video = TRUE;
		xil_printf("RTC forbid_video ST\n\r");
		forbid_video(flag_video_status);
		xil_printf("RTC forbid_video SP\n\r");
	}

	if(flag_battery_fail == FALSE)
#endif
#endif
	{
	// Detect Dongle status and draw image
	xil_printf("tick(%d) = %d;\t%%%s:%s(%d)\r\n", tick_cnt++, g_ms_tick, __FILE__, __func__, __LINE__);
	//xil_printf("check dongle status ST\n\r");
	g_conn_status = psuart0_dongle_ping();
	g_conn_status_old = g_conn_status;
	//xil_printf("check dongle status SP\n\r");
	xil_printf("tick(%d) = %d;\t%%%s:%s(%d)\r\n", tick_cnt++, g_ms_tick, __FILE__, __func__, __LINE__);

	//Xil_DCacheEnable();
	if(g_conn_status == DONGLE_NONE)
	{
			xil_printf("\n\rno dongle or camera step_1 power on\t%s\n\r", asctime(&rtc));
			SetDongleLedGreenStatus(0);		//turn off green led on dongle
			print_time_clear();
			// Set Flags
			g_dongle_plugged = 0;
			g_camera_plugged = 0;
			// Show Message
			RequestShowPicture(0);
			xil_printf("\n\rTurn off camera LED b\n\r");
			ps_gpio_setup(&periphs_inst, GPIO_CAM_LED, 0);
			flag_camera_led_status = 0;
	}
	else if (g_conn_status == CAMERA_NONE)
	{
			xil_printf("\n\rdongle only step_2 power on\t%s\n\r", asctime(&rtc));
			SetDongleLedGreenStatus(0);		//turn off green led on dongle
			print_time_clear();
			// Set Flags
			g_dongle_plugged = 1;
			g_camera_plugged = 0;
			// Show Message
			RequestShowPicture(1);
			xil_printf("\n\rTurn off camera LED c\n\r");
			ps_gpio_setup(&periphs_inst, GPIO_CAM_LED, 0);
			flag_camera_led_status = 0;
	}
	else	//CAMERA_OK
	{
			xil_printf("\n\rdongle+camera step_3 power on--------------\t%s\n\r", asctime(&rtc));
			SetDongleLedGreenStatus(1);		//turn on green led on dongle
			print_time_clear();
			// Set Flags
			g_dongle_plugged = 1;
			g_camera_plugged = 1;
			if(g_procedure_started == STOP)
			{
				// Show Message
				RequestShowPicture(2);
			}
			else
			{
				// Clear Message
				RequestShowPicture(-1);
			}
			XVMix_LayerEnable(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_1);

			xil_printf("tick(%d) = %d;\t%%%s:%s(%d) power on check\r\n", tick_cnt++, g_ms_tick, __FILE__, __func__, __LINE__);
			//debug_console_print("power on check\n");
#ifdef USE_PREVENT_REUSE
			if(flag_camera_invalid == FALSE)
			{
#endif
				xil_printf("\n\rTurn on camera LED d\n\r");
				ps_gpio_setup(&periphs_inst, GPIO_CAM_LED, 1);
				flag_camera_led_status = 1;
#ifdef USE_PREVENT_REUSE
			}
#endif
			xil_printf("david0529: %s:%s(%d) ST\r\n",__FILE__,__func__,__LINE__);
			check_awb_data();
			xil_printf("david0529: %s:%s(%d) ST\r\n",__FILE__,__func__,__LINE__);
			apply_camera_ufm_data();
			xil_printf("\n\rtotal_camera_count = %d\r\n", total_camera_count++);
			psuart0_exposure(g_exposure);

#ifdef USE_COLOR_DEBUG
			//dongle_write_data(0x5080, 0x81);
#endif
	}
	}

	xil_printf("tick(%d) = %d;\t%%%s:%s(%d) USB init ST\r\n", tick_cnt++, g_ms_tick, __FILE__, __func__, __LINE__);
	// USB Init
	ulpi_init();
	ulpi_set_vbus(TRUE);

	tusb_init(); // initialize tinyusb stack

	keyboard_host_app_init(); // Keyboard Host Init
	xil_printf("tick(%d) = %d;\t%%%s:%s(%d) USB init SP\r\n", tick_cnt++, g_ms_tick, __FILE__, __func__, __LINE__);
	//mouse_host_app_init(); // Mouse Host Init
	//Xil_DCacheFlush(); // Flush DCache after USB Init();

	draw_picture(g_conn_status);

	if(g_conn_status == CAMERA_OK)				//all plugged, dongle + camera
		flag_check_camera_reuse = CHECK_CAMERA_REUSE;
	else										//no dongle, no camera
		flag_check_camera_reuse = CHECK_CAMERA_REUSE_CLEAR;

	#ifdef USE_DEBUG_MESSAGE
	show_dongle_usage_count(dongle_usage_count);
	show_fw_write_count(fw_write_count);
	#endif

	xil_printf("tick(%d) = %d;\t%%%s:%s(%d) bootup OK\r\n", tick_cnt++, g_ms_tick, __FILE__, __func__, __LINE__);


	//font_t font = gdispOpenFont("DejaVu*");

	//gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(0));
	//gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(next_framebuffer));
	//gdispDrawString(680, 950, "0", font, Red);

	//gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(1));

	if(flag_use_2_framebuffers == TRUE)
		gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(next_framebuffer));

	#ifdef USE_DEBUG_MESSAGE
	show_dongle_usage_count(dongle_usage_count);
	show_fw_write_count(fw_write_count);
	#endif

#ifdef USE_DATA_INPUT
	createWidgets();
#endif

	status = gdispImageOpenFile(p_Image, ims_logo);

	status = gdispImageDraw(p_Image, swidth - p_Image->width - BORDER_X * 1, sheight - p_Image->height - BORDER_Y * 2, p_Image->width, p_Image->height, 0, 0);

	//xil_printf("swidth = %d sheight = %d\n\r", swidth, sheight);
	//xil_printf("p_Image->width = %d p_Image->height = %d\n\r", p_Image->width, p_Image->height);
	//xil_printf("x_st = %d y_st = %d\n\r", swidth - p_Image->width - BORDER_X * 2, sheight - p_Image->height - BORDER_Y * 2);

	gdispImageClose(p_Image);

	//gdispDrawBox(LAYER0_WIDTH - LAYER1_WIDTH - BORDER_X, BORDER_Y, LAYER1_WIDTH, LAYER1_HEIGHT, Blue);
	//gdispFillCircle(1850, 950, 10, White);	//for showing using 2 framebuffers

#ifdef USE_DEBUG_CONSOLE
	if(flag_enable_debug_console == TRUE)
	{
		debug_console_init();
	}
#endif
	//gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(1));

	if(flag_use_2_framebuffers == TRUE)
	{
	gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(next_framebuffer));
	//gdispDrawString(680, 950, "1", font, Red);

    pixmap_draw(pixmap_2, surface_2, LAYER2_WIDTH, LAYER2_HEIGHT, NULL, 0, 0, 0, 0, 0, POSITION_MIDDLE_CENTER);
	// Blit surface_2 to the real display at the new position
	gdispBlitArea(BORDER_X, LAYER0_HEIGHT - LAYER2_HEIGHT - BORDER_Y, LAYER2_WIDTH, LAYER2_HEIGHT, surface_2);

	//gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(0));
	gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(next_framebuffer));
	}

#ifndef SW_RELEASE
	font_t font = gdispOpenFont("iskpota232");
	gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(next_framebuffer));
	gdispDrawString(BORDER_X + 190, BORDER_Y + THICK1 * 13, "IMS Demo System", font, White);

	gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(1 - next_framebuffer));
	gdispDrawString(BORDER_X + 190, BORDER_Y + THICK1 * 13, "IMS Demo System", font, White);
#endif

#ifdef FAN_OFF
	xil_printf("\n\rTurn off fan\n\r");
	ps_gpio_setup(&periphs_inst, GPIO_FAN_EN, 0);
	fan_speed = 0;
#endif

#ifdef TEMPERATURE_DEBUG
	xil_printf("\n\r\n\r");
	XAdcGetData();
	xil_printf("\n\r\n\r");
#endif

#ifdef USE_COLOR_DEBUG
	//draw_color();
#endif

	xil_printf("tick(%d) = %d;\t%%%s:%s(%d) main_loop ST\r\n", tick_cnt++, g_ms_tick, __FILE__, __func__, __LINE__);
	main_loop();

    cleanup_platform();
    return 0;
}

#define RELEASE_INFO "Insight Medical Solutions Inc., November-21-2019\n"
#define PROMPT "[aries@ims]# "
#define UART_BUFFER_LEN 20
u8 buffer[UART_BUFFER_LEN];
u8 esc_buffer[3];
u8 ptr = 0;
u8 esc_ptr = 0;
u8 length = 0;
u8 vid_error_cnt = 0;

u8 iii = 0;

uint32_t g_ms_tick_st = 0;
uint32_t g_ms_tick1 = 0;
uint32_t g_ms_tick2 = 0;

void main_loop()
{
	// Local variables
	char c[1]  = {0};
	uint32_t skip_usb_check_cnt = 0;
	uint32_t cnt1 = 0;
	uint32_t cnt3 = 0;
	u32 DataRead;
	u8 SW_Start_old = 0;
	u8 SW_Brighten_old = 0;
	u8 SW_Start_prepare = 0;
	u8 SW_Brighten_prepare = 0;
	int flag_doing_gpio_start = 0;
	int flag_doing_gpio_brighten = 0;
	XGpioPs *Gpio = periphs_inst.p_ps_gpio_inst;

#ifdef USE_DEBUG_VIDEO_OUTPUT
	uint32_t cnt2 = 0;
#endif

//#ifdef USE_IMS_LINK
	unsigned int DongleAddr;
	unsigned char DongleData;
//#endif

	while (1)	// Main loop
	{
#ifdef USE_DEBUG_VIDEO_OUTPUT
		if((cnt2 > 7000) && (cnt2 < 18000) && ((cnt2 % 800) == 0))
		{
			char str[40];
			font_t font = gdispOpenFont("iskpota232");

			sprintf(str, "%d - %c", g_ms_tick, 0x41+(cnt2-7000)/800);
			gdispFillArea(0, 1020, 150, 40, Black);
			//gdispFillString(700, 300 + ((cnt2-7000)/800)*35, str, font, White, Red);
			gdispFillString(0, 1020, str, font, White, Red);

			xil_printf("tick(%d) = %d;\t%%%s:%s(%d) - cnt2 = %d\r\n", tick_cnt++, g_ms_tick, __FILE__, __func__, __LINE__, cnt2);

		}
		cnt2++;
#endif
		if(flag_setup_exposure == 1)	//for DARKEN button
		{
			//xil_printf("main_loop catch darken flag\r\n");
			flag_setup_exposure = 0;
			psuart0_exposure(g_exposure);
		}

		if((cnt1++) == 10000)
		{
			DataRead = XGpioPs_Read(Gpio, XGPIOPS_BANK2);

			//xil_printf("DataRead = 0x%08x\r\n", DataRead);
			cnt1 = 0;

			if((DataRead & LED_1) && (DataRead & LED_CEN) && (DataRead & SW_SMART))
			{
				going_to_engineering_mode_cnt++;
				xil_printf("Going to engineering mode %d\r\n", going_to_engineering_mode_cnt);
			}
			else
			{
				if(going_to_engineering_mode_cnt > 0)
				{
					going_to_engineering_mode_cnt--;
				}
			}
		}

#ifdef USE_PREVENT_REUSE
		if(flag_check_camera_reuse != CHECK_CAMERA_REUSE_NONE)
		{
			if(flag_check_camera_reuse == CHECK_CAMERA_REUSE_CLEAR)	//no dongle, no camera
			{
				check_camera_reuse_clear();
			}
			else if(flag_check_camera_reuse == CHECK_CAMERA_REUSE)	//dongle + camera OK
			{
				check_camera_reuse();
			}
			flag_check_camera_reuse = CHECK_CAMERA_REUSE_NONE;
		}

		if(flag_updateShowCameraDate == 1)
		{
			flag_updateShowCameraDate = 0;
			updateShowCameraDate();
		}
#endif
		if((flag_engineering_mode == FALSE) && (flag_camera_access == 0))
		{
			//xil_printf("ping.[flag_update_dongle_status=%d; flag_battery_fail=%d;flag_engineering_mode=%d; flag_camera_access=%d]-----\n\r", flag_update_dongle_status, flag_battery_fail, flag_engineering_mode, flag_camera_access);//JACKY1125
#if defined(USE_PREVENT_REUSE)
		if((flag_update_dongle_status == 1) && (flag_battery_fail == FALSE))
#elif defined(USE_CORRECT_TIME)
		if(flag_update_dongle_status == 1)
#else
		if(flag_update_dongle_status == 1)
#endif
		{
			flag_update_dongle_status = 0;

			//usleep(100000);	//needed, do not let system too busy....
		//xil_printf("p");		//ping camera status

		g_conn_status = psuart0_dongle_ping();	//needed, david @ 20191206

		if((g_conn_status_old != g_conn_status) && (flag_camera_access == 0))
		{
			if(g_conn_status == DONGLE_NONE)
			{
				flag_forbid_video = FALSE;
				xil_printf("no dongle or camera step_1\n\r");
				SetDongleLedGreenStatus(0);		//turn off green led on dongle
				print_time_clear();
				// Set Flags
				g_dongle_plugged = 0;
				g_camera_plugged = 0;
				// Show Message
				RequestShowPicture2(0);
#ifdef USE_PREVENT_REUSE
				char str[40];
				sprintf(str, "no dongle : %s", asctime(&rtc));
				debug_console_print(str);
#endif
				xil_printf("\n\rTurn off camera LED e\n\r");
				ps_gpio_setup(&periphs_inst, GPIO_CAM_LED, 0);
				flag_camera_led_status = 0;
			}
			else if (g_conn_status == CAMERA_NONE)
			{
				flag_forbid_video = FALSE;
				xil_printf("\n\r\n\rdongle only step_2\t%s\n\r", asctime(&rtc));
				//xil_printf("tick(%d) = %d;\t%%%s:%s(%d)\r\n", tick_cnt++, g_ms_tick, __FILE__,__func__,__LINE__);
				SetDongleLedGreenStatus(0);		//turn off green led on dongle
				print_time_clear();

				// Set Flags
				g_dongle_plugged = 1;
				g_camera_plugged = 0;
				// Show Message
				RequestShowPicture2(1);
				g_ms_tick_start = g_ms_tick;

#ifdef USE_PREVENT_REUSE
				if(g_procedure_started == START) {
					xil_printf("g_procedure_started = START\n\r");
				}
				else
					xil_printf("g_procedure_started = STOP\n\r");

				char str[40];
				sprintf(str, "pull out : %s", asctime(&rtc));
				debug_console_print(str);

				print_time(0);
#endif
				xil_printf("\n\rTurn off camera LED f\n\r");
				//xil_printf("tick(%d) = %d;\t%%%s:%s(%d)\r\n", tick_cnt++, g_ms_tick, __FILE__,__func__,__LINE__);
				ps_gpio_setup(&periphs_inst, GPIO_CAM_LED, 0);
				flag_camera_led_status = 0;
				flag_use_user_brightness = FALSE;
			}
			else	//CAMERA_OK
			{
//				flag_forbid_video = FALSE;
				xil_printf("\ntick(%d) = %d;\t%%%s:%s(%d) CAMERA OK\r\n", tick_cnt++, g_ms_tick, __FILE__,__func__,__LINE__);
#ifdef USE_PREVENT_REUSE
				flag_camera_status = get_camera_status();

				if(flag_camera_status == CAMERA_2HR)
				{
					xil_printf("\ntick(%d) = %d;\t%%%s:%s(%d) CAMERA OK flag_camera_status == CAMERA_2HR\r\n", tick_cnt++, g_ms_tick, __FILE__,__func__,__LINE__);
					flag_forbid_video = TRUE;
				}
				else
				{
					xil_printf("\ntick(%d) = %d;\t%%%s:%s(%d) CAMERA OK flag_camera_status XX CAMERA_2HR\r\n", tick_cnt++, g_ms_tick, __FILE__,__func__,__LINE__);
				}

				xil_printf("tick(%d) = %d;\t%%%s:%s(%d) flag_camera_status = %d\r\n", tick_cnt++, g_ms_tick, __FILE__,__func__,__LINE__, flag_camera_status);
				char str[40];
				sprintf(str, "plug in : %s", asctime(&rtc));
				debug_console_print(str);

				if(flag_forbid_video == TRUE)
				{
					xil_printf("\n\r\n\rforbid video mode.... abort a\t%s", asctime(&rtc));
					xil_printf("\n\r%s", PROMPT);
					xil_printf("\n\rTurn off camera LED g\n\r");
					ps_gpio_setup(&periphs_inst, GPIO_CAM_LED, 0);
					flag_camera_led_status = 0;
				}
				else
#endif
				{
					xil_printf("david0529: %s:%s(%d) ST\r\n",__FILE__,__func__,__LINE__);
					check_awb_data();
					xil_printf("david0529: %s:%s(%d) ST\r\n",__FILE__,__func__,__LINE__);
					apply_camera_ufm_data();
					xil_printf("\n\rtotal_camera_count = %d\r\n", total_camera_count++);

					xil_printf("\n\r\n\rdongle+camera step_3 --------------\t%s\n\r", asctime(&rtc));
					//xil_printf("tick(%d) = %d;\t%%%s:%s(%d)\r\n", tick_cnt++, g_ms_tick, __FILE__,__func__,__LINE__);
					SetDongleLedGreenStatus(1);		//turn on green led on dongle
					print_time_clear();
					//xil_printf("\n\rTurn on camera LED h\n\r");
					//ps_gpio_setup(&periphs_inst, GPIO_CAM_LED, 1);
					//flag_camera_led_status = 1;
					// Set Flags
					g_dongle_plugged = 1;
					g_camera_plugged = 1;

					if(g_procedure_started == STOP)
					{
						// Show Message
						RequestShowPicture2(2);
					}
					else
					{
						// Clear Message
						RequestShowPicture2(-1);
					}

					if(XVMix_IsLayerEnabled(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_1) == 0)
					{
						XVMix_LayerEnable(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_1);
					}
					g_ms_tick_start = g_ms_tick;

					increase_dongle_usage_count();
#ifdef USE_DEBUG_MESSAGE
					show_dongle_usage_count(dongle_usage_count);
					if(flag_use_2_framebuffers == TRUE)
					{
						gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(next_framebuffer));
						show_dongle_usage_count(dongle_usage_count);
						gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(next_framebuffer));
					}
#endif
					flag_camera_led_status = 1;
					psuart0_exposure(g_exposure);

					xil_printf("tick(%d) = %d;\t%%%s:%s(%d)\r\n", tick_cnt++, g_ms_tick, __FILE__,__func__,__LINE__);

					xil_printf("\n\rTurn on camera LED h1\n\r");
					ps_gpio_setup(&periphs_inst, GPIO_CAM_LED, 1);
					flag_camera_led_status = 1;
					SetDongleLedGreenStatus(1);		//turn on green led on dongle

					usleep(DELAY*100);
					xil_printf("\n\rTurn off camera LED h2\n\r");
					ps_gpio_setup(&periphs_inst, GPIO_CAM_LED, 0);
					flag_camera_led_status = 0;
					SetDongleLedGreenStatus(0);		//turn off green led on dongle

					usleep(DELAY*100);
					xil_printf("\n\rTurn on camera LED h3\n\r");
					ps_gpio_setup(&periphs_inst, GPIO_CAM_LED, 1);
					flag_camera_led_status = 1;
					SetDongleLedGreenStatus(1);		//turn on green led on dongle

#ifdef USE_AUTO_LIGHT
					usleep(DELAY*100);
					xil_printf("\n\rTurn off camera LED h4\n\r");
					ps_gpio_setup(&periphs_inst, GPIO_CAM_LED, 0);
					flag_camera_led_status = 0;
#endif
				}
#ifdef USE_COLOR_DEBUG
				//dongle_write_data(0x5080, 0x81);
#endif
			}
			//Xil_DCacheFlush();
			//Xil_DCacheDisable();

			draw_picture(g_conn_status);
			if(g_conn_status == CAMERA_OK)		//all plugged, dongle + camera
				flag_check_camera_reuse = CHECK_CAMERA_REUSE;
			else								//no dongle, no camera
				flag_check_camera_reuse = CHECK_CAMERA_REUSE_CLEAR;

			g_conn_status_old = g_conn_status;

			if(flag_operation_mode == MODE_IMS_LINK)
			{
				usleep(300000);
				Send_IMS_Data_Cmd(0xFF, g_conn_status, 0x00);
			}
		}

		if(g_conn_status == DONGLE_NONE) // Nothing is plugged in
		{
			if(g_procedure_started == START) { // Procedure not started

			}
			else {
				if(g_dongle_plugged || g_camera_plugged){
					// Update Flags
					g_dongle_plugged = 0;
					g_camera_plugged = 0;
					// Dongle unplugged
					xil_printf("no dongle or camera step_1\n\r");
					SetDongleLedGreenStatus(0);		//turn off green led on dongle
					// Show Message to plug in dongle
					XVMix_LayerDisable(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_1);
					RequestShowPicture2(0);
					xil_printf("\n\r%s", PROMPT);
					xil_printf("\n\rTurn off camera LED i\n\r");
					ps_gpio_setup(&periphs_inst, GPIO_CAM_LED, 0);
					flag_camera_led_status = 0;
				}
			}
		}
		else if(g_conn_status == CAMERA_NONE){ // Only dongle is plugged in

			if(g_procedure_started == START){ // Procedure started

			}
			else { // Procedure hasn't started
				if(g_dongle_plugged == 0 || g_camera_plugged){
					// Update Flags
					g_dongle_plugged = 1;
					g_camera_plugged = 0;
					// Dongle plugged
					xil_printf("dongle plugged step_2\n\r");
					SetDongleLedGreenStatus(0);		//turn off green led on dongle
					XVMix_LayerDisable(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_1);
					RequestShowPicture2(1);
					xil_printf("\n\r%s", PROMPT);
					xil_printf("\n\rTurn off camera LED j\n\r");
					ps_gpio_setup(&periphs_inst, GPIO_CAM_LED, 0);
					flag_camera_led_status = 0;
				}
			}
		}
		else { // Everything is plugged in		//CAMERA_OK
			if(g_procedure_started == START) { // Procedure not started
				//xil_printf("ggg\r\n");
			}
			else {
				if(g_dongle_plugged == 0 || g_camera_plugged == 0){
					// Update Flags
					g_dongle_plugged = 1;
					g_camera_plugged = 1;
					// Dongle plugged

					//Xil_DCacheEnable();
					xil_printf("all plugged step_3\n\r");
					SetDongleLedGreenStatus(1);		//turn on green led on dongle
					XVMix_LayerEnable(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_1);
					RequestShowPicture2(2);
					increase_dongle_usage_count();
#ifdef USE_DEBUG_MESSAGE
					show_dongle_usage_count(dongle_usage_count);
					if(flag_use_2_framebuffers == TRUE)
					{
						gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(next_framebuffer));
						show_dongle_usage_count(dongle_usage_count);
						gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(next_framebuffer));
					}
#endif
					xil_printf("\n\r%s", PROMPT);
					//xil_printf("\n\rTurn on camera LED k\n\r");
					//ps_gpio_setup(&periphs_inst, GPIO_CAM_LED, 1);
					//flag_camera_led_status = 1;
				}
			}
		}

#ifdef USE_AUTO_LIGHT
		if(g_conn_status == CAMERA_OK)
		{
			//xil_printf("%4d", get_average_gray_value());
			if(flag_camera_led_status == 0)
			{
				#ifdef USE_CORRECT_TIME
				#ifdef USE_PREVENT_REUSE
				if((flag_battery_fail == FALSE) && (flag_forbid_video == FALSE))
				{
				#endif
				#endif
					if(get_average_gray_value() < 50)
					{
						xil_printf("\n\rTurn on camera LED\n\r");
						ps_gpio_setup(&periphs_inst, GPIO_CAM_LED, 1);
						flag_camera_led_status = 1;
					}
				#ifdef USE_CORRECT_TIME
				#ifdef USE_PREVENT_REUSE
				}
				#endif
				#endif
			}
		}
#endif
		}
		else if(update_usb_status == 1)
		{
			update_usb_status = 0;

			//xil_printf("david0823: %s:%s(%d) ST usb_reset_status = %d\r\n",__FILE__,__func__,__LINE__,usb_reset_status);

			if((usb_reset_status_old == 0) && (usb_reset_status == 1))
			{
				xil_printf("A");
				skip_usb_check_cnt++;
				g_ms_tick_wait = g_ms_tick;
				usb_reset_status_old = 1;
			}
			else if((usb_reset_status_old == 1) && (usb_reset_status == 1))
			{
				xil_printf("B %d ", skip_usb_check_cnt);
				skip_usb_check_cnt++;
				//xil_printf("david0823: %s:%s(%d) wait %d\r\n",__FILE__,__func__,__LINE__,skip_usb_check_cnt);
				if(skip_usb_check_cnt > 3)
				{
					xil_printf("C");
					//xil_printf("david0823: %s:%s(%d) OK\r\n",__FILE__,__func__,__LINE__);
					skip_usb_check_cnt = 0;
					usb_reset_status = 0;
					usb_reset_status_old = 0;
				}
			}
			else
			{
				updateConsoleWidgets();
			}
		}
		else if((flag_is_keyboard_mounted == 1) && (flag_get_usb_descriptor_done == 0))
		{
			//First time get usb descriptor
			flag_get_usb_descriptor_done = 1;
			get_usb_descriptor();
		}
		else if((update_usb_descriptor_status == 1) && (flag_get_usb_descriptor_done == 1) && (g_ms_tick > 6000) && (usb_reset_status == 0))
		{
			//Get usb descriptor when keyboard is mounted
			update_usb_descriptor_status = 0;
			//xil_printf("G\r\n");
			get_usb_descriptor();	//here

			psusb0_hal_interrupt_disable(0);
			hal_interrupt_disable(0);
			get_usb_descriptor();
			hal_interrupt_enable(0);
			psusb0_hal_interrupt_enable(0);

		}
		else if((update_usb_descriptor_status == 1) && (flag_is_keyboard_mounted == 0) && (g_ms_tick > 6000) && (usb_reset_status == 0))
		{
			//Get usb descriptor when keyboard is un-mounted
			//xil_printf("\n\r3333\t");
			update_usb_descriptor_status = 0;
			//get_usb_descriptor();
			//xil_printf("f");

			psusb0_hal_interrupt_disable(0);
			hal_interrupt_disable(0);
			xil_printf("Uxxxxxxxxxxx\r\n");
			get_usb_descriptor();
			hal_interrupt_enable(0);
			psusb0_hal_interrupt_enable(0);

		}
		else if((flag_is_keyboard_mounted == 1) && (flag_is_keyboard_mounted_old == 0))
		{
			xil_printf("tick(%d) = %d;\t%%%s:%s(%d) KEYBOARD OK\r\n", tick_cnt++, g_ms_tick, __FILE__, __func__, __LINE__);
			draw_picture(KEYBOARD_OK);
			flag_is_keyboard_mounted_old = flag_is_keyboard_mounted;
			xil_printf("\n\r%s", PROMPT);
		}
		else if((flag_is_keyboard_mounted == 0) && (flag_is_keyboard_mounted_old == 1))
		{
			draw_picture(KEYBOARD_NONE);
			flag_is_keyboard_mounted_old = flag_is_keyboard_mounted;
		}
		else if(flag_is_keyboard_mounted == 0)
		{
			flag_get_usb_descriptor_done = 0;
		}
		}

		if(flag_camera_access == 0)
		{
		if(g_updated) {
			g_updated = 0;
#ifdef USE_PREVENT_REUSE
			if(flag_forbid_video == TRUE)
			{
				xil_printf("\n\r\n\rforbid video mode.... abort b\r\n");
				xil_printf("\n\r%s", PROMPT);
			}
			else
#endif
			{
				if(g_procedure_started == START) { // Remove all pictures
					xil_printf("\n\r\n\rupdate remove picture START\t%s", asctime(&rtc));
					xil_printf("\n\r%s", PROMPT);
					RequestShowPicture2(-1);
					if(g_conn_status_old != CAMERA_OK)
					{
						g_conn_status_old = CAMERA_CLEAR;		//force draw picture again
					}
					g_ms_tick_start = g_ms_tick;
				}
				else { // Add back picture
					xil_printf("\n\r\n\rupdate add picture START step_3 ----------------\t%s", asctime(&rtc));
					xil_printf("\n\r%s", PROMPT);
					RequestShowPicture2(2);
				}
				psuart0_exposure(g_exposure);
			}
		}
		}

		//  Run USB Host Task Handlers
		tusb_task_runner(); // USB House Keeping
	    keyboard_host_app_task(NULL); // Keyboard tasks
	    //mouse_host_app_task(NULL); // Mouse Tasks
		//Xil_DCacheFlush();

	    if(flag_update_RTC_status == 1)
	    {
	    	flag_update_RTC_status = 0;
	    	//xil_printf("tick(%d) = %d;\t%%%s:%s(%d) ST\r\n", tick_cnt++, g_ms_tick, __FILE__,__func__,__LINE__);
	    	//xil_printf("tick(%d) = %d;\t%%%s:%s(%d) call update_RTC_data mm = %d ss = %d\r\n", tick_cnt++, g_ms_tick, __FILE__,__func__,__LINE__,rtc.tm_min, rtc.tm_sec);

			#ifdef USE_RTC
	    	update_RTC_data();
			#endif

	    	if(flag_use_2_framebuffers == TRUE)
	    		update_framebuffer();

	    	check_draw_command();

	    	if(flag_engineering_mode == TRUE)
	    	{
	    		XAdcGetCurrentTemperature();
	    	}

	    	#ifdef TEMPERATURE_DEBUG
    		XAdcGetCurrentTemperature();
	    	if(temperature_array_index <= DEBUG_LENGTH)
	    	{
	    		XAdcGetData();
	    	}
			#endif
	    }

	    /* old engineering mode
	    if((flag_engineering_mode_old == 0) && (flag_engineering_mode == 1))
		{
	    	flag_engineering_mode_old = 1;
	    	show_engineering_mode();
		}
		*/

		if((cnt3++) == 1000)
		{
			cnt3 = 0;
			DataRead = XGpioPs_Read(Gpio, XGPIOPS_BANK2);

			if(DataRead & SW_START)		//process SW_START
			{
				if(SW_Start_old == 0)
				{
					SW_Start_prepare++;
					if(SW_Start_prepare == 1)
					{
						g_ms_tick_st = g_ms_tick;
						g_ms_tick1 = g_ms_tick;
						//xil_printf("\n\r");
					}
					if(SW_Start_prepare == 10)	//about 0.03 sec
					{
						//ok to start
						SW_Start_old = 1;
						g_ms_tick2 = g_ms_tick;
						flag_doing_gpio_start = 1;

						//xil_printf("START\t%d\t%d\t", g_ms_tick1 - g_ms_tick_st, g_ms_tick2 - g_ms_tick_st);
						//xil_printf("START\r\n");
						// Check if we are in a active session
		#ifdef USE_PREVENT_REUSE
						if(flag_forbid_video == FALSE)
		#endif
						{
							if(g_procedure_started == START) { // We are in a active session
								if(g_conn_status == CAMERA_OK)	//dongle + camera
								{
									xil_printf("turn off\r\n");
									g_updated = 1;
									g_procedure_started = STOP;
								}
								else
								{
									xil_printf("no turn off, no dongle or camera\r\n");
								}
							}
							else
							{
								if(g_conn_status == CAMERA_OK)	//dongle + camera
								{
									xil_printf("turn on\r\n");
									g_updated = 1;
									g_procedure_started = START;
								}
								else
								{
									xil_printf("no turn on, no dongle or camera\r\n");
								}
							}
						}
					}
				}
			}
			else
			{
				if(flag_doing_gpio_start == 1)
				{
					flag_doing_gpio_start = 0;
					SW_Start_prepare = 0;
				}

				if(SW_Start_prepare != 0)
				{
					xil_printf("no start %d %d", SW_Start_prepare, g_ms_tick - g_ms_tick_st);
					SW_Start_prepare = 0;
				}
				SW_Start_old = 0;
			}

			if(DataRead & SW_BRIGHT)	//process SW_BRIGHT
			{
				if(SW_Brighten_old == 0)
				{
					SW_Brighten_prepare++;
					if(SW_Brighten_prepare == 1)
					{
						g_ms_tick_st = g_ms_tick;
						g_ms_tick1 = g_ms_tick;
						//xil_printf("\n\r");
					}
					if(SW_Brighten_prepare == 10)	//about 0.03 sec
					{
						//ok to start
						SW_Brighten_old = 1;
						g_ms_tick2 = g_ms_tick;
						flag_doing_gpio_brighten = 1;

						//xil_printf("BRIGHT\t%d\t%d\t", g_ms_tick1 - g_ms_tick_st, g_ms_tick2 - g_ms_tick_st);
						//xil_printf("BRIGHT\r\n");
						// Only lower exposure if at values above 1
						if(g_exposure < 5) {
							g_exposure++;
							psuart0_exposure(g_exposure);
						}
					}
				}
			}
			else
			{
				if(flag_doing_gpio_brighten == 1)
				{
					flag_doing_gpio_brighten = 0;
					SW_Brighten_prepare = 0;
					//xil_printf("Btn up %d\n\r", g_ms_tick - g_ms_tick_st);

					if((g_ms_tick - g_ms_tick_st) > 3000)	//long press more than 3 sec
					{
						if(flag_camera_led_status == 1)
						{
							xil_printf("\n\rTurn off camera LED -\n\r");
							ps_gpio_setup(&periphs_inst, GPIO_CAM_LED, 0);
							flag_camera_led_status = 0;
						}
						else
						{
							xil_printf("\n\rTurn on camera LED -\n\r");
							ps_gpio_setup(&periphs_inst, GPIO_CAM_LED, 1);
							flag_camera_led_status = 1;
						}
					}
				}

				if(SW_Brighten_prepare != 0)
				{
					xil_printf("no brighten %d %d", SW_Brighten_prepare, g_ms_tick - g_ms_tick_st);
					SW_Brighten_prepare = 0;
				}
				SW_Brighten_old = 0;
			}
		}

		c[0] = XUartPs_RecvByte(XPAR_PS7_UART_1_BASEADDR);

		//#ifndef USE_IMS_LINK
		if(flag_operation_mode == MODE_PUTTY)
		{
		if(c[0] == 0)
			continue;

		buffer[ptr] = c[0];
		esc_buffer[esc_ptr] = c[0];
		ptr++;

		if(c[0] == 0x0d)	//Enter
		{
			/*
			for(i=0;i<ptr;i++)
			{
				xil_printf("0x%x ", buffer[i]);
			}
			xil_printf("\n\r");
			*/

			length = ptr;
			ptr = 0;
			/*
			//for(i = 0 ; i < (length - 1); i++)
				//xil_printf("%c", 0x18);
			for(i = 0 ; i < (length - 1); i++)
				xil_printf("%c", 0x7F);
			xil_printf("---");
			*/

			if(length == 1)
			{
				last_command_length = 0;
				last_command[0] = 'h';
				last_command[1] = 'e';
				last_command[2] = 'l';
				last_command[3] = 'p';
			}
			parse_uart_command();
			xil_printf("\n\r%s", PROMPT);
		}
		else if(c[0] == 0x03)	//ctrl + C
		{
			#ifdef TEMPERATURE_DEBUG
				xil_printf("\n\r\n\rbreak temperature debug...\n\r");
				temperature_array_index = DEBUG_LENGTH + 1;
			#endif
				length = 0;
				ptr = 0;
				xil_printf("\n\r%s", PROMPT);
				continue;
		}
		else
		{
			if(c[0] == 0x1B)
			{
				esc_mode = 1;
				buffer[0] = c[0];
				ptr = 1;
				continue;
			}
			else if(c[0] == 0x7F)
			{
				if(ptr >= 2)
				{
					xil_printf("%c", 0x7F);
					//xil_printf(".");
					ptr -= 2;
				}
				else
					ptr--;

				continue;
			}

			if(esc_mode == 1)
			{
				if(ptr == 3)
				{
					//ptr = 0;
					parse_uart_esc_command();
					esc_mode = 0;
				}
				continue;
			}

			if(isprint(c[0]))
				xil_printf("%c", c[0]);
			else
				xil_printf("0x%02x", c[0]);
		}
		usleep(100);
		}
		else
	//#else	//USE_IMS_LINK
		{
		uint32_t status;
		if(flag_receive_camera_serial == 1)
		{
			received_camera_data[received_camera_data_index] = c[0];
			received_camera_data_index++;
			if(received_camera_data_index == 21)
			{
				uint32_t g_ms_tick_tmp;
				xil_printf("tick(%d) = %d;\t%%%s:%s(%d) camera erase and write serial ST\r\n", tick_cnt++, g_ms_tick, __FILE__, __func__, __LINE__);
				g_ms_tick_tmp = g_ms_tick;

				received_camera_data_index = 0;
				flag_receive_camera_serial = 0;

				int i;
				char str[50];
				if(received_camera_data[9] == 0xff)
				{
				sprintf(str, "S/N: %c%c%c%c%c%c%c%c%c   %c%c%c%c-%c%c%c-%c%c%c%c\n\r",
						received_camera_data[0], received_camera_data[1], received_camera_data[2], received_camera_data[3],
						received_camera_data[4], received_camera_data[5], received_camera_data[6], received_camera_data[7],
						received_camera_data[8], received_camera_data[10], received_camera_data[11], received_camera_data[12],
						received_camera_data[13], received_camera_data[14], received_camera_data[15], received_camera_data[16],
						received_camera_data[17], received_camera_data[18], received_camera_data[19], received_camera_data[20]);
				}
				else
				{
				sprintf(str, "S/N: %c%c%c%c%c%c%c%c%c%c   %c%c%c%c-%c%c%c-%c%c%c%c\n\r",
						received_camera_data[0], received_camera_data[1], received_camera_data[2], received_camera_data[3],
						received_camera_data[4], received_camera_data[5], received_camera_data[6], received_camera_data[7],
						received_camera_data[8], received_camera_data[9], received_camera_data[10], received_camera_data[11],
						received_camera_data[12], received_camera_data[13], received_camera_data[14], received_camera_data[15],
						received_camera_data[16], received_camera_data[17], received_camera_data[18], received_camera_data[19], received_camera_data[20]);
				}

				debug_console_print(str);

				for(i = 0;i < 16; i++)
				{
					user_camera_data8[i] = 0;
					user_camera_data9[i] = 0;
				}

				for(i = 0;i < 10; i++)
				{
					user_camera_data8[i] = received_camera_data[i];				//data prepare to write to flash
				}

				for(i = 0;i < 11; i++)
				{
					user_camera_data9[i] = received_camera_data[i + 10];		//data prepare to write to flash
				}

				/*
				xil_printf("\n\rcamera erase data\n\r");
				xil_printf("\n\rENABLE_CONFIGURE\n\r");
				ENABLE_CONFIGURE(1);
				xil_printf("\n\rSET_ADDRESS\n\r");
				SET_ADDRESS(SN_PAGE2);
				xil_printf("\n\rERASE_UFM\n\r");
				ERASE_UFM();
				xil_printf("\n\rDISABLE_CONFIGURE\n\r");
				ENABLE_CONFIGURE(0);
				//xil_printf("\n\rwrite_serial_to_camera 111\n\r");
				*/

				/*
				xil_printf("\n\rsleep st\n\r");
				sleep(2);	//must be 2
				xil_printf("\n\rsleep sp\n\r");
				//xil_printf("\n\rwrite_serial_to_camera\n\r");

				write_user_serial_to_camera();
				sleep(1);
				flag_camera_access = 0;
				*/

				/*
				sleep(1);	//must > 1
				usleep(200000);
				*/

				xil_printf("\n\rread_serial_from_camera\n\r");
				int status;
				status = read_serial_from_camera();			//camera sn1 0x8, camera sn2 0x9

				if(status == XST_SUCCESS)
				{
					if(camera_data_serial1[0] == 0)
					{
						usleep(200000);
						Send_IMS_Data_Cmd(0xEE, 0xEE, 0x00);
						usleep(200000);

						xil_printf("no serial, continue\n");

						xil_printf("\n\rcamera write serial\n\r");
						write_user_serial_to_camera();
						xil_printf("\n\rcamera write serial OK\n\r");
						xil_printf("\n\r\n\r");
						xil_printf("tick(%d) = %d;\t%%%s:%s(%d) camera erase and write serial SP, spend %d msec\r\n", tick_cnt++, g_ms_tick, __FILE__, __func__, __LINE__, (g_ms_tick - g_ms_tick_tmp) * 1);
						xil_printf("\n\r\n\r");
						Send_IMS_Data_Cmd(0xEE, 0xEE, 0x00);
					}
					else
					{
						usleep(200000);
						Send_IMS_Data_Cmd(0xEE, 0xEE, 0xEE);
						usleep(200000);
						xil_printf("already has camera serial\n");
						if(camera_data_serial1[9] == 0xff)	//9B
						{
							xil_printf("\n\rS/N: %c%c%c%c%c%c%c%c%c   %c%c%c%c-%c%c%c-%c%c%c%c\n\r",
								camera_data_serial1[0], camera_data_serial1[1], camera_data_serial1[2], camera_data_serial1[3],
								camera_data_serial1[4], camera_data_serial1[5], camera_data_serial1[6], camera_data_serial1[7],
								camera_data_serial1[8], camera_data_serial2[0], camera_data_serial2[1], camera_data_serial2[2],
								camera_data_serial2[3], camera_data_serial2[4], camera_data_serial2[5], camera_data_serial2[6],
								camera_data_serial2[7], camera_data_serial2[8], camera_data_serial2[9], camera_data_serial2[10]);
						}
						else	//10B
						{
							xil_printf("\n\rS/N: %c%c%c%c%c%c%c%c%c%c   %c%c%c%c-%c%c%c-%c%c%c%c\n\r",
								camera_data_serial1[0], camera_data_serial1[1], camera_data_serial1[2], camera_data_serial1[3],
								camera_data_serial1[4], camera_data_serial1[5], camera_data_serial1[6], camera_data_serial1[7],
								camera_data_serial1[8], camera_data_serial1[9], camera_data_serial2[0], camera_data_serial2[1], camera_data_serial2[2],
								camera_data_serial2[3], camera_data_serial2[4], camera_data_serial2[5], camera_data_serial2[6],
								camera_data_serial2[7], camera_data_serial2[8], camera_data_serial2[9], camera_data_serial2[10]);
						}
					}
				}
				else
				{
					Send_IMS_Data_Cmd(0xFF, 0xFF, 0xFF);
				}
				flag_camera_access = 0;
			}
		}
		else if(flag_receive_camera_model == 1)
		{
			received_camera_data[received_camera_data_index] = c[0];
			received_camera_data_index++;
			if(received_camera_data_index == 16)
			{
				received_camera_data_index = 0;
				flag_receive_camera_model = 0;

				int i;
				char str[50];
				sprintf(str, "model : %c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c\n\r",
						received_camera_data[0], received_camera_data[1], received_camera_data[2], received_camera_data[3],
						received_camera_data[4], received_camera_data[5], received_camera_data[6], received_camera_data[7],
						received_camera_data[8], received_camera_data[9], received_camera_data[10], received_camera_data[11],
						received_camera_data[12], received_camera_data[13], received_camera_data[14], received_camera_data[15]);

				debug_console_print(str);

				for(i = 0;i < 16 ; i++)
				{
					user_camera_data[i] = received_camera_data[i];		//data prepare to write to flash

				}
				/*
				xil_printf("\n\rcamera erase data\n\r");
				xil_printf("\n\rENABLE_CONFIGURE\n\r");
				ENABLE_CONFIGURE(1);
				xil_printf("\n\rSET_ADDRESS\n\r");
				SET_ADDRESS(MODEL_PAGE);
				xil_printf("\n\rERASE_UFM\n\r");
				ERASE_UFM();
				xil_printf("\n\rDISABLE_CONFIGURE\n\r");
				ENABLE_CONFIGURE(0);
				//xil_printf("\n\rwrite_model_to_camera 111\n\r");

				xil_printf("\n\rsleep st\n\r");
				sleep(2);	//must be 2
				xil_printf("\n\rsleep sp\n\r");
				//xil_printf("\n\rwrite_model_to_camera\n\r");
				*/

				write_user_model_to_camera();
				sleep(1);
				flag_camera_access = 0;
			}
		}
		else if(flag_receive_camera_raw_data == 1)
		{
			received_camera_raw_data[received_camera_raw_data_index] = c[0];
			received_camera_raw_data_index++;
			if(received_camera_raw_data_index == 16)
			{
				//uint32_t g_ms_tick_tmp;
				xil_printf("\n\rtick(%d) = %d;\t%%%s:%s(%d) received camera raw data\r\n", tick_cnt++, g_ms_tick, __FILE__, __func__, __LINE__);
				//g_ms_tick_tmp = g_ms_tick;

				received_camera_raw_data_index = 0;
				flag_receive_camera_raw_data = 0;

				int i;
				char str[50];
				sprintf(str, "data: %02x%02x%02x%02x %02x%02x%02x%02x %02x%02x%02x%02x %02x%02x%02x%02x\n\r",
						received_camera_raw_data[0], received_camera_raw_data[1], received_camera_raw_data[2], received_camera_raw_data[3],
						received_camera_raw_data[4], received_camera_raw_data[5], received_camera_raw_data[6], received_camera_raw_data[7],
						received_camera_raw_data[8], received_camera_raw_data[9], received_camera_raw_data[10], received_camera_raw_data[11],
						received_camera_raw_data[12], received_camera_raw_data[13], received_camera_raw_data[14], received_camera_raw_data[15]);
				debug_console_print(str);


				xil_printf("abbb camera flash write, page = 0x%x = %d\n\r", ufm_write_page, ufm_write_page);

				/*

				for(i = 0;i < 16; i++)
				{
					user_camera_data8[i] = 0;
					user_camera_data9[i] = 0;
				}

				for(i = 0;i < 9; i++)
				{
					user_camera_data8[i] = received_camera_data[i];				//data prepare to write to flash
				}

				for(i = 0;i < 11; i++)
				{
					user_camera_data9[i] = received_camera_data[i + 9];		//data prepare to write to flash
				}

				 */

				for(i = 0;i < 16; i++)
				{
					page_data[i] = received_camera_raw_data[i];
				}

				//xil_printf("\n\rwrite_user_flah_data_to_camera page = 0x%02x = %d\n\r", ufm_write_page, ufm_write_page);
				//xil_printf("\n\rENABLE_CONFIGURE\n\r");
				ENABLE_CONFIGURE(1);
				//xil_printf("\n\rSET_ADDRESS\n\r");
				SET_ADDRESS(ufm_write_page);
				usleep(DELAY);
				//xil_printf("\n\rPROG_1PAGE\n\r");
				//PROG_1PAGE();
				PROG_1PAGE_user_data();
				xil_printf("\n\rDISABLE_CONFIGURE\n\r");
				ENABLE_CONFIGURE(0);

				xil_printf("\n\rsleep st\n\r");
				sleep(2);	//must be 2
				xil_printf("\n\rsleep sp\n\r");
				flag_camera_access = 0;

				xil_printf("\n\rwrite user flash data to camera flash OK, page = 0x%02x = %d\n\r", ufm_write_page, ufm_write_page);

				//apply data to camera
				if(ufm_write_page == USER_PAGE1)
				{
					xil_printf("Setup saturation TH2 = 0x%02x = %d\n\r", page_data[9], page_data[9]);
					xil_printf("Setup saturation TH1 = 0x%02x = %d\n\r", page_data[12], page_data[12]);

					flag_camera_access = 1;

					DongleAddr = page_data[7] << 8 | page_data[8];
					DongleData = page_data[9];

					dongle_write_data(DongleAddr, DongleData);
					usleep(2000);

					DongleAddr = page_data[10] << 8 | page_data[11];
					DongleData = page_data[12];

					dongle_write_data(DongleAddr, DongleData);
					usleep(2000);

					flag_camera_access = 0;

				}
				else if(ufm_write_page == USER_PAGE2)
				{
					if((page_data[1] == 0xAA) && (page_data[2] == 0xBB))
					{
						flag_use_user_brightness = TRUE;
						default_user_brightness = page_data[3];

						xil_printf("Setup default_user_brightness = %d\n\r", default_user_brightness);

						g_exposure = 3;
						psuart0_exposure(g_exposure);
					}
					else
					{
						xil_printf("data wrong, abort\n\r");
					}
				}

				/*
				xil_printf("\n\rcamera erase data\n\r");
				xil_printf("\n\rENABLE_CONFIGURE\n\r");
				ENABLE_CONFIGURE(1);
				xil_printf("\n\rSET_ADDRESS\n\r");
				SET_ADDRESS(SN_PAGE2);
				xil_printf("\n\rERASE_UFM\n\r");
				ERASE_UFM();
				xil_printf("\n\rDISABLE_CONFIGURE\n\r");
				ENABLE_CONFIGURE(0);
				//xil_printf("\n\rwrite_serial_to_camera 111\n\r");
				*/

				/*
				xil_printf("\n\rsleep st\n\r");
				sleep(2);	//must be 2
				xil_printf("\n\rsleep sp\n\r");
				//xil_printf("\n\rwrite_serial_to_camera\n\r");

				write_user_serial_to_camera();
				sleep(1);
				flag_camera_access = 0;
				*/

				/*
				sleep(1);	//must > 1
				usleep(200000);
				*/

				flag_camera_access = 0;
			}
		}
		else if(flag_receive_camera_awb_data == 1)
		{
			received_camera_data[received_camera_data_index] = c[0];
			received_camera_data_index++;
			if(received_camera_data_index == 4)
			{
				received_camera_data_index = 0;
				flag_receive_camera_awb_data = 0;

				int i;
				char str[50];
				sprintf(str, "AWB data : R : 0x%02x%02x B : 0x%02x%02x\n\r",
						received_camera_data[0], received_camera_data[1], received_camera_data[2], received_camera_data[3]);

				debug_console_print(str);

				int data_r = received_camera_data[0] << 8 | received_camera_data[1];
				int data_b = received_camera_data[2] << 8 | received_camera_data[3];

				xil_printf("\ncamera AWB data R : 0x%04x = %4d  B : 0x%04x = %4d ", data_r, data_r, data_b, data_b);

				for(i = 0;i < 16 ; i++)
				{
					user_camera_data[i] = 0;

				}

				for(i = 0;i < 4 ; i++)
				{
					user_camera_data[i] = received_camera_data[i];		//data prepare to write to flash
				}

				xil_printf("\n\rwrite_user_awb_data_to_camera\n\r");
				//xil_printf("\n\rENABLE_CONFIGURE\n\r");
				ENABLE_CONFIGURE(1);
				//xil_printf("\n\rSET_ADDRESS\n\r");
				SET_ADDRESS(AWB_PAGE0);
				usleep(DELAY);
				//xil_printf("\n\rPROG_1PAGE\n\r");
				page_data[12] = 0xE2;
				page_data[13] = 0xE2;
				page_data[14] = 0xE2;
				page_data[15] = 0xE2;
				PROG_1PAGE();
				xil_printf("\n\rDISABLE_CONFIGURE\n\r");
				ENABLE_CONFIGURE(0);

				xil_printf("\n\rsleep st\n\r");
				sleep(2);	//must be 2
				xil_printf("\n\rsleep sp\n\r");
				flag_camera_access = 0;

				xil_printf("\n\rwrite AWB data to camera flash OK\n\r");
			}
		}
		else if(flag_receive_mb_model == 1)
		{
			u8 mb_data[50];
			received_mb_data[received_mb_data_index] = c[0];
			received_mb_data_index++;
			if(received_mb_data_index == 50)
			{
				received_mb_data_index = 0;
				flag_receive_mb_model = 0;

				int i;
				char str[50];
				sprintf(str, "model : %02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x\n\r",
						received_mb_data[0], received_mb_data[1], received_mb_data[2], received_mb_data[3],
						received_mb_data[4], received_mb_data[5], received_mb_data[6], received_mb_data[7],
						received_mb_data[8], received_mb_data[9], received_mb_data[10], received_mb_data[11],
						received_mb_data[12], received_mb_data[13], received_mb_data[14], received_mb_data[15]);
				debug_console_print(str);

				for(i = 0;i < 50 ; i++)
				{
					mb_data[i] = received_mb_data[i];		//data prepare to write to eeprom
				}
				XIicPs_WriteEepromData(29, 0, 50, mb_data);
				sleep(1);
				flag_camera_access = 0;
			}
		}
		else if(flag_receive_rtc_data == 1)
		{
			received_rtc_data[received_rtc_data_index] = c[0];
			received_rtc_data_index++;
			if(received_rtc_data_index == 7)
			{
				received_rtc_data_index = 0;
				flag_receive_rtc_data = 0;

				char str[50];
				sprintf(str, "rtc data: %d/%02d/%02d %d %02d:%02d:%02d\n\r",
						received_rtc_data[0] + 2000, received_rtc_data[1], received_rtc_data[2], received_rtc_data[3],
						received_rtc_data[4], received_rtc_data[5], received_rtc_data[6]);
				debug_console_print(str);

				u8 type;
				int data;

				type = RTC_YEAR;
				data = received_rtc_data[0];
				XIicPs_SetRTCData(&Iic, type, data);

				type = RTC_MON;
				data = received_rtc_data[1];
				XIicPs_SetRTCData(&Iic, type, data);

				type = RTC_MD;
				data = received_rtc_data[2];
				XIicPs_SetRTCData(&Iic, type, data);

				type = RTC_WD;
				data = received_rtc_data[3];
				XIicPs_SetRTCData(&Iic, type, data);

				type = RTC_HH;
				data = received_rtc_data[4];
				XIicPs_SetRTCData(&Iic, type, data);

				type = RTC_MM;
				data = received_rtc_data[5];
				XIicPs_SetRTCData(&Iic, type, data);

				type = RTC_SS;
				data = received_rtc_data[6];
				XIicPs_SetRTCData(&Iic, type, data);

				flag_camera_access = 0;
			}
		}
		else if((start_data == 0) && ((c[0] == 0x99) || (c[0] == 0xAA) || (c[0] == 0xA0) || (c[0] == 0xA1) || (c[0] == 0xB0) || (c[0] == 0xC0) || (c[0] == 0xC1) || (c[0] == 0xD0) || (c[0] == 0xD1) || (c[0] == 0xE0) || (c[0] == 0xE1) || (c[0] == 0xE2) || (c[0] == 0xE3) || (c[0] == 0xEE) || (c[0] == 0xF0) || (c[0] == 0xF1) || (c[0] == 0xFF)|| (c[0] == '^')))
		{
			start_data = 1;
			gui_cmd[gui_cmd_index] = c[0];
			gui_cmd_index++;
			//xil_printf("david0410: %s:%s(%d) ST\r\n", __FILE__, __func__, __LINE__);
			//g_conn_status = psuart0_dongle_ping_old();	//needed, david @ 20191206	//must use ping1111111111() 1210 old
			//g_conn_status = psuart0_dongle_ping();	//needed, david @ 20191206	//must use ping1111111111() 1210 old
			psuart0_dongle_ping_old();	//needed, david @ 20191206	//must use ping1111111111() 1210 old zzz

			if(c[0] == '^')
			{
				flag_going_to_putty_mode = 1;
			}
			else if(c[0] == '@')
			{
				flag_ask_operation_mode = 1;
			}
		}
		else if(start_data == 1)
		{
			if((c[0] == 0x00) && ((flag_going_to_putty_mode == 1) || (flag_ask_operation_mode == 1)))
			{
				continue;
			}
			gui_cmd[gui_cmd_index] = c[0];
			gui_cmd_index++;
			if(gui_cmd_index == 5)
			{
				gui_cmd_index = 0;
				start_data = 0;

				u16 checksum = CalcCheckSum(gui_cmd, 4);

				char str[60];
				if((gui_cmd[4] != checksum) && (flag_going_to_putty_mode != 1) && (flag_ask_operation_mode != 1))
				{
					sprintf(str, "cmd %02x %02x %02x %02x %02x command fail checksum fail\n\r", gui_cmd[0], gui_cmd[1], gui_cmd[2], gui_cmd[3], gui_cmd[4]);
					debug_console_print(str);
				}
				else
				{
					//xil_printf("aaaa cmd ok %2x %2x %2x %2x %2x\n", gui_cmd[0], gui_cmd[1], gui_cmd[2], gui_cmd[3], gui_cmd[4]);
					if(gui_cmd[0] == 0xAA)
					{
						if((gui_cmd[1] == 0x00) && (gui_cmd[2] == 0xAA) && (gui_cmd[3] == 0xAA))	//camera serial
						{
							sprintf(str, "aaaa cmd ok %02x %02x %02x %02x %02x   camera serial read\n\r", gui_cmd[0], gui_cmd[1], gui_cmd[2], gui_cmd[3], gui_cmd[4]);
							debug_console_print(str);

							xil_printf("\n\rread_serial_from_camera\n\r");
							status = read_serial_from_camera();			//camera sn1 0x8, camera sn2 0x9

							xil_printf("\n\rsleep 1 sec\n\r");
							usleep(500000);
							usleep(500000);

							if(status == XST_SUCCESS)
							{
								Send_IMS_Data_Cmd(0xC1, 0x00, 0x00);
								int i;
								for(i = 0; i < 16; i++)
								{
									xil_printf("%c", camera_data_serial1[i]);
									//xil_printf("%c", 'A');
								}
								for(i = 0; i < 16; i++)
								{
									xil_printf("%c", camera_data_serial2[i]);
									//xil_printf("%c", 'B');
								}
								sleep(1);
							}
							else
							{
								Send_IMS_Data_Cmd(0xFF, 0xFF, 0xFF);
							}
						}
						else if((gui_cmd[1] == 0x01) && (gui_cmd[3] == 0xAA))	//camera flash read  ??????
						{
							int page = gui_cmd[2];
							sprintf(str, "bbbb cmd ok %02x %02x %02x %02x %02x   camera flash read ?? when\n\r", gui_cmd[0], gui_cmd[1], gui_cmd[2], gui_cmd[3], gui_cmd[4]);
							debug_console_print(str);
							sprintf(str, "camera flash read, page = 0x%x = %d\n\r", page, page);
							debug_console_print(str);

							if((page < MODEL_PAGE) ||(page > (USER_PAGE1 + 10)))
							{
								xil_printf("\n\rread_data_from_camera_flash, abort\n\r");
							}
							else
							{
								int i;
								xil_printf("aaa1 camera flash read, page = 0x%2X = %d\n\r", page, page);
								u8 camera_data_tmp[16] = {0};
								read_data_from_camera(page);

								for(i = 0; i < 16; i++)
								{
									camera_data_tmp[i] = page_data[i];
								}

								usleep(500000);
								Send_IMS_Data_Cmd(0xD1, page, 0x00);
								for(i = 0; i < 16; i++)
								{
									xil_printf("%c", camera_data_tmp[i]);
								}
								usleep(500000);
							}
						}
						else if((gui_cmd[1] == 0x03) && (gui_cmd[3] == 0xAA))	//RTC
						{
							if(gui_cmd[2] == 0x00)
							{
								sprintf(str, "cmd ok %02x %02x %02x %02x %02x   RTC write\n\r", gui_cmd[0], gui_cmd[1], gui_cmd[2], gui_cmd[3], gui_cmd[4]);
								debug_console_print(str);
							}
							else if(gui_cmd[2] == 0x11)
							{
								sprintf(str, "cmd ok %02x %02x %02x %02x %02x   RTC read\n\r", gui_cmd[0], gui_cmd[1], gui_cmd[2], gui_cmd[3], gui_cmd[4]);
								debug_console_print(str);
								/*
								int i;
								xil_printf("aaa2 camera flash read, page = 0x%x = %d\n\r", page, page);
								u8 camera_data_tmp[16] = {0};
								read_data_from_camera(page);
								for(i = 0; i < 16; i++)
								{
									camera_data_tmp[i] = page_data[i];
								}
								sleep(1);

								Send_IMS_Data_Cmd(0xD1, page, 0x00);
								for(i = 0; i < 16; i++)
								{
									xil_printf("%c", camera_data_tmp[i]);
								}
								*/

								//xil_printf("rtc data: %d/%d/%d %d %02d:%02d:%02d\r\n", rtc.tm_year, rtc.tm_mon, rtc.tm_mday, rtc.tm_wday, rtc.tm_hour, rtc.tm_min, rtc.tm_sec);

								usleep(300000);
								usleep(300000);
								usleep(300000);

								int i;
								u8 camera_data_tmp[16] = {0};
								for(i = 0; i < 16; i++)
								{
									camera_data_tmp[i] = 0x00;
								}
								camera_data_tmp[0] = rtc.tm_year;
								camera_data_tmp[1] = rtc.tm_mon;
								camera_data_tmp[2] = rtc.tm_mday;
								camera_data_tmp[3] = rtc.tm_wday;
								camera_data_tmp[4] = rtc.tm_hour;
								camera_data_tmp[5] = rtc.tm_min;
								camera_data_tmp[6] = rtc.tm_sec;

								Send_IMS_Data_Cmd(0xB1, 0x00, 0x00);
								for(i = 0; i < 16; i++)
								{
									xil_printf("%c", camera_data_tmp[i]);
								}
							}
							else
							{
								sprintf(str, "cmd unknown %02x %02x %02x %02x %02x   RTC unknown\n\r", gui_cmd[0], gui_cmd[1], gui_cmd[2], gui_cmd[3], gui_cmd[4]);
								debug_console_print(str);
							}
						}
						else
						{
							sprintf(str, "cmd unknown %02x %02x %02x %02x %02x   RTC unknown\n\r", gui_cmd[0], gui_cmd[1], gui_cmd[2], gui_cmd[3], gui_cmd[4]);
							debug_console_print(str);
						}
					}
					else if(gui_cmd[0] == 0xA0)
					{
						flag_camera_access = 1;
						if((gui_cmd[1]==0x35)&&(gui_cmd[2]==0x01))
						{
							sprintf(str, "cmd ok %02x %02x %02x %02x %02x   write sensor EXPO H\n\r", gui_cmd[0], gui_cmd[1], gui_cmd[2], gui_cmd[3], gui_cmd[4]);
						}
						else if((gui_cmd[1]==0x35)&&(gui_cmd[2]==0x02))
						{
							sprintf(str, "cmd ok %02x %02x %02x %02x %02x   write sensor EXPO L\n\r", gui_cmd[0], gui_cmd[1], gui_cmd[2], gui_cmd[3], gui_cmd[4]);
						}
						else if((gui_cmd[1]==0x35)&&(gui_cmd[2]==0x03))
						{
							if(gui_cmd[3] == 0)
								sprintf(str, "cmd ok %02x %02x %02x %02x %02x   GAIN EXPO AUTO\n\r", gui_cmd[0], gui_cmd[1], gui_cmd[2], gui_cmd[3], gui_cmd[4]);
							else if(gui_cmd[3] == 0x01)
								sprintf(str, "cmd ok %02x %02x %02x %02x %02x   E Manual G Auto\n\r", gui_cmd[0], gui_cmd[1], gui_cmd[2], gui_cmd[3], gui_cmd[4]);
							else if(gui_cmd[3] == 0x02)
								sprintf(str, "cmd ok %02x %02x %02x %02x %02x   E Auto G Manual\n\r", gui_cmd[0], gui_cmd[1], gui_cmd[2], gui_cmd[3], gui_cmd[4]);
							else if(gui_cmd[3] == 0x03)
								sprintf(str, "cmd ok %02x %02x %02x %02x %02x   GAIN EXPO Manual\n\r", gui_cmd[0], gui_cmd[1], gui_cmd[2], gui_cmd[3], gui_cmd[4]);
							else
								sprintf(str, "cmd ok %02x %02x %02x %02x %02x   GAIN EXPO xxxxx\n\r", gui_cmd[0], gui_cmd[1], gui_cmd[2], gui_cmd[3], gui_cmd[4]);
						}
						else if((gui_cmd[1]==0x35)&&(gui_cmd[2]==0x0A))
						{
							sprintf(str, "cmd ok %02x %02x %02x %02x %02x   write sensor GAIN H\n\r", gui_cmd[0], gui_cmd[1], gui_cmd[2], gui_cmd[3], gui_cmd[4]);
						}
						else if((gui_cmd[1]==0x35)&&(gui_cmd[2]==0x0B))
						{
							sprintf(str, "cmd ok %02x %02x %02x %02x %02x   write sensor GAIN L\n\r", gui_cmd[0], gui_cmd[1], gui_cmd[2], gui_cmd[3], gui_cmd[4]);
						}
						else if((gui_cmd[1]==0x52)&&(gui_cmd[2]==0x1A))
						{
							sprintf(str, "cmd ok %02x %02x %02x %02x %02x   write sensor R H\n\r", gui_cmd[0], gui_cmd[1], gui_cmd[2], gui_cmd[3], gui_cmd[4]);
						}
						else if((gui_cmd[1]==0x52)&&(gui_cmd[2]==0x1B))
						{
							sprintf(str, "cmd ok %02x %02x %02x %02x %02x   write sensor R L\n\r", gui_cmd[0], gui_cmd[1], gui_cmd[2], gui_cmd[3], gui_cmd[4]);
						}
						else if((gui_cmd[1]==0x52)&&(gui_cmd[2]==0x1C))
						{
							sprintf(str, "cmd ok %02x %02x %02x %02x %02x   write sensor G H\n\r", gui_cmd[0], gui_cmd[1], gui_cmd[2], gui_cmd[3], gui_cmd[4]);
						}
						else if((gui_cmd[1]==0x52)&&(gui_cmd[2]==0x1D))
						{
							sprintf(str, "cmd ok %02x %02x %02x %02x %02x   write sensor G L\n\r", gui_cmd[0], gui_cmd[1], gui_cmd[2], gui_cmd[3], gui_cmd[4]);
						}
						else if((gui_cmd[1]==0x52)&&(gui_cmd[2]==0x1E))
						{
							sprintf(str, "cmd ok %02x %02x %02x %02x %02x   write sensor B H\n\r", gui_cmd[0], gui_cmd[1], gui_cmd[2], gui_cmd[3], gui_cmd[4]);
						}
						else if((gui_cmd[1]==0x52)&&(gui_cmd[2]==0x1F))
						{
							sprintf(str, "cmd ok %02x %02x %02x %02x %02x   write sensor B L\n\r", gui_cmd[0], gui_cmd[1], gui_cmd[2], gui_cmd[3], gui_cmd[4]);
						}
						else
							sprintf(str, "cmd ok %02x %02x %02x %02x %02x   write camera sensor\n\r", gui_cmd[0], gui_cmd[1], gui_cmd[2], gui_cmd[3], gui_cmd[4]);

						debug_console_print(str);

						DongleAddr = gui_cmd[1] << 8 | gui_cmd[2];
						DongleData = gui_cmd[3];

						dongle_write_data(DongleAddr, DongleData);
						usleep(2000);
						flag_camera_access = 0;
					}
					else if(gui_cmd[0] == 0xA1)
					{
						//sprintf(str, "cmd ok %02x %02x %02x %02x %02x   read camera sensor\n\r", gui_cmd[0], gui_cmd[1], gui_cmd[2], gui_cmd[3], gui_cmd[4]);
						//debug_console_print(str);

						DongleAddr = gui_cmd[1] << 8 | gui_cmd[2];
						DongleData = dongle_read_data(DongleAddr);

						//Send_IMS_Data_Cmd(0xA1, DongleData, 0x00);
						Send_IMS_Data_Cmd(gui_cmd[1], gui_cmd[2], DongleData);
						usleep(100000);
					}
					else if(gui_cmd[0] == 0xB0)
					{
						if((gui_cmd[1] == 0x12) && (gui_cmd[2] == 0x34) && (gui_cmd[3] == 0x56))
						{
							flag_camera_access = 1;
							sprintf(str, "cccc cmd ok %02x %02x %02x %02x %02x   RTC write\n\r", gui_cmd[0], gui_cmd[1], gui_cmd[2], gui_cmd[3], gui_cmd[4]);
							debug_console_print(str);
							flag_receive_rtc_data = 1;
						}
					}
					else if(gui_cmd[0] == 0xC0)
					{
						if((gui_cmd[1] == 0x12) && (gui_cmd[2] == 0x34) && (gui_cmd[3] == 0x56))
						{
							flag_camera_access = 1;
							sprintf(str, "cccc1 cmd ok %02x %02x %02x %02x %02x   camera serial write1\n\r", gui_cmd[0], gui_cmd[1], gui_cmd[2], gui_cmd[3], gui_cmd[4]);
							debug_console_print(str);
							//wait pc send data......
							flag_receive_camera_serial = 1;
						}
						else if((gui_cmd[1] == 0x65) && (gui_cmd[2] == 0x43) && (gui_cmd[3] == 0x21))
						{
							xil_printf("\n\rxxxxxxxxxxxxxxxxxxx when use this????\n\r");
							flag_camera_access = 1;
							sprintf(str, "cccc2 cmd ok %02x %02x %02x %02x %02x   camera serial write2\n\r", gui_cmd[0], gui_cmd[1], gui_cmd[2], gui_cmd[3], gui_cmd[4]);
							debug_console_print(str);

							xil_printf("\n\rcamera erase data\n\r");
							xil_printf("\n\rENABLE_CONFIGURE\n\r");
							ENABLE_CONFIGURE(1);
							xil_printf("\n\rSET_ADDRESS\n\r");
							SET_ADDRESS(SN_PAGE2);
							xil_printf("\n\rERASE_UFM\n\r");
							ERASE_UFM();
							xil_printf("\n\rDISABLE_CONFIGURE\n\r");
							ENABLE_CONFIGURE(0);

							sleep(2);	//must > 1

							xil_printf("\n\rcamera write serial\n\r");
							write_serial_to_camera();
							xil_printf("\n\rcamera write serial OK\n\r");

							flag_camera_access = 0;
						}
					}
					else if(gui_cmd[0] == 0xC1)
					{
						if((gui_cmd[1] == 0xAB) && (gui_cmd[2] == 0xCD) && (gui_cmd[3] == 0xEF))
						{
							flag_camera_access = 1;
							sprintf(str, "XXXXXX cmd ok %02x %02x %02x %02x %02x   camera serial read\n\r", gui_cmd[0], gui_cmd[1], gui_cmd[2], gui_cmd[3], gui_cmd[4]);
							debug_console_print(str);

							xil_printf("\n\rread_serial_from_camera\n\r");
							read_serial_from_camera();			//camera 0xA

							sleep(1);

							Send_IMS_Data_Cmd(0xC1, 0x00, 0x00);
							int i;
							for(i = 0; i < 16; i++)
							{
								xil_printf("%c", camera_data_serial2[i]);
							}
							sleep(1);
							flag_camera_access = 0;
						}
					}
					else if(gui_cmd[0] == 0xD0)
					{

						int page = gui_cmd[1];
						sprintf(str, "eeee cmd ok %02x %02x %02x %02x %02x   camera flash write\n\r", gui_cmd[0], gui_cmd[1], gui_cmd[2], gui_cmd[3], gui_cmd[4]);
						debug_console_print(str);
						sprintf(str, "camera flash write, page = 0x%x = %d\n\r", page, page);
						debug_console_print(str);

						if((page < MODEL_PAGE) ||(page > (USER_PAGE1 + 10)))
						{
							xil_printf("\n\rwrite_data_to_camera_flash, abort\n\r");

						}
						else
						{
							xil_printf("bbbb camera flash write, page = 0x%x = %d\n\r", page, page);
							flag_receive_camera_raw_data = 1;
							ufm_write_page = page;
						}
					}
					else if(gui_cmd[0] == 0xD1)
					{

						int page = gui_cmd[1];
						sprintf(str, "eeee cmd ok %02x %02x %02x %02x %02x   camera flash read\n\r", gui_cmd[0], gui_cmd[1], gui_cmd[2], gui_cmd[3], gui_cmd[4]);
						debug_console_print(str);
						sprintf(str, "camera flash read, page = 0x%x = %d\n\r", page, page);
						debug_console_print(str);

						if((page < MODEL_PAGE) ||(page > (USER_PAGE1 + 10)))
						{
							xil_printf("\n\rread_data_from_camera_flash, abort\n\r");

						}
						else
						{
							int i;
							xil_printf("bbb camera flash read, page = 0x%x = %d\n\r", page, page);
							u8 camera_data_tmp[16] = {0};
							read_data_from_camera(page);
							for(i = 0; i < 16; i++)
							{
								camera_data_tmp[i] = page_data[i];
							}
							sleep(1);

							Send_IMS_Data_Cmd(0xD1, page, 0x00);
							for(i = 0; i < 16; i++)
							{
								xil_printf("%c", camera_data_tmp[i]);
							}
						}
					}
					else if(gui_cmd[0] == 0xE0)
					{
						if((gui_cmd[1] == 0x12) && (gui_cmd[2] == 0x34) && (gui_cmd[3] == 0x56))
						{
							flag_camera_access = 1;
							sprintf(str, "cccc cmd ok %02x %02x %02x %02x %02x   camera model write\n\r", gui_cmd[0], gui_cmd[1], gui_cmd[2], gui_cmd[3], gui_cmd[4]);
							debug_console_print(str);
							//wait pc send data......
							flag_receive_camera_model = 1;
						}
					}
					else if(gui_cmd[0] == 0xE1)
					{
						if((gui_cmd[1] == 0xAB) && (gui_cmd[2] == 0xCD) && (gui_cmd[3] == 0xEF))
						{
							flag_camera_access = 1;
							sprintf(str, "cmd ok %02x %02x %02x %02x %02x   camera model read\n\r", gui_cmd[0], gui_cmd[1], gui_cmd[2], gui_cmd[3], gui_cmd[4]);
							debug_console_print(str);

							//xil_printf("\n\rread_model_from_camera\n\r");
							read_model_from_camera();			//camera model 0x07

							sleep(1);

							Send_IMS_Data_Cmd(0xE1, 0x00, 0x00);

							int i;
							for(i = 0; i < 16; i++)
							{
								xil_printf("%c", camera_data_model[i]);
							}
							sleep(1);
							flag_camera_access = 0;
						}
					}
					else if(gui_cmd[0] == 0xE2)
					{
						if((gui_cmd[1] == 0x12) && (gui_cmd[2] == 0x34) && (gui_cmd[3] == 0x56))
						{
							flag_camera_access = 1;
							sprintf(str, "cccc cmd ok %02x %02x %02x %02x %02x   camera awb write\n\r", gui_cmd[0], gui_cmd[1], gui_cmd[2], gui_cmd[3], gui_cmd[4]);
							debug_console_print(str);
							//wait pc send data......
							flag_receive_camera_awb_data = 1;
						}
					}
					else if(gui_cmd[0] == 0xE3)
					{
						if((gui_cmd[1] == 0xAB) && (gui_cmd[2] == 0xCD) && (gui_cmd[3] == 0xEF))
						{
							flag_camera_access = 1;
							sprintf(str, "cmd ok %02x %02x %02x %02x %02x   camera awb read\n\r", gui_cmd[0], gui_cmd[1], gui_cmd[2], gui_cmd[3], gui_cmd[4]);
							debug_console_print(str);

							//xil_printf("\n\rread_model_from_camera\n\r");
							read_model_from_camera();			//camera model 0x07

							sleep(1);

							Send_IMS_Data_Cmd(0xE1, 0x00, 0x00);

							int i;
							for(i = 0; i < 16; i++)
							{
								xil_printf("%c", camera_data_model[i]);
							}
							sleep(1);
							flag_camera_access = 0;
						}
					}
					else if(gui_cmd[0] == 0xEE)
					{
						if((gui_cmd[1] == 0xFF) && (gui_cmd[2] == 0xEE) && (gui_cmd[3] == 0xFF))
						{
							sprintf(str, "cmd ok %02x %02x %02x %02x %02x   camera erase all flash data\n\r", gui_cmd[0], gui_cmd[1], gui_cmd[2], gui_cmd[3], gui_cmd[4]);
							debug_console_print(str);

							xil_printf("\n\rcamera erase data\n\r");
							xil_printf("\n\rENABLE_CONFIGURE\n\r");
							ENABLE_CONFIGURE(1);
							xil_printf("\n\rSET_ADDRESS\n\r");
							SET_ADDRESS(AWB_PAGE0);
							xil_printf("\n\rERASE_UFM\n\r");
							ERASE_UFM();
							xil_printf("\n\rDISABLE_CONFIGURE\n\r");
							ENABLE_CONFIGURE(0);
							//xil_printf("\n\rwrite_serial_to_camera 111\n\r");
							sleep(1);	//must > 1

							xil_printf("\n\rcamera erase data OK\n\r");
						}
					}
					else if(gui_cmd[0] == 0xF0)
					{
						if((gui_cmd[1] == 0x12) && (gui_cmd[2] == 0x34) && (gui_cmd[3] == 0x56))
						{
							flag_camera_access = 1;
							sprintf(str, "cccc cmd ok %02x %02x %02x %02x %02x   mb model write\n\r", gui_cmd[0], gui_cmd[1], gui_cmd[2], gui_cmd[3], gui_cmd[4]);
							debug_console_print(str);
							//wait pc send data......
							flag_receive_mb_model = 1;
						}
					}
					else if(gui_cmd[0] == 0xF1)
					{
						if((gui_cmd[1] == 0xAB) && (gui_cmd[2] == 0xCD) && (gui_cmd[3] == 0xEF))
						{
							flag_camera_access = 1;
							sprintf(str, "cmd ok %02x %02x %02x %02x %02x   mb model read\n\r", gui_cmd[0], gui_cmd[1], gui_cmd[2], gui_cmd[3], gui_cmd[4]);
							debug_console_print(str);

							xil_printf("\n\rread_model_from_main_board\n\r");

							int state;
							state = XIicPs_ReadEepromData(29, 0, 50, RecvBuffer);
							if(state == XST_FAILURE)
							{
								xil_printf("xxxxxxx I2C fail, try again\n\r");
								usleep(1000);
								state = XIicPs_ReadEepromData(29, 0, 50, RecvBuffer);
							}

							int i;

							xil_printf("data: \t0x");
							for (i = 0; i < 50; i++) {
								xil_printf("%02x ", RecvBuffer[i]);
							}
							xil_printf("\n\r");

							sleep(1);

							for(i = 0; i < 50; i++)
							{
								mb_model_new[i] = RecvBuffer[i];
							}

							Send_IMS_Data_Cmd(0xF1, 0x00, 0x00);	//send mb data
							for(i = 0; i < 50; i++)
							{
								xil_printf("%c", mb_model_new[i]);
							}
							sleep(1);
							flag_camera_access = 0;
						}
					}
					else if(gui_cmd[0] == 0xFF)
					{
						if((gui_cmd[1] == 0xAA) && (gui_cmd[2] == 0xBB) && (gui_cmd[3] == 0xCC))
						{
							sprintf(str, "ffff cmd ok %02x %02x %02x %02x %02x   START\n\r", gui_cmd[0], gui_cmd[1], gui_cmd[2], gui_cmd[3], gui_cmd[4]);
							debug_console_print(str);
				#ifdef USE_PREVENT_REUSE
							if(flag_forbid_video == FALSE)
				#endif
							{
								if(g_procedure_started == START) { // We are in a active session
									if(g_conn_status == CAMERA_OK)	//dongle + camera
									{
										xil_printf("turn off\r\n");
										g_updated = 1;
										g_procedure_started = STOP;
									}
									else
									{
										xil_printf("no turn off, no dongle or camera\r\n");
									}
								}
								else
								{
									if(g_conn_status == CAMERA_OK)	//dongle + camera
									{
										xil_printf("turn on\r\n");
										g_updated = 1;
										g_procedure_started = START;
									}
									else
									{
										xil_printf("no turn on, no dongle or camera\r\n");
									}
								}
							}
						}
						else if((gui_cmd[1] == 0xCC) && (gui_cmd[2] == 0xBB) && (gui_cmd[3] == 0xAA))
						{
							sprintf(str, "ffff cmd ok %02x %02x %02x %02x %02x   LED\n\r", gui_cmd[0], gui_cmd[1], gui_cmd[2], gui_cmd[3], gui_cmd[4]);
							debug_console_print(str);
							if(flag_camera_led_status == 1)
							{
								xil_printf("\n\rTurn off camera LED -\n\r");
								ps_gpio_setup(&periphs_inst, GPIO_CAM_LED, 0);
								flag_camera_led_status = 0;
							}
							else
							{
								xil_printf("\n\rTurn on camera LED -\n\r");
								ps_gpio_setup(&periphs_inst, GPIO_CAM_LED, 1);
								flag_camera_led_status = 1;
							}
						}
						else if((gui_cmd[1] == 0x11) && (gui_cmd[2] == 0x66) && (gui_cmd[3] == 0x88))
						{
							sprintf(str, "ffff cmd ok %02x %02x %02x %02x %02x   goto putty mode\n\r", gui_cmd[0], gui_cmd[1], gui_cmd[2], gui_cmd[3], gui_cmd[4]);
							debug_console_print(str);
							flag_operation_mode = MODE_PUTTY;
							flag_going_to_putty_mode = 0;
							xil_printf("\n\rGoto putty mode\r\n");
						}
						else if((gui_cmd[1] == 0x11) && (gui_cmd[2] == 0x52) && (gui_cmd[3] == 0x00))
						{
							sprintf(str, "ffff cmd ok %02x %02x %02x %02x %02x   get UART status\n\r", gui_cmd[0], gui_cmd[1], gui_cmd[2], gui_cmd[3], gui_cmd[4]);
							debug_console_print(str);
							Send_IMS_Data_Cmd(0x11, 0x52, 0x00);
						}
						else
						{
							sprintf(str, "gggg cmd ok %02x %02x %02x %02x %02x   read dongle status\n\r", gui_cmd[0], gui_cmd[1], gui_cmd[2], gui_cmd[3], gui_cmd[4]);
							debug_console_print(str);
							usleep(300000);
							g_conn_status = psuart0_dongle_ping();

							if(g_conn_status == CAMERA_OK)
							{
								uint32_t camera_sensor_status = SENSOR_OK;
								camera_sensor_status = check_camera_status();
								if(camera_sensor_status == SENSOR_FAIL)
								{
									g_conn_status = CAMERA_SENSOR_FAIL;
								}
							}
							usleep(300000);
							Send_IMS_Data_Cmd(0xFF, g_conn_status, 0x00);
						}
					}
					else if((gui_cmd[0] == '^') &&(gui_cmd[1] == '^') && (gui_cmd[2] == '^') && (gui_cmd[3] == '^'))
					{
						sprintf(str, "ffff cmd ok %02x %02x %02x %02x %02x   goto putty mode\n\r", gui_cmd[0], gui_cmd[1], gui_cmd[2], gui_cmd[3], gui_cmd[4]);
						debug_console_print(str);
						flag_operation_mode = MODE_PUTTY;
						flag_going_to_putty_mode = 0;

						xil_printf("\n\rGoto putty mode\r\n");
					}
					else if((gui_cmd[0] == 0x99) &&(gui_cmd[1] == 0x00) && (gui_cmd[2] == 0x00) && (gui_cmd[3] == 0x0D))
					{
						sprintf(str, "ffff cmd ok %02x %02x %02x %02x %02x   get op mode\n\r", gui_cmd[0], gui_cmd[1], gui_cmd[2], gui_cmd[3], gui_cmd[4]);
						debug_console_print(str);
						xil_printf("\n\rRead OP mode.\r\n");
						flag_ask_operation_mode = 0;

						if(flag_operation_mode == MODE_PUTTY)
						{
							usleep(500000);
							Send_IMS_Data_Cmd(0x99, 0x00, 0x00);
							usleep(500000);
						}
						else	//MODE_IMS_LINK
						{
							usleep(500000);
							Send_IMS_Data_Cmd(0x99, 0x11, 0x11);
							usleep(500000);
						}
					}
					else
					{
						sprintf(str, "hhhh cmd ok %02x %02x %02x %02x %02x   unknown command\n\r", gui_cmd[0], gui_cmd[1], gui_cmd[2], gui_cmd[3], gui_cmd[4]);
						debug_console_print(str);
					}


				}


			}
			g_conn_status = psuart0_dongle_ping();		//needed, david @ 20191206
		}
		else if(c[0] == 0)
		{
			//debug_console_print("got 0 ");
		}

		//g_conn_status = psuart0_dongle_ping();

		//#endif
		}
	}
}

static void updateConsoleWidgets(void)
{
	xil_printf("david0121: %s:%s(%d) ST XXXXXXXXXXXXXXXXXXXXXXXXXx\r\n",__FILE__,__func__,__LINE__);
	/* Set a font */
	gwinSetDefaultFont(gdispOpenFont("iskpota232"));

	uint8_t reg;
	uint8_t val0 = 0;
	uint8_t val1 = 0;
	uint8_t val2 = 0;
	uint8_t val3 = 0;
	uint8_t val4 = 0;
	uint8_t val5 = 0;
	uint8_t val6 = 0;
	uint8_t val7 = 0;
	uint8_t val8 = 0;
	uint8_t val9 = 0;
	int i;
	uint32_t value = 0;

	reg = ULPI_FC_CTRL;					val0 = ulpi_ReadReg(reg);
	reg = ULPI_IFC_CTRL;				val1 = ulpi_ReadReg(reg);
	reg = ULPI_OTG_CTRL;				val2 = ulpi_ReadReg(reg);
	reg = ULPI_USB_INT_EN_RISE;			val3 = ulpi_ReadReg(reg);
	reg = ULPI_USB_INT_EN_FALL;			val4 = ulpi_ReadReg(reg);

	reg = ULPI_USB_INT_STS;				val5 = ulpi_ReadReg(reg);
	reg = ULPI_USB_INT_LATCH;			val6 = ulpi_ReadReg(reg);
	reg = ULPI_HS_TX_BOOST;				val7 = ulpi_ReadReg(reg);
	reg = ULPI_VENDOR_RID_CONVERSION;	val8 = ulpi_ReadReg(reg);
	reg = ULPI_USB_IO_POWER_MAN;		val9 = ulpi_ReadReg(reg);

	//xil_printf("read value : %02X\n\r", val0);

	if((flag_updateConsoleWidgets == 0) && (flag_updateConsoleWidgets_old == 1))
	{
		flag_updateConsoleWidgets_old = 0;
		gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(0));
		gwinSetBgColor(GW0b, Black);
		gwinClear(GW0b);
		gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(1));
		gwinSetBgColor(GW1b, Black);
		gwinClear(GW1b);
	}

	gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(0));
	gwinSetBgColor(GW0b, Purple);
	gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(0));
	gwinSetBgColor(GW1b, Purple);
	if(vendor_id_tmp != 0x0426)
	{
		if(vid_error_cnt < 3)
		{
			if(flag_updateConsoleWidgets == 1)
			{
				gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(0));
				gwinPrintf(GW0b, "\n%02X  %02X  %02X  %02X  %02X  %02X  %02X  %02X  %02X  %02X  %d %04X %04X ", val0, val1, val2, val3, val4, val5, val6, val7, val8, val9, flag_is_keyboard_mounted,vendor_id_tmp, product_id_tmp);
				gwinSetColor(GW0b, Red);
				gwinPrintf(GW0b, "FAIL");
				gwinSetColor(GW0b, White);
				gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(1));
				gwinPrintf(GW1b, "\n%02X  %02X  %02X  %02X  %02X  %02X  %02X  %02X  %02X  %02X  %d %04X %04X ", val0, val1, val2, val3, val4, val5, val6, val7, val8, val9, flag_is_keyboard_mounted,vendor_id_tmp, product_id_tmp);
				gwinSetColor(GW1b, Red);
				gwinPrintf(GW1b, "FAIL");
				gwinSetColor(GW1b, White);
			}
		}
		else
		{
			if(flag_updateConsoleWidgets == 1)
			{
				gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(0));
				gwinSetColor(GW0b, Red);
				gwinPrintf(GW0b, "\n\r U S B    F A I L ,   R E S E T   U S B        %d", vid_error_cnt - 2);
				gwinSetColor(GW0b, White);
				gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(1));
				gwinSetColor(GW1b, Red);
				gwinPrintf(GW1b, "\n\r U S B    F A I L ,   R E S E T   U S B        %d", vid_error_cnt - 2);
				gwinSetColor(GW1b, White);
			}
			if(vid_error_cnt > 3)
			{
				vid_error_cnt = 0;

				if(flag_updateConsoleWidgets == 1)
				{
					gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(0));
					gwinSetColor(GW0b, Red);
					gwinPrintf(GW0b, "\nU S B   R e s e t t i n g . . . . . . . . . . . . . ");
					gwinSetColor(GW0b, White);

					gwinSetColor(GW0b, Red);
					gwinPrintf(GW0b, "\nU S B   R e s e t t i n g . . . . . . . . . . . . . ");
					gwinPrintf(GW0b, "\nU S B   R e s e t t i n g . . . . . . . . . . . . . ");
					gwinPrintf(GW0b, "\nU S B   R e s e t t i n g . . . . . . . . . . . . . ");
					gwinPrintf(GW0b, "\nU S B   R e s e t t i n g . . . . . . . . . . . . . ");
					gwinPrintf(GW0b, "\nU S B   R e s e t t i n g . . . . . . . . . . . . . ");
					gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(1));
					gwinSetColor(GW1b, Red);
					gwinPrintf(GW1b, "\nU S B   R e s e t t i n g . . . . . . . . . . . . . ");
					gwinSetColor(GW1b, White);

					gwinSetColor(GW1b, Red);
					gwinPrintf(GW1b, "\nU S B   R e s e t t i n g . . . . . . . . . . . . . ");
					gwinPrintf(GW1b, "\nU S B   R e s e t t i n g . . . . . . . . . . . . . ");
					gwinPrintf(GW1b, "\nU S B   R e s e t t i n g . . . . . . . . . . . . . ");
					gwinPrintf(GW1b, "\nU S B   R e s e t t i n g . . . . . . . . . . . . . ");
					gwinPrintf(GW1b, "\nU S B   R e s e t t i n g . . . . . . . . . . . . . ");
				}

				xil_printf("\n\rusb HW reset\n\r");
				reset_usb();

				xil_printf("\n\rusb SW reset\n\r");
				tusb_init(); // initialize tinyusb stack
				value = 0x60;
				ulpi_WriteReg(value, ULPI_FC_CTRL);	//0x16
				port_connect_status_change_isr(0);
				tusb_isr(0);

				if(flag_updateConsoleWidgets == 1)
				{
					gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(0));
					gwinSetColor(GW0b, White);
					gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(1));
					gwinSetColor(GW1b, White);
				}
			}
		}
		vid_error_cnt++;
	}
	else
	{
		if(flag_updateConsoleWidgets == 1)
		{
			gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(0));
			gwinPrintf(GW0b, "\n%02X  %02X  %02X  %02X  %02X  %02X  %02X  %02X  %02X  %02X   %d   %04X %04X   O K", val0, val1, val2, val3, val4, val5, val6, val7, val8, val9, flag_is_keyboard_mounted,vendor_id_tmp, product_id_tmp);
			gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(1));
			gwinPrintf(GW1b, "\n%02X  %02X  %02X  %02X  %02X  %02X  %02X  %02X  %02X  %02X   %d   %04X %04X   O K", val0, val1, val2, val3, val4, val5, val6, val7, val8, val9, flag_is_keyboard_mounted,vendor_id_tmp, product_id_tmp);
		}
		vid_error_cnt = 0;
	}
	flag_updateConsoleWidgets_old = flag_updateConsoleWidgets;

	if(val0 != 0x40)
	{
		if(flag_updateConsoleWidgets == 1)
		{
			gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(0));
			gwinSetColor(GW0b, Red);
			for(i = 0; i < 10; i++)
			{
				gwinPrintf(GW0b, "\nUSB FAIL, RESET USB");
				usleep(100000);
			}
			gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(1));
			gwinSetColor(GW1b, Red);
			for(i = 0; i < 10; i++)
			{
				gwinPrintf(GW1b, "\nUSB FAIL, RESET USB");
				usleep(100000);
			}
		}
		reset_usb();
		if(flag_updateConsoleWidgets == 1)
		{
			gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(0));
			gwinSetColor(GW0b, White);
			gwinSetBgColor(GW0b, Black);
			gwinClear(GW0b);
			gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(1));
			gwinSetColor(GW1b, White);
			gwinSetBgColor(GW1b, Black);
			gwinClear(GW1b);
		}
	}
	return;
}

static void updateWidgets_age_data(void) {
	GWidgetInit	wi;
	int OFFSET = WIDTH1;

	// Apply some default values for GWIN
	gwinWidgetClearInit(&wi);
	wi.g.show = TRUE;
	//wi.text = "12345678901234567890";
	//wi.text = "1234567890";

	gwinSetDefaultFont(gdispOpenFont("iskpota232"));

	// Create label
	wi.g.width = WIDTH1; wi.g.height = THICK1; wi.g.x = OFFSET_X + BORDER_X; wi.g.y = BORDER_Y + THICK1 * 5;
	wi.text = "AGE:";
	ghLabel4 = gwinLabelCreate(0, &wi);

	wi.g.width = WIDTH2; wi.g.height = THICK1; wi.g.x = OFFSET_X + BORDER_X + OFFSET; wi.g.y = BORDER_Y + THICK1 * 5;

	gdispFillArea(wi.g.x - 5, wi.g.y - 5, 312, 40, Black);

	wi.text = "12345678901234567890";
	sprintf((char *)wi.text, "%d", birth_age);

	ghLabel4 = gwinLabelCreate(0, &wi);

	//also update widgets2 age
	wi.g.width = CAMERA_INFO_WIDTH2A; wi.g.height = THICK1; wi.g.x = CAMERA_INFO_POS_X2 + CAMERA_INFO_POS_OFFSET2; wi.g.y = CAMERA_INFO_POS_Y3;
	ghLabel1 = gwinLabelCreate(0, &wi);
}

static void createWidgets(void) {
	GWidgetInit	wi;
	int OFFSET = WIDTH1;

	// Apply some default values for GWIN
	gwinWidgetClearInit(&wi);
	wi.g.show = TRUE;
	//wi.text = "12345678901234567890";
	//wi.text = "1234567890";

	gwinSetDefaultFont(gdispOpenFont("iskpota232"));

	// Create label
	wi.g.width = WIDTH1; wi.g.height = THICK1; wi.g.x = OFFSET_X + BORDER_X; wi.g.y = BORDER_Y + THICK1 * 0;
	wi.text = "ID NO:";
	ghLabel1 = gwinLabelCreate(0, &wi);

	wi.g.width = WIDTH2; wi.g.height = THICK1; wi.g.x = OFFSET_X + BORDER_X + OFFSET; wi.g.y = BORDER_Y + THICK1 * 0;
#ifdef USE_DATA_INPUT
	font_t font = gdispOpenFont("iskpota232");

	wi.text = "12345678901234567890";
	//sprintf((char *)wi.text, "%d", p_infos[p_info_index].id_no);
	wi.text = (const char *)p_infos[p_info_index].id_no;
	ghLabel1 = gwinLabelCreate(0, &wi);

	wi.g.width = WIDTH2; wi.g.height = THICK1; wi.g.x = BORDER_X; wi.g.y = BORDER_Y + THICK1 * 0;
	gdispFillString(wi.g.x, wi.g.y, "F1", font, White, Gray);
#endif

	// Create label
	wi.g.width = WIDTH1; wi.g.height = THICK1; wi.g.x = OFFSET_X + BORDER_X; wi.g.y = BORDER_Y + THICK1 * 1;
	wi.text = "NAME:";
	ghLabel2 = gwinLabelCreate(0, &wi);

	wi.g.width = WIDTH2; wi.g.height = THICK1; wi.g.x = OFFSET_X + BORDER_X + OFFSET; wi.g.y = BORDER_Y + THICK1 * 1;
#ifdef USE_DATA_INPUT
	if(p_infos[p_info_index].name != (unsigned char *)"")
	{
		wi.text = "12345678901234567890";
		wi.text = (const char *)p_infos[p_info_index].name;
	}
	else
	{
		wi.text = "                    ";
	}
	ghLabel2 = gwinLabelCreate(0, &wi);

	wi.g.width = WIDTH2; wi.g.height = THICK1; wi.g.x = BORDER_X; wi.g.y = BORDER_Y + THICK1 * 1;
	gdispFillString(wi.g.x, wi.g.y, "F2", font, White, Gray);
	//gdispFillString(wi.g.x + 400 + 30, wi.g.y, "PgUp", font, White, Gray);
#endif

	// Create label
	wi.g.width = WIDTH1; wi.g.height = THICK1; wi.g.x = OFFSET_X + BORDER_X; wi.g.y = BORDER_Y + THICK1 * 3;
	wi.text = "SEX:";
	ghLabel3 = gwinLabelCreate(0, &wi);

	wi.g.width = CAMERA_INFO_WIDTH2A; wi.g.height = THICK1; wi.g.x = OFFSET_X + BORDER_X + OFFSET; wi.g.y = BORDER_Y + THICK1 * 3;
#ifdef USE_DATA_INPUT
	if(p_infos[p_info_index].sex != 0)
	{
		if(p_infos[p_info_index].sex == 1)
			wi.text = "Male";
		else
			wi.text = "Female";
	}
	else
	{
		wi.text = "                    ";
	}
	ghLabel3 = gwinLabelCreate(0, &wi);

	wi.g.width = WIDTH2; wi.g.height = THICK1; wi.g.x = BORDER_X; wi.g.y = BORDER_Y + THICK1 * 3;
	gdispFillString(wi.g.x, wi.g.y, "F3", font, White, Gray);
	//gdispFillString(wi.g.x + 400 + 30, wi.g.y, "PgDn", font, White, Gray);
#endif

	// Create label
	wi.g.width = WIDTH1; wi.g.height = THICK1; wi.g.x = OFFSET_X + BORDER_X; wi.g.y = BORDER_Y + THICK1 * 5;
	wi.text = "AGE:";
	ghLabel4 = gwinLabelCreate(0, &wi);

	wi.g.width = WIDTH2; wi.g.height = THICK1; wi.g.x = OFFSET_X + BORDER_X + OFFSET; wi.g.y = BORDER_Y + THICK1 * 5;
#ifdef USE_DATA_INPUT
	if(p_infos[p_info_index].age != 0)
	{
		wi.text = "12345678901234567890";
		sprintf((char *)wi.text, "%d", p_infos[p_info_index].age);
	}
	else
	{
		wi.text = "                    ";
	}
	ghLabel4 = gwinLabelCreate(0, &wi);

	wi.g.width = WIDTH2; wi.g.height = THICK1; wi.g.x = BORDER_X; wi.g.y = BORDER_Y + THICK1 * 5;
	//gdispFillString(wi.g.x, wi.g.y, "F5", font, White, Gray);
#endif

	// Create label
	wi.g.width = WIDTH1; wi.g.height = THICK1; wi.g.x = OFFSET_X + BORDER_X; wi.g.y = BORDER_Y + THICK1 * 4;
	wi.text = "Birthday:";
	ghLabel5 = gwinLabelCreate(0, &wi);

	wi.g.width = WIDTH2; wi.g.height = THICK1; wi.g.x = OFFSET_X + BORDER_X + OFFSET; wi.g.y = BORDER_Y + THICK1 * 4;
#ifdef USE_DATA_INPUT
	if(p_infos[p_info_index].birthday != (unsigned char *)"")
	{
		wi.text = "12345678901234567890";
		wi.text = (const char *)p_infos[p_info_index].birthday;
	}
	else
	{
		wi.text = "                    ";
	}
	ghLabel5 = gwinLabelCreate(0, &wi);

	wi.g.width = WIDTH2; wi.g.height = THICK1; wi.g.x = BORDER_X; wi.g.y = BORDER_Y + THICK1 * 4;
	gdispFillString(wi.g.x, wi.g.y, "F4", font, White, Gray);
#endif

	/*
	// Create label
	wi.g.width = wide; wi.g.height = thick; wi.g.x = BORDER_X; wi.g.y = BORDER_Y + thick * 7;
	wi.text = "08/30/2018";
	ghLabel4 = gwinLabelCreate(0, &wi);

	// Create label
	wi.g.width = wide; wi.g.height = thick; wi.g.x = BORDER_X; wi.g.y = BORDER_Y + thick * 8;
	wi.text = "00:00:00";
	ghLabel5 = gwinLabelCreate(0, &wi);
	*/

	/*
	// Create label
	wi.g.width = wide; wi.g.height = thick; wi.g.x = 1920/6; wi.g.y =600;
	wi.text = "XXXXXXXXXXXXXXXXXXXXXxx";
	ghLabel5 = gwinLabelCreate(0, &wi);
	*/

	createWidgets2();
	return;
}

static void createWidgets2(void) {
	GWidgetInit	wi;

	// Apply some default values for GWIN
	gwinWidgetClearInit(&wi);
	wi.g.show = TRUE;
	//wi.text = "12345678901234567890";
	//wi.text = "1234567890";

	gwinSetDefaultFont(gdispOpenFont("iskpota232"));

	// Create label
	wi.text = "ID NO:";

	wi.g.width = CAMERA_INFO_WIDTH1; wi.g.height = THICK1; wi.g.x = CAMERA_INFO_POS_X1; wi.g.y = CAMERA_INFO_POS_Y1;
	ghLabel1 = gwinLabelCreate(0, &wi);

#ifdef USE_DATA_INPUT
	//font_t font = gdispOpenFont("iskpota232");

	wi.text = "12345678901234567890";
	//sprintf((char *)wi.text, "%d", p_infos[p_info_index].id_no);
	wi.text = (const char *)p_infos[p_info_index].id_no;
	wi.g.width = CAMERA_INFO_WIDTH1A; wi.g.height = THICK1; wi.g.x = CAMERA_INFO_POS_X1 + CAMERA_INFO_POS_OFFSET1; wi.g.y = CAMERA_INFO_POS_Y1;
	ghLabel1 = gwinLabelCreate(0, &wi);
#endif

	// Create label
	wi.text = "NAME:";
	wi.g.width = CAMERA_INFO_WIDTH1; wi.g.height = THICK1; wi.g.x = CAMERA_INFO_POS_X1; wi.g.y = CAMERA_INFO_POS_Y2;
	ghLabel2 = gwinLabelCreate(0, &wi);

#ifdef USE_DATA_INPUT
	if(p_infos[p_info_index].name != (unsigned char *)"")
	{
		wi.text = "12345678901234567890";
		wi.text = (const char *)p_infos[p_info_index].name;
	}
	else
	{
		wi.text = "                    ";
	}
	wi.g.width = CAMERA_INFO_WIDTH1A; wi.g.height = THICK1; wi.g.x = CAMERA_INFO_POS_X1 + CAMERA_INFO_POS_OFFSET1; wi.g.y = CAMERA_INFO_POS_Y2;
	ghLabel2 = gwinLabelCreate(0, &wi);

#endif

	wi.text = "SEX:";
	wi.g.width = CAMERA_INFO_WIDTH2; wi.g.height = THICK1; wi.g.x = CAMERA_INFO_POS_X2; wi.g.y = CAMERA_INFO_POS_Y2;
	ghLabel3 = gwinLabelCreate(0, &wi);

#ifdef USE_DATA_INPUT
	if(p_infos[p_info_index].sex != 0)
	{
		if(p_infos[p_info_index].sex == 1)
			wi.text = "Male";
		else
			wi.text = "Female";
	}
	else
	{
		wi.text = "                     ";
	}
	wi.g.width = CAMERA_INFO_WIDTH2A; wi.g.height = THICK1; wi.g.x = CAMERA_INFO_POS_X2 + CAMERA_INFO_POS_OFFSET2; wi.g.y = CAMERA_INFO_POS_Y2;
	ghLabel3 = gwinLabelCreate(0, &wi);
#endif

	wi.text = "AGE:";

	wi.g.width = CAMERA_INFO_WIDTH2; wi.g.height = THICK1; wi.g.x = CAMERA_INFO_POS_X2; wi.g.y = CAMERA_INFO_POS_Y3;
	ghLabel4 = gwinLabelCreate(0, &wi);

#ifdef USE_DATA_INPUT
	if(p_infos[p_info_index].age != 0)
	{
		wi.text = "12345678901234567890";
		sprintf((char *)wi.text, "%d", p_infos[p_info_index].age);
	}
	else
	{
		wi.text = "                    ";
	}
	wi.g.width = CAMERA_INFO_WIDTH2A; wi.g.height = THICK1; wi.g.x = CAMERA_INFO_POS_X2 + CAMERA_INFO_POS_OFFSET2; wi.g.y = CAMERA_INFO_POS_Y3;
	ghLabel4 = gwinLabelCreate(0, &wi);
#endif

	// Create label
	wi.text = "Birthday:";
	wi.g.width = CAMERA_INFO_WIDTH1; wi.g.height = THICK1; wi.g.x = CAMERA_INFO_POS_X1; wi.g.y = CAMERA_INFO_POS_Y3;
	ghLabel5 = gwinLabelCreate(0, &wi);

#ifdef USE_DATA_INPUT
	if(p_infos[p_info_index].birthday != (unsigned char *)"")
	{
		wi.text = "12345678901234567890";
		wi.text = (const char *)p_infos[p_info_index].birthday;
	}
	else
	{
		wi.text = "                    ";
	}
	wi.g.width = CAMERA_INFO_WIDTH1A; wi.g.height = THICK1; wi.g.x = CAMERA_INFO_POS_X1 + CAMERA_INFO_POS_OFFSET1; wi.g.y = CAMERA_INFO_POS_Y3;
	ghLabel5 = gwinLabelCreate(0, &wi);
#endif


	return;
}

void pixmap_draw(GDisplay* pixmap, pixel_t* surface, coord_t pm_width, coord_t pm_height, gdispImage *p_Image, uint32_t s_x, uint32_t s_y, uint32_t d_x, uint32_t d_y, u8 alpha, u8 position)
{
	volatile uint32_t g_ms_tick_tmp1;
	volatile uint32_t g_ms_tick_tmp2;
	uint32_t i, j;
	uint32_t status;
	//color_t color = 0;

	//source image
	coord_t w;			//source image size width
	coord_t h;			//source image size height
	coord_t sx;			//source image start position x
	coord_t sy;			//source image start position y
	coord_t sWidth;		//source image capture size width
	coord_t sHeight;	//source image capture size height

	//destination canvas
	coord_t W;			//destination canvas size width
	coord_t H;			//destination canvas size height
	coord_t dx;			//destination canvas start position x
	coord_t dy;			//destination canvas start position y
	coord_t dWidth;		//destination canvas draw size width
	coord_t dHeight;	//destination canvas draw size height

	if(p_Image != NULL) {
		//source image
		w = p_Image->width;		//source image size width
		h = p_Image->height;	//source image size height
	}
	else {
		w = 0;					//source image size width
		h = 0;					//source image size height
	}
	sx = s_x;					//source image start position x
	sy = s_y;					//source image start position y
	sWidth = w;					//source image capture size width
	sHeight = h;				//source image capture size height

	//destination canvas
	W = pm_width;				//destination canvas size width
	H = pm_height;				//destination canvas size height
	dx = 0;						//destination canvas start position x
	dy = 0;						//destination canvas start position y
	dWidth = w;					//destination canvas draw size width
	dHeight = h;				//destination canvas draw size height

	//xil_printf("enter pixmap_draw\r\n");
	// Clear pixmap with 0
	memset(surface, 0, W * H * 4); // Clear buffer

	// Overlay file is necessary
	if(p_Image != NULL) {
		// Load image

		if(position == POSITION_USER)
		{
			dx = d_x;
			dy = d_y;
		}
		else if(position == POSITION_MIDDLE_CENTER)
		{
			dx = (W - w) >> 1;
			dy = (H - h) >> 1;
		}
		else if(position == POSITION_MIDDLE_LEFT)
		{
			dx = 0;
			dy = (H - h) >> 1;
		}
		else if(position == POSITION_MIDDLE_RIGHT)
		{
			dx = (W - w) >> 0;
			dy = (H - h) >> 1;
		}
		else if(position == POSITION_TOP_CENTER)
		{
			dx = (W - w) >> 1;
			dy = 0;
		}
		else if(position == POSITION_TOP_LEFT)
		{
			dx = 0;
			dy = 0;
		}
		else if(position == POSITION_TOP_RIGHT)
		{
			dx = (W - w) >> 0;
			dy = 0;
		}
		else if(position == POSITION_BOTTOM_CENTER)
		{
			dx = (W - w) >> 1;
			dy = (H - h) >> 0;
		}
		else if(position == POSITION_BOTTOM_LEFT)
		{
			dx = 0;
			dy = (H - h) >> 0;
		}
		else if(position == POSITION_BOTTOM_RIGHT)
		{
			dx = (W - w) >> 0;
			dy = (H - h) >> 0;
		}
		else
		{
			xil_printf("pixmap_draw, unknown position = %d, abort.\n\r", position);
			return;
		}
		xil_printf("pixmap_draw : w = %d, h = %d, sx = %d, sy = %d, sW =%d, sH = %d, W = %d, H = %d, dx = %d, dy = %d, dW = %d, dH = %d, alpha = %d, pos = %d\r\n", w, h, sx, sy, sWidth, sHeight, W, H, dx, dy, dWidth, dHeight, alpha, position);
		//ex: step_3              w = 760, h = 384, sx = 0, sy = 0, sW =760, sH = 384, W = 1216, H = 912, dx = 0, dy = 0, dW =760, dH = 384(center)
		g_ms_tick_tmp1 = g_ms_tick;
		status = gdispGImageDraw(pixmap, p_Image, dx, dy, sWidth, sHeight, sx, sy);
		g_ms_tick_tmp2 = g_ms_tick;
		xil_printf("draw pixmap, time1 = %d\n\r", g_ms_tick_tmp2 - g_ms_tick_tmp1);
		//xil_printf("status draw: %d\r\n", status);
		pic_dx = dx;
		pic_dy = dy;
	}
	else
	{
		xil_printf("pixmap_draw : clear image\n\r");
	}

	uint32_t r;
	uint32_t g;
	uint32_t b;
	int cut;

	if(H > 500)
		cut = CUT_PIXEL1;
	else
		cut = CUT_PIXEL2;

    // Draw transparency required on layer 1
    for(j = 0; j < H; j++) {
    	for(i = 0; i < W; i++) {
    		if((j > (cut - 1)) && (j < (H - cut))) {	//middle
    			//color = gdisp_lld_get_pixel_color(pixmap);
    			//xil_printf("color: %x\r\n", color);
    			if((i >= dx) && (i < dx + w) && (j >= dy) && (j < dy + h))
    			{
       				r = surface[j * W + i] & 0xff;
       				g = (surface[j * W + i] >> 8) & 0xff;
       				b = (surface[j * W + i] >> 16) & 0xff;
       				surface[j * W + i] = ABGR2COLOR(alpha, r, g, b);	//really picture
       				//surface[j * W + i] &= 0x000000FF;		//pure red
       				//surface[j * W + i] = 0x2200FF00;		//pure green
       				//surface[j * W + i] &= 0x00FF0000;		//pure blue
       				//surface[j * W + i] = 0x00FFFFFF;		//pure white
    			}
    			else
    			{
    				surface[j * W + i] = ABGR2COLOR(0x00, 0x00, 0x00, 0x00);	//OSD 0% black => all transparent
    			}
    		}
    		else {
    			if(j < cut) { // Top lines
    				if ((i < (cut - j)) || (i > ((W - cut) - 1 + j))) {
    					//surface[j * W + i] = ABGR2COLOR(0x80, 0xff, 0xff, 0xff);	//old
    					surface[j * W + i] = ABGR2COLOR(0xff, 0x00, 0x00, 0x00);		//OSD 100% black
    					//xil_printf("c: %x\r\n", surface_1[j*PIXMAP_WIDTH_1 + i]);
    				}
    				else {
    	    			if((i >= dx) && (i < dx + w) && (j >= dy) && (j < dy + h))
    	    			{
    	       				r = surface[j * W + i] & 0xff;
    	       				g = (surface[j * W + i] >> 8) & 0xff;
    	       				b = (surface[j * W + i] >> 16) & 0xff;
    	       				surface[j * W + i] = ABGR2COLOR(alpha, r, g, b);
    	    			}
    	    			else
    	    			{
    	    				surface[j*W + i] = ABGR2COLOR(0x00, 0x00, 0x00, 0x00);	//OSD 0% black => all transparent
    	    			}
    				}

				}
				else { // Bottom lines
					if((i < (j + cut - H) ) || i > ((W - (cut-(H - j))) -1 )){
						//surface[j * W + i] = ABGR2COLOR(0x80, 0xff, 0xff, 0xff);	//old
						surface[j * W + i] = ABGR2COLOR(0xff, 0x00, 0x00, 0x00);	//OSD 100% black
					}
					else {
    	    			if((i >= dx) && (i < dx + w) && (j >= dy) && (j < dy + h))
    	    			{
    	       				r = surface[j * W + i] & 0xff;
    	       				g = (surface[j * W + i] >> 8) & 0xff;
    	       				b = (surface[j * W + i] >> 16) & 0xff;

    	       				surface[j * W + i] = ABGR2COLOR(alpha, r, g, b);
    	    			}
    	    			else
    	    			{
    	    				surface[j * W + i] = ABGR2COLOR(0x00, 0x00, 0x00, 0x00);	//OSD 0% black => all transparent
    	    			}
					}
				}
     		}
    	}
    }
}


///* Global timer set up*/
//
///* start timer */
// void gtimer_start_clock(void)
//{
//	*(volatile unsigned int*)SCU_GLOBAL_TIMER_CONTROL = ((1 << 0) | // Timer Enable
//														 (1 << 1) | // Comparator Comparison Enable
//						      	  	  	  	  	  	  	 (1 << 3) | // Auto-increment
//														 (0 << 8) 	// Pre-scale
//	);
//}
//
///* stop timer and reset timer count regs */
// void gtimer_reset_clock(void)
//{
//	gtimer_disable_clock();
//	*(volatile unsigned int*)SCU_GLOBAL_TIMER_COUNT_L32 = 0; // Reset Clock
//	*(volatile unsigned int*)SCU_GLOBAL_TIMER_COUNT_U32 = 0;
//}
//
// /* Set Comparator values */
//  void gtimer_set_comparator(uint32_t L32, uint32_t U32)
// {
// 	*(volatile unsigned int*)SCU_GLOBAL_TIMER_COMP_L32 = L32;
// 	*(volatile unsigned int*)SCU_GLOBAL_TIMER_COMP_U32 = U32;
// }
//
///* stop timer */
// void gtimer_disable_clock(void)
//{
//	*(volatile unsigned int*)SCU_GLOBAL_TIMER_CONTROL = 0;
//}
//
///* Compute mask for given delay in miliseconds*/
//int get_number_of_cycles_for_delay(unsigned int delay)
//{
//  // GTC is always clocked at 1/2 of the CPU frequency (CPU_3x2x)
//  return (XPAR_PS7_CORTEXA9_0_CPU_CLK_FREQ_HZ*delay/(2*1000));
//
//}
//
//void gtimer_reset_and_start_timer()
//{
//  	    gtimer_reset_clock();
//	    gtimer_start_clock();
//}

// uGFX SystemTick
systemticks_t gfxSystemTicks(void)
{
	return g_ms_tick;
}

systemticks_t gfxMillisecondsToTicks(delaytime_t ms)
{
	return ms;
}
/////////////////////////////////////

uint32_t tusb_tick_get(void)
{
  //return system_ticks;
  return g_ms_tick;
}

void reset_usb(void)
{
	uint8_t reg;
	uint8_t val = 0;

	usb_reset_status = 1;
	usb_reset_status_old = 0;
	//xil_printf("david0823: %s:%s(%d) ST usb_reset_status = %d\r\n",__FILE__,__func__,__LINE__,usb_reset_status);

	xil_printf("usb reset\n\r");
	reg = ULPI_OTG_CTRL;
	val = 0;
	val = ulpi_ReadReg(reg);
	xil_printf("read value : %02X\n\r", val);

	val &= 0xDF;
	xil_printf("set value : %02X\n\r", val);
	ulpi_WriteReg(val, reg);

	usleep(500000);

	val |= 0x20;
	xil_printf("set value : %02X\n\r", val);
	ulpi_WriteReg(val, reg);
}

void get_usb_descriptor(void)
{
	//xil_printf("\n\rGet usb descriptor\n\r");
	uint16_t vid_tmp = 0;
	uint16_t pid_tmp = 0;
	uint8_t ret = 0;
	ret = usb_command(&vid_tmp, &pid_tmp);

	if(ret == TUSB_ERROR_NONE)
	{
		vendor_id_tmp = vid_tmp;
		product_id_tmp = pid_tmp;
	}
	else
	{
		xil_printf("fail\n\r");
	}
}

void read_usb_registers(void)
{
	uint32_t value = 0;
	uint8_t i;

	xil_printf("\n\rRead usb registers\n\r");
	value = XUsbPs_ReadReg(XPAR_XUSBPS_0_BASEADDR, 0);xil_printf("%08X ", value);
	value = XUsbPs_ReadReg(XPAR_XUSBPS_0_BASEADDR, 4);xil_printf("%08X ", value);
	value = XUsbPs_ReadReg(XPAR_XUSBPS_0_BASEADDR, 8);xil_printf("%08X ", value);
	value = XUsbPs_ReadReg(XPAR_XUSBPS_0_BASEADDR, 0xc);xil_printf("%08X ", value);
	value = XUsbPs_ReadReg(XPAR_XUSBPS_0_BASEADDR, 0x10);xil_printf("%08X ", value);
	value = XUsbPs_ReadReg(XPAR_XUSBPS_0_BASEADDR, 0x14);xil_printf("%08X\n\r", value);

	xil_printf("\n\rRead ulpi registers\n\r");
	/*
	for(i = 0; i < 8; i++)
	{
		xil_printf("0x%02X ", i);
	}
	xil_printf("\n");
	*/

	for(i = 0; i < 64; i++)
	{
		value = ulpi_ReadReg(i);	//0x16
		xil_printf("%02X", value);
		if((i%8) == 7)
			xil_printf("\n\r");
		else
			xil_printf("  ");
	}
	xil_printf("\n\r");
	xil_printf("\n\r");

	xil_printf("Keyboard : ");
	if(flag_is_keyboard_mounted == 1)
	{
		xil_printf("mounted\n\r");
	}
	else
	{
		xil_printf("unmounted\n\r");
	}
	xil_printf("\n\r");
}

void parse_uart_esc_command(void)
{
	int i;
	if((buffer[0] == 0x1B)&&(buffer[1] == '[')&&(buffer[2] == 'A'))
	{
		//xil_printf("Up\t");
		//xil_printf("Up, len = %d\t", length);
		//xil_printf("Up, len = %d\t", last_command_length);
		xil_printf("\r%s", PROMPT);
		if(last_command_length == 1)
			xil_printf("%s", last_command);
		ptr = last_command_length - 1;
		for(i = 0; i < ptr; i++)
		{
			buffer[i] = last_command[i];
			xil_printf("%c", buffer[i]);
		}
		length = last_command_length;
	}
	else if((buffer[0] == 0x1B)&&(buffer[1] == '[')&&(buffer[2] == 'B'))
	{
		//xil_printf("Down\t");
		xil_printf("\r%s", PROMPT);
		xil_printf("%s", last_command);
		ptr = last_command_length - 1;
		for(i = 0; i < ptr; i++)
		{
			buffer[i] = last_command[i];
		}
		length = last_command_length;
	}
	else if((buffer[0] == 0x1B)&&(buffer[1] == '[')&&(buffer[2] == 'C'))
	{
		//xil_printf("Right\t");
		xil_printf("\r%s", PROMPT);
		xil_printf("%s", last_command);
		ptr = last_command_length - 1;
		for(i = 0; i < ptr; i++)
		{
			buffer[i] = last_command[i];
		}
		length = last_command_length;
	}
	else if((buffer[0] == 0x1B)&&(buffer[1] == '[')&&(buffer[2] == 'D'))
	{
		//xil_printf("Left\t");
		/*
		// not very good
		if(ptr >= 2)
		{
			xil_printf("%c", 0x08);
			//xil_printf(".");
			ptr -= 2;
		}
		else
			ptr--;
		*/
		xil_printf("\r%s", PROMPT);
		xil_printf("%s", last_command);
		ptr = last_command_length - 1;
		for(i = 0; i < ptr; i++)
		{
			buffer[i] = last_command[i];
		}
		length = last_command_length;
	}
	else if((buffer[0] == 0x1B)&&(buffer[1] == 0x4F)&&(buffer[2] == 'A'))
	{
		xil_printf("Ctrl + Up\n\r");
	}
	else if((buffer[0] == 0x1B)&&(buffer[1] == 0x4F)&&(buffer[2] == 'B'))
	{
		xil_printf("Ctrl + Down\n\r");
	}
	else if((buffer[0] == 0x1B)&&(buffer[1] == 0x4F)&&(buffer[2] == 'C'))
	{
		xil_printf("Ctrl + Right\n\r");
	}
	else if((buffer[0] == 0x1B)&&(buffer[1] == 0x4F)&&(buffer[2] == 'D'))
	{
		xil_printf("Ctrl + Left\n\r");
	}
	else if((buffer[0] == 0x1B)&&(buffer[1] == '[')&&(buffer[2] == 0x35))
	{
		xil_printf("PageUp\n\r");
	}
	else if((buffer[0] == 0x1B)&&(buffer[1] == '[')&&(buffer[2] == 0x36))
	{
		xil_printf("PageDown\n\r");
	}
	else if((buffer[0] == 0x1B)&&(buffer[1] == '[')&&(buffer[2] == 0x31))
	{
		xil_printf("Home\n\r");
	}
	else if((buffer[0] == 0x1B)&&(buffer[1] == '[')&&(buffer[2] == 0x32))
	{
		xil_printf("Insert\n\r");
	}
	else if((buffer[0] == 0x1B)&&(buffer[1] == '[')&&(buffer[2] == 0x33))
	{
		xil_printf("Delete\n\r");
	}
	else if((buffer[0] == 0x1B)&&(buffer[1] == '[')&&(buffer[2] == 0x34))
	{
		xil_printf("End\n\r");
	}
	else
	{
		xil_printf("XXXX ESC\t");
		for( i = 0; i<3; i++)
		{
			xil_printf("0x%x ", buffer[i]);
		}
		xil_printf("\n\r");
	}
}

int cnt = 0;
u8 exposure = 0x42;

void show_command_not_found(void)
{
	int i;
	xil_printf("\n\r");
	for(i = 0; i < (length-1); i++)
		xil_printf("%c", buffer[i]);
	xil_printf(": not found\n\r");
}

void parse_uart_command(void)
{
	int status;
	int i;
	u32 reg = 0;
	u32 value = 0;
	//int j;
	uint8_t val = 0;

	if(length == 20)
	{
		if((buffer[0] == 'w')&&(buffer[1] == ' '))
		{
			for(i = 2; i < 10; i++)
			{
				if((buffer[i] >= 'A') && (buffer[i] <= 'F'))
				{
					reg |= (buffer[i] - 'A' + 10) << ((9 - i) * 4);
					//xil_printf("%c %x", buffer[i], reg);
				}
				else if((buffer[i] >= 'a') && (buffer[i] <= 'f'))
				{
					reg |= (buffer[i] - 'a' + 10) << ((9 - i) * 4);
					//xil_printf("%c %x", buffer[i], reg);
				}
				else if((buffer[i] >= '0') && (buffer[i] <= '9'))
				{
					reg |= (buffer[i] - '0') << ((9 - i) * 4);
					//xil_printf("%c %x", buffer[i], reg);
				}
				else
				{
					xil_printf("\n\rWrite register, illegal parameters %c, abort\n\r", buffer[i]);
					return;
				}
			}
			//xil_printf("reg = 0x%08x\n\r", reg);
			for(i = 11; i < 19; i++)
			{
				if((buffer[i] >= 'A') && (buffer[i] <= 'F'))
				{
					value |= (buffer[i] - 'A' + 10) << ((18 - i) * 4);
					//xil_printf("%c %x", buffer[i], value);
				}
				else if((buffer[i] >= 'a') && (buffer[i] <= 'f'))
				{
					value |= (buffer[i] - 'a' + 10) << ((18 - i) * 4);
					//xil_printf("%c %x", buffer[i], value);
				}
				else if((buffer[i] >= '0') && (buffer[i] <= '9'))
				{
					value |= (buffer[i] - '0') << ((18 - i) * 4);
					//xil_printf("%c %x", buffer[i], value);
				}
				else
				{
					xil_printf("\n\rWrite register, illegal parameters %c, abort\n\r", buffer[i]);
					return;
				}
			}
			//xil_printf("value = 0x%08x = %d\n\r", value, value);

			Xil_Out32(reg, value);
			xil_printf("\n\rRegister : 0x%08x\twrite value : 0x%08x\n\r",reg, value);

			value = Xil_In32(reg);
			xil_printf("\n\rRegister : 0x%08x\tread value : 0x%08x\n\r",reg, value);
		}
		else
		{
			show_command_not_found();
		}
	}
	else if(length == 19)
	{
		//rtc YYYYMMDDhhmmss
		if((buffer[0] == 'r')&&(buffer[1] == 't')&&(buffer[2] == 'c')&&(buffer[3] == ' '))
		{
			u8 type;
			int data;
			int year;

			if((buffer[4] < 0x30) || (buffer[4] > 0x39) || (buffer[5] < 0x30) || (buffer[5] > 0x39) || (buffer[6] < 0x30) || (buffer[6] > 0x39) || (buffer[7] < 0x30) || (buffer[7] > 0x39))
			{
				xil_printf("\n\rIllegal parameters.\n\r");
				return;
			}
			year = (buffer[4] - 0x30) * 1000 + (buffer[5] - 0x30) * 100 + (buffer[6] - 0x30) * 10 + (buffer[7] - 0x30);
			if((year < 2020) || (year > 3000))
			{
				xil_printf("\n\rIllegal parameters, year = %d\n\r", year);
				return;
			}
			XIicPs_SetRTCData(&Iic, RTC_YEAR, (u8)(year - 2000));

			type = RTC_MON;
			if((buffer[8] < 0x30) || (buffer[8] > 0x39) || (buffer[9] < 0x30) || (buffer[9] > 0x39))
			{
				xil_printf("\n\rIllegal parameters.\n\r");
				return;
			}
			data = (buffer[8] - 0x30) * 10 + (buffer[9] - 0x30);
			if((data < 1) || (data > 12))
			{
				xil_printf("\n\rIllegal parameters, month = %d\n\r", data);
				return;
			}
			XIicPs_SetRTCData(&Iic, type, data);

			type = RTC_MD;
			if((buffer[10] < 0x30) || (buffer[10] > 0x39) || (buffer[11] < 0x30) || (buffer[11] > 0x39))
			{
				xil_printf("\n\rIllegal parameters.\n\r");
				return;
			}
			data = (buffer[10] - 0x30) * 10 + (buffer[11] - 0x30);
			if((data < 0) || (data > 31))
			{
				xil_printf("\n\rIllegal parameters, month day = %d\n\r", data);
				return;
			}
			XIicPs_SetRTCData(&Iic, type, data);

			type = RTC_HH;
			if((buffer[12] < 0x30) || (buffer[12] > 0x39) || (buffer[13] < 0x30) || (buffer[13] > 0x39))
			{
				xil_printf("\n\rIllegal parameters.\n\r");
				return;
			}
			data = (buffer[12] - 0x30) * 10 + (buffer[13] - 0x30);
			if((data < 0) || (data > 23))
			{
				xil_printf("\n\rIllegal parameters, hour = %d\n\r", data);
				return;
			}
			XIicPs_SetRTCData(&Iic, type, data);

			type = RTC_MM;
			if((buffer[14] < 0x30) || (buffer[14] > 0x39) || (buffer[15] < 0x30) || (buffer[15] > 0x39))
			{
				xil_printf("\n\rIllegal parameters.\n\r");
				return;
			}
			data = (buffer[14] - 0x30) * 10 + (buffer[15] - 0x30);
			if((data < 0) || (data > 59))
			{
				xil_printf("\n\rIllegal parameters, minute = %d\n\r", data);
				return;
			}
			XIicPs_SetRTCData(&Iic, type, data);

			type = RTC_SS;
			if((buffer[16] < 0x30) || (buffer[16] > 0x39) || (buffer[17] < 0x30) || (buffer[17] > 0x39))
			{
				xil_printf("\n\rIllegal parameters.\n\r");
				return;
			}
			data = (buffer[16] - 0x30) * 10 + (buffer[17] - 0x30);
			if((data < 0) || (data > 59))
			{
				xil_printf("\n\rIllegal parameters, second = %d\n\r", data);
				return;
			}
			XIicPs_SetRTCData(&Iic, type, data);
		}
		else
		{
			show_command_not_found();
		}
	}
	else if(length == 13)
	{
		if((buffer[0] == 'w')&&(buffer[1] == ' ')&&(buffer[2] == 'c')&&(buffer[3] == 's')&&(buffer[4] == ' '))	//w cs #### ##
		{
			for(i = 5; i <= 8; i++)
			{
				if((buffer[i] >= 'A') && (buffer[i] <= 'F'))
				{
					reg |= (buffer[i] - 'A' + 10) << ((8 - i) * 4);
					//xil_printf("%c %x", buffer[i], reg);
				}
				else if((buffer[i] >= 'a') && (buffer[i] <= 'f'))
				{
					reg |= (buffer[i] - 'a' + 10) << ((8 - i) * 4);
					//xil_printf("%c %x", buffer[i], reg);
				}
				else if((buffer[i] >= '0') && (buffer[i] <= '9'))
				{
					reg |= (buffer[i] - '0') << ((8 - i) * 4);
					//xil_printf("%c %x", buffer[i], reg);
				}
				else
				{
					xil_printf("\n\rWrite register, illegal parameters %c, abort\n\r", buffer[i]);
					return;
				}
			}
			for(i = 10; i <= 11; i++)
			{
				if((buffer[i] >= 'A') && (buffer[i] <= 'F'))
				{
					value |= (buffer[i] - 'A' + 10) << ((11 - i) * 4);
					//xil_printf("%c %x", buffer[i], value);
				}
				else if((buffer[i] >= 'a') && (buffer[i] <= 'f'))
				{
					value |= (buffer[i] - 'a' + 10) << ((11 - i) * 4);
					//xil_printf("%c %x", buffer[i], value);
				}
				else if((buffer[i] >= '0') && (buffer[i] <= '9'))
				{
					value |= (buffer[i] - '0') << ((11 - i) * 4);
					//xil_printf("%c %x", buffer[i], value);
				}
				else
				{
					xil_printf("\n\rWrite register, illegal parameters %c, abort\n\r", buffer[i]);
					return;
				}
			}
			//xil_printf("\n\rreg = 0x%08x\n\r", reg);
			//xil_printf("value = 0x%08x = %d\n\r", value, value);
			dongle_write_data(reg, value);
			xil_printf("\n\rCamera Sensor Register : 0x%04x\twrite value : 0x%02x\n\r",reg, value);
		}
	}
	else if(length == 11)
	{
		if((buffer[0] == 's')&&(buffer[1] == 'y')&&(buffer[2] == 's')&&(buffer[3] == 't')&&(buffer[4] == 'e')&&(buffer[5] == 'm')&&(buffer[6] == 'i')&&(buffer[7] == 'n')&&(buffer[8] == 'f')&&(buffer[9] == 'o'))
		{
			show_systeminfo();
		}
		else if((buffer[0] == 'r')&&(buffer[1] == 't')&&(buffer[2] == 'c')&&(buffer[3] == ' ')&&(buffer[4] == 'y')&&(buffer[5] == ' '))
		{
			int year;
			if((buffer[6] < 0x30) || (buffer[6] > 0x39) || (buffer[7] < 0x30) || (buffer[7] > 0x39) || (buffer[8] < 0x30) || (buffer[8] > 0x39) || (buffer[9] < 0x30) || (buffer[9] > 0x39))
			{
				xil_printf("\n\rIllegal parameters.\n\r");
				return;
			}
			year = (buffer[6] - 0x30) * 1000 + (buffer[7] - 0x30) * 100 + (buffer[8] - 0x30) * 10 + (buffer[9] - 0x30);
			if((year < 2020) || (year > 3000))
			{
				xil_printf("\n\rIllegal parameters, year = %d\n\r", year);
				return;
			}
			XIicPs_SetRTCData(&Iic, RTC_YEAR, (u8)(year - 2000));
		}
		else if((buffer[0] == 'd')&&(buffer[1] == 'o')&&(buffer[2] == 'n')&&(buffer[3] == 'g')&&(buffer[4] == 'l')&&(buffer[5] == 'e')&&(buffer[6] == ' ')&&(buffer[7] == 'o')&&(buffer[8] == 'f')&&(buffer[8] == 'f'))
		{
			xil_printf("\n\rTurn off dongle LEDs\n\r");
			SetDongleLedRedStatus(0);		//turn off red led on dongle
			SetDongleLedGreenStatus(0);		//turn off green led on dongle
		}
		else if((buffer[0] == 'r')&&(buffer[1] == ' '))
		{
			for(i = 2; i < 10; i++)
			{
				if((buffer[i] >= 'A') && (buffer[i] <= 'F'))
				{
					reg |= (buffer[i] - 'A' + 10) << ((9 - i) * 4);
					//xil_printf("%c %x", buffer[i], reg);
				}
				else if((buffer[i] >= 'a') && (buffer[i] <= 'f'))
				{
					reg |= (buffer[i] - 'a' + 10) << ((9 - i) * 4);
					//xil_printf("%c %x", buffer[i], reg);
				}
				else if((buffer[i] >= '0') && (buffer[i] <= '9'))
				{
					reg |= (buffer[i] - '0') << ((9 - i) * 4);
					//xil_printf("%c %x", buffer[i], reg);
				}
				else
				{
					xil_printf("\n\rRead register, illegal parameters %c, abort\n\r", buffer[i]);
					return;
				}
			}
			//xil_printf("reg = 0x%08x\n\r", reg);
			value = Xil_In32(reg);
			xil_printf("\n\rRegister : 0x%08x\tread value : 0x%08x\n\r",reg, value);
		}
		else
		{
			show_command_not_found();
		}
	}
	else if(length == 10)
	{
		u8 type;
		int data;
		if((buffer[0] == 'r')&&(buffer[1] == 't')&&(buffer[2] == 'c')&&(buffer[3] == ' ')&&(buffer[6] == ' '))	//for hh, mm, ss
		{
			if((buffer[4] == 'h')&&(buffer[5] == 'h'))
			{
				type = RTC_HH;
				if((buffer[7] < 0x30) || (buffer[7] > 0x39) || (buffer[8] < 0x30) || (buffer[8] > 0x39))
				{
					xil_printf("\n\rIllegal parameters.\n\r");
					return;
				}
				data = (buffer[7] - 0x30) * 10 + (buffer[8] - 0x30);
				if((data < 0) || (data > 23))
				{
					xil_printf("\n\rIllegal parameters, hour = %d\n\r", data);
					return;
				}
				XIicPs_SetRTCData(&Iic, type, data);
			}
			else if((buffer[4] == 'm')&&(buffer[5] == 'm'))
			{
				type = RTC_MM;
				if((buffer[7] < 0x30) || (buffer[7] > 0x39) || (buffer[8] < 0x30) || (buffer[8] > 0x39))
				{
					xil_printf("\n\rIllegal parameters.\n\r");
					return;
				}
				data = (buffer[7] - 0x30) * 10 + (buffer[8] - 0x30);
				if((data < 0) || (data > 59))
				{
					xil_printf("\n\rIllegal parameters, minute = %d\n\r", data);
					return;
				}
				XIicPs_SetRTCData(&Iic, type, data);
			}
			else if((buffer[4] == 's')&&(buffer[5] == 's'))
			{
				type = RTC_SS;
				if((buffer[7] < 0x30) || (buffer[7] > 0x39) || (buffer[8] < 0x30) || (buffer[8] > 0x39))
				{
					xil_printf("\n\rIllegal parameters.\n\r");
					return;
				}
				data = (buffer[7] - 0x30) * 10 + (buffer[8] - 0x30);
				if((data < 0) || (data > 59))
				{
					xil_printf("\n\rIllegal parameters, second = %d\n\r", data);
					return;
				}
				XIicPs_SetRTCData(&Iic, type, data);
			}
			else
			{
				show_command_not_found();
			}
		}
		else if((buffer[0] == 'r')&&(buffer[1] == 't')&&(buffer[2] == 'c')&&(buffer[3] == ' ')&&(buffer[5] == ' '))	//for hh, mm, ss
		{
			//rtc # ###       Setup RTC addr(#) with data(###) in decimal
			u8 addr;
			if((buffer[4] < 0x30) || (buffer[4] > 0x39))
			{
				xil_printf("\n\rIllegal parameters.\n\r");
				return;
			}
			if((buffer[6] < 0x30) || (buffer[6] > 0x39) || (buffer[7] < 0x30) || (buffer[7] > 0x39) || (buffer[8] < 0x30) || (buffer[8] > 0x39))
			{
				xil_printf("\n\rIllegal parameters.\n\r");
				return;
			}
			addr = (buffer[4] - 0x30);
			data = (buffer[6] - 0x30) * 100 + (buffer[7] - 0x30) * 10 + (buffer[8] - 0x30);
			if((addr < 0) || (addr > 7))
			{
				xil_printf("\n\rIllegal parameters, addr = %d\n\r", addr);
				return;
			}
			if((data < 0) || (data > 255))
			{
				xil_printf("\n\rIllegal parameters, data = %d\n\r", data);
				return;
			}
			XIicPs_SetData(&Iic, addr, data);
		}
		else if((buffer[0] == 'd')&&(buffer[1] == 'o')&&(buffer[2] == 'n')&&(buffer[3] == 'g')&&(buffer[4] == 'l')&&(buffer[5] == 'e')&&(buffer[6] == ' ')&&(buffer[7] == 'o')&&(buffer[8] == 'n'))
		{
			xil_printf("\n\rTurn on dongle LEDs\n\r");
			SetDongleLedRedStatus(1);		//turn on red led on dongle
			SetDongleLedGreenStatus(1);		//turn on green led on dongle
		}
		else if((buffer[0] == 'r')&&(buffer[1] == ' ')&&(buffer[2] == 'c')&&(buffer[3] == 's')&&(buffer[4] == ' '))	//r cs ####
		{
			unsigned int reg = 0;
			for(i = 5; i <= 8; i++)
			{
				if((buffer[i] >= 'A') && (buffer[i] <= 'F'))
				{
					reg |= (buffer[i] - 'A' + 10) << ((8 - i) * 4);
					//xil_printf("%c %x", buffer[i], reg);
				}
				else if((buffer[i] >= 'a') && (buffer[i] <= 'f'))
				{
					reg |= (buffer[i] - 'a' + 10) << ((8 - i) * 4);
					//xil_printf("%c %x", buffer[i], reg);
				}
				else if((buffer[i] >= '0') && (buffer[i] <= '9'))
				{
					reg |= (buffer[i] - '0') << ((8 - i) * 4);
					//xil_printf("%c %x", buffer[i], reg);
				}
				else
				{
					xil_printf("\n\rWrite register, illegal parameters %c, abort\n\r", buffer[i]);
					return;
				}
			}
			unsigned char DongleData;
			DongleData = dongle_read_data(reg);
			xil_printf("\n\rCamera Sensor Register : 0x%04x\tread value : 0x%02x\n\r",reg, DongleData);
		}
		else if((buffer[0] == 'w')&&(buffer[1] == ' ')&&(buffer[2] == 'c')&&(buffer[3] == 'f')&&(buffer[4] == ' '))	//w cf #### ##
		{
			if((buffer[5] >= 'A') && (buffer[5] <= 'F'))
			{
				reg |= (buffer[5] - 'A' + 10);
				//xil_printf("%c %x", buffer[i], reg);
			}
			else if((buffer[5] >= 'a') && (buffer[5] <= 'f'))
			{
				reg |= (buffer[5] - 'a' + 10);
				//xil_printf("%c %x", buffer[i], reg);
			}
			else if((buffer[5] >= '0') && (buffer[5] <= '9'))
			{
				reg |= (buffer[5] - '0');
				//xil_printf("%c %x", buffer[i], reg);
			}
			else
			{
				xil_printf("\n\rWrite register, illegal parameters %c, abort\n\r", buffer[5]);
				return;
			}

			for(i = 7; i <= 8; i++)
			{
				if((buffer[i] >= 'A') && (buffer[i] <= 'F'))
				{
					value |= (buffer[i] - 'A' + 10) << ((8 - i) * 4);
					//xil_printf("%c %x", buffer[i], value);
				}
				else if((buffer[i] >= 'a') && (buffer[i] <= 'f'))
				{
					value |= (buffer[i] - 'a' + 10) << ((8 - i) * 4);
					//xil_printf("%c %x", buffer[i], value);
				}
				else if((buffer[i] >= '0') && (buffer[i] <= '9'))
				{
					value |= (buffer[i] - '0') << ((8 - i) * 4);
					//xil_printf("%c %x", buffer[i], value);
				}
				else
				{
					xil_printf("\n\rWrite register, illegal parameters %c, abort\n\r", buffer[i]);
					return;
				}
			}
			//xil_printf("\n\rreg = 0x%08x\n\r", reg);
			//xil_printf("value = 0x%08x = %d\n\r", value, value);
			camera_fpga_write_data(reg, value);
			xil_printf("\n\rCamera FPGA Register : 0x%x\twrite value : 0x%02x\n\r",reg, value);
		}
		else
		{
			show_command_not_found();
		}
	}
	else if(length == 9)
	{
		u8 type;
		int data;
		if((buffer[0] == 'r')&&(buffer[1] == 't')&&(buffer[2] == 'c')&&(buffer[3] == ' ')&&(buffer[5] == ' '))	//for month(m), monthday(d)
		{
			if(buffer[4] == 'm')
			{
				type = RTC_MON;
				if((buffer[6] < 0x30) || (buffer[6] > 0x39) || (buffer[7] < 0x30) || (buffer[7] > 0x39))
				{
					xil_printf("\n\rIllegal parameters.\n\r");
					return;
				}
				data = (buffer[6] - 0x30) * 10 + (buffer[7] - 0x30);
				if((data < 1) || (data > 12))
				{
					xil_printf("\n\rIllegal parameters, month = %d\n\r", data);
					return;
				}
				XIicPs_SetRTCData(&Iic, type, data);
			}
			else if(buffer[4] == 'd')
			{
				type = RTC_MD;
				if((buffer[6] < 0x30) || (buffer[6] > 0x39) || (buffer[7] < 0x30) || (buffer[7] > 0x39))
				{
					xil_printf("\n\rIllegal parameters.\n\r");
					return;
				}
				data = (buffer[6] - 0x30) * 10 + (buffer[7] - 0x30);
				if((data < 0) || (data > 31))
				{
					xil_printf("\n\rIllegal parameters, month day = %d\n\r", data);
					return;
				}
				XIicPs_SetRTCData(&Iic, type, data);
			}
			else
			{
				show_command_not_found();
			}
		}
		else if((buffer[0] == 'r')&&(buffer[1] == ' ')&&(buffer[2] == 'c')&&(buffer[3] == 's')&&(buffer[4] == ' ')&&(buffer[5] == 'a')&&(buffer[6] == 'l')&&(buffer[7] == 'l'))
		{
			xil_printf("\n\rRead Camera Sensor registers all\n\r");
			unsigned char DongleData;
			unsigned int DongleAddr;

			DongleAddr = 0x0100;
			DongleData = dongle_read_data(DongleAddr);
			xil_printf("addr = 0x%04x, data = 0x%02x\t", DongleAddr, DongleData);
			if(DongleData == 0)
				xil_printf("Sleep\n\r");
			else if(DongleData == 1)
				xil_printf("Streaming\n\r");
			else
				xil_printf("impossible data = 0x%02x\n\r", DongleData);
			DongleAddr = 0x300a;
			DongleData = dongle_read_data(DongleAddr);
			xil_printf("addr = 0x%04x, data = 0x%02x\tCHIP ID H\n\r", DongleAddr, DongleData);
			DongleAddr = 0x300b;
			DongleData = dongle_read_data(DongleAddr);
			xil_printf("addr = 0x%04x, data = 0x%02x\tCHIP ID L\n\r", DongleAddr, DongleData);
			DongleAddr = 0x302a;
			DongleData = dongle_read_data(DongleAddr);
			xil_printf("addr = 0x%04x, data = 0x%02x\tCHIP REVISION\n\r", DongleAddr, DongleData);
			DongleAddr = 0x3820;
			DongleData = dongle_read_data(DongleAddr);
			xil_printf("addr = 0x%04x, data = 0x%02x\tIMAGE ORIENTATION\n\r", DongleAddr, DongleData);
			DongleAddr = 0x4A00;
			DongleData = dongle_read_data(DongleAddr);
			xil_printf("addr = 0x%04x, data = 0x%02x\tFRAME COUNT\n\r", DongleAddr, DongleData);


			xil_printf("\n\r7.1 general status\n\r");
			print_cs_data(0x0100);
			print_cs_data(0x0103);
			print_cs_data(0x0106);
			print_cs_data(0x300A);
			print_cs_data(0x300B);
			print_cs_data(0x302A);
			print_cs_data(0x3820);
			print_cs_data(0x4A00);
			xil_printf("\n\r");

			xil_printf("7.2 SCCB control\n\r");
			print_cs_data(0x0107);
			print_cs_data(0x3031);
			xil_printf("\n\r");

			xil_printf("7.3 IO control\n\r");
			print_cs_data(0x3001);
			print_cs_data(0x3002);
			print_cs_data(0x3009);
			xil_printf("\n\r");

			xil_printf("7.4 clock configuration\n\r");
			print_cs_data(0x3080);
			print_cs_data(0x3081);
			print_cs_data(0x3082);
			print_cs_data(0x3083);
			print_cs_data(0x3103);
			print_cs_data(0x301E);
			xil_printf("\n\r");

			xil_printf("7.5 gain/exposure control\n\r");
			print_cs_data(0x3501);
			print_cs_data(0x3502);
			print_cs_data(0x3503);
			print_cs_data(0x350A);
			print_cs_data(0x350B);
			xil_printf("\n\r");

			xil_printf("7.6 analog control\tRSVD\n\r");
			xil_printf("7.7 sensor control\tRSVD\n\r");
			xil_printf("7.8 PSRAM control\tRSVD\n\r");

			xil_printf("7.9 frame timing\n\r");
			for(DongleAddr = 0x3800; DongleAddr <= 0x3829; DongleAddr++)
			{
				print_cs_data(DongleAddr);
				if((DongleAddr % 8) == 7)
					xil_printf("\n\r");
			}
			xil_printf("\n\r");

			xil_printf("7.10 AEC control\n\r");
			for(DongleAddr = 0x3A00; DongleAddr <= 0x3A1A; DongleAddr++)
			{
				print_cs_data(DongleAddr);
				if((DongleAddr % 8) == 7)
					xil_printf("\n\r");
			}
			xil_printf("\n\r");

			xil_printf("7.11 BLC control\n\r");
			for(DongleAddr = 0x4000; DongleAddr <= 0x404F; DongleAddr++)
			{
				print_cs_data(DongleAddr);
				if((DongleAddr % 8) == 7)
					xil_printf("\n\r");
			}
			xil_printf("\n\r");

			xil_printf("7.12 frame control\n\r");
			print_cs_data(0x4201);
			print_cs_data(0x4202);
			xil_printf("\n\r");

			xil_printf("7.13 output data clipping\n\r");
			for(DongleAddr = 0x4300; DongleAddr <= 0x4307; DongleAddr++)
			{
				print_cs_data(DongleAddr);
				if((DongleAddr % 8) == 7)
					xil_printf("\n\r");
			}
			xil_printf("\n\r");

			xil_printf("7.14 output format control\n\r");
			print_cs_data(0x4308);
			xil_printf("\n\r");

			xil_printf("7.15 DVP control\n\r");
			for(DongleAddr = 0x4700; DongleAddr <= 0x4708; DongleAddr++)
			{
				print_cs_data(DongleAddr);
				if((DongleAddr % 8) == 7)
					xil_printf("\n\r");
			}
			xil_printf("\n\r");

			xil_printf("7.16 SPI control\n\r");
			print_cs_data(0x4F01);
			print_cs_data(0x4F02);
			xil_printf("\n\r");

			xil_printf("7.17 ISP control\n\r");
			for(DongleAddr = 0x5000; DongleAddr <= 0x500B; DongleAddr++)
			{
				print_cs_data(DongleAddr);
				if((DongleAddr % 8) == 7)
					xil_printf("\n\r");
			}
			xil_printf("\n\r");

			xil_printf("7.18 test pattern\n\r");
			print_cs_data(0x5080);
			xil_printf("\n\r");

			xil_printf("7.19 LENC control\n\r");
			for(DongleAddr = 0x5100; DongleAddr <= 0x511C; DongleAddr++)
			{
				print_cs_data(DongleAddr);
				if((DongleAddr % 8) == 7)
					xil_printf("\n\r");
			}
			xil_printf("\n\r");

			xil_printf("7.20 AWB control\n\r");
			for(DongleAddr = 0x5200; DongleAddr <= 0x5230; DongleAddr++)
			{
				print_cs_data(DongleAddr);
				if((DongleAddr % 8) == 7)
					xil_printf("\n\r");
			}
			xil_printf("\n\r");
			for(DongleAddr = 0x5238; DongleAddr <= 0x523D; DongleAddr++)
			{
				print_cs_data(DongleAddr);
				if((DongleAddr % 8) == 7)
					xil_printf("\n\r");
			}
			xil_printf("\n\r");

			xil_printf("7.21 gamma control\n\r");
			for(DongleAddr = 0x5300; DongleAddr <= 0x5310; DongleAddr++)
			{
				print_cs_data(DongleAddr);
				if((DongleAddr % 8) == 7)
					xil_printf("\n\r");
			}
			xil_printf("\n\r");

			xil_printf("7.22 DPC control\n\r");
			print_cs_data(0x5400);
			print_cs_data(0x5401);
			print_cs_data(0x5402);
			print_cs_data(0x5403);
			print_cs_data(0x5404);
			print_cs_data(0x5405);
			print_cs_data(0x540E);
			print_cs_data(0x540F);
			xil_printf("\n\r");

			xil_printf("7.23 CIP control\n\r");
			for(DongleAddr = 0x5500; DongleAddr <= 0x5514; DongleAddr++)
			{
				print_cs_data(DongleAddr);
				if((DongleAddr % 8) == 7)
					xil_printf("\n\r");
			}
			xil_printf("\n\r");

			xil_printf("7.24 CMX control\n\r");
			print_cs_data(0x5600);
			print_cs_data(0x5601);
			print_cs_data(0x5602);
			print_cs_data(0x5603);
			print_cs_data(0x5604);
			print_cs_data(0x5605);
			print_cs_data(0x5612);
			print_cs_data(0x5615);
			xil_printf("\n\r");

			xil_printf("7.25 SDE control\n\r");
			print_cs_data(0x5800);
			for(DongleAddr = 0x5803; DongleAddr <= 0x580C; DongleAddr++)
			{
				print_cs_data(DongleAddr);
				if((DongleAddr % 8) == 7)
					xil_printf("\n\r");
			}
			xil_printf("\n\r");
			xil_printf("\n\r");




		}
		else
		{
			show_command_not_found();
		}
	}
	else if(length == 8)
	{
		if((buffer[0] == 'r')&&(buffer[1] == 't')&&(buffer[2] == 'c')&&(buffer[3] == ' ')&&(buffer[5] == ' '))	//for weekday(w)
		{
			u8 type;
			int data;
			if(buffer[4] == 'w')
			{
				type = RTC_WD;
				if((buffer[6] < 0x30) || (buffer[6] > 0x39))
				{
					xil_printf("\n\rIllegal parameters.\n\r");
					return;
				}
				data = (buffer[6] - 0x30);
				if((data < 0) || (data > 6))
				{
					xil_printf("\n\rIllegal parameters, week day = %d\n\r", data);
					return;
				}
				XIicPs_SetRTCData(&Iic, type, data);
			}
		}
		else if((buffer[0] == 'f')&&(buffer[1] == 'a')&&(buffer[2] == 'n')&&(buffer[3] == ' ')&&(buffer[4] == 'o')&&(buffer[5] == 'f')&&(buffer[6] == 'f'))
		{
			xil_printf("\n\rTurn off fan\n\r");
			ps_gpio_setup(&periphs_inst, GPIO_FAN_EN, 0);
			fan_speed = 0;
		}
		else if((buffer[0] == 'c')&&(buffer[1] == 'a')&&(buffer[2] == 'm')&&(buffer[3] == ' ')&&(buffer[4] == 'o')&&(buffer[5] == 'f')&&(buffer[6] == 'f'))
		{
			xil_printf("\n\rTurn off camera LED\n\r");
			ps_gpio_setup(&periphs_inst, GPIO_CAM_LED, 0);
			flag_camera_led_status = 0;
		}
		else if((buffer[0] == 'i')&&(buffer[1] == 'm')&&(buffer[2] == 's')&&(buffer[3] == 'l')&&(buffer[4] == 'i')&&(buffer[5] == 'n')&&(buffer[6] == 'k'))
		{
			char str[40];
			sprintf(str, "imslink   goto imsLink mode\n\r");
			debug_console_print(str);
			flag_operation_mode = MODE_IMS_LINK;
			xil_printf("\n\rGoto imsLink mode\r\n");
			usleep(500000);
			Send_IMS_Data_Cmd(0x99, 0x11, 0x11);
			usleep(500000);
		}
		else
		{
			show_command_not_found();
		}
	}
	else if(length == 7)
	{
		if((buffer[0] == 'u')&&(buffer[1] == 'p')&&(buffer[2] == 't')&&(buffer[3] == 'i')&&(buffer[4] == 'm')&&(buffer[5] == 'e'))
		{
			//Get System Up time
			get_system_up_time();
		}
		else if((buffer[0] == 'f')&&(buffer[1] == 'a')&&(buffer[2] == 'n')&&(buffer[3] == ' ')&&(buffer[4] == 'o')&&(buffer[5] == 'n'))
		{
			xil_printf("\n\rTurn on fan\n\r");
			ps_gpio_setup(&periphs_inst, GPIO_FAN_EN, 1);
			fan_speed = 10;
		}
		else if((buffer[0] == 'c')&&(buffer[1] == 'a')&&(buffer[2] == 'm')&&(buffer[3] == ' ')&&(buffer[4] == 'o')&&(buffer[5] == 'n'))
		{
			xil_printf("\n\rTurn on camera LED\n\r");
			ps_gpio_setup(&periphs_inst, GPIO_CAM_LED, 1);
			flag_camera_led_status = 1;
		}
		else if((buffer[0] == 'b')&&(buffer[1] == 'l')&&(buffer[2] == ' ')&&(buffer[3] == 'o')&&(buffer[4] == 'f')&&(buffer[5] == 'f'))
		{
			xil_printf("\n\rTurn off back light\n\r");
			ps_gpio_setup(&periphs_inst, GPIO_LED_BL, 0);
		}
		else if((buffer[0] == 'r')&&(buffer[1] == ' ')&&(buffer[2] == 'c')&&(buffer[3] == 'f')&&(buffer[4] == ' '))	//r cf #
		{
			if((buffer[5] >= 'A') && (buffer[5] <= 'F'))
			{
				reg |= (buffer[5] - 'A' + 10);
				//xil_printf("%c %x", buffer[i], reg);
			}
			else if((buffer[5] >= 'a') && (buffer[5] <= 'f'))
			{
				reg |= (buffer[5] - 'a' + 10);
				//xil_printf("%c %x", buffer[i], reg);
			}
			else if((buffer[5] >= '0') && (buffer[5] <= '9'))
			{
				reg |= (buffer[5] - '0');
				//xil_printf("%c %x", buffer[i], reg);
			}
			else
			{
				xil_printf("\n\rWrite register, illegal parameters %c, abort\n\r", buffer[5]);
				return;
			}
			unsigned char DongleData = 0;
			DongleData = camera_fpga_read_data(reg);
			xil_printf("\n\rCamera FPGA Register : 0x%x\tread value : 0x%02x\n\r",reg, DongleData);
		}
		else
		{
			show_command_not_found();
		}
	}
	else if(length == 6)
	{
		if((buffer[0] == 'b')&&(buffer[1] == 'l')&&(buffer[2] == 'a')&&(buffer[3] == 'c')&&(buffer[4] == 'k'))
		{
			gdispClear(Black);
		}
		else if((buffer[0] == 'c')&&(buffer[1] == 'l')&&(buffer[2] == 'e')&&(buffer[3] == 'a')&&(buffer[4] == 'r'))
		{
			gdispClear(Black);
		}
		else if((buffer[0] == 'c')&&(buffer[1] == 'o')&&(buffer[2] == 'l')&&(buffer[3] == 'o')&&(buffer[4] == 'r'))
		{
//#ifdef USE_COLOR_DEBUG
			draw_color();
//#endif
		}
		else if((buffer[0] == 'w')&&(buffer[1] == 'h')&&(buffer[2] == 'i')&&(buffer[3] == 't')&&(buffer[4] == 'e'))
		{
			xil_printf("\n\rmemory copy from WHITE to framebuffer 0\n\r");
			volatile uint32_t g_ms_tick_tmp;
			g_ms_tick_tmp = g_ms_tick;
			gdispClear(White);
			xil_printf("memory copy ok, time = %d\n\r", g_ms_tick - g_ms_tick_tmp);
		}
		else if((buffer[0] == 'e')&&(buffer[1] == ' ')&&(buffer[2] == 'a')&&(buffer[3] == 'l')&&(buffer[4] == 'l'))
		{
			XIicPs_EraseEepromAll();
		}
		else if((buffer[0] == 'r')&&(buffer[1] == ' ')&&(buffer[2] == 'a')&&(buffer[3] == 'l')&&(buffer[4] == 'l'))
		{
			XIicPs_ReadEepromAll();
		}
		else if((buffer[0] == 'w')&&(buffer[1] == ' ')&&(buffer[2] == 'a')&&(buffer[3] == 'l')&&(buffer[4] == 'l'))
		{
			XIicPs_WriteEepromAll();
		}
		else if((buffer[0] == 'p')&&(buffer[1] == 'r')&&(buffer[2] == 'i')&&(buffer[3] == 'n')&&(buffer[4] == 't'))
		{
			xil_printf("ABCDEFGHIJKLMNOPQ");
			sleep(3);
			xil_printf("%c", 0x08);
			xil_printf("%c", 0x08);
			xil_printf("%c", 0x08);
			xil_printf("%c", 0x08);
			xil_printf("%c", 0x08);
			xil_printf("%c", 0x08);
			xil_printf("%c", 0x08);
			xil_printf("%c", 0x08);
			xil_printf("%c", 0x08);
			xil_printf("%c", 0x08);
			xil_printf("abcdefg");
			sleep(3);
			xil_printf("\r");
			xil_printf("-------");

		}
		else if((buffer[0] == 'u')&&(buffer[1] == 's')&&(buffer[2] == 'b')&&(buffer[3] == 'r')&&(buffer[4] == '1'))
		{
			xil_printf("\n\rusb HW reset\n\r");
			reset_usb();
		}
		else if((buffer[0] == 'u')&&(buffer[1] == 's')&&(buffer[2] == 'b')&&(buffer[3] == 'r')&&(buffer[4] == '2'))
		{
			xil_printf("\n\rusb SW reset\n\r");
			tusb_init(); // initialize tinyusb stack
			value = 0x60;
			ulpi_WriteReg(value, ULPI_FC_CTRL);	//0x16
			port_connect_status_change_isr(0);
			tusb_isr(0);
		}
		else if((buffer[0] == 'b')&&(buffer[1] == 'l')&&(buffer[2] == ' ')&&(buffer[3] == 'o')&&(buffer[4] == 'n'))
		{
			xil_printf("\n\rTurn on back light\n\r");
			ps_gpio_setup(&periphs_inst, GPIO_LED_BL, 1);
		}
		else if((buffer[0] == 'h')&&(buffer[1] == 'e')&&(buffer[2] == 'l')&&(buffer[3] == 'p')&&(buffer[4] == '2'))
		{
			show_help2_menu();
		}
		else if((buffer[0] == 'c')&&(buffer[1] == 'o')&&(buffer[2] == 'l')&&(buffer[3] == 'r')&&(buffer[4] == 'r'))//JACKY
		{
			read_color_matrix();
		}
		else if((buffer[0] == 'c')&&(buffer[1] == 'o')&&(buffer[2] == 'l')&&(buffer[3] == 'r')&&(buffer[4] == 'w'))//JACKY
		{
			write_color_matrix();
		}
		else if((buffer[0] == 'a')&&(buffer[1] == 'x')&&(buffer[2] == 'i')&&(buffer[3] == 's')&&(buffer[4] == 'l'))//JACKY2020 axisl
		{
			int axis_right_top, axis_left_dwon;
			//xil_printf("\n\rCENTER = %08x; LSW = %d %%, W = 0x%04x = %d, H = 0x%04x = %d\n\r", CENTER, LSW, (((LSW*320)/100)), (((LSW*320)/100)), ((LSW*240)/100), ((LSW*240)/100));
			axis_right_top=CENTER-(((LSW*320)/100)<<16)-((LSW*240)/100);
			axis_left_dwon=CENTER+(((LSW*320)/100-1)<<16)+(((LSW*240)/100)-1);
			xil_printf("\n\rL area((%d, %d)-(%d, %d), C(%d, %d), %d X %d)\n\r", (axis_right_top>>16)&0xffff, axis_right_top&0xffff, (axis_left_dwon>>16)&0xffff, axis_left_dwon&0xffff, (CENTER>>16)&0xffff, CENTER&0xffff, LSW * 320 / 100 * 2, LSW * 240 / 100 * 2);
			GpioOutput_graylevel_axis_Write(XPAR_VIDEO_PATH_CAMERA_IN_CDR_VIDEO_IN_AXI4_RDY_CDR_REGISTERS_AXI_GPIO_OTOTAL_CALC_LSW_GRAYLEVEL_AXIS_WRITE_DEVICE_ID, axis_right_top, axis_left_dwon );
		}
		else if((buffer[0] == 'a')&&(buffer[1] == 'x')&&(buffer[2] == 'i')&&(buffer[3] == 's')&&(buffer[4] == 's'))//JACKY2020 axiss
		{
			int axis_right_top, axis_left_dwon;
			//xil_printf("\n\rCENTER = %08x; SSW = %d %%, W = 0x%04x = %d, H = 0x%04x = %d\n\r", CENTER, SSW, (((SSW*320)/100)), (((SSW*320)/100)), ((SSW*240)/100), ((SSW*240)/100));
			axis_right_top=CENTER-(((SSW*320)/100)<<16)-((SSW*240)/100);
			axis_left_dwon=CENTER+(((SSW*320)/100-1)<<16)+(((SSW*240)/100)-1);
			xil_printf("\n\rS area((%d, %d)-(%d, %d), C(%d, %d), %d X %d)\n\r", (axis_right_top>>16)&0xffff, axis_right_top&0xffff, (axis_left_dwon>>16)&0xffff, axis_left_dwon&0xffff, (CENTER>>16)&0xffff, CENTER&0xffff, SSW * 320 / 100 * 2, SSW * 240 / 100 * 2);
			GpioOutput_graylevel_axis_Write(XPAR_VIDEO_PATH_CAMERA_IN_CDR_VIDEO_IN_AXI4_RDY_CDR_REGISTERS_AXI_GPIO_OTOTAL_CALC_LSW_GRAYLEVEL_AXIS_WRITE_DEVICE_ID, axis_right_top, axis_left_dwon );
		}
		else if((buffer[0] == 'g')&&(buffer[1] == 'r')&&(buffer[2] == 'a')&&(buffer[3] == 'y')&&(buffer[4] == 't'))//JACKY2020 grayr
		{
			int axis_right_top, axis_left_dwon;
			//xil_printf("\n\rCENTER = %08x; LSW = %d %%, W = 0x%04x = %d, H = 0x%04x = %d\n\r", CENTER, LSW, (((LSW*320)/100)), (((LSW*320)/100)), ((LSW*240)/100), ((LSW*240)/100));
			axis_right_top=CENTER-(((LSW*320)/100)<<16)-((LSW*240)/100);
			axis_left_dwon=CENTER+(((LSW*320)/100-1)<<16)+(((LSW*240)/100)-1);
			xil_printf("\n\rL area((%d, %d)-(%d, %d), C(%d, %d), %d X %d)\n\r", (axis_right_top>>16)&0xffff, axis_right_top&0xffff, (axis_left_dwon>>16)&0xffff, axis_left_dwon&0xffff, (CENTER>>16)&0xffff, CENTER&0xffff, LSW * 320 / 100 * 2, LSW * 240 / 100 * 2);

			//xil_printf("\n\rCENTER = %08x; SSW = %d %%, W = 0x%04x = %d, H = 0x%04x = %d\n\r", CENTER, SSW, (((SSW*320)/100)), (((SSW*320)/100)), ((SSW*240)/100), ((SSW*240)/100));
			axis_right_top=CENTER-(((SSW*320)/100)<<16)-((SSW*240)/100);
			axis_left_dwon=CENTER+(((SSW*320)/100-1)<<16)+(((SSW*240)/100)-1);
			xil_printf("S area((%d, %d)-(%d, %d), C(%d, %d), %d X %d)\n\r", (axis_right_top>>16)&0xffff, axis_right_top&0xffff, (axis_left_dwon>>16)&0xffff, axis_left_dwon&0xffff, (CENTER>>16)&0xffff, CENTER&0xffff, SSW * 320 / 100 * 2, SSW * 240 / 100 * 2);

			gray_monitor((((LSW*320)/100))*2, ((LSW*240)/100)*2, (((SSW*320)/100))*2, ((SSW*240)/100)*2);
		}
		else if((buffer[0] == 's')&&(buffer[1] == 't')&&(buffer[2] == 'a')&&(buffer[3] == 'r')&&(buffer[4] == 't'))
		{
			xil_printf("\n\rVideo Mixer Start\n\r");
			XVMix_LayerEnable(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_MASTER);
			XVMix_InterruptDisable(periphs_inst.p_vid_output_mixer_l2_inst); // use auto reload mode
			XVMix_Start(periphs_inst.p_vid_output_mixer_l2_inst);
		}
		else if((buffer[0] == 'b')&&(buffer[1] == 'r')&&(buffer[2] == 'e')&&(buffer[3] == 'a')&&(buffer[4] == 'k'))
		{
			#ifdef TEMPERATURE_DEBUG
				xil_printf("\n\r\n\rbreak temperature debug...\n\r");
				temperature_array_index = DEBUG_LENGTH + 1;
			#endif
		}
		else if((buffer[0] == 'l')&&(buffer[1] == 'a')&&(buffer[2] == 'y')&&(buffer[3] == 'e')&&(buffer[4] == 'r'))
		{
			gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(next_framebuffer));
			draw_layer_boundary();
			gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(1 - next_framebuffer));
			draw_layer_boundary();
		}
		else if((buffer[0] == 'u')&&(buffer[1] == 'g')&&(buffer[2] == 'f')&&(buffer[3] == 'x'))
		{
			if(buffer[4]  == '0')
			{
				xil_printf("\n\rufgx 0\n\r");

				uint32_t addr;
				addr = gdispGetFrameBufferAddr(0);
				xil_printf("frame buffer 0 addr = 0x%08x\n\r", addr);
				gdispSetuGFXFrameBufferAddr(addr);
				xil_printf("\n\rufgx 0 ok\n\r");
			}
			else if(buffer[4]  == '1')
			{
				xil_printf("\n\rufgx 1\n\r");

				uint32_t addr;
				addr = gdispGetFrameBufferAddr(1);
				xil_printf("frame buffer 1 addr = 0x%08x\n\r", addr);

				gdispSetuGFXFrameBufferAddr(addr);
				xil_printf("\n\rufgx 1 ok\n\r");
			}
			else
			{
				xil_printf("\n\rufgx unknown\n\r");
			}
		}
		else if((buffer[0] == 'r')&&(buffer[1] == 'c')&&(buffer[2] == 'f')&&(buffer[3] == ' '))
		{
			if((buffer[4] >= 'A') && (buffer[4] <= 'F'))
			{
				reg |= (buffer[4] - 'A' + 10);
				//xil_printf("%c %x", buffer[i], reg);
			}
			else if((buffer[4] >= 'a') && (buffer[4] <= 'f'))
			{
				reg |= (buffer[4] - 'a' + 10);
				//xil_printf("%c %x", buffer[i], reg);
			}
			else if((buffer[4] >= '0') && (buffer[4] <= '9'))
			{
				reg |= (buffer[4] - '0');
				//xil_printf("%c %x", buffer[i], reg);
			}
			else
			{
				xil_printf("\n\rRead Camera Fpga, illegal parameters %c, abort\n\r", buffer[4]);
				return;
			}
			//xil_printf("\n\rRead Camera Fpga, illegal parameters %c, abort\n\r", buffer[4]);
			read_camera_fpga(reg);
		}
		else if((buffer[0] == 'r')&&(buffer[1] == 'r')&&(buffer[2] == ' '))
		{
			int page;
			if((buffer[3] < 0x30) || (buffer[3] > 0x39) || (buffer[4] < 0x30) || (buffer[4] > 0x39))
			{
				xil_printf("\n\rIllegal parameters.\n\r");
				return;
			}
			page = (buffer[3] - 0x30) * 10 + (buffer[4] - 0x30);
			if((page > 31) || (page < 0))
			{
				xil_printf("\n\rIllegal parameters, page = %d\n\r", page);
				return;
			}
			xil_printf("\n\rXIicPs_ReadEepromPage, page = %d\n\r", page);
			XIicPs_ReadEepromPage(page, eeprom_page_buffer);
			XIicPs_PrintPageDataRaw(page, eeprom_page_buffer);
		}
		else
		{
			show_command_not_found();
		}
	}
	else if(length == 5)
	{
		if((buffer[0] == 'e')&&(buffer[1] == ' '))
		{
			int page;
			if((buffer[2] < 0x30) || (buffer[2] > 0x39) || (buffer[3] < 0x30) || (buffer[3] > 0x39))
			{
				xil_printf("\n\rIllegal parameters.\n\r");
				return;
			}
			page = (buffer[2] - 0x30) * 10 + (buffer[3] - 0x30);
			if((page > 31) || (page < 0))
			{
				xil_printf("\n\rIllegal parameters, page = %d\n\r", page);
				return;
			}
			XIicPs_EraseEepromPage(page);
		}
		else if((buffer[0] == 'r')&&(buffer[1] == ' ')&&(buffer[2] == 'c')&&(buffer[3] == 'f'))	//r cf
		{
			xil_printf("\n\rRead Camera FPGA registers\n\r");
			unsigned char DongleData = 0;
			reg = 0x08;DongleData = camera_fpga_read_data(reg);xil_printf("CFGCR\t\taddr : 0x%02x, read value : 0x%02x\n\r",reg, DongleData);
			reg = 0x09;DongleData = camera_fpga_read_data(reg);xil_printf("CFGTXDR\t\taddr : 0x%02x, read value : 0x%02x\n\r",reg, DongleData);
			reg = 0x0A;DongleData = camera_fpga_read_data(reg);xil_printf("CFGSR\t\taddr : 0x%02x, read value : 0x%02x\n\r",reg, DongleData);
			reg = 0x0B;DongleData = camera_fpga_read_data(reg);xil_printf("CFGRXDR\t\taddr : 0x%02x, read value : 0x%02x\n\r",reg, DongleData);
			reg = 0x0C;DongleData = camera_fpga_read_data(reg);xil_printf("CFGIRQ\t\taddr : 0x%02x, read value : 0x%02x\n\r",reg, DongleData);
			reg = 0x0D;DongleData = camera_fpga_read_data(reg);xil_printf("CFGIRQEN\taddr : 0x%02x, read value : 0x%02x\n\r",reg, DongleData);
		}
		else if((buffer[0] == 'r')&&(buffer[1] == ' ')&&(buffer[2] == 'c')&&(buffer[3] == 's'))
		{
			xil_printf("\n\rRead Camera Sensor registers\n\r");
			unsigned char DongleData;
			unsigned int DongleAddr;

			DongleAddr = 0x0100;
			DongleData = dongle_read_data(DongleAddr);
			xil_printf("addr = 0x%04x, data = 0x%02x\t", DongleAddr, DongleData);
			if(DongleData == 0)
				xil_printf("Sleep\n\r");
			else if(DongleData == 1)
				xil_printf("Streaming\n\r");
			else
				xil_printf("impossible data = 0x%02x\n\r", DongleData);
			DongleAddr = 0x300a;
			DongleData = dongle_read_data(DongleAddr);
			xil_printf("addr = 0x%04x, data = 0x%02x\tCHIP ID H\n\r", DongleAddr, DongleData);
			DongleAddr = 0x300b;
			DongleData = dongle_read_data(DongleAddr);
			xil_printf("addr = 0x%04x, data = 0x%02x\tCHIP ID L\n\r", DongleAddr, DongleData);
			DongleAddr = 0x302a;
			DongleData = dongle_read_data(DongleAddr);
			xil_printf("addr = 0x%04x, data = 0x%02x\tCHIP REVISION\n\r", DongleAddr, DongleData);
			DongleAddr = 0x3820;
			DongleData = dongle_read_data(DongleAddr);
			xil_printf("addr = 0x%04x, data = 0x%02x\tIMAGE ORIENTATION\n\r", DongleAddr, DongleData);
			DongleAddr = 0x4A00;
			DongleData = dongle_read_data(DongleAddr);
			xil_printf("addr = 0x%04x, data = 0x%02x\tFRAME COUNT\n\r", DongleAddr, DongleData);
		}
		else if((buffer[0] == 'r')&&(buffer[1] == ' '))
		{
			int page;
			if((buffer[2] < 0x30) || (buffer[2] > 0x39) || (buffer[3] < 0x30) || (buffer[3] > 0x39))
			{
				xil_printf("\n\rIllegal parameters.\n\r");
				return;
			}
			page = (buffer[2] - 0x30) * 10 + (buffer[3] - 0x30);
			if((page > 31) || (page < 0))
			{
				xil_printf("\n\rIllegal parameters, page = %d\n\r", page);
				return;
			}
			xil_printf("\n\rXIicPs_ReadEepromPage, page = %d\n\r", page);
			XIicPs_ReadEepromPage(page, eeprom_page_buffer);
			XIicPs_PrintPageData(page, eeprom_page_buffer);
		}
		else if((buffer[0] == 'w')&&(buffer[1] == ' '))
		{
			int page;
			if((buffer[2] < 0x30) || (buffer[2] > 0x39) || (buffer[3] < 0x30) || (buffer[3] > 0x39))
			{
				xil_printf("\n\rIllegal parameters.\n\r");
				return;
			}
			page = (buffer[2] - 0x30) * 10 + (buffer[3] - 0x30);
			if((page > 31) || (page < 0))
			{
				xil_printf("\n\rIllegal parameters, page = %d\n\r", page);
				return;
			}
			XIicPs_WriteEepromPage(page);
		}
		else if((buffer[0] == 'h')&&(buffer[1] == 'e')&&(buffer[2] == 'l')&&(buffer[3] == 'p'))
		{
			show_help_menu();
		}
		else if((buffer[0] == 'u')&&(buffer[1] == 's')&&(buffer[2] == 'b')&&(buffer[3] == 'r'))
		{
			xil_printf("\n\rPlease use 'usbr1' or 'usbr2'\n\r");
		}
		else if((buffer[0] == 'd')&&(buffer[1] == 'a')&&(buffer[2] == 't')&&(buffer[3] == 'e'))
		{
			xil_printf("\n\r%s", asctime(&rtc));
			char now[30];
	        strftime(now, 30, "%m/%d/%Y %a", &rtc);
	        xil_printf("\r%s\n\r", now);
	        strftime(now, 30, "%H:%M:%S", &rtc);
	        xil_printf("%s\n\r", now);
		}
		else if((buffer[0] == 'l')&&(buffer[1] == 'i')&&(buffer[2] == 'n')&&(buffer[3] == 'e'))
		{
			xil_printf("\n\rline\n\r");
			coord_t width;
			coord_t height;
			// Get the screen size
			width = gdispGetWidth();
			height = gdispGetHeight();

			gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(next_framebuffer));
			for(i = 0; i < width; i += 100)
			{
				gdispDrawLine(i, 0, i, height, Gray);
			}
			for(i = 0; i < height; i += 100)
			{
				gdispDrawLine(0, i, width, i, Gray);
			}
			draw_layer_boundary();

			gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(1 - next_framebuffer));
			for(i = 0; i < width; i += 100)
			{
				gdispDrawLine(i, 0, i, height, Gray);
			}
			for(i = 0; i < height; i += 100)
			{
				gdispDrawLine(0, i, width, i, Gray);
			}
			draw_layer_boundary();
		}
		else if((buffer[0] == 's')&&(buffer[1] == 't')&&(buffer[2] == 'o')&&(buffer[3] == 'p'))
		{
			xil_printf("\n\rVideo Mixer Stop\n\r");
			XVMix_Stop(periphs_inst.p_vid_output_mixer_l2_inst);
		}
		else if((buffer[0] == 'c')&&(buffer[1] == 'a')&&(buffer[2] == 'r')&&(buffer[3] == 's'))
		{
			xil_printf("\n\rcamera read serial\n\r");
			read_serial_from_camera();

			/*
			xil_printf("\n\rENABLE_CONFIGURE\n\r");
			ENABLE_CONFIGURE(1);
			xil_printf("\n\rSET_ADDRESS\n\r");
			SET_ADDRESS(SN_PAGE2);
			usleep(100000);
			xil_printf("\n\rREAD_1PAGE\n\r");
			READ_1PAGE();
			xil_printf("\n\rDISABLE_CONFIGURE\n\r");
			ENABLE_CONFIGURE(0);
			*/
			/*
			xil_printf("Page Data:\t");
			for(i = 0;i<16;i++)
			{
				xil_printf("%02x ", page_data[i]);
			}
			xil_printf("\n\r");
			*/

			show_camera_serial(1);
			if(flag_use_2_framebuffers == TRUE)
			{
				gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(next_framebuffer));
				show_camera_serial(1);
				gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(1 - next_framebuffer));
			}
		}
		else if((buffer[0] == 'c')&&(buffer[1] == 'a')&&(buffer[2] == 'w')&&(buffer[3] == 's'))
		{
			xil_printf("\n\rcamera write serial\n\r");
			write_serial_to_camera();
			xil_printf("\n\rcamera write serial OK\n\r");
		}
		else if((buffer[0] == 'c')&&(buffer[1] == 'a')&&(buffer[2] == 'r')&&(buffer[3] == 'd'))
		{
#ifdef USE_PREVENT_REUSE
			xil_printf("\n\rcamera read date\n\r");
			flag_camera_status = get_camera_status();
			show_camera_date(1);
			if(flag_use_2_framebuffers == TRUE)
			{
				gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(next_framebuffer));
				show_camera_date(1);
				gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(1 - next_framebuffer));
				show_camera_date(1);
			}
#endif
		}
		else if((buffer[0] == 'c')&&(buffer[1] == 'a')&&(buffer[2] == 'w')&&(buffer[3] == 'd'))
		{
			xil_printf("\n\rcamera write date\n\r");
			write_date_to_camera(DATE_PAGE1);
			xil_printf("\n\rcamera write date OK\n\r");
		}
		else if((buffer[0] == 'c')&&(buffer[1] == 'a')&&(buffer[2] == 'e')&&((buffer[3] == 'e') || (buffer[3] == 'r')))
		{
			uint32_t g_ms_tick_tmp;
			xil_printf("tick(%d) = %d;\t%%%s:%s(%d) camera erase and write serial ST\r\n", tick_cnt++, g_ms_tick, __FILE__, __func__, __LINE__);
			g_ms_tick_tmp = g_ms_tick;

			xil_printf("\n\rcamera erase data\n\r");
			xil_printf("\n\rENABLE_CONFIGURE\n\r");
			ENABLE_CONFIGURE(1);
			xil_printf("\n\rSET_ADDRESS\n\r");
			SET_ADDRESS(SN_PAGE2);
			xil_printf("\n\rERASE_UFM\n\r");
			ERASE_UFM();
			xil_printf("\n\rDISABLE_CONFIGURE\n\r");
			ENABLE_CONFIGURE(0);

			//sleep(1);	//must > 1
			usleep(200000);

			xil_printf("\n\rcamera write serial\n\r");
			write_serial_to_camera();
			xil_printf("\n\rcamera write serial OK\n\r");

		    xil_printf("tick(%d) = %d;\t%%%s:%s(%d) camera erase and write serial SP, spend %d msec\r\n", tick_cnt++, g_ms_tick, __FILE__, __func__, __LINE__, (g_ms_tick - g_ms_tick_tmp) * 1);
		}
		else if((buffer[0] == 'c')&&(buffer[1] == 'a')&&(buffer[2] == 'r')&&(buffer[3] == 'e'))
		{
			xil_printf("\n\rcamera erase data\n\r");
			xil_printf("\n\rENABLE_CONFIGURE\n\r");
			ENABLE_CONFIGURE(1);
			xil_printf("\n\rSET_ADDRESS\n\r");
			SET_ADDRESS(SN_PAGE2);
			xil_printf("\n\rERASE_UFM\n\r");
			ERASE_UFM();
			xil_printf("\n\rDISABLE_CONFIGURE\n\r");
			ENABLE_CONFIGURE(0);
		}
		else if((buffer[0] == 'i')&&(buffer[1] == 'n')&&(buffer[2] == 'f')&&(buffer[3] == 'o'))
		{
#ifdef USE_PREVENT_REUSE
			xil_printf("flag_camera_status = %d\t", flag_camera_status);
			switch(flag_camera_status)
			{
			case CAMERA_NEW:	xil_printf("CAMERA_NEW\r\n");break;
			case CAMERA_1M:		xil_printf("CAMERA_1M\r\n");break;
			case CAMERA_2HR:	xil_printf("CAMERA_2HR\r\n");break;
			default:			xil_printf("xxxxxxx\r\n");break;
			}
#endif
		}
		else
		{
			show_command_not_found();
		}
	}
	else if(length == 4)
	{
		if((buffer[0] == 'e')&&(buffer[1] == ' '))
		{
			int page;
			if((buffer[2] < 0x30) || (buffer[2] > 0x39))
			{
				xil_printf("\n\rIllegal parameters.\n\r");
				return;
			}
			page = buffer[2] - 0x30;
			if((page > 31) || (page < 0))
			{
				xil_printf("\n\rIllegal parameters, page = %d\n\r", page);
				return;
			}
			XIicPs_EraseEepromPage(page);
		}
		else if((buffer[0] == 'r')&&(buffer[1] == ' '))
		{
			int page;
			if((buffer[2] < 0x30) || (buffer[2] > 0x39))
			{
				xil_printf("\n\rIllegal parameters.\n\r");
				return;
			}
			page = buffer[2] - 0x30;
			if((page > 31) || (page < 0))
			{
				xil_printf("\n\rIllegal parameters, page = %d\n\r", page);
				return;
			}
			xil_printf("\n\rXIicPs_ReadEepromPage, page = %d\n\r", page);
			XIicPs_ReadEepromPage(page, eeprom_page_buffer);
			XIicPs_PrintPageData(page, eeprom_page_buffer);
		}
		else if((buffer[0] == 'w')&&(buffer[1] == ' '))
		{
			int page;
			if((buffer[2] < 0x30) || (buffer[2] > 0x39))
			{
				xil_printf("\n\rIllegal parameters.\n\r");
				return;
			}
			page = buffer[2] - 0x30;
			if((page > 31) || (page < 0))
			{
				xil_printf("\n\rIllegal parameters, page = %d\n\r", page);
				return;
			}
			XIicPs_WriteEepromPage(page);
		}
		else if((buffer[0] == 'r')&&(buffer[1] == 't')&&(buffer[2] == 'c'))
		{
			read_RTC_data();
		}
		else if((buffer[0] == 'u')&&(buffer[1] == 's')&&(buffer[2] == 'b'))
		{
			read_usb_registers();
		}
		else if((buffer[0] == 'e')&&(buffer[1] == 'n')&&(buffer[2] == 'g'))
		{
			flag_engineering_mode = TRUE;
			flag_check_engineering_mode = 0;
			show_engineering_mode();
		}
		else if((buffer[0] == 'd')&&(buffer[1] == 'o')&&(buffer[2] == 't'))
		{
			xil_printf("\n\rdot\n\r");
			//int x,y;
			coord_t width;
			coord_t height;
			// Get the screen size
			width = gdispGetWidth();
			height = gdispGetHeight();

			/*
			gdispDrawPixel(0, 0, White);

			//gdispDrawPixel(1, 0, White);
			//gdispDrawPixel(2, 0, White);
			//gdispDrawPixel(3, 0, White);

			gdispDrawPixel(0, 1, Red);
			gdispDrawPixel(0, 2, Green);
			gdispDrawPixel(0, 3, Blue);


			for(j = 0;j<200;j++)
			{
				for(i = 0;i<400 ;i++)
				{
					gdispDrawPixel(width / 2 - i, height / 2+ j, Blue);
				}
			}


			gdispDrawPixel(width / 3, height / 2, Red);

			gdispDrawPixel(width / 3, height / 2 + 100, Green);

			gdispDrawPixel(width / 3, height / 2 + 200, Blue);

			gdispDrawPixel(width / 3 + 1, height / 2 + 300, White);
			gdispDrawPixel(width / 3 + 2, height / 2 + 300, White);
			gdispDrawPixel(width / 3 + 3, height / 2 + 300, White);

			gdispDrawPixel(width -1, height - 1, White);

			*/

			for (coord_t x = 0; x < width; x += 20)
			{
				for (coord_t y = 0; y < height; y += 20)
				{
					gdispDrawPixel(x, y, Gray);
				}
			}
		}
		else if((buffer[0] == 't')&&(buffer[1] == 'i')&&(buffer[2] == 'c'))
		{
			g_ms_tick = 0;
		}
		else if((buffer[0] == 't')&&(buffer[1] == 'o')&&(buffer[2] == 'c'))
		{
			uint32_t tt = g_ms_tick;
			uint32_t hh;
			uint32_t mm;
			uint32_t ss;
			uint32_t dd;

			dd = tt % 1000 * 1;
			ss = (tt / 1000) % 60;
			mm = ((tt / 1000) / 60) % 60;
			hh = ((tt / 1000) / 60) / 60;

			xil_printf("\n\rElasped time is %02d:%02d:%02d.%03d\n\r", hh, mm, ss, dd);
		}
		else if((buffer[0] == 'c')&&(buffer[1] == 'a')&&(buffer[2] == '1'))
		{
			xil_printf("\n\rcamera test 1, toggle camera setup\n\r");
			unsigned char DongleData;
			unsigned int DongleAddr;

			DongleAddr = 0x3820;
			DongleData = dongle_read_data(DongleAddr);
			xil_printf("addr = 0x%x, data = 0x%x ORIENTATION\n\r", DongleAddr, DongleData);

			cnt++;
			cnt %= 4;

			DongleData = 0x10 | (cnt << 2);
			xil_printf("DongleData to write = 0x%x\n\r", DongleData);

			dongle_write_data(DongleAddr, DongleData);

			usleep(200000);

			DongleAddr = 0x3820;
			DongleData = dongle_read_data(DongleAddr);
			xil_printf("addr = 0x%x, data = 0x%x ORIENTATION\n\r", DongleAddr, DongleData);
		}
		else if((buffer[0] == 'c')&&(buffer[1] == 'a')&&(buffer[2] == '2'))
		{
			xil_printf("\n\rcamera test 2, test pattern setup\n\r");
			unsigned char DongleData;
			unsigned int DongleAddr;
			DongleAddr = 0x5080;
			DongleData = dongle_read_data(DongleAddr);
			xil_printf("addr = 0x%x, data = 0x%x test pattern registers\n\r", DongleAddr, DongleData);
			usleep(2000);
			cnt %= 5;
			if(cnt == 0)
				DongleData = (1<<7) | (0 << 2);
			else if(cnt == 1)
				DongleData = (1<<7) | (1 << 2);
			else if(cnt == 2)
				DongleData = (1<<7) | (2 << 2);
			else if(cnt == 3)
				DongleData = (1<<7) | (3 << 2);
			else if(cnt == 4)
				DongleData = 0;
			else
			{
				xil_printf("impossible\n\r");
			}
			cnt++;
			dongle_write_data(DongleAddr, DongleData);
			xil_printf("cnt = %d write data = 0x%x\n\r", cnt, DongleData);
		}
		else if((buffer[0] == 'c')&&(buffer[1] == 'a')&&(buffer[2] == '3'))
		{
			unsigned char addr;

			cnt += 17;
			cnt %= 255;

			addr = 0x02;

			xil_printf("\n\rwrite camera fpga addr = 0x%02x data = 0x%02x\n\r", addr, cnt);
			camera_fpga_write_data(addr, cnt);
		}
		else if((buffer[0] == 'c')&&(buffer[1] == 'a')&&(buffer[2] == '4'))
		{
			unsigned char addr;
			unsigned char DongleData;
			addr = 0x02;
			xil_printf("\n\r");
			DongleData = camera_fpga_read_data(addr);
			xil_printf("read camera fpga addr = 0x%02x, data = 0x%02x\n\r", addr, DongleData);
		}
		else if((buffer[0] == 0x99)&&(buffer[1] == 0x00)&&(buffer[2] == 0x00))
		{
			char str[50];
			sprintf(str, "ffff cmd ok %02x %02x %02x %02x %02x   get op mode\n\r", gui_cmd[0], gui_cmd[1], gui_cmd[2], gui_cmd[3], gui_cmd[4]);
			debug_console_print(str);
			xil_printf("\n\rRead OP mode.\r\n");

			if(flag_operation_mode == MODE_PUTTY)
			{
				Send_IMS_Data_Cmd(0xFF, g_conn_status, 0x00);
				usleep(500000);
				Send_IMS_Data_Cmd(0x99, 0x00, 0x00);
				usleep(500000);
			}
			else	//MODE_IMS_LINK
			{
				usleep(500000);
				Send_IMS_Data_Cmd(0x99, 0x11, 0x11);
				usleep(500000);
			}
		}
		else if((buffer[0] == 'e')&&(buffer[1] == 's')&&(buffer[2] == 'c'))
		{
			flag_engineering_mode = FALSE;
			clear_engineering_mode();
		}
		else if((buffer[0] == 'r')&&(buffer[1] == 'r')&&(buffer[2] == 'r'))
		{
			xil_printf("\n\rsetup a fake rtc time 01/15/Mon Wed 12:34:56\n\r");

			u8 type;
			int data;
			int year;
			year = 2020;
			XIicPs_SetRTCData(&Iic, RTC_YEAR, (u8)(year - 2000));

			type = RTC_MON;
			data = 1;
			XIicPs_SetRTCData(&Iic, type, data);

			type = RTC_MD;
			data = 15;
			XIicPs_SetRTCData(&Iic, type, data);

			type = RTC_HH;
			data = 12;
			XIicPs_SetRTCData(&Iic, type, data);

			type = RTC_MM;
			data = 34;
			XIicPs_SetRTCData(&Iic, type, data);

			type = RTC_SS;
			data = 56;
			XIicPs_SetRTCData(&Iic, type, data);

			type = RTC_WD;
			data = 3;
			XIicPs_SetRTCData(&Iic, type, data);
		}
		else if((buffer[0] == 'e')&&(buffer[1] == 'e')&&(buffer[2] == 'e'))
		{
		}
		else if((buffer[0] == 'd')&&(buffer[1] == 'm')&&(buffer[2] == 'a'))
		{
			xil_printf("\n\rDMA test ST\n\r");

			/* Initialize source */
			for (i = 0; i < DMA_LENGTH; i++)
				DMA_src[i] = (u32)(DMA_LENGTH - i);

			/* Clear destination */
			for (i = 0; i < DMA_LENGTH; i++)
				DMA_dst[i] = (u32)0;

			status = dma_copy((u32)DMA_src, (u32)DMA_dst, DMA_LENGTH);

			if (status != XST_SUCCESS)
			{
				xil_printf("\n\rXDmaPs_Test fail\r\n");
			}
			else
			{
				xil_printf("\n\rXDmaPs_Test OK\r\n");
			}
		}
		else if((buffer[0] == 'r')&&(buffer[1] == 'e')&&(buffer[2] == 'd'))
		{
			xil_printf("\n\rdma copy from RED to framebuffer 0\n\r");
			void* addr;
			uint32_t *f_ptr;
			int length;
			length = 2048 * 30;

			addr = gfxAlloc(length);	//DMA_LENGTH = 8192 * 30

			f_ptr = addr;
			for(i = 0; i< length; i++)
			{
				f_ptr[i] = 0xff0000ff;		//red
			}

			uint32_t addr0;
			uint32_t addr1;
			addr0 = (uint32_t)addr;
			addr1 = gdispGetFrameBufferAddr(0);

			int total_round = 1200 / 30 / 2;
			volatile uint32_t g_ms_tick_tmp;
			g_ms_tick_tmp = g_ms_tick;

			for(i = 0; i < total_round; i++)
			{
				dma_copy((u32) addr0, (u32) addr1 + length * 4 * i, length/2);
				//xil_printf("i = %02d as0 = 0x%08x ad = 0x%08x len = %d\n\r", i, (u32) addr0, (u32) addr1 + length * 4 * i, length);
			}
			xil_printf("dma copy ok, time = %d\n\r", g_ms_tick - g_ms_tick_tmp);
		}
		else if((buffer[0] == 'p')&&(buffer[1] == '1')&&(buffer[2] == 'c'))
		{
			print_surface_1c_data();
		}
		else if((buffer[0] == 'a')&&(buffer[1] == 'd')&&(buffer[2] == 'c'))
		{
			#ifdef TEMPERATURE_DEBUG
			xil_printf("\n\rTEMPERATURE_DEBUG restart....\n\r");
			temperature_array_index = 0;
			#else
			xil_printf("\n\rdo nothing\n\r");
			#endif
		}
		else if((buffer[0] == 'e')&&(buffer[1] == 'n')&&(buffer[2] == 'v'))
		{
			show_environment_parameters();
		}
		else
		{
			show_command_not_found();
		}
	}
	else if(length == 3)
	{
		if((((buffer[0] == 'l')&&(buffer[1] == 's')))||((buffer[0] == 'l')&&(buffer[1] == 'l')))
		{
			xil_printf("\n\r");
			xil_printf("Type `help' to see help list.\n\r");
		}
		else if((buffer[0] == 'r')&&(buffer[1] == 'r'))
		{
			xil_printf("\n\rusb HW reset\n\r");
			reset_usb();
		}
		else if((buffer[0] == 'd')&&(buffer[1] == 'e'))
		{
			xil_printf("Xil_DCacheEnable()\n\r");
			Xil_DCacheEnable();
		}
		else if((buffer[0] == 'd')&&(buffer[1] == 'd'))
		{
			xil_printf("Xil_DCacheDisable()\n\r");
			Xil_DCacheDisable();
		}
		else if((buffer[0] == 'd')&&(buffer[1] == 'f'))
		{
			xil_printf("Xil_DCacheFlush()\n\r");
			Xil_DCacheFlush();
		}
		else if(((buffer[0] == 'L')||(buffer[0] == 'l'))&&(buffer[1] == '0'))
		{
			xil_printf("Enabling/bypassing Layer 0.\n\r");
			status = XVMix_IsLayerEnabled(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_MASTER);
			if(status) { // Enabled
				XVMix_LayerDisable(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_MASTER);
			} else {
				XVMix_LayerEnable(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_MASTER);
			}
		}
		else if(((buffer[0] == 'L')||(buffer[0] == 'l'))&&(buffer[1] == '1'))
		{
			xil_printf("Enabling/bypassing Layer 1.\n\r");
			status = XVMix_IsLayerEnabled(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_1);
			if(status) { // Enabled
				XVMix_LayerDisable(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_1);
			} else {
				XVMix_LayerEnable(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_1);
			}
		}
		else if(((buffer[0] == 'L')||(buffer[0] == 'l'))&&(buffer[1] == '2'))
		{
			xil_printf("Enabling/bypassing Layer 2.\n\r");
			status = XVMix_IsLayerEnabled(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_2);
			if(status) { // Enabled
				XVMix_LayerDisable(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_2);
			} else {
				XVMix_LayerEnable(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_2);
			}
		}
		else if(((buffer[0] == 'L')||(buffer[0] == 'l'))&&(buffer[1] == '3'))
		{
			xil_printf("Enabling/bypassing Layer 3.\n\r");
			status = XVMix_IsLayerEnabled(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_3);
			if(status) { // Enabled
				XVMix_LayerDisable(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_3);
			} else {
				XVMix_LayerEnable(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_3);
			}
		}
		else if((buffer[0] == 'u')&&(buffer[1] == '0'))
		{
			xil_printf("USB Hub Power Down\n\r");
			reg = ULPI_OTG_CTRL;
			val = 0;
			val = ulpi_ReadReg(reg);
			xil_printf("read value : %02X\n\r", val);

			sleep(1);

			val &= 0xDF;
			xil_printf("set value : %02X\n\r", val);
			ulpi_WriteReg(val, reg);

			sleep(1);

			val = 0;
			val = ulpi_ReadReg(reg);
			xil_printf("read value : %02X\n\r", val);
		}
		else if((buffer[0] == 'u')&&(buffer[1] == '1'))
		{
			xil_printf("USB Hub Power Up\n\r");
			reg = ULPI_OTG_CTRL;
			val = 0;
			val = ulpi_ReadReg(reg);
			xil_printf("read value : %02X\n\r", val);

			sleep(1);

			val |= 0x20;
			xil_printf("set value : %02X\n\r", val);
			ulpi_WriteReg(val, reg);

			sleep(1);

			val = 0;
			val = ulpi_ReadReg(reg);
			xil_printf("read value : %02X\n\r", val);
		}
		else if((buffer[0] == 'p')&&(buffer[1] == '0'))
		{
			print_layer0_data(0);
		}
		else if((buffer[0] == 'p')&&(buffer[1] == '1'))
		{
			print_surface_1_data();
		}
		else if((buffer[0] == 't')&&(buffer[1] == '1'))
		{
			set_time();
		}
		else if((buffer[0] == 't')&&(buffer[1] == '2'))
		{
			get_time();
		}
		else if((buffer[0] == 'm')&&(buffer[1] == 'm'))
		{
			volatile uint32_t g_ms_tick_tmp;
			uint32_t addr0;
			uint32_t addr1;
			addr0 = gdispGetFrameBufferAddr(0);
			addr1 = gdispGetFrameBufferAddr(1);
			xil_printf("\n\rmemory copy from framebuffer 0 to framebuffer 1, size = W X H = 8192 X 1200\n\r");
			g_ms_tick_tmp = g_ms_tick;
			//for(i = 0; i< (1920 * 1080 * 4 / 2); i++)	//copy half screen
			for(i = 0; i< (1920 * 1080 * 4); i++)	//copy one screen
			{
				Xil_Out32(addr1 + i, (Xil_In32(addr0 + i)));
			}
			xil_printf("memory copy ok, time = %d\n\r", g_ms_tick - g_ms_tick_tmp);
		}
		else if((buffer[0] == 'b')&&(buffer[1] == 'b'))
		{
			xil_printf("\n\rdma copy from framebuffer 0 to framebuffer 1\n\r");
			int length;
			length = 2048 * 30;
			uint32_t addr0;
			uint32_t addr1;
			addr0 = gdispGetFrameBufferAddr(0);
			addr1 = gdispGetFrameBufferAddr(1);

			int total_round = 1200 / 30 / 2;
			volatile uint32_t g_ms_tick_tmp;
			g_ms_tick_tmp = g_ms_tick;

			for(i = 0; i < total_round; i++)
			{
				dma_copy((u32) addr0 + length * 4 * i, (u32) addr1 + length * 4 * i, length / 2);
				//xil_printf("i = %02d as0 = 0x%08x ad = 0x%08x len = %d\n\r", i, (u32) addr0 + length * 4 * i, (u32) addr1 + length * 4 * i, length);
			}
			xil_printf("dma copy ok, time = %d\n\r", g_ms_tick - g_ms_tick_tmp);
		}
		else if((buffer[0] == 'b')&&(buffer[1] == '0'))
		{
			switch_to_framebuffer(FRAMEBUFFER0);
		}
		else if((buffer[0] == 'b')&&(buffer[1] == '1'))
		{
			switch_to_framebuffer(FRAMEBUFFER1);
		}
		else if((buffer[0] == 'b')&&(buffer[1] == 'a'))
		{
			xil_printf("\n\rshow framebuffer addresses\n\r\n\r");
			uint32_t addr;
			addr = gdispGetFrameBufferAddr(0);
			xil_printf("frame buffer 0 addr = 0x%08x\n\r", addr);
			addr = gdispGetFrameBufferAddr(1);
			xil_printf("frame buffer 1 addr = 0x%08x\n\r", addr);
		}
		else if((buffer[0] == 'f')&&(buffer[1] == 'b'))
		{
			if(flag_use_2_framebuffers == FALSE)
			{
				flag_use_2_framebuffers = TRUE;
				xil_printf("\n\rflag_use_2_framebuffers = TRUE\n\r");
			}
			else
			{
				flag_use_2_framebuffers = FALSE;
				xil_printf("\n\rflag_use_2_framebuffers = FALSE\n\r");
			}
		}
		else if((buffer[0] == 'd')&&(buffer[1] == 'c'))
		{
#ifdef USE_DEBUG_CONSOLE
			if(flag_enable_debug_console == TRUE)
			{
				xil_printf("Disable debug console\n\r");
				flag_enable_debug_console = FALSE;
				debug_console_close();
				// Blit surface_2 to the real display at the new position
				gdispBlitArea(BORDER_X, LAYER0_HEIGHT - LAYER2_HEIGHT - BORDER_Y, LAYER2_WIDTH, LAYER2_HEIGHT, surface_2);
			}
			else
			{
				xil_printf("Enable debug console\n\r");
				flag_enable_debug_console = TRUE;
				debug_console_init();
			}
#endif
		}
		else if((buffer[0] == 'c')&&(buffer[1] == 'b'))
		{
			dongle_write_data(0x5080, 0x81);
		}
		else if((buffer[0] == 'c')&&(buffer[1] == 'c'))
		{
			xil_printf("check dongle status old\t");
			g_conn_status = psuart0_dongle_ping_old();
			if(g_conn_status == DONGLE_NONE){			// Nothing is plugged in
				xil_printf("no dongle or camera\n\r");
			}
			else if(g_conn_status == CAMERA_NONE){		// Only dongle is plugged in
				xil_printf("dongle plugged\n\r");
			}
			else if(g_conn_status == CAMERA_OK){		// Everything is plugged in
				xil_printf("all plugged\n\r");
			}
			else {										// Unknown
				xil_printf("unknown status\n\r");
			}

			if(g_conn_status_old != g_conn_status)
			{
				draw_picture(g_conn_status);
				g_conn_status_old = g_conn_status;
			}
//#ifdef USE_DEBUG_MESSAGE
			dongle_usage_count = check_dongle_usage_count();
			xil_printf("dongle_usage_count = %d\r\n", dongle_usage_count);
//#endif
		}
		else
		{
			show_command_not_found();
		}
	}
	else if(length == 2)
	{
		xil_printf("\n\r");
		if(buffer[0] == 's')
		{
#ifdef USE_PREVENT_REUSE
			if(flag_forbid_video == FALSE)
#endif
			{
				if(g_procedure_started == START) { // We are in a active session
					if(g_conn_status == CAMERA_OK)	//dongle + camera
					{
						xil_printf("turn off\r\n");
						g_updated = 1;
						g_procedure_started = STOP;
					}
					else
					{
						xil_printf("no turn off, no dongle or camera\r\n");
					}
				}
				else
				{
					if(g_conn_status == CAMERA_OK)	//dongle + camera
					{
						xil_printf("turn on\r\n");
						g_updated = 1;
						g_procedure_started = START;
					}
					else
					{
						xil_printf("no turn on, no dongle or camera\r\n");
					}
				}
			}
		}
		else if(buffer[0] == '0')
		{
			setup_camera_exposure(CAMERA_EXPO_DEFAULT);
		}
		else if(buffer[0] == '+')
		{
			setup_camera_exposure(CAMERA_EXPO_INC);
		}
		else if(buffer[0] == '-')
		{
			setup_camera_exposure(CAMERA_EXPO_DEC);
		}
		else if(buffer[0] == '1')
		{
			xil_printf("psuart0_exposure(%c)\n\r",buffer[0]);g_exposure = 1;psuart0_exposure(g_exposure);
		}
		else if(buffer[0] == '2')
		{
			xil_printf("psuart0_exposure(%c)\n\r",buffer[0]);g_exposure = 2;psuart0_exposure(g_exposure);
		}
		else if(buffer[0] == '3')
		{
			xil_printf("psuart0_exposure(%c)\n\r",buffer[0]);g_exposure = 3;psuart0_exposure(g_exposure);
		}
		else if(buffer[0] == '4')
		{
			xil_printf("psuart0_exposure(%c)\n\r",buffer[0]);g_exposure = 4;psuart0_exposure(g_exposure);
		}
		else if(buffer[0] == '5')
		{
			xil_printf("psuart0_exposure(%c)\n\r",buffer[0]);g_exposure = 5;psuart0_exposure(g_exposure);
		}
		else if(buffer[0] == '+')
		{
			/*
			if(fan_speed < 5)
				fan_speed = 5;
			else if(fan_speed < 10)
				fan_speed++;
			xil_printf("fan_speed = %d\n\r", fan_speed);
			*/
			/*
			if(exposure <= 245)
				exposure += 10;
			psuart0_exposure_data(exposure);
			*/

			cut_pixel += 20;
			if(cut_pixel > 250)
				cut_pixel = 250;
			xil_printf("+, cut %d\n\r", cut_pixel);
			layer1_blit_corners(next_framebuffer);
			layer1_blit_corners(1 - next_framebuffer);
		}
		else if(buffer[0] == '-')
		{
			/*
			if(fan_speed > 5)
				fan_speed--;
			else
				fan_speed = 0;
			xil_printf("fan_speed = %d\n\r", fan_speed);
			*/
			if(exposure >= 10)
				exposure -= 10;
			psuart0_exposure_data(exposure);
		}
		else if(buffer[0] == '>')
		{
			if(alpha <= 239)
				alpha += 16;
			xil_printf("alpha = %d\n\r", alpha);
		}
		else if(buffer[0] == '<')
		{
			if(alpha >= 16)
				alpha -= 16;
			xil_printf("alpha = %d\n\r", alpha);
		}
		else if(buffer[0] == 'j')
		{
		}
		else if(buffer[0] == 't')
		{
			//xil_printf("Enabling/bypassing camera TPG. fail now\n\r");
			//periphs_toggle_camera_tpg(&periphs_inst);

			if(flag_camera_led_status == 1)
			{
				xil_printf("\n\rTurn off camera LED -\n\r");
				ps_gpio_setup(&periphs_inst, GPIO_CAM_LED, 0);
				flag_camera_led_status = 0;
			}
			else
			{
				xil_printf("\n\rTurn on camera LED -\n\r");
				ps_gpio_setup(&periphs_inst, GPIO_CAM_LED, 1);
				flag_camera_led_status = 1;
			}
		}
		else if(buffer[0] == 'y')
		{
			xil_printf("Enabling/bypassing Layer 2.\n\r");

			status = XVMix_IsLayerEnabled(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_2);
			if(status) { // Enabled
				//XVMix_LayerDisable(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_2);
			} else {
				XVMix_LayerEnable(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_2);
			}

			xil_printf("Enabling/bypassing GUI TPG. on layer 2\n\r");
			periphs_toggle_GUI_tpg(&periphs_inst);
		}
		else if(buffer[0] == 'u')
		{
			xil_printf("Park/Unpark Camera Freeze VDMA.\n\r");
			periphs_toggle_camera_freeze_vdma(&periphs_inst);
			// Determine if we're in TPG or passthrough mode
			if (periphs_inst.enable_camera_freeze_vdma == PERIPHS_SEL_ENABLE_PARK)
			{
				XVMix_LayerEnable(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_2);
			}
			else
			{
				XVMix_LayerDisable(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_2);
			}
		}
		else if(buffer[0] == 'c')
		{
			xil_printf("check dongle status\t");
			g_conn_status = psuart0_dongle_ping();
			if(g_conn_status == DONGLE_NONE){			// Nothing is plugged in
				xil_printf("no dongle or camera\n\r");
			}
			else if(g_conn_status == CAMERA_NONE){		// Only dongle is plugged in
				xil_printf("dongle plugged\n\r");
			}
			else if(g_conn_status == CAMERA_OK){		// Everything is plugged in
				xil_printf("all plugged\n\r");
			}
			else {										// Unknown
				xil_printf("unknown status\n\r");
			}

			if(g_conn_status_old != g_conn_status)
			{
				draw_picture(g_conn_status);
				g_conn_status_old = g_conn_status;
			}
//#ifdef USE_DEBUG_MESSAGE
			dongle_usage_count = check_dongle_usage_count();
			xil_printf("dongle_usage_count = %d\r\n", dongle_usage_count);
//#endif
		}
		else if(buffer[0] == 'a')
		{
			XAdcGetData();
		}
		else if(buffer[0] == 'f')
		{
			//psusb0_hal_interrupt_disable(0);
			//hal_interrupt_disable(0);
			//get_usb_descriptor();
			//hal_interrupt_enable(0);
			//psusb0_hal_interrupt_enable(0);

			uint32_t status = XVMix_IsLayerEnabled(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_1);
			xil_printf("\t\rfreeze, L1 status: 0x%x\n\r", status);
			if(status) { // Enabled
				XGpioPs *Gpio = periphs_inst.p_ps_gpio_inst;
				periphs_toggle_camera_freeze_vdma(&periphs_inst);
				// Determine if we're in TPG or passthrough mode
				if (periphs_inst.enable_camera_freeze_vdma == PERIPHS_SEL_ENABLE_PARK)
				{
					xil_printf("freeze\n\r");
					XVMix_LayerEnable(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_2);
					// Turn on Red light
					XGpioPs_WritePin(Gpio, GPIO_LED_RED, 1);
				}
				else
				{
					xil_printf("un-freeze\n\r");
					XVMix_LayerDisable(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_2);
					// Turn off red light
					XGpioPs_WritePin(Gpio, GPIO_LED_RED, 0);
				}
			}
			else
				xil_printf("no work\n\r");
		}
		/*
		else if(buffer[0] == 'm')
		{
			xil_printf("METER\r\n");

			if(flag_updateConsoleWidgets == 0)
				flag_updateConsoleWidgets = 1;
			else
				flag_updateConsoleWidgets = 0;
		}
		*/
		/*
		else if(buffer[0] == 'd')
		{
			xil_printf("disable USB interrupt\n\r");
			psusb0_hal_interrupt_disable(0);
			hal_interrupt_disable(0);
		}
		else if(buffer[0] == 'e')
		{
			xil_printf("enable USB interrupt\n\r");
			hal_interrupt_enable(0);
			psusb0_hal_interrupt_enable(0);
		}
		*/
		else if(buffer[0] == 'g')
		{
			xil_printf("gdisp test for GDISP_CONTROL_BUFFERS_SWAP\n\r");
			gdisp_lld_control(GDISP);
		}
		else if(buffer[0] == 'p')
		{
#ifdef TEMPERATURE_DEBUG
			u32 TempRawData;
			float TempData;

			xil_printf("\n\r\n\rprint adc result\n\r\n\r");
			u32 i = 0;
			for(i = 0; i < DEBUG_LENGTH; i++)
			{
				TempRawData = temperature_array[i];
				TempData = XAdcPs_RawToTemperature(TempRawData);
				xil_printf("T(%d)=%0d.%03d;", i+1, (int)(TempData), XAdcFractionToInt(TempData));

				if((i%6) == 5)
					xil_printf("\n\r");
			}

			xil_printf("\n\r\n\r");
#endif
			print_screen_data(0);
		}
		else if(buffer[0] == 'l')
		{
			preload_picture_to_memory();
		}
		else if(buffer[0] == 'v')
		{
			xil_printf("Y U V  => R G B\n\r");

			//White	FF 84 7C 		249 255 255
			yuv2rgb(0xFF, 0x84, 0x7C);

			//Yellow	DF 00 93		249 253 0
			yuv2rgb(0xDF, 0x00, 0x93);

			//Blue	B0 DE 00		0 235 255
			yuv2rgb(0xB0, 0xDE, 0x00);

			//Green	91 00 00		0 255 0
			yuv2rgb(0x91, 0x00, 0x00);

			//Pink	71 FF FF		255 0 255
			yuv2rgb(0x71, 0xFF, 0xFF);

			//Red	52 27 FF		255 21 0
			yuv2rgb(0x52, 0x27, 0xFF);

			//Blue	23 FF 6A		4 6 255
			yuv2rgb(0x23, 0xFF, 0x6A);


			//Black	04 81 81		5 2 5
			yuv2rgb(0x04, 0x81, 0x81);


			//Green 00 00 00	0 135 0
			yuv2rgb(0x00, 0x00, 0x00);

			reg = 0x321F0000;
			value = 0;

			xil_printf("\n\rreg = 0x%08x\n\r\n\r", reg);

			for(i = 0; i < 1000; i++)
			{
				value = Xil_In32(reg + i * 4);
				xil_printf("%08x ",value);
				if((i % 16) == 15)
					xil_printf("\n\r");
			}
			xil_printf("\n\r");





			xil_printf("tick(%d) = %d;\t%%%s:%s(%d) ST sleep 10\r\n", tick_cnt++, g_ms_tick, __FILE__, __func__, __LINE__);

			sleep(10);

			xil_printf("tick(%d) = %d;\t%%%s:%s(%d) SP\r\n", tick_cnt++, g_ms_tick, __FILE__, __func__, __LINE__);






		}
		else if(buffer[0] == 'd')
		{
			xil_printf("david test\n\r");

			/*
			xil_printf("\n\rread awb page data page = 0x%x\n\r", AWB_PAGE0);
			ENABLE_CONFIGURE(1);
			SET_ADDRESS(AWB_PAGE0);
			READ_1PAGE();
			ENABLE_CONFIGURE(0);
			if((page_data[0] == 0x00) && (page_data[1] == 0x00) && (page_data[2] == 0x00) && (page_data[3] == 0x00))
			{
				xil_printf("no awb data\n\r");
			}
			else
			{
				int data_r = page_data[0]<<8 | page_data[1];
				int data_b = page_data[2]<<8 | page_data[3];
				xil_printf("\ncamera AWB data R : 0x%04x = %4d  B : 0x%04x = %4d ", data_r, data_r, data_b, data_b);
			}
			*/
/*
			xil_printf("Test sensor linearity, GAIN EXPO Manual\n\r");
			dongle_write_data(0x3503, 0x03);

			unsigned int DongleAddr;
			unsigned char DongleData;
			int value = 0;
			int i;

			value = 0;
			DongleAddr = 0x3501;
			DongleData = dongle_read_data(DongleAddr);
			xil_printf("david0513: %s:%s(%d) addr = 0x%04x value=0x%02x\r\n",__FILE__,__func__,__LINE__,DongleAddr,DongleData);
			value |=  DongleData << 8;

			DongleAddr = 0x3502;
			DongleData = dongle_read_data(DongleAddr);
			xil_printf("david0513: %s:%s(%d) addr = 0x%04x value=0x%02x\r\n",__FILE__,__func__,__LINE__,DongleAddr,DongleData);
			value |=  DongleData;
			xil_printf("david0513: %s:%s(%d) value=0x%04x\r\n",__FILE__,__func__,__LINE__,value);
*/

			/*
			for(i = value ;i<512;i++)
			{
				xil_printf("i=0x%04x = %d\r\n",i, i);
				DongleAddr = 0x3501;
				DongleData = (i>>8)&0xff;
				dongle_write_data(DongleAddr, DongleData);
				DongleAddr = 0x3502;
				DongleData = (i>>0)&0xff;
				dongle_write_data(DongleAddr, DongleData);
				usleep(500000);
			}
			*/

/*
			value = 0;
			DongleAddr = 0x350A;
			DongleData = dongle_read_data(DongleAddr);
			xil_printf("david0513: %s:%s(%d) addr = 0x%04x value=0x%02x\r\n",__FILE__,__func__,__LINE__,DongleAddr,DongleData);
			value |=  DongleData << 8;

			DongleAddr = 0x350B;
			DongleData = dongle_read_data(DongleAddr);
			xil_printf("david0513: %s:%s(%d) addr = 0x%04x value=0x%02x\r\n",__FILE__,__func__,__LINE__,DongleAddr,DongleData);
			value |=  DongleData;
			xil_printf("david0513: %s:%s(%d) value=0x%04x\r\n",__FILE__,__func__,__LINE__,value);

			for(i = 0 ;i<512;i++)
			{
				xil_printf("i=0x%04x = %d\r\n",i, i);
				DongleAddr = 0x350A;
				DongleData = (i>>8)&0xff;
				dongle_write_data(DongleAddr, DongleData);
				DongleAddr = 0x350B;
				DongleData = (i>>0)&0xff;
				dongle_write_data(DongleAddr, DongleData);
				usleep(100000);
			}
			*/



			/*
			//SD
			status = InitSD("BOOT.BIN");
			if (status != XST_SUCCESS) {
				xil_printf("InitSD fail\r\n");
			}
			else
			{
				xil_printf("InitSD OK\r\n");
			}
			*/



			/*	ok for sd card read-write ST

			xil_printf("Loading test.png\r\n");
		    status = loadFileFromSD("test.png", ((volatile unsigned int *) 0x04000000));
		    if ( status != XST_SUCCESS ) {
		    	xil_printf("Fail\r\n");
		    }
		    xil_printf("loaded\r\n");

			xil_printf("Loading test.jpg\r\n");
		    status = loadFileFromSD("test.jpg", ((volatile unsigned int *) 0x04000000));
		    if ( status != XST_SUCCESS ) {
		    	xil_printf("Fail\r\n");
		    }
		    xil_printf("loaded\r\n");

			xil_printf("Loading test.bmp\r\n");
		    status = loadFileFromSD("test.bmp", ((volatile unsigned int *) 0x04000000));
		    if ( status != XST_SUCCESS ) {
		    	xil_printf("Fail\r\n");
		    }
		    xil_printf("loaded\r\n");
		    //ok for sd card read-write SP
			*/

			/*
		    const char src_str[] = "hsp test sd card write and read!";
		    u32 len = strlen((const char *)src_str);
		    xil_printf("string len = %d zzz\r\n", len);

		    //SD_Transfer_write("aaaaaa.txt",(u32)src_str,(len));
		    SD_Init();

		    char filename[40];
		    sprintf(filename, "DA%02d%02d%02d.txt", rtc.tm_hour, rtc.tm_min, rtc.tm_sec);
		    xil_printf("filename : %s\n\r", filename);
		    SD_Transfer_write(filename, (u32)src_str, len);

*/




			/*
			dongle_write_data(0x5080, 0x81);


			sleep(5);


			reg = 0x32100000;
			value = 0;

			//xil_printf("reg = 0x%08x\n\r", reg);

			for(i = 0;i<1000;i++)
			{
				//value = Xil_In32(reg + i * 4);
				value = Xil_In32(reg + i * 4 * 16);
				//xil_printf("\n\rRegister : 0x%08x\tread value : 0x%08x\n\r",reg, value);
				if((i % 32) < 22 )
					xil_printf("%08x ",value);
				if((i % 32) == 31)
					xil_printf("\n\r");
			}
			xil_printf("\n\r");
			 */

			//dongle_write_data(0x5080, 0x81);


			/*
			xil_printf("freeze\n\r");

			(&periphs_inst)->enable_camera_freeze_vdma = PERIPHS_SEL_ENABLE_PARK;
			XAxiVdma_StartParking((&periphs_inst)->p_vdma_camera_freeze_inst, 0, XAXIVDMA_READ);
			//XAxiVdma_StartParking(p_periphs_inst->p_vdma_camera_freeze_inst, (ccc%3), XAXIVDMA_READ);
			xil_printf(">>>>>Park camera freeze vdma.  aaaaa\n\r");


			xil_printf("tick(%d) = %d;\t%%%s:%s(%d) ST\r\n", tick_cnt++, g_ms_tick, __FILE__, __func__, __LINE__);
			Save_Image_To_SD();
			xil_printf("tick(%d) = %d;\t%%%s:%s(%d) SP\r\n", tick_cnt++, g_ms_tick, __FILE__, __func__, __LINE__);


			xil_printf("un-freeze\n\r");
			(&periphs_inst)->enable_camera_freeze_vdma = PERIPHS_SEL_DISABLE_PARK;
			XAxiVdma_StopParking((&periphs_inst)->p_vdma_camera_freeze_inst, XAXIVDMA_READ);

			xil_printf(">>>>>Unpark camera freeze vdma.  bbbb\n\r");

			*/

			/*
			xil_printf("\n\r");
			int length = 16 * 17 * 4;

			int tmp;
			int tmp2 = 0;
			for(i = 0; i < length; i++)
			{
				tmp = (((i/4)/8)*8+0)%257;
				if (tmp == 256)
					tmp = 255;

				//f_ptr_color3[i] = 0xFF000000 + 0x00000100 * ((((((i/4)/8)*8)%256)+0)%256);	//Red
				if(tmp2 != tmp)
					xil_printf("\n\r");
				tmp2 = tmp;
				xil_printf("%4d %4d   ", i, tmp);
			}
			 */

			/*
			xil_printf("GPIO test\n\r");
			gpio_test();
			*/

			/*

			xil_printf("sleep 10 s ST\n\r");
			sleep_A9(10);
			xil_printf("sleep 10 s SP\n\r");
			 */


			/*
			XTime tmp;

			my_XTime_GetTime(&tmp);
			sleep_A9(5);
			my_XTime_GetTime(&tmp);
			 */

			/*
		      u32 status;
		      u32 DataRead;
		      status = GpioInputExample(XPAR_VIDEO_PATH_CAMERA_IN_CDR_VIDEO_IN_AXI4_RDY_CDR_REGISTERS_AXI_GPIO_NFRAMESREADY_DEVICE_ID, &DataRead);
		      if (status == 0) {
		         xil_printf("GpioInputExample PASSED. Read data:0x%X\r\n", DataRead);
		      }
		      else {
		         print("GpioInputExample FAILED.\r\n");
		      }

		      XTime_GetStartTime();
		      */


			/*
		      u32 status;

		      print("\r\nRunning GpioOutputExample() for video_path_camera_in_CDR_VIdeo_In_AXI4_rdy_CDR_Registers_axi_gpio_SDK_NFrames...\r\n");

		      status = GpioOutputExample(XPAR_VIDEO_PATH_CAMERA_IN_CDR_VIDEO_IN_AXI4_RDY_CDR_REGISTERS_AXI_GPIO_SDK_NFRAMES_DEVICE_ID,8, 60);

		      if (status == 0) {
		         print("GpioOutputExample PASSED.\r\n");
		      }
		      else {
		         print("GpioOutputExample FAILED.\r\n");
		      }
*/

			/*
			xil_printf("\n\rmeasure brightness ST\n\r");
			int x_st = 0;
			int y_st = 0;
			int W = 0;
			int H = 0;
			int value = 0;
			int dd = 20;

			int N = 10;
			u8 gray[10][10] =
			{
			};

			int dx = 640 / N;
			int dy = 480 / N;

			W = dd;
			H = dd;

			for(y_st = 0;y_st < 480; y_st += dy)
			{
				for(x_st = 0; x_st < 640; x_st += dx)
				{
					value = get_gray_value(x_st, y_st, W, H);

					if(value != -1)
					{
						//xil_printf("get_gray_value x_st = %3d y _st = %3d W = %3d H = %3d, result :%4d\n\r", x_st, y_st, W, H, value);

						//xil_printf("gray[%d, %d] = %d;\n\r", x_st/dx, y_st/dy, value);
						gray[x_st/dx][y_st/dy] = (u8)value;
						//gray[3,3] = 5;
						//xil_printf("gray2(%d, %d) = %d;\n\r", x_st/dd + 1, y_st/dd + 1, value);

						//xil_printf("%8d", value);


					}

				}


			}
			xil_printf("measure brightness SP, result :\n\r\n\r");

			int j;

			for(j = 0; j < 10; j++)
			{
				for(i = 0; i < 10; i++)
				{
					xil_printf("%8d", gray[i][j]);

				}
				xil_printf("\n\r");
			}
			*/

			/*
			for(i = 0; i < 10; i++)
			{
				value = get_average_gray_value();
				xil_printf("%4d", value);
			}
			xil_printf("\n\r");
			 */


			//char s4[] = "happy new year\n";
			//xil_printf("s4: %d\n", strlen(s4));

			print_time0(0);


		}
		else if(buffer[0] == 'q')
		{
			debug_console_print("lion-mouse\n");
		}
		else if(buffer[0] == '!')
		{
			debug_console_close();
		}
		else if(buffer[0] == '@')
		{
		}
		else if(buffer[0] == '#')
		{
#ifdef USE_PREVENT_REUSE
			/*
			xil_printf("\n\rread_error_code_from_camera:\t");
			int ret;
			flag_video_status = read_error_code_from_camera();

			switch(flag_video_status)
			{
			case VIDEO_OK:							xil_printf("VIDEO_OK\n");break;
			case VIDEO_FORBID_ALL:					xil_printf("VIDEO_FORBID_ALL\n");break;
			case VIDEO_FORBID_USE_2HR:				xil_printf("VIDEO_FORBID_USE_2HR\n");break;
			case VIDEO_FORBID_RTC_FAIL:				xil_printf("VIDEO_FORBID_RTC_FAIL\n");break;
			default:								xil_printf("unknown video status : %d\n", (int)flag_video_status);break;
			}

			xil_printf("\n\rread_serial_from_camera\n\r");
			read_serial_from_camera();			//camera 0xA
			xil_printf("\n\rread_date_from_camera page1\n\r");
			ret = read_date_from_camera(DATE_PAGE1);	//camera 0xB
			if(ret == 1)
				xil_printf("Page 0xB has date data, 1m data\n\r");
			else
				xil_printf("Page 0xB does not have date data\n\r");
			xil_printf("\n\rread_date_from_camera page3\n\r");
			ret = read_date_from_camera(DATE_PAGE3);	//camera 0xD
			if(ret == 1)
				xil_printf("Page 0xD has date data, 2hr data\n\r");
			else
				xil_printf("Page 0xD does not have date data\n\r");
			*/
#endif
#ifdef USE_PREVENT_REUSE
			unsigned long difftime = 0;
			difftime = get_camera_use_time();
			xil_printf("\n\rdifftime_CAMERA_1MIN = ");
			xil_printf("david0529: %s:%s(%d) ST\r\n",__FILE__,__func__,__LINE__);
			print_time(difftime);
#endif
		}
		else if(buffer[0] == '$')
		{
		}
		else if(buffer[0] == 'w')
		{
		}
		else if(buffer[0] == 'm')
		{
			pirnt_mixer_data();
		}
		else if(buffer[0] == 'W')
		{
			xil_printf("write eeprom data XIicPs_WritedEepromData\n\r");
			//char ims_info[] = "iiiiimmmmmsssss15iiiiimmmmmsssss15";
			char ims_info[] = "abcdefghijklmnopqrstuvwxyz";
			//char ims_info[] = "ims-v1.0.0.3 sn:12345_ims-v1.0.0.3 sn:12345";
			int len;
			len = sizeof(ims_info) - 1;
			XIicPs_WriteEepromData(0, 64 * 0, len, (u8*)ims_info);
			usleep(10000);
			XIicPs_WriteEepromData(0, 64 * 1, len, (u8*)ims_info);
			usleep(10000);
			XIicPs_WriteEepromData(0, 64 * 3, len, (u8*)ims_info);
			usleep(10000);
			XIicPs_WriteEepromData(0, 64 * 5, len, (u8*)ims_info);
			usleep(10000);
			XIicPs_WriteEepromData(0, 64 * 7, len, (u8*)ims_info);
			usleep(10000);
			XIicPs_WriteEepromData(0, 64 * 9, len, (u8*)ims_info);
			usleep(10000);
			XIicPs_WriteEepromData(0, 64 * 13, len, (u8*)ims_info);
			usleep(10000);
		}
		else if(buffer[0] == 'r')
		{
			/*
			u32 addr = 0x43030028;
			u32 value = 0;
			value = ReadRegister(addr);
			xil_printf("result : 0x%08x\n\r", value);
			*/
			u32 addr;
			u32 value = 0;

			xil_printf("\n\r");

			addr = REGISTER_BOOT_MODE;
			value = ReadRegister(addr);
			u32 boot_mode;
			boot_mode = value&0xf;
			xil_printf("REGISTER_BOOT_MODE : 0x%08x, boot_mode = %d\t", value, boot_mode);
			switch(boot_mode)
			{
			case 0:		xil_printf("JTAG");break;
			case 1:		xil_printf("QSPI");break;
			case 4:		xil_printf("NAND");break;
			case 5:		xil_printf("SD");break;
			default:	xil_printf("xxx unknown");break;
			}
			xil_printf(" mode\n\r");

			addr = REGISTER_PSS_IDCODE;
			value = ReadRegister(addr);
			xil_printf("REGISTER_PSS_IDCODE : 0x%08x\n\r", value);
			u32 device;
			device = (value >> 12)&0x1f;
			xil_printf("device : 0x%x\tDevice code: ", device);
			switch(device)
			{
			case 0x02:		xil_printf("7z010");break;
			case 0x1b:		xil_printf("7z015");break;
			case 0x07:		xil_printf("7z020");break;
			case 0x0c:		xil_printf("7z030");break;
			case 0x11:		xil_printf("7z045");break;
			default:	xil_printf("xxx unknown");break;
			}
			xil_printf("\n\r");
			u32 manufacturer_id;
			manufacturer_id = (value >>1)&0x7ff;
			xil_printf("manufacturer_id : 0x%x\n\r", manufacturer_id);
		}
		else if(buffer[0] == 'R')
		{
			int state;
			int page = 0;
			int addr = 0;
			int len = 512;
			u8 RecvBuffer[1024];

			xil_printf("read eeprom data XIicPs_ReadEepromData, page = %d, addr = %d, len = %d\n\r", page, addr, len);
			state = XIicPs_ReadEepromData(page, addr, len, RecvBuffer);

			if(state == XST_FAILURE)
			{
				xil_printf("xxxxxxx I2C fail, XIicPs_ReadEepromData\n\r");
			}
			else
			{
				xil_printf("data: \n\r");
				xil_printf("0123456789012345678901234567890123456789012345678901234567890123\n\r");
				for (i = 0; i < len; i++) {
					if(isprint(RecvBuffer[i]))
						xil_printf("%c", RecvBuffer[i]);
					else
					{
						//xil_printf("^");
						xil_printf("%02x", RecvBuffer[i]);
					}
					if((i % 64) == 63)
						xil_printf("\n\r");
				}
				xil_printf("\n\r");
			}
		}
		else if(buffer[0] == 'b')
		{
			/*
			xil_printf("\n\rGet usb descriptor\n\r");
			uint16_t vid_tmp = 0;
			uint16_t pid_tmp = 0;
			uint8_t ret = 0;
			ret = usb_command(&vid_tmp, &pid_tmp);

			if(ret == TUSB_ERROR_NONE)
			{
				vendor_id_tmp = vid_tmp;
				product_id_tmp = pid_tmp;
			}
			else
			{
				xil_printf("fail\n\r");
			}
			*/

			//xil_printf("\n\rUSB test\n\r");
			//usb_test();

			draw_layer2_boundary();


		}
		else
		{
			show_command_not_found();
		}
	}
	else
	{
		if(length > 1)
		{
			show_command_not_found();
		}
	}

	last_command_length = length;
	for(i = 0; i < (last_command_length - 1); i++)
	{
		last_command[i] = buffer[i];
	}

	length = 0;
}

void get_system_up_time(void)
{
	uint32_t tt = g_ms_uptime;
	uint32_t hh;
	uint32_t mm;
	uint32_t ss;
	uint32_t dd;

	dd = tt % 1000 * 1;
	ss = (tt / 1000) % 60;
	mm = ((tt / 1000) / 60) % 60;
	hh = ((tt / 1000) / 60) / 60;

	xil_printf("\n\rSystem up time is %02d:%02d:%02d.%03d\n\r", hh, mm, ss, dd);
}

struct timespec	ts;

void set_time(void)
{
	ts.tv_sec = g_ms_tick / 1000;
	ts.tv_nsec = (g_ms_tick % 1000) * 1000000;
}

void get_time(void)
{
	xil_printf("time is %ld.%ld\n\r",ts.tv_sec,ts.tv_nsec);
}

void ps_gpio_setup(periphs_t* p_periphs_inst, u32 Pin, u32 Data)
{
	XGpioPs *Gpio = p_periphs_inst->p_ps_gpio_inst;
	XGpioPs_WritePin(Gpio, Pin, Data);
}

void show_engineering_mode0(void)
{
	//int x,y;
	coord_t width;
	coord_t height;
	// Get the screen size
	width = gdispGetWidth();
	height = gdispGetHeight();

	for (coord_t x = 0; x < width; x += 100)
	{
		for (coord_t y = 0; y < height; y += 100)
		{
			//gdispDrawPixel(x, y, Gray);
		}
	}

	gdispDrawBox(300, 100, width - 100 * 2 - 200, height - 100 * 2, Yellow);
	gdispDrawLine(COLUMN2 - 20, 100, COLUMN2 - 20, height - 100, Yellow);
	gdispDrawLine(COLUMN3 - 20, 100, COLUMN3 - 20, height - 100, Yellow);
	gdispDrawLine(COLUMN4 - 20, 100, COLUMN4 - 20, height - 100, Yellow);
	gdispDrawLine(300, ROW1 - 20, width - 100 - 1, ROW1 - 20, Yellow);
	gdispDrawLine(COLUMN4 - 20, ROW4 - 20, width - 100 - 1, ROW4 - 20, Yellow);
	gdispDrawLine(COLUMN4 - 20, ROW5 - 20, width - 100 - 1, ROW5 - 20, Yellow);

	/*
	for (coord_t x = 100; x < (height - 100); x += 100)
	{
		gdispDrawLine(100, x, width - 100, x, Yellow);
	}
	for (coord_t x = 100; x < (width - 100); x += 100)
	{
		gdispDrawLine(x, 100, x, height - 100, Yellow);
	}
	*/

	font_t font = gdispOpenFont("iskpota232");
	gdispFillString(300, 50, "Engineering Mode", font, White, Magenta);

	//font = gdispOpenFont("DejaVu*");
	gdispFillString(COLUMN1, ROW0, "Time", font, White, Olive);
	gdispFillString(COLUMN2, ROW0, "Info", font, White, Olive);
	gdispFillString(COLUMN3, ROW0, "Camera", font, White, Olive);
	gdispFillString(COLUMN4, ROW0, "Language", font, White, Olive);
	gdispFillString(COLUMN4, ROW4, "Misc", font, White, Olive);

	/*
	xil_printf("year : %d\n\r", rtc.tm_year);
	xil_printf("month : %d\n\r", rtc.tm_mon);
	xil_printf("mday : %d\n\r", rtc.tm_mday);
	xil_printf("wday : %d\n\r", rtc.tm_wday);
	xil_printf("hour : %d\n\r", rtc.tm_hour);
	xil_printf("minute : %d\n\r", rtc.tm_min);
	xil_printf("second : %d\n\r", rtc.tm_sec);
	*/

    char str[40];
    sprintf(str, "%d", rtc.tm_year + 1900);
	gdispDrawString(COLUMN1, ROW1, "Year :", font, Red);
	gdispDrawString(COLUMN1 + 120, ROW1, str, font, Red);

    sprintf(str, "%d", rtc.tm_mon + 1);
	gdispDrawString(COLUMN1, ROW2, "Month :", font, Red);
	gdispDrawString(COLUMN1 + 120, ROW2, str, font, Red);

    sprintf(str, "%d", rtc.tm_mday);
	gdispDrawString(COLUMN1, ROW3, "Day :", font, Red);
	gdispDrawString(COLUMN1 + 120, ROW3, str, font, Red);

	switch(rtc.tm_wday)
	{
	case 0:		sprintf(str, "%s", "Sun");	break;
	case 1:		sprintf(str, "%s", "Mon");	break;
	case 2:		sprintf(str, "%s", "Tue");	break;
	case 3:		sprintf(str, "%s", "Wed");	break;
	case 4:		sprintf(str, "%s", "Thu");	break;
	case 5:		sprintf(str, "%s", "Fri");	break;
	case 6:		sprintf(str, "%s", "Sat");	break;
	case 7:		sprintf(str, "%s", "Sun");	break;
	default:	sprintf(str, "%s", "Mon");	break;
	}
	gdispDrawString(COLUMN1 + 120, ROW4, str, font, Red);

	sprintf(str, "%d", rtc.tm_hour);
	gdispDrawString(COLUMN1, ROW5, "Hour :", font, Red);
	gdispDrawString(COLUMN1 + 120, ROW5, str, font, Red);
    sprintf(str, "%d", rtc.tm_min);
	gdispDrawString(COLUMN1, ROW6, "Minute :", font, Red);
	gdispDrawString(COLUMN1 + 120, ROW6, str, font, Red);
    sprintf(str, "%d", rtc.tm_sec);
	gdispDrawString(COLUMN1, ROW7, "Second :", font, Red);
	gdispDrawString(COLUMN1 + 120, ROW7, str, font, Red);

	const char * const txt1 = __DATE__;
	const char * const txt2 = __TIME__;

	xil_printf("\n\rread_model_from_main_board\n\r");

	int state;
	state = XIicPs_ReadEepromData(29, 0, 50, RecvBuffer);
	if(state == XST_FAILURE)
	{
		xil_printf("xxxxxxx I2C fail, try again\n\r");
		usleep(1000);
		state = XIicPs_ReadEepromData(29, 0, 50, RecvBuffer);
	}

	/*
	int i;
	xil_printf("data: \t0x");
	for (i = 0; i < 50; i++) {
		xil_printf("%02x ", RecvBuffer[i]);
	}
	xil_printf("\n\r");
	 */


	if((RecvBuffer[0] == 0xFF) && (RecvBuffer[1] == 0xFF))
	{
		sprintf(str, "MB : ---------------------------");
		gdispDrawString(COLUMN2, ROW2, str, font, Red);

		sprintf(str, "SN1 : --------------------------");
		gdispDrawString(COLUMN2, ROW3, str, font, Red);

		sprintf(str, "SN2 : --------------------------");
		gdispDrawString(COLUMN2, ROW4, str, font, Red);
	}
	else
	{
		sprintf(str, "MB : %C%C%C%C%C%C%C%C%C%C%C%C%C", RecvBuffer[0], RecvBuffer[1], RecvBuffer[2], RecvBuffer[3], RecvBuffer[4], RecvBuffer[5], RecvBuffer[6], RecvBuffer[7], RecvBuffer[8], RecvBuffer[9], RecvBuffer[10], RecvBuffer[11], RecvBuffer[12]);
		gdispDrawString(COLUMN2, ROW2, str, font, Red);

		sprintf(str, "SN1 : %C%C%C%C%C%C%C%C%C%C%C%C%C", RecvBuffer[13], RecvBuffer[14], RecvBuffer[15], RecvBuffer[16], RecvBuffer[17], RecvBuffer[18], RecvBuffer[19], RecvBuffer[20], RecvBuffer[21], RecvBuffer[22], RecvBuffer[23], RecvBuffer[24], RecvBuffer[25]);
		gdispDrawString(COLUMN2, ROW3, str, font, Red);

		sprintf(str, "SN2 : %C%C%C%C%C%C%C%C%C%C%C%C%C%C%C%C%C%C%C%C%C%C%C%C", RecvBuffer[26], RecvBuffer[27], RecvBuffer[28], RecvBuffer[29], RecvBuffer[30], RecvBuffer[31], RecvBuffer[32], RecvBuffer[33], RecvBuffer[34], RecvBuffer[35], RecvBuffer[36], RecvBuffer[37], RecvBuffer[38], RecvBuffer[39], RecvBuffer[40], RecvBuffer[41], RecvBuffer[42], RecvBuffer[43], RecvBuffer[44], RecvBuffer[45], RecvBuffer[46], RecvBuffer[47], RecvBuffer[48], RecvBuffer[49]);
		gdispDrawString(COLUMN2, ROW4, str, font, Red);
	}

	gdispDrawString(COLUMN2, ROW1, "IMS HW v3", font, Red);
	gdispDrawString(COLUMN2 + 200, ROW1, "Freeze : Ctrl + F12", font, Red);
	gdispDrawString(COLUMN2, ROW5, "Aries 1.0.0", font, Red);
	gdispDrawString(COLUMN2, ROW6, txt1, font, Red);
	gdispDrawString(COLUMN2 + 180, ROW6, txt2, font, Red);
	/*
    sprintf(str, "%d x %d", width, height);
    gdispDrawString(COLUMN2, ROW6, str, font, Red);
    */

#ifdef SW_RELEASE
	gdispDrawString(COLUMN2, ROW7, "SW_RELEASE", font, Red);
#else
	gdispDrawString(COLUMN2, ROW7, "Engineering", font, Red);
	#ifdef USE_IMS_LINK
		gdispDrawString(COLUMN2 + 180, ROW7, "USE_IMS_LINK", font, Red);
	#else
		gdispDrawString(COLUMN2 + 180, ROW7, "USE_comport", font, Red);
	#endif
#endif
		gdispDrawString(COLUMN2, ROW8, "HW :", font, Red);

	    u32 status;
	    u32 DataRead;
	    status = GpioInputExample(XPAR_VIDEO_PATH_CAMERA_IN_CDR_VIDEO_IN_AXI4_RDY_CDR_REGISTERS_AXI_GPIO_NFRAMESREADY_DEVICE_ID, &DataRead);
	    if (status == 0) {
	       //xil_printf("GpioInputExample PASSED. Read data:0x%08X\r\n", DataRead);
	       int year = ((DataRead >> 28) & 0x0F)*100+((DataRead >> 24) & 0x0F)*10+((DataRead >> 20) & 0x0F)*1 + 2000;
	       int month = ((DataRead >> 16) & 0x0F)*10+((DataRead >> 12) & 0x0F)*1;
	       int day = ((DataRead >> 8) & 0x0F)*10+((DataRead >> 4) & 0x0F)*1;

	       //xil_printf("%04d/%02d/%02d\n\r", year, month, day);

	       sprintf(str, "%04d/%02d/%02d", year, month, day);
	       gdispDrawString(COLUMN2 + 180, ROW8, str, font, Red);
	    }
	    else {
	       //print("GpioInputExample FAILED.\r\n");
	    }

		u32 addr;
		u32 value = 0;

		addr = REGISTER_BOOT_MODE;
		value = ReadRegister(addr);
		u32 boot_mode;
		boot_mode = value&0xf;
		//xil_printf("REGISTER_BOOT_MODE : 0x%08x, boot_mode = %d\t", value, boot_mode);
		gdispDrawString(COLUMN2, ROW9, "Boot mode :", font, Red);
		switch(boot_mode)
		{
		case 0:		gdispDrawString(COLUMN2 + 180, ROW9, "JTAG Mode", font, Red);break;
		case 1:		gdispDrawString(COLUMN2 + 180, ROW9, "QSPI Mode", font, Red);break;
		case 4:		gdispDrawString(COLUMN2 + 180, ROW9, "NAND Mode", font, Red);break;
		case 5:		gdispDrawString(COLUMN2 + 180, ROW9, "SD Mode", font, Red);break;
		default:	gdispDrawString(COLUMN2 + 180, ROW9, "Unknown Mode", font, Red);break;
		}

		sprintf(str, "Bootup : %s", asctime(&rtc_bootup));
		gdispDrawString(COLUMN2, ROW10, str, font, Red);

		unsigned long difftime_bootup = 0;
		difftime_bootup = diff_time(rtc, rtc_bootup);
		//xil_printf("Bootup ellapsed : %ld sec\r\n", difftime_bootup);

		sprintf(str, "Ellapsed :");
		gdispDrawString(COLUMN2, ROW11, str, font, Red);

		print_time_eng(difftime_bootup);

	switch(SelectedLanguage)
	{
	case 0:		sprintf(str, "%s", "T. Chinese");	break;
	case 1:		sprintf(str, "%s", "S. Chinese");	break;
	case 2:		sprintf(str, "%s", "English");		break;
	default:	sprintf(str, "%s", "xxx");			break;
	}
	gdispDrawString(COLUMN4, ROW1, str, font, Red);
	gdispFillString(COLUMN3 + 130, ROW12, "F9 : Refresh", font, White, Gray);

    return;
}

void show_engineering_mode(void)
{
	xil_printf("\n\rdavid0211: %s:%s(%d) ST\r\n", __FILE__, __func__, __LINE__);
	gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(next_framebuffer));
	show_engineering_mode0();
	gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(1 - next_framebuffer));
	show_engineering_mode0();
	read_camera_info_from_camera_eng();
	show_camera_info_eng();
	return;
}

void clear_engineering_mode(void)
{
	xil_printf("\n\rdavid0211: %s:%s(%d) ST\r\n", __FILE__, __func__, __LINE__);
	gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(next_framebuffer));
	clear_engineering_mode0();
	gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(1 - next_framebuffer));
	clear_engineering_mode0();
	return;
}

int IicPsMasterInit(u16 DeviceId)
{
	int Status;
	XIicPs_Config *Config;
	/*
	 * Initialize the IIC driver so that it's ready to use
	 * Look up the configuration in the config table,
	 * then initialize it.
	 */
	Config = XIicPs_LookupConfig(DeviceId);
	if (NULL == Config) {
		return XST_FAILURE;
	}

	Status = XIicPs_CfgInitialize(&Iic, Config, Config->BaseAddress);
	if (Status != XST_SUCCESS) {
		return XST_FAILURE;
	}

	/*
	 * Perform a self-test to ensure that the hardware was built correctly.
	 */
	Status = XIicPs_SelfTest(&Iic);
	if (Status != XST_SUCCESS) {
		return XST_FAILURE;
	}

	/*
	 * Set the IIC serial clock rate.
	 */
	XIicPs_SetSClk(&Iic, IIC_SCLK_RATE);

	/*
	XIicPs_SetDate(&Iic, 2018, 9, 14, 5, 17, 59, 30);
	usleep(2000);
	XIicPs_SetInfo();
	usleep(2000);
	*/
	return XST_SUCCESS;
}

int XIicPs_SetDate(XIicPs *InstancePtr, u32 year, u8 month, u8 date, u8 day, u8 hour, u8 minutes, u8 seconds)
{
	/*	debug
    int j;

	for(j = 0; j < 7; j++)
	{
		SendBuffer[0] = j;	//offset
		SendBuffer[1] = 6;	//data
		Status = XIicPs_MasterSendPolled(&Iic, SendBuffer,
				 2, IIC_SLAVE_ADDR);
		if (Status != XST_SUCCESS) {
			xil_printf("david0719: %s:%s(%d) ffff b\r\n",__FILE__,__func__,__LINE__);
			return XST_FAILURE;
		}
	}
	*/

	int Status;
	xil_printf("raw data: %d/%d/%d %d %02d:%02d:%02d\r\n", year, month, date, day, hour, minutes, seconds);

	seconds = ((seconds / 10) << 4) + (seconds % 10);
	minutes = ((minutes / 10) << 4) + (minutes % 10);
	hour = ((hour / 10) << 4) + (hour % 10);
	date = ((date / 10) << 4) + (date % 10);
	month = ((month / 10) << 4) + (month % 10);
	year = (((year - 2000) / 10) << 4) + ((year - 2000) % 10);

	xil_printf("new data: %d/%d/%d %d %02d:%02d:%02d\r\n", year, month, date, day, hour, minutes, seconds);

	SendBuffer[0] = 0;			//offset
	SendBuffer[1] = seconds;	//data
	Status = XIicPs_MasterSendPolled(InstancePtr, SendBuffer,
			 2, IIC_SLAVE_ADDR);
	if (Status != XST_SUCCESS) {
		xil_printf("david0719: %s:%s(%d) ffff b\r\n",__FILE__,__func__,__LINE__);
		return XST_FAILURE;
	}

	SendBuffer[0] = 1;			//offset
	SendBuffer[1] = minutes;	//data
	Status = XIicPs_MasterSendPolled(InstancePtr, SendBuffer,
			 2, IIC_SLAVE_ADDR);
	if (Status != XST_SUCCESS) {
		xil_printf("david0719: %s:%s(%d) ffff b\r\n",__FILE__,__func__,__LINE__);
		return XST_FAILURE;
	}

	SendBuffer[0] = 2;			//offset
	SendBuffer[1] = hour;		//data
	Status = XIicPs_MasterSendPolled(InstancePtr, SendBuffer,
			 2, IIC_SLAVE_ADDR);
	if (Status != XST_SUCCESS) {
		xil_printf("david0719: %s:%s(%d) ffff b\r\n",__FILE__,__func__,__LINE__);
		return XST_FAILURE;
	}

	SendBuffer[0] = 3;			//offset
	SendBuffer[1] = day;		//data
	Status = XIicPs_MasterSendPolled(InstancePtr, SendBuffer,
			 2, IIC_SLAVE_ADDR);
	if (Status != XST_SUCCESS) {
		xil_printf("david0719: %s:%s(%d) ffff b\r\n",__FILE__,__func__,__LINE__);
		return XST_FAILURE;
	}

	SendBuffer[0] = 4;			//offset
	SendBuffer[1] = date;		//data
	Status = XIicPs_MasterSendPolled(InstancePtr, SendBuffer,
			 2, IIC_SLAVE_ADDR);
	if (Status != XST_SUCCESS) {
		xil_printf("david0719: %s:%s(%d) ffff b\r\n",__FILE__,__func__,__LINE__);
		return XST_FAILURE;
	}

	SendBuffer[0] = 5;			//offset
	SendBuffer[1] = month;		//data
	Status = XIicPs_MasterSendPolled(InstancePtr, SendBuffer,
			 2, IIC_SLAVE_ADDR);
	if (Status != XST_SUCCESS) {
		xil_printf("david0719: %s:%s(%d) ffff b\r\n",__FILE__,__func__,__LINE__);
		return XST_FAILURE;
	}

	SendBuffer[0] = 6;			//offset
	SendBuffer[1] = year;		//data
	Status = XIicPs_MasterSendPolled(InstancePtr, SendBuffer,
			 2, IIC_SLAVE_ADDR);
	if (Status != XST_SUCCESS) {
		xil_printf("david0719: %s:%s(%d) ffff b\r\n",__FILE__,__func__,__LINE__);
		return XST_FAILURE;
	}
	return XST_SUCCESS;
}

int XIicPs_SetData(XIicPs *InstancePtr, u8 addr, u8 data)
{
	int Status;
	xil_printf("\n\rXIicPs_SetData, addr = 0x%02x = %d, data = 0x%02x = %d\n\r", addr, addr, data, data);

	SendBuffer[0] = addr;	//offset
	SendBuffer[1] = data;	//data
	Status = XIicPs_MasterSendPolled(InstancePtr, SendBuffer,
			 2, IIC_SLAVE_ADDR);
	if (Status != XST_SUCCESS) {
		xil_printf("david0719: %s:%s(%d) ffff b\r\n",__FILE__,__func__,__LINE__);
		return XST_FAILURE;
	}
	return XST_SUCCESS;
}

int XIicPs_SetInfo()
{
	int Status;
	int i;
	//char ims_info[] = "ims-v1.0.0.3 sn:12345";
	char ims_info[] = "iiiiimmmmmsssss15";

	for(i = 0; i < (INFO_BUFFER_SIZE + 1); i++)
	{
		if(i == 0)
			SetInfoBuffer[i] = '-';			//data
		else if(i <= 26)
			SetInfoBuffer[i] = 'A' - 1 + i;	//data
		else if(i == 27)
			SetInfoBuffer[i] = '{';			//data
		else if(i == 28)
			SetInfoBuffer[i] = '}';			//data
		else if(i <= 54)
			SetInfoBuffer[i] = 'a' - 29 + i;//data
		else if(i == 55)
			SetInfoBuffer[i] = '(';			//data
		else if(i == 56)
			SetInfoBuffer[i] = ')';			//data
		else
			SetInfoBuffer[i] = '~';			//data
	}

	xil_printf("old data: ");
	for(i = 0; i < (INFO_BUFFER_SIZE + 1); i++)
	{
		xil_printf("%c", SetInfoBuffer[i]);
	}
	xil_printf("\n\r");

	xil_printf("size of ims-info is %d\n\r", sizeof(ims_info));

	for(i = 0; i < (sizeof(ims_info) - 1); i++)
	{
		SetInfoBuffer[i+1] = ims_info[i];	//data
	}

	xil_printf("new data: ");
	for(i = 0; i < (INFO_BUFFER_SIZE + 1); i++)
	{
		xil_printf("%c", SetInfoBuffer[i]);
	}
	xil_printf("\n\r");

	SetInfoBuffer[0] = 0x08;			//offset

	xil_printf("    data:  ");
	for(i = 1; i < (INFO_BUFFER_SIZE + 1); i++)
	{
		xil_printf("%c",SetInfoBuffer[i]);
	}
	xil_printf("\n\r");

	Status = XIicPs_MasterSendPolled(&Iic, SetInfoBuffer,
			(INFO_BUFFER_SIZE + 1), IIC_SLAVE_ADDR);
	if (Status != XST_SUCCESS) {
		xil_printf("david0719: %s:%s(%d) ffff b\r\n",__FILE__,__func__,__LINE__);
		return XST_FAILURE;
	}

	return XST_SUCCESS;
}

int XIicPs_GetInfo()
{
	int Status;
	int Index;

	for (Index = 0; Index < INFO_BUFFER_SIZE; Index++) {
		GetInfoBuffer[Index] = '-';
	}

	SendBuffer[0] = 0x08;	//offset
	/*
	 * Send the buffer using the IIC and ignore the number of bytes sent
	 * as the return value since we are using it in interrupt mode.
	 */

	Status = XIicPs_MasterSendPolled(&Iic, SendBuffer,
			1, IIC_SLAVE_ADDR);

	if (Status != XST_SUCCESS) {
		xil_printf("david0719: %s:%s(%d) ffff b\r\n",__FILE__,__func__,__LINE__);
		return XST_FAILURE;
	}

	/*
	 * Wait until bus is idle to start another transfer.
	 */
	while (XIicPs_BusIsBusy(&Iic)) {
		/* NOP */
	}

	Status = XIicPs_MasterRecvPolled(&Iic, GetInfoBuffer,
			INFO_BUFFER_SIZE, IIC_SLAVE_ADDR);
	if (Status != XST_SUCCESS) {
		return XST_FAILURE;
	}

	for (Index = 0; Index < INFO_BUFFER_SIZE; Index++) {
		if(isprint(GetInfoBuffer[Index]))
			xil_printf("%c", GetInfoBuffer[Index]);
		else
			xil_printf("^");
	}
	xil_printf("+++++\n\r");

	return XST_SUCCESS;
}

void ShowDateInfo(u8 *RecvBuffer)
{
	int i = 0;
	xil_printf("\n\rRTC data: \t0x ", i++);
	for (i = 0; i < I2C_BUFFER_SIZE; i++) {
		xil_printf("%02X ",RecvBuffer[i]);
	}
	xil_printf("\t");
	u8 ampm = 0;	//default is 24HR
	ampm = (RecvBuffer[2] >> 6) & 0x01;
	if(ampm == 1)
		xil_printf("12HR\n\r");
	else
		xil_printf("24HR\n\r");

	u8 seconds = (((RecvBuffer[0] >> 4) & 0x07) * 10) + (RecvBuffer[0] & 0x0f);
	u8 minutes = (((RecvBuffer[1] >> 4) & 0x07) * 10) + (RecvBuffer[1] & 0x0f);
	//u8 hour = (((RecvBuffer[2] >> 4) & 0x07) * 10) + (RecvBuffer[2] & 0x0f);
	u8 hour;
	if(ampm == 1)
		hour = (((RecvBuffer[2] >> 4) & 0x01) * 10) + (RecvBuffer[2] & 0x0f);
	else
		hour = (((RecvBuffer[2] >> 4) & 0x03) * 10) + (RecvBuffer[2] & 0x0f);

	u8 day = RecvBuffer[3] & 0x07;
	u8 date = (((RecvBuffer[4] >> 4) & 0x03) * 10) + (RecvBuffer[4] & 0x0f);
	u8 month = (((RecvBuffer[5] >> 4) & 0x01) * 10) + (RecvBuffer[5] & 0x0f);
	u32 year = (((RecvBuffer[6] >> 4) & 0x0f) * 10) + (RecvBuffer[6] & 0x0f) + 2000;

	xil_printf("\n\r");

	//xil_printf("raw data: %d/%d/%d %d %02d:%02d:%02d\r\n", RecvBuffer[6], RecvBuffer[5], RecvBuffer[4], RecvBuffer[3], RecvBuffer[2], RecvBuffer[1], RecvBuffer[0]);
	//xil_printf("new data: %d/%d/%d %d %02d:%02d:%02d\r\n", year, month, date, day, hour, minutes, seconds);
	xil_printf("Date: %02d/%02d/%02d ", year, month, date);
	switch(day)
	{
	case 0:		xil_printf("Sun");	break;
	case 1:		xil_printf("Mon");	break;
	case 2:		xil_printf("Tue");	break;
	case 3:		xil_printf("Wed");	break;
	case 4:		xil_printf("Thu");	break;
	case 5:		xil_printf("Fri");	break;
	case 6:		xil_printf("Sat");	break;
	case 7:		xil_printf("Sun");	break;
	default:	xil_printf("Mon");	break;
	}
	xil_printf(" %02d:%02d:%02d\t\t", hour, minutes, seconds);
}

void get_RTC_data()
{
	int Index;
	int Status;
	SendBuffer[0] = 0;

	for (Index = 0; Index < I2C_BUFFER_SIZE; Index++) {
		RecvBuffer[Index] = 0;
	}

	/*
	 * Send the buffer using the IIC and ignore the number of bytes sent
	 * as the return value since we are using it in interrupt mode.
	 */

	Status = XIicPs_MasterSendPolled(&Iic, SendBuffer,
			1, IIC_SLAVE_ADDR);

	if (Status != XST_SUCCESS) {
		xil_printf("david0719: %s:%s(%d) ffff b\r\n",__FILE__,__func__,__LINE__);
		return;
	}

	/*
	 * Wait until bus is idle to start another transfer.
	 */
	while (XIicPs_BusIsBusy(&Iic)) {
		/* NOP */
	}

	Status = XIicPs_MasterRecvPolled(&Iic, RecvBuffer,
			I2C_BUFFER_SIZE, IIC_SLAVE_ADDR);
	if (Status != XST_SUCCESS) {
		return;
	}

	u8 ampm = 0;	//default is 24HR
	ampm = (RecvBuffer[2] >> 6) & 0x01;

	rtc.tm_sec    = (((RecvBuffer[0] >> 4) & 0x07) * 10) + (RecvBuffer[0] & 0x0f);
	rtc.tm_min    = (((RecvBuffer[1] >> 4) & 0x07) * 10) + (RecvBuffer[1] & 0x0f);

	if(ampm == 1)
		rtc.tm_hour = (((RecvBuffer[2] >> 4) & 0x01) * 10) + (RecvBuffer[2] & 0x0f);
	else
		rtc.tm_hour = (((RecvBuffer[2] >> 4) & 0x03) * 10) + (RecvBuffer[2] & 0x0f);

	rtc.tm_wday   =    RecvBuffer[3] & 0x07;
	rtc.tm_mday   = (((RecvBuffer[4] >> 4) & 0x03) * 10) + (RecvBuffer[4] & 0x0f);
	rtc.tm_mon    = (((RecvBuffer[5] >> 4) & 0x01) * 10) + (RecvBuffer[5] & 0x0f);
	rtc.tm_year   = (((RecvBuffer[6] >> 4) & 0x0f) * 10) + (RecvBuffer[6] & 0x0f) + 100;

#ifdef USE_CORRECT_TIME
#ifdef USE_PREVENT_REUSE
	if(rtc.tm_year < 120)
	{
		xil_printf("david0106: %s:%s(%d) year = %d\r\n",__FILE__,__func__,__LINE__, rtc.tm_year);
		xil_printf("david0106: %s:%s(%d) month = %d\r\n",__FILE__,__func__,__LINE__, rtc.tm_mon);
		xil_printf("tick(%d) = %d;\t%%%s:%s(%d) system bootup time : %s\tRTC fails\r\n", tick_cnt++, g_ms_tick, __FILE__,__func__,__LINE__, asctime(&rtc));
		flag_battery_fail = TRUE;
	}
	else
#endif
#endif
	{
		//xil_printf("\n\rsystem bootup time : %s\n\r", asctime(&rtc));
		xil_printf("tick(%d) = %d;\t%%%s:%s(%d) system bootup time : %s\r\n", tick_cnt++, g_ms_tick, __FILE__,__func__,__LINE__, asctime(&rtc));
		rtc_bootup = rtc;
		rtc_bootup.tm_mon = rtc_bootup.tm_mon - 1;

		//xil_printf("new data: %d/%d/%d %d %02d:%02d:%02d\r\n", rtc.tm_year, rtc.tm_mon, rtc.tm_mday, rtc.tm_wday, rtc.tm_hour, rtc.tm_min, rtc.tm_sec);
#ifdef USE_CORRECT_TIME
#ifdef USE_PREVENT_REUSE
		flag_battery_fail = FALSE;
#endif
#endif
	}
	return;
}

int flag_show_warning = 0;

int update_RTC_data()
{
	int Index;
	int Status;
	SendBuffer[0] = 0;

	for (Index = 0; Index < I2C_BUFFER_SIZE; Index++) {
		RecvBuffer[Index] = 0;
	}

	/*
	 * Send the buffer using the IIC and ignore the number of bytes sent
	 * as the return value since we are using it in interrupt mode.
	 */

	Status = XIicPs_MasterSendPolled(&Iic, SendBuffer,
			1, IIC_SLAVE_ADDR);

	if (Status != XST_SUCCESS) {
		xil_printf("david0719: %s:%s(%d) ffff b\r\n",__FILE__,__func__,__LINE__);
		return XST_FAILURE;
	}

	/*
	 * Wait until bus is idle to start another transfer.
	 */
	while (XIicPs_BusIsBusy(&Iic)) {
		/* NOP */
	}

	Status = XIicPs_MasterRecvPolled(&Iic, RecvBuffer,
			I2C_BUFFER_SIZE, IIC_SLAVE_ADDR);
	if (Status != XST_SUCCESS) {
		return XST_FAILURE;
	}

	//XIicPs_GetInfo();
	return XST_SUCCESS;
}

//int cccc = 0;

u8 bootup_time = 1;
u8 seconds_old = 0;
u8 minutes_old = 0;
u8 hour_old = 0;
u8 day_old = 0;
u8 date_old = 0;
u8 month_old = 0;
u32 year_old = 0;

u8 seconds_eng = 0;
u8 minutes_eng = 0;
u8 hour_eng = 0;
u8 day_eng = 0;
u8 date_eng = 0;
u8 month_eng = 0;
u32 year_eng = 0;

void update_widget_data(u8 *RecvBuffer)
{
	GWidgetInit	wi;

	// Apply some default values for GWIN
	gwinWidgetClearInit(&wi);
	wi.g.show = TRUE;
	wi.text = "12345678901234567890123456789012345678901234567890";

	gwinSetDefaultFont(gdispOpenFont("iskpota232"));

#ifdef USE_RTC
	int weekday = 0;
	coord_t wide = 300;		//reserved for 1 framebuffer
	u8 ampm = 0;	//default is 24HR
	ampm = (RecvBuffer[2] >> 6) & 0x01;
	/*
	if(ampm == 1)
		xil_printf("12HR\n\r");
	else
		xil_printf("24HR\n\r");
	*/

	rtc.tm_sec    = (((RecvBuffer[0] >> 4) & 0x07) * 10) + (RecvBuffer[0] & 0x0f);
	rtc.tm_min    = (((RecvBuffer[1] >> 4) & 0x07) * 10) + (RecvBuffer[1] & 0x0f);
	//rtc.tm_hour   = (((RecvBuffer[2] >> 4) & 0x07) * 10) + (RecvBuffer[2] & 0x0f);
	//rtc.tm_hour   = (((RecvBuffer[2] >> 4) & 0x01) * 10) + (RecvBuffer[2] & 0x0f);

	if(ampm == 1)
		rtc.tm_hour = (((RecvBuffer[2] >> 4) & 0x01) * 10) + (RecvBuffer[2] & 0x0f);
	else
		rtc.tm_hour = (((RecvBuffer[2] >> 4) & 0x03) * 10) + (RecvBuffer[2] & 0x0f);

	rtc.tm_wday   =    RecvBuffer[3] & 0x07;
	rtc.tm_mday   = (((RecvBuffer[4] >> 4) & 0x03) * 10) + (RecvBuffer[4] & 0x0f);
	rtc.tm_mon    = (((RecvBuffer[5] >> 4) & 0x01) * 10) + (RecvBuffer[5] & 0x0f);
	rtc.tm_year   = (((RecvBuffer[6] >> 4) & 0x0f) * 10) + (RecvBuffer[6] & 0x0f) + 100;

	//xil_printf("raw data: %d/%d/%d %d %02d:%02d:%02d\r\n", RecvBuffer[6], RecvBuffer[5], RecvBuffer[4], RecvBuffer[3], RecvBuffer[2], RecvBuffer[1], RecvBuffer[0]);
	//xil_printf("new data: %d/%d/%d %d %02d:%02d:%02d\r\n", rtc.tm_year, rtc.tm_mon, rtc.tm_mday, rtc.tm_wday, rtc.tm_hour, rtc.tm_min, rtc.tm_sec);

	if(flag_engineering_mode == TRUE)
	{
		font_t font = gdispOpenFont("iskpota232");

		/*
		xil_printf("year : %d\n\r", rtc.tm_year);
		xil_printf("month : %d\n\r", rtc.tm_mon);
		xil_printf("mday : %d\n\r", rtc.tm_mday);
		xil_printf("wday : %d\n\r", rtc.tm_wday);
		xil_printf("hour : %d\n\r", rtc.tm_hour);
		xil_printf("minute : %d\n\r", rtc.tm_min);
		xil_printf("second : %d\n\r", rtc.tm_sec);
		*/

	    char str[40];
	    if(engineering_mode_setup_item == 1)
	    	sprintf(str, "%ld", year_eng + 1900);
	    else
	    	sprintf(str, "%d", rtc.tm_year + 1900);
		gdispFillArea(COLUMN1 + 120, ROW1, 100, 40, Black);
	    if(engineering_mode_setup_item == 1)
	    	gdispFillString(COLUMN1 + 120, ROW1, str, font, White, Red);
	    else
	    	gdispDrawString(COLUMN1 + 120, ROW1, str, font, Red);

	    if(engineering_mode_setup_item == 2)
	    	sprintf(str, "%d", month_eng);
	    else
	    	sprintf(str, "%d", rtc.tm_mon);
    	gdispFillArea(COLUMN1 + 120, ROW2, 100, 40, Black);
	    if(engineering_mode_setup_item == 2)
	    	gdispFillString(COLUMN1 + 120, ROW2, str, font, White, Red);
	    else
	    	gdispDrawString(COLUMN1 + 120, ROW2, str, font, Red);

	    if(engineering_mode_setup_item == 3)
	    	sprintf(str, "%d", date_eng);
	    else
    	sprintf(str, "%d", rtc.tm_mday);
	    gdispFillArea(COLUMN1 + 120, ROW3, 100, 40, Black);
	    if(engineering_mode_setup_item == 3)
	    	gdispFillString(COLUMN1 + 120, ROW3, str, font, White, Red);
	    else
	    	gdispDrawString(COLUMN1 + 120, ROW3, str, font, Red);

	    if(engineering_mode_setup_item == 4)
	    	weekday =  day_eng;
	    else
	    	weekday = rtc.tm_wday;

	    switch(weekday)
		{
		case 0:		sprintf(str, "%s", "Sun");	break;
		case 1:		sprintf(str, "%s", "Mon");	break;
		case 2:		sprintf(str, "%s", "Tue");	break;
		case 3:		sprintf(str, "%s", "Wed");	break;
		case 4:		sprintf(str, "%s", "Thu");	break;
		case 5:		sprintf(str, "%s", "Fri");	break;
		case 6:		sprintf(str, "%s", "Sat");	break;
		case 7:		sprintf(str, "%s", "Sun");	break;
		default:	sprintf(str, "%s", "Mon");	break;
		}
		gdispFillArea(COLUMN1 + 120, ROW4, 100, 40, Black);
	    if(engineering_mode_setup_item == 4)
	    	gdispFillString(COLUMN1 + 120, ROW4, str, font, White, Red);
	    else
	    	gdispDrawString(COLUMN1 + 120, ROW4, str, font, Red);

	    if(engineering_mode_setup_item == 5)
	    	sprintf(str, "%d", hour_eng);
	    else
    	sprintf(str, "%d", rtc.tm_hour);
		gdispFillArea(COLUMN1 + 120, ROW5, 100, 40, Black);
	    if(engineering_mode_setup_item == 5)
	    	gdispFillString(COLUMN1 + 120, ROW5, str, font, White, Red);
	    else
	    	gdispDrawString(COLUMN1 + 120, ROW5, str, font, Red);

	    if(engineering_mode_setup_item == 6)
	    	sprintf(str, "%d", minutes_eng);
	    else
	    	sprintf(str, "%d", rtc.tm_min);
	    gdispFillArea(COLUMN1 + 120, ROW6, 100, 40, Black);
	    if(engineering_mode_setup_item == 6)
	    	gdispFillString(COLUMN1 + 120, ROW6, str, font, White, Red);
	    else
	    	gdispDrawString(COLUMN1 + 120, ROW6, str, font, Red);

	    if(engineering_mode_setup_item == 7)
	    	sprintf(str, "%d", seconds_eng);
	    else
	    	sprintf(str, "%d", rtc.tm_sec);
	    gdispFillArea(COLUMN1 + 120, ROW7, 100, 40, Black);
	    if(engineering_mode_setup_item == 7)
	    	gdispFillString(COLUMN1 + 120, ROW7, str, font, White, Red);
	    else
	    	gdispDrawString(COLUMN1 + 120, ROW7, str, font, Red);
	}

	// Create label
	if(flag_use_2_framebuffers == TRUE)
	{
	bootup_time = 0;
	wi.g.width = WIDTH1 + 10; wi.g.height = THICK1; wi.g.x = BORDER_X; wi.g.y = BORDER_Y + THICK1 * 7;
	//wi.text = "";
	sprintf((char *)wi.text, "%02d/%02d/%4d", rtc.tm_mon, rtc.tm_mday, rtc.tm_year + 1900);
	rtc.tm_mon -= 1;	//for asctime
	ghLabel4 = gwinLabelCreate(0, &wi);

#ifdef USE_DATA_INPUT
	wi.g.width = CAMERA_INFO_WIDTH3; wi.g.height = THICK1; wi.g.x = CAMERA_INFO_POS_X3; wi.g.y = CAMERA_INFO_POS_Y2;
	ghLabel4 = gwinLabelCreate(0, &wi);
#endif

	// Create label
	wi.g.width = WIDTH5; wi.g.height = THICK1; wi.g.x = BORDER_X + WIDTH1 + 10; wi.g.y = BORDER_Y + THICK1 * 7;
	//wi.text = "";
	switch(rtc.tm_wday)
	{
	case 0:		sprintf((char *)wi.text, "%s", "Sun");	break;
	case 1:		sprintf((char *)wi.text, "%s", "Mon");	break;
	case 2:		sprintf((char *)wi.text, "%s", "Tue");	break;
	case 3:		sprintf((char *)wi.text, "%s", "Wed");	break;
	case 4:		sprintf((char *)wi.text, "%s", "Thu");	break;
	case 5:		sprintf((char *)wi.text, "%s", "Fri");	break;
	case 6:		sprintf((char *)wi.text, "%s", "Sat");	break;
	case 7:		sprintf((char *)wi.text, "%s", "Sun");	break;
	default:	sprintf((char *)wi.text, "%s", "Mon");	break;
	}

	ghLabel5 = gwinLabelCreate(0, &wi);

#ifdef USE_DATA_INPUT
	wi.g.width = 60; wi.g.height = THICK1; wi.g.x = CAMERA_INFO_POS_X3 + 160; wi.g.y = CAMERA_INFO_POS_Y2;
	ghLabel5 = gwinLabelCreate(0, &wi);
#endif

	// Create label
	wi.g.width = CAMERA_INFO_WIDTH3; wi.g.height = THICK1; wi.g.x = BORDER_X; wi.g.y = BORDER_Y + THICK1 * 8;
	//wi.text = "";
	sprintf((char *)wi.text, "%02d:%02d:%02d", rtc.tm_hour, rtc.tm_min, rtc.tm_sec);
	ghLabel6 = gwinLabelCreate(0, &wi);

#ifdef USE_DATA_INPUT
	wi.g.width = CAMERA_INFO_WIDTH3; wi.g.height = THICK1; wi.g.x = CAMERA_INFO_POS_X3; wi.g.y = CAMERA_INFO_POS_Y3;
	ghLabel6 = gwinLabelCreate(0, &wi);
#endif
	}
	else
	{
	if((rtc.tm_min != minutes_old) || (bootup_time == 1))
	{
	bootup_time = 0;
	wi.g.width = WIDTH1 + 10; wi.g.height = THICK1; wi.g.x = BORDER_X; wi.g.y = BORDER_Y + THICK1 * 7;
	//wi.text = "";
	sprintf((char *)wi.text, "%02d/%02d/%4d", rtc.tm_mon, rtc.tm_mday, rtc.tm_year + 1900);
	rtc.tm_mon -= 1;	//for asctime
	ghLabel4 = gwinLabelCreate(0, &wi);

	// Create label
	wi.g.width = WIDTH5; wi.g.height = THICK1; wi.g.x = BORDER_X + WIDTH1 + 10; wi.g.y = BORDER_Y + THICK1 * 7;
	//wi.text = "";
	switch(rtc.tm_wday)
	{
	case 0:		sprintf((char *)wi.text, "%s", "Sun");	break;
	case 1:		sprintf((char *)wi.text, "%s", "Mon");	break;
	case 2:		sprintf((char *)wi.text, "%s", "Tue");	break;
	case 3:		sprintf((char *)wi.text, "%s", "Wed");	break;
	case 4:		sprintf((char *)wi.text, "%s", "Thu");	break;
	case 5:		sprintf((char *)wi.text, "%s", "Fri");	break;
	case 6:		sprintf((char *)wi.text, "%s", "Sat");	break;
	case 7:		sprintf((char *)wi.text, "%s", "Sun");	break;
	default:	sprintf((char *)wi.text, "%s", "Mon");	break;
	}

	ghLabel5 = gwinLabelCreate(0, &wi);

	// Create label
	wi.g.width = WIDTH1; wi.g.height = THICK1; wi.g.x = BORDER_X; wi.g.y = BORDER_Y + THICK1 * 8;
	//wi.text = "";
	sprintf((char *)wi.text, "%02d:%02d:%02d", rtc.tm_hour, rtc.tm_min, rtc.tm_sec);
	ghLabel6 = gwinLabelCreate(0, &wi);
	}
	else
	{
		/*
						// Create label
						wi.g.width = wide; wi.g.height = thick; wi.g.x = BORDER_X; wi.g.y = BORDER_Y + thick * 8;
						wi.text = "";
						sprintf((char *)wi.text, "%02d:%02d:%02d", rtc.tm_hour, rtc.tm_min, rtc.tm_sec);
						ghLabel6 = gwinLabelCreate(0, &wi);
		*/

		if(((rtc.tm_sec % 10) == 0) || (abs(rtc.tm_sec, seconds_old) > 1))
		{
			wi.g.width = wide - 84 - 10; wi.g.height = THICK1; wi.g.x = BORDER_X + 84; wi.g.y = BORDER_Y + THICK1 * 8;
			//wi.text = "";
			sprintf((char *)wi.text, "%02d", rtc.tm_sec);
			ghLabel6 = gwinLabelCreate(0, &wi);
		}
		else
		{
			wi.g.width = wide - 84 - 15 - 10; wi.g.height = THICK1; wi.g.x = BORDER_X + 84 + 15; wi.g.y = BORDER_Y + THICK1 * 8;
			//wi.text = "";
			sprintf((char *)wi.text, "%d", (rtc.tm_sec%10));
			ghLabel6 = gwinLabelCreate(0, &wi);
		}
	}
	}

#ifdef USE_ANALOG_CLOCK
    //center
    int cx = 400;
    int cy = 400;

    //get time
    int ss = rtc.tm_sec;
    int mm = rtc.tm_min;
    int hh = rtc.tm_hour;
    int handCoord[2];

	gdispFillCircle(cx, cy, 98, Black);
	gdispDrawCircle(cx, cy, 100, Gray);

	//font_t font = font = gdispOpenFont("DejaVuSansBold12");
	font_t font = font = gdispOpenFont("iskpota232");

	gdispFillString(392, 305, "12", font, Gray, Black);
	gdispFillString(489, 393, "3", font, Gray, Black);
	gdispFillString(395, 485, "6", font, Gray, Black);
	gdispFillString(304, 393, "9", font, Gray, Black);

    //second hand
    handCoord[0] = ss_coord[ss][0];
    handCoord[1] = ss_coord[ss][1];
    gdispDrawLine(cx, cy, cx + handCoord[0], cy + handCoord[1], Red);

    //minute hand
    handCoord[0] = mm_coord[mm][0];
    handCoord[1] = mm_coord[mm][1];
    gdispDrawLine(cx, cy, cx + handCoord[0], cy + handCoord[1], Magenta);

    //hour hand
    handCoord[0] = hh_coord[hh % 12][0];
    handCoord[1] = hh_coord[hh % 12][1];
    gdispDrawLine(cx, cy, cx + handCoord[0], cy + handCoord[1], Cyan);

#endif
#endif

#ifdef USE_PREVENT_REUSE

    //check_use_time_seconds = 0;
    //camera_use_time_this

	if((g_conn_status == CAMERA_OK) && (flag_forbid_video == FALSE))
	{
		if((g_procedure_started == START) && (flag_camera_status == CAMERA_NEW))
		{
			//xil_printf("david0507a1: %s:%s(%d) flag_camera_status = %d   camera_use_time_this = %d\r\n",__FILE__,__func__,__LINE__,flag_camera_status,camera_use_time_this);
			if(camera_use_time_this == 60)
			{
				flag_camera_status = CAMERA_1M;
				show_camera_date(1);
				write_date_to_camera(DATE_PAGE1);
				flag_updateShowCameraDate = 1;
			}
			#ifdef USE_RTC
			if(seconds_old != rtc.tm_sec)
			{
				//xil_printf("%d ", camera_use_time_this);
				xil_printf("david0529: %s:%s(%d) ST\r\n",__FILE__,__func__,__LINE__);
				print_time0(camera_use_time_this);
				camera_use_time_this++;
				if(abs_sec(rtc.tm_sec, seconds_old) > 1)
				{
					//xil_printf("axxx new = %d old = %d\n\r", rtc.tm_sec, seconds_old);
				}
			}
			#endif
		}
		else if(flag_camera_status == CAMERA_1M)
		{
			xil_printf("david0507a2: %s:%s(%d) flag_camera_status = %d   camera_use_time_this = %d\r\n",__FILE__,__func__,__LINE__,flag_camera_status,camera_use_time_this);
			if(camera_use_time_this >= TWO_HOURS * 60)
			{

				xil_printf("david0507b: %s:%s(%d) flag_camera_status = %d   camera_use_time_this = %d\r\n",__FILE__,__func__,__LINE__,flag_camera_status,camera_use_time_this);

				/*
				GWidgetInit	wi;

				gwinWidgetClearInit(&wi);
				wi.g.show = TRUE;
				wi.text = "123456789012345678901234567890";

				wi.g.width = WIDTH2; wi.g.height = THICK1; wi.g.x = CAMERA_INFO_POS_X1; wi.g.y = CAMERA_INFO_POS_Y3;

				if(flag_show_warning == 0)
				{
					flag_show_warning = 1;
					sprintf((char *)wi.text, "EGD is expired.");
				}
				else
				{
					flag_show_warning = 0;
					sprintf((char *)wi.text, " ");
				}
				ghLabel6 = gwinLabelCreate(0, &wi);
				*/

				if(flag_show_warning == 0)
				{
					//xil_printf("david0115: %s:%s(%d) EGD message ON\r\n",__FILE__,__func__,__LINE__);
					flag_show_warning = 1;
					font_t font = gdispOpenFont("iskpota232");
					gdispDrawString(CAMERA_INFO_POS_X2 + 100, CAMERA_INFO_POS_Y1, "EGD is expired.", font, Red);
				}
				else
				{
					//xil_printf("david0115: %s:%s(%d) EGD message OFF\r\n",__FILE__,__func__,__LINE__);
					flag_show_warning = 0;
					gdispFillArea(CAMERA_INFO_POS_X2 + 100, CAMERA_INFO_POS_Y1, CAMERA_INFO_WIDTH3, THICK1, Black);
				}
			}

			if((camera_use_time_this % 60) == 0)	//check use time every 60 sec
			{
				//camera_use_time = get_camera_use_time();
				xil_printf("\n\r%ld sec\n\r", camera_use_time_this + 60);
				//print_time0(camera_use_time_this);

				if(camera_use_time_this >= (TWO_HOURS + 1) * 60)
				{
					xil_printf("check 1 min : Forbid video, use too long, time = %ld sec = %ld min %ld sec\n\r", camera_use_time_this, camera_use_time_this / 60, camera_use_time_this % 60);
					write_date_to_camera(DATE_PAGE3);
					flag_camera_invalid = TRUE;
					flag_video_status = VIDEO_FORBID_USE_2HR;
					flag_camera_status = CAMERA_2HR;
					flag_forbid_video = TRUE;
					forbid_video(flag_video_status);
					//sleep(2);	//must > 1
					//write_error_code_to_camera(flag_video_status);
					forbid_camera_cnt = 5;
					xil_printf("david0529: %s:%s(%d) ST\r\n",__FILE__,__func__,__LINE__);
					print_time0(camera_use_time_this);
					flag_show_print_time = TRUE;
					flag_updateShowCameraDate = 1;
				}
			}
			#ifdef USE_RTC
			if(seconds_old != rtc.tm_sec)
			{
				//xil_printf("%d ", camera_use_time_this);
				xil_printf("david0529: %s:%s(%d) ST flag_video_status = %d\r\n",__FILE__,__func__,__LINE__, flag_video_status);
				if(flag_video_status == VIDEO_OK)
					print_time0(camera_use_time_this);
				camera_use_time_this++;
				if(abs_sec(rtc.tm_sec, seconds_old) > 1)
				{
					//xil_printf("bxxx new = %d old = %d\n\r", rtc.tm_sec, seconds_old);
				}

			}
			#endif
		}
	}
	//else if((g_procedure_started == START) && (g_conn_status == CAMERA_OK) && (flag_forbid_video == TRUE))
	else if((g_conn_status == CAMERA_OK) && (flag_forbid_video == TRUE))
	{
		//xil_printf("david0507a3: %s:%s(%d) flag_camera_status = %d   camera_use_time_this = %d\r\n",__FILE__,__func__,__LINE__,flag_camera_status,camera_use_time_this);
		#ifdef USE_RTC
		if(flag_show_print_time == TRUE)
		{
			if(seconds_old != rtc.tm_sec)
			{
				xil_printf("david0529: %s:%s(%d) ST\r\n",__FILE__,__func__,__LINE__);
				print_time0(camera_use_time_this);
				camera_use_time_this++;
				if(abs_sec(rtc.tm_sec, seconds_old) > 1)
				{
					xil_printf("cxxx new = %d old = %d\n\r", rtc.tm_sec, seconds_old);
				}
			}
		}
		#endif

		if(forbid_camera_cnt > 0)
			forbid_camera_cnt++;
		if(forbid_camera_cnt == 10)
		{
			xil_printf("\n\rwrite_error_code_to_camera\t%s  flag_video_status = %d\n\r", asctime(&rtc), flag_video_status);
			forbid_camera_cnt = 0;
			write_error_code_to_camera(flag_video_status);
		}

	}
	#endif

#ifdef USE_RTC
	seconds_old = rtc.tm_sec;
	minutes_old = rtc.tm_min;
	hour_old = rtc.tm_hour;
	day_old = rtc.tm_wday;
	date_old = rtc.tm_mday;
	month_old = rtc.tm_mon;
	year_old = rtc.tm_year;

	if((rtc.tm_year == 119) && (rtc.tm_mon < 5))
	{
		wi.g.width = 500; wi.g.height = THICK1; wi.g.x = BORDER_X; wi.g.y = BORDER_Y + THICK1 * 7;
		//wi.text = "";
		sprintf((char *)wi.text, "Battery fails, please replace the battery.");
		ghLabel4 = gwinLabelCreate(0, &wi);

		wi.g.width = 500; wi.g.height = THICK1; wi.g.x = BORDER_X; wi.g.y = BORDER_Y + THICK1 * 8;
		//wi.text = "";
		sprintf((char *)wi.text, "Battery fails, please replace the battery.");
		ghLabel6 = gwinLabelCreate(0, &wi);
	}
#endif

#ifdef USE_DEBUG_MESSAGE
	u32 TempRawData;
	float TempData;

	if(temperature_current == 0)
		return;

	TempRawData = temperature_current;
	TempData = XAdcPs_RawToTemperature(TempRawData);

	wi.g.width = 180; wi.g.height = THICK1; wi.g.x = BORDER_X + 150; wi.g.y = BORDER_Y + THICK1 * 10;
	//wi.text = "";
	sprintf((char *)wi.text, "T: %0d.%03d  C", (int)(TempData), XAdcFractionToInt(TempData));
	ghLabel6 = gwinLabelCreate(0, &wi);
	gdispDrawCircle(wi.g.x + 140 , wi.g.y, 5, White);
#endif

	if(flag_engineering_mode == TRUE)
	{
		u32 TempRawData;
		float TempData;

		if(temperature_current == 0)
			return;

		TempRawData = temperature_current;
		TempData = XAdcPs_RawToTemperature(TempRawData);

		char str[40];
		font_t font = gdispOpenFont("iskpota232");

	   	sprintf(str, "T: %0d.%03d  C", (int)(TempData), XAdcFractionToInt(TempData));
	    gdispFillArea(COLUMN4, ROW7, 180, 40, Black);
		gdispDrawString(COLUMN4, ROW7, str, font, White);
	   	gdispDrawCircle(COLUMN4 + 140, ROW7, 4, White);


		unsigned long difftime_bootup = 0;
		difftime_bootup = diff_time(rtc, rtc_bootup);
		//xil_printf("Bootup ellapsed : %ld sec\r\n", difftime_bootup);

		sprintf(str, "Ellapsed :");
		gdispFillArea(COLUMN2, ROW11 - 8, 480, 40, Black);
		gdispDrawString(COLUMN2, ROW11, str, font, Red);

		print_time_eng(difftime_bootup);

	}
	return;
}

int XIicPs_ReadEepromData(uint16_t page, uint16_t addr, uint16_t len, u8 *Buffer)
{
	int Status;
	int Index;

	//xil_printf("XIicPs_ReadEepromData\n\r");

	xil_printf("XIicPs_ReadEepromData page = %d addr = %d len = %d\n\r", page, addr, len);
	if((page < 0) || (page > 31))
	{
		xil_printf("XIicPs_ReadEepromData parameter error, page=%d\n\r", page);
		return XST_FAILURE;
	}

	if((addr < 0) || (addr > 1023))
	{
		xil_printf("XIicPs_ReadEepromData parameter error, addr = %d\n\r", addr);
		return XST_FAILURE;
	}

	if((len < 0) || (len > 1024))
	{
		xil_printf("XIicPs_ReadEepromData parameter error, len = %d\n\r", len);
		return XST_FAILURE;
	}

	if((addr + len) > 1024)
	{
		xil_printf("XIicPs_ReadEepromData parameter error, addr = %d, len = %d, addr + len = %d\n\r", addr, len, addr + len);
		return XST_FAILURE;
	}

	if(Buffer == 0)
	{
		xil_printf("XIicPs_ReadEepromData parameter error, Buffer = null\n\r");
		return XST_FAILURE;
	}

	for (Index = 0; Index < len; Index++) {
		Buffer[Index] = '-';
	}

	//SendBuffer[0] = 0x00;	//offset
	//SendBuffer[1] = 0x00;	//offset

	SendBuffer[0] = (page << 2) | ((addr >> 8) & 0x03);	//offset
	SendBuffer[1] = addr & 0xff;	//offset

	/*
	 * Send the buffer using the IIC and ignore the number of bytes sent
	 * as the return value since we are using it in interrupt mode.
	 */

	Status = XIicPs_MasterSendPolled(&Iic, SendBuffer,
			2, EEPROM_IIC_SLAVE_ADDR);

	if (Status != XST_SUCCESS) {
		xil_printf("david0719: %s:%s(%d) ffff b\r\n",__FILE__,__func__,__LINE__);
		return XST_FAILURE;
	}


	/*
	 * Wait until bus is idle to start another transfer.
	 */
	while (XIicPs_BusIsBusy(&Iic)) {
		/* NOP */
	}

	Status = XIicPs_MasterRecvPolled(&Iic, Buffer,
			len, EEPROM_IIC_SLAVE_ADDR);
	if (Status != XST_SUCCESS) {
		return XST_FAILURE;
	}

	/*
	for (Index = 0; Index < len; Index++) {
		if(isprint(Buffer[Index]))
			xil_printf("%c", Buffer[Index]);
		else
		{
			//xil_printf("^");
			xil_printf("%02x ", Buffer[Index]);
		}
	}
	xil_printf("+++++\n\r");
	*/

	return XST_SUCCESS;
}

int XIicPs_WriteEepromData(uint16_t page, uint16_t addr, uint16_t len, u8 *Buffer)
{
	int Status;
	int i;

	//xil_printf("XIicPs_WriteEepromData page = %d addr = %d len = %d\n\r", page, addr, len);
	if((page < 0) || (page > 31))
	{
		xil_printf("XIicPs_WriteEepromData parameter error, page=%d\n\r", page);
		return XST_FAILURE;
	}

	if((addr < 0) || (addr > 1023))
	{
		xil_printf("XIicPs_WriteEepromData parameter error, addr = %d\n\r", addr);
		return XST_FAILURE;
	}

	if((len < 0) || (len > 1023))
	{
		xil_printf("XIicPs_WriteEepromData parameter error, len = %d\n\r", len);
		return XST_FAILURE;
	}

	if((addr + len) > 1023)
	{
		xil_printf("XIicPs_WriteEepromData parameter error, addr = %d, len = %d, addr + len = %d\n\r", addr, len, addr + len);
		return XST_FAILURE;
	}

	if(Buffer == 0)
	{
		xil_printf("XIicPs_ReadEepromData parameter error, Buffer = null\n\r");
		return XST_FAILURE;
	}

	//copy data
	for(i = 0; i < len; i++)
	{
		SetInfoBuffer[i + 2] = Buffer[i];	//data
	}

	SetInfoBuffer[0] = (page << 2) | ((addr >> 8) & 0x03);	//offset
	SetInfoBuffer[1] = addr & 0xff;	//offset

	xil_printf("XIicPs_WriteEepromData page = %d addr = %d len = %d\n\r", page, addr, len);
	Status = XIicPs_MasterSendPolled(&Iic, SetInfoBuffer,
			(len + 2), EEPROM_IIC_SLAVE_ADDR);
	if (Status != XST_SUCCESS) {
		xil_printf("david0719: %s:%s(%d) fail b\r\n",__FILE__,__func__,__LINE__);
		return XST_FAILURE;
	}
	return XST_SUCCESS;
}

int XIicPs_ReadEepromPage(uint16_t page, u8 *eeprom_page_buffer)
{
	int Status;
	int Index;

	xil_printf("\n\rXIicPs_ReadEepromPage, page = %d\n\r", page);
	if((page < 0) || (page > 31))
	{
		xil_printf("XIicPs_ReadEepromPage parameter error, page=%d\n\r", page);
		return XST_FAILURE;
	}

	if(eeprom_page_buffer == 0)
	{
		xil_printf("XIicPs_ReadEepromPage parameter error, Buffer = null\n\r");
		return XST_FAILURE;
	}

	for (Index = 0; Index < INFO_BUFFER_SIZE; Index++) {
		eeprom_page_buffer[Index] = '-';
	}

	SendBuffer[0] = page << 2;	//offset
	SendBuffer[1] = 0;			//offset

	/*
	 * Send the buffer using the IIC and ignore the number of bytes sent
	 * as the return value since we are using it in interrupt mode.
	 */

	xil_printf("11");

	Status = XIicPs_MasterSendPolled(&Iic, SendBuffer,
			2, EEPROM_IIC_SLAVE_ADDR);

	if (Status != XST_SUCCESS) {
		xil_printf("david0719: %s:%s(%d) ffff b\r\n",__FILE__,__func__,__LINE__);
		return XST_FAILURE;
	}

	/*
	 * Wait until bus is idle to start another transfer.
	 */

	xil_printf("22");

	while (XIicPs_BusIsBusy(&Iic)) {
		/* NOP */
	}

	Status = XIicPs_MasterRecvPolled(&Iic, eeprom_page_buffer,
			INFO_BUFFER_SIZE, EEPROM_IIC_SLAVE_ADDR);
	if (Status != XST_SUCCESS) {
		return XST_FAILURE;
	}
	xil_printf("33");
	return XST_SUCCESS;
}

int XIicPs_EraseEepromPage(uint16_t page)
{
	int Status;
	int i;
	int j;
	int len = 64;
	int addr = 0;
	u8 Buffer[64];

	xil_printf("\n\rXIicPs_EraseEepromPage, page= %d\n\r", page);
	if((page < 0) || (page > 31))
	{
		xil_printf("XIicPs_EraseEepromPage parameter error, page=%d\n\r", page);
		return XST_FAILURE;
	}

	for(j = 0; j < (1024/64); j++)
	{
		//xil_printf("j = %d\n\r", j);
		addr = j * 64;
		for(i = 0; i < len; i++)
		{
			Buffer[i] = 0xFF;
			/*
			if(page < 26)
				Buffer[i] = 'A' + page;		//data
			else if(page == 26)
				Buffer[i] = '{';			//data
			else if(page == 27)
				Buffer[i] = '}';			//data
			else if(page == 28)
				Buffer[i] = '[';			//data
			else if(page == 29)
				Buffer[i] = ']';			//data
			else if(page == 30)
				Buffer[i] = '(';			//data
			else if(page == 31)
				Buffer[i] = ')';			//data
			*/
		}

		//copy data
		for(i = 0; i < len; i++)
		{
			SetInfoBuffer[i + 2] = Buffer[i];	//data
		}

		SetInfoBuffer[0] = (page << 2) | ((addr >> 8) & 0x03);	//offset
		SetInfoBuffer[1] = addr & 0xff;	//offset

		Status = XIicPs_MasterSendPolled(&Iic, SetInfoBuffer,
				(len + 2), EEPROM_IIC_SLAVE_ADDR);
		if (Status != XST_SUCCESS) {
			xil_printf("david0719: %s:%s(%d) fail b\r\n",__FILE__,__func__,__LINE__);
			return XST_FAILURE;
		}
		usleep(10000);
	}
	return XST_SUCCESS;
}

int XIicPs_EraseEeprom(uint16_t page, uint16_t addr0, uint16_t len)
{
	int Status;
	int i;
	int j;
	int burst_len = 64;
	int addr = 0;
	u8 Buffer[64];

	xil_printf("\n\rXIicPs_EraseEeprom, page= %d\n\r", page);
	if((page < 0) || (page > 31))
	{
		xil_printf("XIicPs_EraseEeprom parameter error, page=%d\n\r", page);
		return XST_FAILURE;
	}

	for(j = 0; j < (len/burst_len); j++)
	{
		addr = addr0 + j * burst_len;
		xil_printf("j = %d addr = %d\n\r", j, addr);
		for(i = 0; i < burst_len; i++)
		{
			//Buffer[i] = 0xFF;
			if(page < 26)
				Buffer[i] = 'A' + page;		//data
			else if(page == 26)
				Buffer[i] = '-';			//data
			else if(page == 27)
				Buffer[i] = '-';			//data
			else if(page == 28)
				Buffer[i] = '-';			//data
			else if(page == 29)
				Buffer[i] = '-';			//data
			else if(page == 30)
				Buffer[i] = '-';			//data
			else if(page == 31)
				Buffer[i] = '-';			//data
		}

		//copy data
		for(i = 0; i < burst_len; i++)
		{
			SetInfoBuffer[i + 2] = Buffer[i];	//data
		}

		SetInfoBuffer[0] = (page << 2) | ((addr >> 8) & 0x03);	//offset
		SetInfoBuffer[1] = addr & 0xff;	//offset

		Status = XIicPs_MasterSendPolled(&Iic, SetInfoBuffer,
				(burst_len + 2), EEPROM_IIC_SLAVE_ADDR);
		if (Status != XST_SUCCESS) {
			xil_printf("david0719: %s:%s(%d) fail b\r\n",__FILE__,__func__,__LINE__);
			return XST_FAILURE;
		}
		usleep(10000);
	}
	return XST_SUCCESS;
}

int XIicPs_WriteEepromPage(uint16_t page)
{
	int Status;
	int i;
	int j;
	int len = 64;
	int addr = 0;
	u8 Buffer[64];

	xil_printf("\n\rXIicPs_WriteEepromPage, page= %d\n\r", page);
	if((page < 0) || (page > 31))
	{
		xil_printf("XIicPs_WriteEepromPage parameter error, page=%d\n\r", page);
		return XST_FAILURE;
	}

	for(j = 0; j < (1024/64); j++)
	{
		//xil_printf("j = %d\n\r", j);
		addr = j * 64;

		for(i = 0; i < len; i++)
		{
			Buffer[i] = page;
		}

		//copy data
		for(i = 0; i < len; i++)
		{
			SetInfoBuffer[i + 2] = Buffer[i];	//data
		}

		SetInfoBuffer[0] = (page << 2) | ((addr >> 8) & 0x03);	//offset
		SetInfoBuffer[1] = addr & 0xff;	//offset

		Status = XIicPs_MasterSendPolled(&Iic, SetInfoBuffer,
				(len + 2), EEPROM_IIC_SLAVE_ADDR);
		if (Status != XST_SUCCESS) {
			xil_printf("david0719: %s:%s(%d) fail b\r\n",__FILE__,__func__,__LINE__);
			return XST_FAILURE;
		}
		usleep(10000);
	}
	return XST_SUCCESS;
}

int XIicPs_EraseEepromAll(void)
{
	int i;
	xil_printf("\n\rXIicPs_EraseEepromAll\n\r");
	for(i = 0; i< 32; i++)
	{
		XIicPs_EraseEepromPage(i);
	}
	return XST_SUCCESS;
}

int XIicPs_ReadEepromAll(void)
{
	int i;
	xil_printf("\n\rXIicPs_ReadEepromAll\n\r");
	for(i = 0; i< 32; i++)
	{
		xil_printf("page= %d\n\r", i);
		XIicPs_ReadEepromPage(i, eeprom_page_buffer);
		XIicPs_PrintPageData(i, eeprom_page_buffer);
	}
	return XST_SUCCESS;
}

int XIicPs_WriteEepromAll(void)
{
	int i;
	xil_printf("\n\rXIicPs_WriteEepromAll\n\r");
	for(i = 0; i< 32; i++)
	{
		XIicPs_WriteEepromPage(i);
	}
	return XST_SUCCESS;
}

uint32_t check_dongle_usage_count(void)
{
	uint32_t i;
	int state;
	xil_printf("\n\rXIicPs_ReadEepromPage, page = %d\n\r", 26);
	state = XIicPs_ReadEepromPage(26, eeprom_page_buffer);
	if(state == XST_FAILURE)
	{
		xil_printf("xxxxxxx I2C fail, try again\n\r");
		usleep(1000);
		state = XIicPs_ReadEepromPage(26, eeprom_page_buffer);
	}

	//XIicPs_PrintPageData(26, eeprom_page_buffer);
	for (i = 0; i < INFO_BUFFER_SIZE; i++) {
		if(eeprom_page_buffer[i] != 'X')
		{
			break;
		}
	}
	return i;
}

#ifdef USE_DEBUG_MESSAGE
void write_compile_time_count(void)
{
	XIicPs_WriteEepromData(27, 0, 8, (u8*)__TIME__);
	return;
}

uint32_t check_fw_write_count(void)
{
	int i;
	uint32_t cnt;
	int diff = 0;

	cnt = read_compile_time_count();

	xil_printf("power_on_count = %d\n\r", power_on_count);

	xil_printf("flash time :\t");
	for (i = 0; i < 8; i++) {
		xil_printf("%c", compile_time[i]);
	}
	xil_printf("\n\r");

	xil_printf("compile time :\t");

	const char * const txt2 = __TIME__;
	for(i = 0; i< 8; i++)
	{
		xil_printf("%c", txt2[i]);
	}

	for(i = 0; i< 8; i++)
	{
		if(compile_time[i] != txt2[i])
		{
			diff = 1;
			//xil_printf("different in i = %d\n\r", i);
			//xil_printf("write cnt = %d to eeprom\n\r", cnt);
			xil_printf("\tdifferent, count + 1\n\r");
			XIicPs_WriteEepromData(27, cnt + 8, 1, (u8*)"X");
			write_compile_time_count();
			if(cnt < 512)
				cnt++;
			XIicPs_EraseEeprom(27, 512, 512);
			power_on_count = 0;
			break;
		}
	}
	if(diff == 0)
	{
		xil_printf("\tthe same\n\r");
		//xil_printf("\tthe same power on count ++\n\r");
		increase_power_on_count();
	}
	return cnt;
}

uint32_t read_compile_time_count(void)
{
	uint32_t i;
	int compile_time_count = 0;
	int state;
	xil_printf("\n\rXIicPs_ReadEepromPage, page = %d\n\r", 27);
	state = XIicPs_ReadEepromPage(27, eeprom_page_buffer);
	xil_printf("aa");
	if(state == XST_FAILURE)
	{
		xil_printf("xxxxxxx I2C fail, try again\n\r");
		usleep(1000);
		state = XIicPs_ReadEepromPage(27, eeprom_page_buffer);
	}

	for (i = 0; i < 8; i++) {
		compile_time[i] = eeprom_page_buffer[i];
	}
	xil_printf("bb");

	for (i = 8; i < INFO_BUFFER_SIZE/2; i++) {
		if(eeprom_page_buffer[i] != 'X')
		{
			//xil_printf("break, i = %d\n\r", i);
			break;
		}
	}
	xil_printf("cc");
	compile_time_count = i - 8;

	for (i = 512; i < INFO_BUFFER_SIZE; i++) {
		if(eeprom_page_buffer[i] != 'P')
		{
			xil_printf("break, i = %d\n\r", i);
			break;
		}
	}
	xil_printf("dd");
	power_on_count = i - 512;

	return compile_time_count;
}
#endif

void XIicPs_PrintPageData(int page, u8 *eeprom_page_buffer)
{
	int i;
	//xil_printf("0123456789012345678901234567890123456789012345678901234567890123\n\r");

	switch(page)
	{
	case 25:	xil_printf("\n\rPage %d, recent use camera info\n\r", page);break;
	case 26:	xil_printf("\n\rPage %d, camera count ever used\n\r", page);break;
	case 27:	xil_printf("\n\rPage %d, compile time count / power on count\n\r", page);break;
	case 28:	xil_printf("\n\rPage %d, power on count every minute\n\r", page);break;
	default:	break;
	}

	for (i = 0; i < INFO_BUFFER_SIZE; i++)
	{
		if(((eeprom_page_buffer[1023] == 0xFF) && (i < 7)) && ((page == 25) || (page == 28)))
		{
			if(eeprom_page_buffer[0] == 0xFF)
			{
				//xil_printf("%c", eeprom_page_buffer[i]);
				xil_printf(".");
			}
			else
			{
				if(i == 0)
					xil_printf("Date : %d", eeprom_page_buffer[i] + 2000);
				else
					xil_printf("%02d", eeprom_page_buffer[i]);
				if((i == 0)||(i == 1))
					xil_printf("/");
				else if((i == 4)||(i == 5))
					xil_printf(":");
				else
					xil_printf(" ");
			}
		}
		else if(((eeprom_page_buffer[55] == 0xFF) && (i >= 16) && (i < 32)) && (page == 25))
		{
			if(eeprom_page_buffer[16] == 0xFF)
			{
				//xil_printf("%c", eeprom_page_buffer[i]);
				xil_printf(".");
			}
			else
			{
				if(i == 16)
					xil_printf("S/N : ");
				xil_printf("%02X", eeprom_page_buffer[i]);
				if((i == 17)||(i == 19)||(i == 21)||(i == 23)||(i == 25)||(i == 27)||(i == 29))
					xil_printf("-");
			}
		}
		else if(((eeprom_page_buffer[55] == 0xFF) && (i >= 56) && (i < 62)) && (page == 25))
		{
			if(i == 61)
			{
				if(eeprom_page_buffer[i] == 0xFF)
					xil_printf("0");
				else
					xil_printf("%d", eeprom_page_buffer[i]);
			}
			else
			{
				if(eeprom_page_buffer[i] == 0xFF)
					xil_printf("V");
				else if(eeprom_page_buffer[i] == 'X')
					xil_printf("X");
				else
					xil_printf("z");
			}

		}
		else if(eeprom_page_buffer[55] == 0xFF)
		{
			if(eeprom_page_buffer[i] == 0xFF)
				xil_printf(".");
			else
				xil_printf("%c", eeprom_page_buffer[i]);
		}
		else if(isprint(eeprom_page_buffer[i]))
			xil_printf("%c", eeprom_page_buffer[i]);
		else
		{
			//xil_printf("%c", Buffer[i]);
			xil_printf("%02x", eeprom_page_buffer[i]);
		}
		if((i % 64) == 63)
			xil_printf("\n\r");
	}
	xil_printf("\n\r");
}

void XIicPs_PrintPageDataRaw(int page, u8 *eeprom_page_buffer)
{
	int i;
	xil_printf("\n\r      0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f 10 11 12 13 14 15 16 17 18 19 1a 1b 1c 1d 1e 1f\n\r");
	for (i = 0; i < INFO_BUFFER_SIZE; i++)
	{
		if((i % 32) == 0)
			xil_printf("%03x: ", i);

		xil_printf("%02x", eeprom_page_buffer[i]);
		if((i % 32) == 31)
			xil_printf("\n\r");
		else
			xil_printf(" ");
	}
	xil_printf("\n\r");
}

void increase_dongle_usage_count(void)
{
	XIicPs_WriteEepromData(26, dongle_usage_count, 1, (u8*)"X");

	if(dongle_usage_count < 1023)
		dongle_usage_count++;
}

#ifdef USE_DEBUG_MESSAGE
void show_dongle_usage_count(uint32_t dongle_usage_count)
{
	GWidgetInit	wi;

	// Apply some default values for GWIN
	gwinWidgetClearInit(&wi);
	wi.g.show = TRUE;
	wi.text = "1234567890";
	//wi.text = "";

	gwinSetDefaultFont(gdispOpenFont("iskpota232"));

	// Create label
	wi.g.width = WIDTH1; wi.g.height = THICK1; wi.g.x = BORDER_X; wi.g.y = BORDER_Y + THICK1 * 12;

	sprintf((char *)wi.text, "Use: %d", (int)dongle_usage_count);
	ghLabel4 = gwinLabelCreate(0, &wi);

	//const char * const txt1 = __DATE__;
	const char * const txt2 = __TIME__;

	wi.g.width = WIDTH2; wi.g.height = THICK1; wi.g.x = BORDER_X; wi.g.y = BORDER_Y + THICK1 * 13;
	//sprintf((char *)wi.text, "Compiled: %s %s", txt1, txt2);		wrong
	wi.text = "12345678901234567890";
	sprintf((char *)wi.text, "Compiled: %s", txt2);
	ghLabel5 = gwinLabelCreate(0, &wi);

#ifndef SW_RELEASE
	wi.g.width = 190; wi.g.height = THICK1; wi.g.x = 300; wi.g.y = BORDER_Y + THICK1 * 13;
	wi.text = "Engineering";
	ghLabel5 = gwinLabelCreate(0, &wi);
	wi.g.width = 180; wi.g.height = THICK1; wi.g.x = 500; wi.g.y = BORDER_Y + THICK1 * 13;
	#ifdef USE_IMS_LINK
	wi.text = "IMS_LINK";
	#else
	wi.text = "comport";
	#endif
	ghLabel5 = gwinLabelCreate(0, &wi);
#endif

	return;
}

void increase_power_on_count(void)
{
	XIicPs_WriteEepromData(27, power_on_count + 512, 1, (u8*)"P");

	if(power_on_count < 512)
		power_on_count++;
}

void show_fw_write_count(uint32_t fw_write_count)
{
	GWidgetInit	wi;

	// Apply some default values for GWIN
	gwinWidgetClearInit(&wi);
	wi.g.show = TRUE;
	wi.text = "1234567890";

	gwinSetDefaultFont(gdispOpenFont("iskpota232"));

	// Create label
	wi.g.width = WIDTH1; wi.g.height = THICK1; wi.g.x = BORDER_X + WIDTH1; wi.g.y = BORDER_Y + THICK1 * 12;
	sprintf((char *)wi.text, "C: %d", (int)fw_write_count);
	ghLabel4 = gwinLabelCreate(0, &wi);

	wi.g.width = WIDTH1; wi.g.height = THICK1; wi.g.x = BORDER_X + WIDTH1 + 100; wi.g.y = BORDER_Y + THICK1 * 12;
	sprintf((char *)wi.text, "P: %d", (int)(power_on_count + 1));
	ghLabel4 = gwinLabelCreate(0, &wi);

	return;
}
#endif

void show_dongle_usage_count_eng(uint32_t dongle_usage_count)
{
	GWidgetInit	wi;
	// Apply some default values for GWIN
	gwinWidgetClearInit(&wi);
	wi.g.show = TRUE;
	wi.text = "1234567890";

	gwinSetDefaultFont(gdispOpenFont("iskpota232"));
	// Create label
	wi.g.width = WIDTH1; wi.g.height = THICK1; wi.g.x = COLUMN4; wi.g.y = ROW6;
	sprintf((char *)wi.text, "Use: %d", (int)dongle_usage_count);
	ghLabel4 = gwinLabelCreate(0, &wi);
	return;
}

int read_RTC_data()
{
	int Index;
	int Status;
	SendBuffer[0] = 0;

	for (Index = 0; Index < I2C_BUFFER_SIZE; Index++) {
		RecvBuffer[Index] = 0;
	}

	/*
	 * Send the buffer using the IIC and ignore the number of bytes sent
	 * as the return value since we are using it in interrupt mode.
	 */

	Status = XIicPs_MasterSendPolled(&Iic, SendBuffer,
			1, IIC_SLAVE_ADDR);

	if (Status != XST_SUCCESS) {
		xil_printf("david0719: %s:%s(%d) ffff b\r\n",__FILE__,__func__,__LINE__);
		return XST_FAILURE;
	}

	/*
	 * Wait until bus is idle to start another transfer.
	 */
	while (XIicPs_BusIsBusy(&Iic)) {
		/* NOP */
	}

	Status = XIicPs_MasterRecvPolled(&Iic, RecvBuffer,
			I2C_BUFFER_SIZE, IIC_SLAVE_ADDR);
	if (Status != XST_SUCCESS) {
		return XST_FAILURE;
	}

	ShowDateInfo(RecvBuffer);

	update_widget_data(RecvBuffer);

	//XIicPs_GetInfo();
	return XST_SUCCESS;
}

int XIicPs_SetRTCData(XIicPs *InstancePtr, u8 type, u8 data)
{
	int Status;
	xil_printf("\n\rRTC write, type = %d, data = %d\r\n", type, data);

	if((type < 0) || (type > 7))
	{
		xil_printf("Illegal parameters, type = %d\n", type);
		return XST_FAILURE;
	}

	if(type == RTC_SS)
	{
		if((data < 0) || (data > 59))
		{
			xil_printf("Illegal parameters, data = %d\n", data);
			return XST_FAILURE;
		}
		else
			data = ((data/10)<<4) + (data % 10);
	}
	else if(type == RTC_MM)
	{
		if((data < 0) || (data > 59))
		{
			xil_printf("Illegal parameters, data = %d\n", data);
			return XST_FAILURE;
		}
		else
			data = ((data/10)<<4) + (data % 10);
	}
	else if(type == RTC_HH)
	{
		if((data < 0) || (data > 23))
		{
			xil_printf("Illegal parameters, data = %d\n", data);
			return XST_FAILURE;
		}
		else
			data = ((data/10)<<4) + (data % 10);
	}
	else if(type == RTC_WD)
	{
		if((data < 0) || (data > 6))
		{
			xil_printf("Illegal parameters, data = %d\n", data);
			return XST_FAILURE;
		}
	}
	else if(type == RTC_MD)
	{
		if((data < 1) || (data > 31))
		{
			xil_printf("Illegal parameters, data = %d\n", data);
			return XST_FAILURE;
		}
		else
			data = ((data/10)<<4) + (data % 10);
	}
	else if(type == RTC_MON)
	{
		if((data < 1) || (data > 12))
		{
			xil_printf("Illegal parameters, data = %d\n", data);
			return XST_FAILURE;
		}
		else
			data = ((data/10)<<4) + (data % 10);
	}
	else if(type == RTC_YEAR)
	{
		if((data < 0) || (data > 150))	//year rnage : 2020 ~ (2020 + 150)
		{
			xil_printf("Illegal parameters, data = %d\n", data);
			return XST_FAILURE;
		}
		else
			data = (((data)/10)<<4) + ((data) % 10);
	}
	else if(type == RTC_CONTROL)
	{
		if((data < 0) || (data > 255))
		{
			xil_printf("Illegal parameters, data = %d\n", data);
			return XST_FAILURE;
		}
	}

	SendBuffer[0] = type;	//offset
	SendBuffer[1] = data;	//data
	Status = XIicPs_MasterSendPolled(InstancePtr, SendBuffer,
			 2, IIC_SLAVE_ADDR);
	if (Status != XST_SUCCESS) {
		xil_printf("david0719: %s:%s(%d) ffff b\r\n",__FILE__,__func__,__LINE__);
		return XST_FAILURE;
	}
	return XST_SUCCESS;
}

void show_systeminfo()
{
	xil_printf("\n\rIMS system info:\n\r\n\r");
	xil_printf(RELEASE_INFO);
	xil_printf("\n\r");
    xil_printf("Compiled time: %s %s\n\r", __DATE__, __TIME__);
	xil_printf("Bootup time : %s", asctime(&rtc_bootup));

	unsigned long difftime_bootup = 0;
	difftime_bootup = diff_time(rtc, rtc_bootup);
	xil_printf("\rBootup ellapsed : ");
	print_time_s2hms(difftime_bootup);
}

void show_help_menu()
{
	xil_printf("\n\rIMS command prompt, ");
	xil_printf(RELEASE_INFO);
	xil_printf("\n\r");
	xil_printf("---------------- Aries Demo ------------------\n\r");
	xil_printf("L0\t\tToggle Layer 0 (background)\n\r");
	xil_printf("L1\t\tToggle Layer 1 (right)\n\r");
	xil_printf("L2\t\tToggle Layer 2 (left)\n\r");
	xil_printf("L3\t\tToggle Layer 3 (OSD)\n\r");
	//xil_printf("'n' = Set to new scaler datapath\n\r");
	xil_printf("t\t\tEnable/bypass camera TPG (TBD)\n\r");
	xil_printf("y\t\tEnable/bypass GUI TPG\n\r");
	xil_printf("u\t\tPark/Unpark Camera Freeze VDMA\n\r");
	//xil_printf("'s' = Set output frame size\n\r");
	//xil_printf("'p' = Print this menu\n\r");
	xil_printf("usb\t\tread USB registers\n\r");
	xil_printf("r\t\tread USB registers\n\r");
	xil_printf("usbr1\t\tUSB HW reset\n\r");
	xil_printf("usbr2\t\tUSB SW reset\n\r");
	xil_printf("dd\t\tDCache Disable\n\r");
	xil_printf("de\t\tDCache Enable\n\r");
	xil_printf("df\t\tDCache Flush\n\r");
	xil_printf("help\t\thelp menu\n\r");
	xil_printf("\n\r--- camera -----------------------------------\n\r");
	xil_printf("+/-\t\tIncrease/decrease camera exposure\n\r");
	xil_printf("1~5\t\tSetup camera exposure\n\r");
	xil_printf("\n\r--- GPIO -------------------------------------\n\r");
	xil_printf("fan on\t\tTurn on fan\n\r");
	xil_printf("fan off\t\tTurn off fan\n\r");
	xil_printf("cam on\t\tTurn on camera LED\n\r");
	xil_printf("cam off\t\tTurn off camera LED\n\r");
	xil_printf("dongle on\tTurn on dongle LED\n\r");
	xil_printf("dongle off\tTurn off dongle LED\n\r");
	xil_printf("bl on\t\tTurn on back light\n\r");
	xil_printf("bl off\t\tTurn off back light\n\r");
	xil_printf("\n\r--- RTC --------------------------------------\n\r");
	xil_printf("rtc\t\tRead RTC result\n\r");
	xil_printf("rtc YYYYMMDDhhmmss\tSetup RTC data YYYY/MM/DD hh:mm:ss\n\r");
	xil_printf("rtc y ####\tSetup RTC data year(2020~2099)\n\r");
	xil_printf("rtc m ##\tSetup RTC data month(01~12)\n\r");
	xil_printf("rtc d ##\tSetup RTC data day(01~31)\n\r");
	xil_printf("rtc w #\t\tSetup RTC data week day(0~6)\n\r");
	xil_printf("rtc hh ##\tSetup RTC data hour(00~23)\n\r");
	xil_printf("rtc mm ##\tSetup RTC data minute(00~59)\n\r");
	xil_printf("rtc ss ##\tSetup RTC data second(00~59)\n\r");
	xil_printf("rtc # ###\tSetup RTC addr(#) with data(###) in decimal\n\r");
	xil_printf("\n\r--- EEPROM -----------------------------------\n\r");
	xil_printf("r n\t\tRead EEPROM page n (n = 0~31)\n\r");
	xil_printf("w n\t\tWrite EEPROM page n (n = 0~31)\n\r");
	xil_printf("e n\t\tErase EEPROM page n (n = 0~31)\n\r");
	xil_printf("r all\t\tRead EEPROM all\n\r");
	xil_printf("w all\t\tWrite EEPROM all\n\r");
	xil_printf("e all\t\tErase EEPROM all\n\r");
	xil_printf("R\t\tRead EEPROM test, page 0\n\r");
	xil_printf("W\t\tWrite EEPROM test, page 0\n\r");
	xil_printf("\n\r--- DMA -----------------------------------\n\r");
	xil_printf("dma\t\tDMA test\n\r");
	xil_printf("ba\t\tshow framebuffer addresses\n\r");
	xil_printf("b0\t\tuse framebuffer 0\n\r");
	xil_printf("b1\t\tuse framebuffer 1\n\r");
	xil_printf("bb\t\tdma copy from framebuffer 0 to framebuffer 1\n\r");
	xil_printf("mm\t\tmemory copy from framebuffer 0 to framebuffer 1\n\r");
	xil_printf("white\t\tmemory copy from WHITE to framebuffer 0\n\r");
	xil_printf("red\t\tdma copy from RED to framebuffer 0\n\r");
	xil_printf("\n\r--- Camera Sensor, Camera FPGA ---------------\n\r");
	xil_printf("ca1\t\tToggle camera setup for ORIENTATION\n\r");
	xil_printf("ca2\t\tToggle camera setup for TEST PATTERN\n\r");
	xil_printf("r cf\t\tRead Camera FPGA registers\n\r");
	xil_printf("r cf #\t\tRead camera fpga at addr(#)\n\r");
	xil_printf("w cf # ##\tWrite camera fpga at addr(#) with data(##)\n\r");
	xil_printf("r cs\t\tRead Camera Sensor registers\n\r");
	xil_printf("r cs all\t\tRead Camera Sensor registers all\n\r");
	xil_printf("r cs ####\tRead camera sensor at addr(####)\n\r");
	xil_printf("w cs #### ##\tWrite camera sensor at addr(####) with data(##)\n\r");
	xil_printf("cars\t\tcamera read  serial number\n\r");
	xil_printf("caws\t\tcamera write serial number\n\r");
	xil_printf("card\t\tcamera read  date\n\r");
	xil_printf("cawd\t\tcamera write date\n\r");
	xil_printf("caer\t\tcamera erase data\n\r");
	xil_printf("\n\r--- others -----------------------------------\n\r");
	xil_printf("supported commands:\n\r");
	xil_printf("help, systeminfo, date, uptime, tic, toc\n\r");
	xil_printf("----------------------------------------------\n\r");
	xil_printf("colr\t\tread_color_matrix\n\r");
	xil_printf("colw\t\twrite_color_matrix\n\r");
	xil_printf("axisl\t\twrite_axis_(0,0)-(640,480) AREA=640x480\n\r");
	xil_printf("axiss\t\twrite_axis_(320,240)-(320,240) AREA=0\n\r");
	xil_printf("grayt()\t\t---Monitor Windows Total Gray Level\n\r");
	return;
}

void show_help2_menu()
{
	show_systeminfo();
	xil_printf("eng\t\tEnter engineering mode\n\r");
	xil_printf("dot\t\tDraw dot\n\r");
	xil_printf("line\t\tDraw line\n\r");
	xil_printf("clear\t\tclear screen\n\r");
	xil_printf("black\t\tclear screen to black\n\r");
	xil_printf("white\t\tclear screen to white\n\r");
	xil_printf("ca0~2\t\tcamera test\n\r");
	xil_printf("st\t\tstart button\n\r");
	xil_printf("u0\t\tusb power down\n\r");
	xil_printf("u1\t\tusb power on\n\r");
	xil_printf("d0~8\t\tdraw test\n\r");
	xil_printf("g1~2\t\tgpio test\n\r");
	xil_printf("f0\t\tfile test\n\r");
	xil_printf("t1\t\tset time\n\r");
	xil_printf("t2\t\tget time\n\r");
	xil_printf("tic/toc\t\ttick st/sp\n\r");
	xil_printf("print\t\tprint test\n\r");
	xil_printf("usb\t\tread usb registers\n\r");
	xil_printf("p q r\t\tshow picture test\n\r");
	xil_printf("c\t\tcheck dongle status\n\r");
	xil_printf("d\t\tdavid test\n\r");

	return;
}

void read_color_matrix()
{
	xil_printf("\n\rread_color_matrix\n\r");
	XVprocSs_GetPictureColorRange(periphs_inst.p_scaler_camera_freeze_inst->CscPtr);
	return;
}

void write_color_matrix()//colrw
{
    //-------------------------------------------JACKY ADD---------------------------------------------
	   #define GPIO_CHANNEL1 1
	   #define GPIO_CHANNEL2 2
	   static XScuGic intc;
	   static XGpio video_path_camera_in_CDR_VIdeo_In_AXI4_rdy_CDR_Registers_axi_gpio_NFrameReady_Gpio;
	//-------------------------------------------------------------------------------------------------

	   {
	      u32 status;

	      print("\r\nRunning GpioOutputExample() for video_path_camera_in_CDR_VIdeo_In_AXI4_rdy_CDR_Registers_axi_gpio_SDK_NFrames...\r\n");
	      status = GpioOutputExample(XPAR_VIDEO_PATH_CAMERA_IN_CDR_VIDEO_IN_AXI4_RDY_CDR_REGISTERS_AXI_GPIO_SDK_NFRAMES_DEVICE_ID,8, 250);

	      if (status == 0) {
	         print("GpioOutputExample PASSED.\r\n");
	      }
	      else {
	         print("GpioOutputExample FAILED.\r\n");
	      }
	   }


	  /* {
	      u32 status;
	      u32 DataRead;

	      print("\r\nRunning GpioInputExample() for video_path_camera_in_CDR_VIdeo_In_AXI4_rdy_CDR_Registers_axi_gpio_NFrameReady...\r\n");
	      status = GpioInputExample(XPAR_VIDEO_PATH_CAMERA_IN_CDR_VIDEO_IN_AXI4_RDY_CDR_REGISTERS_AXI_GPIO_NFRAMESREADY_DEVICE_ID, &DataRead);

	      if (status == 0) {
	         xil_printf("GpioInputExample PASSED. Read data:0x%X\r\n", DataRead);
	      }
	      else {
	         print("GpioInputExample FAILED.\r\n");
	      }
	   }*/
	   {
	      int Status;

	      print(" Press button to Generate Interrupt\r\n");

	      Status = GpioIntrExample(&intc, &video_path_camera_in_CDR_VIdeo_In_AXI4_rdy_CDR_Registers_axi_gpio_NFrameReady_Gpio, \
	                               XPAR_VIDEO_PATH_CAMERA_IN_CDR_VIDEO_IN_AXI4_RDY_CDR_REGISTERS_AXI_GPIO_NFRAMESREADY_DEVICE_ID, \
	                               XPAR_FABRIC_VIDEO_PATH_CAMERA_IN_CDR_VIDEO_IN_AXI4_RDY_CDR_REGISTERS_AXI_GPIO_NFRAMESREADY_IP2INTC_IRPT_INTR, \
	                               GPIO_CHANNEL1);

	    /*{
	  	Status = XGpio_Initialize(video_path_camera_in_CDR_VIdeo_In_AXI4_rdy_CDR_Registers_axi_gpio_NFrameReady_Gpio, XPAR_VIDEO_PATH_CAMERA_IN_CDR_VIDEO_IN_AXI4_RDY_CDR_REGISTERS_AXI_GPIO_NFRAMESREADY_DEVICE_ID);
	  	if (Status != XST_SUCCESS) {
	  		return XST_FAILURE;
	  	}

	  	//Bock scutimer_IntrHandler JACKY1126
	  	Status = GpioSetupIntrSystem(intc, video_path_camera_in_CDR_VIdeo_In_AXI4_rdy_CDR_Registers_axi_gpio_NFrameReady_Gpio, XPAR_VIDEO_PATH_CAMERA_IN_CDR_VIDEO_IN_AXI4_RDY_CDR_REGISTERS_AXI_GPIO_NFRAMESREADY_DEVICE_ID,
	  			XPAR_FABRIC_VIDEO_PATH_CAMERA_IN_CDR_VIDEO_IN_AXI4_RDY_CDR_REGISTERS_AXI_GPIO_NFRAMESREADY_IP2INTC_IRPT_INTR, GPIO_CHANNEL1);
	  	if (Status != XST_SUCCESS) {
	  		return XST_FAILURE;
	  	}
	    }*/

	      if (Status == 0 ){
	                print("Gpio Interrupt Test PASSED. \r\n");
	      }
	      else {
	         print("Gpio Interrupt Test FAILED.\r\n");
	      }

	   }

	return;
}

void draw_picture(int pic)
{
#ifdef USE_DEBUG_PICTURE

	if(pic == CAMERA_OK)
	{
		uint32_t camera_sensor_status = SENSOR_OK;
		camera_sensor_status = check_camera_status();
		if(camera_sensor_status == SENSOR_FAIL)
		{
			pic = CAMERA_SENSOR_FAIL;
		}
	}

	if(flag_use_2_framebuffers == TRUE)
	{
		gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(next_framebuffer));
	}

	draw_picture0(pic);

	if(flag_use_2_framebuffers == TRUE)
	{
		//switch_to_framebuffer(next_framebuffer);
		gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(1 - next_framebuffer));
		draw_picture0(pic);
	}
#endif
	return;
}

void draw_picture0(int pic)
{
#ifdef USE_DEBUG_PICTURE
	coord_t swidth, sheight;
	uint32_t status;

	gdispImage *p_Image;

	p_Image = &myImage;

	swidth = gdispGetWidth();
	sheight = gdispGetHeight();

	if(pic == DONGLE_NONE)			//no dongle
	{
		xil_printf("\n\rshow DONGLE_NONE\r\n");
		status = gdispImageOpenFile(p_Image, recorder_faila);
		status = gdispImageDraw(p_Image, swidth - p_Image->width - BORDER_X * 2 - 600, sheight - p_Image->height - 10, p_Image->width, p_Image->height, 0, 0);
		gdispImageClose(p_Image);
	}
	else if(pic == CAMERA_NONE)		//dongle only
	{
		xil_printf("\n\rclear CAMERA_NONE\r\n");
		status = gdispImageOpenFile(p_Image, recorder_nonea);
		status = gdispImageDraw(p_Image, swidth - p_Image->width - BORDER_X * 2 - 600, sheight - p_Image->height - 10, p_Image->width, p_Image->height, 0, 0);
		gdispImageClose(p_Image);
	}
	else if(pic == CAMERA_OK)		//dongle + camera
	{
		xil_printf("\n\rshow CAMERA_OK\r\n");
		status = gdispImageOpenFile(p_Image, recorder_oka);
		status = gdispImageDraw(p_Image, swidth - p_Image->width - BORDER_X * 2 - 600, sheight - p_Image->height - 10, p_Image->width, p_Image->height, 0, 0);
		gdispImageClose(p_Image);
	}
	else if(pic == CAMERA_SENSOR_FAIL)		//camera exists, but sensor fails
	{
		xil_printf("\n\rshow CAMERA_SENSOR_FAIL\r\n");
		status = gdispImageOpenFile(p_Image, recorder_sensor_faila);
		status = gdispImageDraw(p_Image, swidth - p_Image->width - BORDER_X * 2 - 600, sheight - p_Image->height - 10, p_Image->width, p_Image->height, 0, 0);
		gdispImageClose(p_Image);
	}
	else if(pic == CAMERA_CLEAR)		//clear picture
	{
		xil_printf("\n\rclear camera\r\n");
		status = gdispImageOpenFile(p_Image, recorder_oka);
		gdispFillArea(swidth - p_Image->width - BORDER_X * 2 - 600, sheight - p_Image->height - 10, p_Image->width, p_Image->height, Black);
		gdispImageClose(p_Image);
	}
	else if(pic == KEYBOARD_OK)		//dongle + camera
	{
		xil_printf("\n\rshow KEYBOARD_OK\r\n");
		status = gdispImageOpenFile(p_Image, cameraa);
		status = gdispImageDraw(p_Image, swidth - p_Image->width - BORDER_X * 2 - 300, sheight - p_Image->height + 80 + 24, p_Image->width, p_Image->height + 10 + 24 + 24, 0, 0);
		gdispImageClose(p_Image);
	}
	else if(pic == KEYBOARD_NONE)		//clear picture
	{
		xil_printf("\n\rclear KEYBOARD_NONE\r\n");
		status = gdispImageOpenFile(p_Image, cameraa);
		gdispFillArea(swidth - p_Image->width - BORDER_X * 2 - 300, sheight - p_Image->height + 80 + 24, p_Image->width, p_Image->height, Black);
		gdispImageClose(p_Image);
	}
	else
	{
		xil_printf("\n\rdraw_picture, unknown pic = %d\r\n", pic);
	}
#endif
	return;
}

u32 ReadRegister(u32 reg)
{
	return Xil_In32(reg);
}

u32 WriteRegister(u32 reg, u32 value)
{
	Xil_Out32(reg, value);
	return 0;
}

#define LAYERALPHA	0x00100
#define LAYERSTARTX	0x00108
#define LAYERSTARTY	0x00110
#define LAYERWIDTH	0x00118
#define LAYERSTRIDE	0x00120
#define LAYERHEIGHT	0x00128
#define LAYERFACTOR	0x00130
#define LAYERP1BUF	0x00140
#define LAYERP2BUF	0x0014c

void pirnt_mixer_data(void)
{
	u32 result;
	u32 off;
	u32 offset;
	u32 layer;
	u32 base = 0x43cc0000;
	u32 addr;


	xil_printf("Top-Level Registers\n\r");
	for(addr = 0; addr <= 0x40; addr += 4)
	{
		result = ReadRegister(base + addr);
		xil_printf("addr = 0x%04x\tdata = 0x%08x = %d\r\n", addr, result, result);
	}

	xil_printf("\n\r");


	for(layer = 0; layer < 4; layer++)
	{
		xil_printf("layer = %d\r\n", layer);
		off = layer * 0x100;
		offset = base + off;

		addr = offset + LAYERALPHA;
		result = ReadRegister(addr);
		xil_printf("LAYERALPHA\t addr = 0x%08x\talpha\t = 0x%08x = %d\r\n", addr, result, result);

		addr = offset + LAYERSTARTX;
		result = ReadRegister(addr);
		xil_printf("LAYERSTARTX\t addr = 0x%08x\tX_st\t = 0x%08x = %d\r\n", addr, result, result);

		addr = offset + LAYERSTARTY;
		result = ReadRegister(addr);
		xil_printf("LAYERSTARTY\t addr = 0x%08x\tY_st\t = 0x%08x = %d\r\n", addr, result, result);

		addr = offset + LAYERWIDTH;
		result = ReadRegister(addr);
		xil_printf("LAYERWIDTH\t addr = 0x%08x\tW\t = 0x%08x = %d\r\n", addr, result, result);

		addr = offset + LAYERHEIGHT;
		result = ReadRegister(addr);
		xil_printf("LAYERHEIGHT\t addr = 0x%08x\tH\t = 0x%08x = %d\r\n", addr, result, result);

		addr = offset + LAYERSTRIDE;
		result = ReadRegister(addr);
		xil_printf("LAYERSTRIDE\t addr = 0x%08x\tstride\t = 0x%08x = %d\r\n", addr, result, result);

		addr = offset + LAYERFACTOR;
		result = ReadRegister(addr);
		xil_printf("LAYERFACTOR\t addr = 0x%08x\tfactor\t = 0x%08x = %d\r\n", addr, result, result);

		addr = offset + LAYERP1BUF;
		result = ReadRegister(addr);
		xil_printf("LAYERP1BUF\t addr = 0x%08x\tp1_buf\t = 0x%08x = %d\r\n", addr, result, result);

		addr = offset + LAYERP2BUF;
		result = ReadRegister(addr);
		xil_printf("LAYERP2BUF\t addr = 0x%08x\tp2_buf\t = 0x%08x = %d\r\n", addr, result, result);

		xil_printf("\n\r");
	}
}

int SetupInterruptSystem(XScuGic *GicPtr, XDmaPs *DmaPtr)
{
	int Status;
	XScuGic_Config *GicConfig;

	Xil_ExceptionInit();

	/*
	 * Initialize the interrupt controller driver so that it is ready to
	 * use.
	 */
	xil_printf("=========================XScuGic_LookupConfig DeviceId=%d\n\r", XPAR_PS7_SCUGIC_0_DEVICE_ID);
	GicConfig = XScuGic_LookupConfig(XPAR_PS7_SCUGIC_0_DEVICE_ID);
	if (NULL == GicConfig) {
		return XST_FAILURE;
	}

	Status = XScuGic_CfgInitialize(GicPtr, GicConfig,
				       GicConfig->CpuBaseAddress);
	xil_printf("=====XScuGic_CfgInitialize: GicConfig=%8x, GicConfig->CpuBaseAddress=%8x=====\n\r", GicConfig, GicConfig->CpuBaseAddress);
	if (Status != XST_SUCCESS) {
		return XST_FAILURE;
	}

	/*
	 * Connect the interrupt controller interrupt handler to the hardware
	 * interrupt handling logic in the processor.
	 */
	xil_printf("david0423: %s:%s(%d) ST\r\n", __FILE__, __func__, __LINE__);
	Xil_ExceptionRegisterHandler(XIL_EXCEPTION_ID_IRQ_INT,
			     (Xil_ExceptionHandler)XScuGic_InterruptHandler,
			     GicPtr);
	/*
	 * Connect the device driver handlers that will be called when an interrupt
	 * for the device occurs, the device driver handler performs the specific
	 * interrupt processing for the device
	 */

	/*
	 * Connect the Fault ISR
	 */
	Status = XScuGic_Connect(GicPtr,
				 DMA_FAULT_INTR,
				 (Xil_InterruptHandler)XDmaPs_FaultISR,
				 (void *)DmaPtr);
	if (Status != XST_SUCCESS) {
		return XST_FAILURE;
	}

	/*
	 * Connect the Done ISR for all 8 channels of DMA 0
	 */
	Status = XScuGic_Connect(GicPtr,
				 DMA_DONE_INTR_0,
				 (Xil_InterruptHandler)XDmaPs_DoneISR_0,
				 (void *)DmaPtr);
	Status |= XScuGic_Connect(GicPtr,
				 DMA_DONE_INTR_1,
				 (Xil_InterruptHandler)XDmaPs_DoneISR_1,
				 (void *)DmaPtr);
	Status |= XScuGic_Connect(GicPtr,
				 DMA_DONE_INTR_2,
				 (Xil_InterruptHandler)XDmaPs_DoneISR_2,
				 (void *)DmaPtr);
	Status |= XScuGic_Connect(GicPtr,
				 DMA_DONE_INTR_3,
				 (Xil_InterruptHandler)XDmaPs_DoneISR_3,
				 (void *)DmaPtr);
	Status |= XScuGic_Connect(GicPtr,
				 DMA_DONE_INTR_4,
				 (Xil_InterruptHandler)XDmaPs_DoneISR_4,
				 (void *)DmaPtr);
	Status |= XScuGic_Connect(GicPtr,
				 DMA_DONE_INTR_5,
				 (Xil_InterruptHandler)XDmaPs_DoneISR_5,
				 (void *)DmaPtr);
	Status |= XScuGic_Connect(GicPtr,
				 DMA_DONE_INTR_6,
				 (Xil_InterruptHandler)XDmaPs_DoneISR_6,
				 (void *)DmaPtr);
	Status |= XScuGic_Connect(GicPtr,
				 DMA_DONE_INTR_7,
				 (Xil_InterruptHandler)XDmaPs_DoneISR_7,
				 (void *)DmaPtr);

	if (Status != XST_SUCCESS)
		return XST_FAILURE;

	/*
	 * Enable the interrupts for the device
	 */
	XScuGic_Enable(GicPtr, DMA_DONE_INTR_0);
	XScuGic_Enable(GicPtr, DMA_DONE_INTR_1);
	XScuGic_Enable(GicPtr, DMA_DONE_INTR_2);
	XScuGic_Enable(GicPtr, DMA_DONE_INTR_3);
	XScuGic_Enable(GicPtr, DMA_DONE_INTR_4);
	XScuGic_Enable(GicPtr, DMA_DONE_INTR_5);
	XScuGic_Enable(GicPtr, DMA_DONE_INTR_6);
	XScuGic_Enable(GicPtr, DMA_DONE_INTR_7);
	XScuGic_Enable(GicPtr, DMA_FAULT_INTR);

	Xil_ExceptionEnable();

	return XST_SUCCESS;

}

void DmaDoneHandler(unsigned int Channel, XDmaPs_Cmd *DmaCmd, void *CallbackRef)
{
	/* done handler */
	volatile int *DMAReady = (volatile int *)CallbackRef;
	*DMAReady = 1;
}

unsigned int Channel = 0;
int dma_copy(u32 SrcAddr, u32 DstAddr, int length)
{
	int Status = XST_SUCCESS;
	int TimeOutCnt;
	volatile int DMAReady;

	XDmaPs_Cmd DmaCmd;
	XDmaPs *DmaInst = periphs_inst.p_pdma0_inst;

	memset(&DmaCmd, 0, sizeof(XDmaPs_Cmd));
	DmaCmd.ChanCtrl.SrcBurstSize = 4;
	DmaCmd.ChanCtrl.SrcBurstLen = 4;
	DmaCmd.ChanCtrl.SrcInc = 1;
	DmaCmd.ChanCtrl.DstBurstSize = 4;
	DmaCmd.ChanCtrl.DstBurstLen = 4;
	DmaCmd.ChanCtrl.DstInc = 1;
	DmaCmd.BD.SrcAddr = SrcAddr;
	DmaCmd.BD.DstAddr = DstAddr;
	DmaCmd.BD.Length = length * sizeof(int);

	Channel++;
	Channel %= 8;

	DMAReady = 0;

	/* Set the Done interrupt handler */
	XDmaPs_SetDoneHandler(DmaInst,
			       Channel,
			       DmaDoneHandler,
			       (void *)(&DMAReady));

	Status = XDmaPs_Start(DmaInst, Channel, &DmaCmd, 0);
	if (Status != XST_SUCCESS) {
		xil_printf("FAIL 1\n\r");
		return XST_FAILURE;
	}

	TimeOutCnt = 0;

	/* Now the DMA is done */
	while ((DMAReady == 0) && TimeOutCnt < TIMEOUT_LIMIT)
	{
		TimeOutCnt++;
	}

	if (TimeOutCnt >= TIMEOUT_LIMIT) {
		xil_printf("FAIL 2 TIMEOUT_LIMIT\n\r");
		Status = XST_FAILURE;
	}
	else
	{
		Status = XST_SUCCESS;
	}
	return Status;
}

int XAdcFractionToInt(float FloatNum)
{
	float Temp;

	Temp = FloatNum;
	if (FloatNum < 0) {
		Temp = -(FloatNum);
	}

	return( ((int)((Temp -(float)((int)Temp)) * (1000.0f))));
}

int XAdcInit(u16 DeviceId)
{
	int Status;
	XAdcPs_Config *ConfigPtr;
	XAdcPs *XAdcInstPtr = &XAdcInst;

	xil_printf("\r\nEntering the XAdc Polled Example. \r\n");

	/*
	 * Initialize the XAdc driver.
	 */
	ConfigPtr = XAdcPs_LookupConfig(DeviceId);
	if (ConfigPtr == NULL) {
		return XST_FAILURE;
	}
	XAdcPs_CfgInitialize(XAdcInstPtr, ConfigPtr,
				ConfigPtr->BaseAddress);

	/*
	 * Self Test the XADC/ADC device
	 */
	Status = XAdcPs_SelfTest(XAdcInstPtr);
	if (Status != XST_SUCCESS) {
		return XST_FAILURE;
	}

	/*
	 * Disable the Channel Sequencer before configuring the Sequence
	 * registers.
	 */
	XAdcPs_SetSequencerMode(XAdcInstPtr, XADCPS_SEQ_MODE_SAFE);
	return XST_SUCCESS;
}

int XAdcGetData()
{
	u32 TempRawData;
	float TempData;
	u32 VccPintRawData;
	u32 VccPauxRawData;
	u32 VccPdroRawData;
	float VccPintData;
	float VccPauxData;
	float MaxData;
	float MinData;

	XAdcPs *XAdcInstPtr = &XAdcInst;

	/*
	 * Read the on-chip Temperature Data (Current/Maximum/Minimum)
	 * from the ADC data registers.
	 */
	TempRawData = XAdcPs_GetAdcData(XAdcInstPtr, XADCPS_CH_TEMP);
	TempData = XAdcPs_RawToTemperature(TempRawData);

#ifndef TEMPERATURE_DEBUG
	temperature_array_index = DEBUG_LENGTH + 1;
#endif

	if(temperature_array_index == 1)
	{
		xil_printf("\r\n\n\rTEMPERATURE_DEBUG ST, DEBUG_LENGTH = %d\n\r", DEBUG_LENGTH);
		xil_printf("\n\rTEMPERATURE_DEBUG i = %3d\t.", 0);
	}

	if(temperature_array_index < DEBUG_LENGTH)
	{
		if((temperature_array_index % 10) == 0)
		{
			if(temperature_array_index > 0)
			{
				xil_printf("\n\rTEMPERATURE_DEBUG i = %3d\t.", temperature_array_index);
			}
		}
		else
		{
			xil_printf(".");
		}
		temperature_array[temperature_array_index] = TempRawData;
		temperature_array_index++;
	}
	else if(temperature_array_index == (DEBUG_LENGTH))
	{
		temperature_array_index++;
		xil_printf("\r\n\n\rTEMPERATURE_DEBUG SP, DEBUG_LENGTH = %d\n\r", DEBUG_LENGTH);
		xil_printf("\n\r%s", PROMPT);
	}
	else
	{
		xil_printf("\r\nThe Current Temperature is %0d.%03d Centigrades.\r\n",
					(int)(TempData), XAdcFractionToInt(TempData));

	TempRawData = XAdcPs_GetMinMaxMeasurement(XAdcInstPtr, XADCPS_MAX_TEMP);
	MaxData = XAdcPs_RawToTemperature(TempRawData);
	xil_printf("The Maximum Temperature is %0d.%03d Centigrades. \r\n",
				(int)(MaxData), XAdcFractionToInt(MaxData));

	TempRawData = XAdcPs_GetMinMaxMeasurement(XAdcInstPtr, XADCPS_MIN_TEMP);
	MinData = XAdcPs_RawToTemperature(TempRawData & 0xFFF0);
	xil_printf("The Minimum Temperature is %0d.%03d Centigrades. \r\n",
				(int)(MinData), XAdcFractionToInt(MinData));

	/*
	 * Read the VccPint Votage Data (Current/Maximum/Minimum) from the
	 * ADC data registers.
	 */
	VccPintRawData = XAdcPs_GetAdcData(XAdcInstPtr, XADCPS_CH_VCCPINT);
	VccPintData = XAdcPs_RawToVoltage(VccPintRawData);
	xil_printf("\r\nThe Current VCCPINT is %0d.%03d Volts. \r\n",
			(int)(VccPintData), XAdcFractionToInt(VccPintData));

	VccPintRawData = XAdcPs_GetMinMaxMeasurement(XAdcInstPtr,
							XADCPS_MAX_VCCPINT);
	MaxData = XAdcPs_RawToVoltage(VccPintRawData);
	xil_printf("The Maximum VCCPINT is %0d.%03d Volts. \r\n",
			(int)(MaxData), XAdcFractionToInt(MaxData));

	VccPintRawData = XAdcPs_GetMinMaxMeasurement(XAdcInstPtr,
							XADCPS_MIN_VCCPINT);
	MinData = XAdcPs_RawToVoltage(VccPintRawData);
	xil_printf("The Minimum VCCPINT is %0d.%03d Volts. \r\n",
			(int)(MinData), XAdcFractionToInt(MinData));

	/*
	 * Read the VccPaux Votage Data (Current/Maximum/Minimum) from the
	 * ADC data registers.
	 */
	VccPauxRawData = XAdcPs_GetAdcData(XAdcInstPtr, XADCPS_CH_VCCPAUX);
	VccPauxData = XAdcPs_RawToVoltage(VccPauxRawData);
	xil_printf("\r\nThe Current VCCPAUX is %0d.%03d Volts. \r\n",
			(int)(VccPauxData), XAdcFractionToInt(VccPauxData));

	VccPauxRawData = XAdcPs_GetMinMaxMeasurement(XAdcInstPtr,
								XADCPS_MAX_VCCPAUX);
	MaxData = XAdcPs_RawToVoltage(VccPauxRawData);
	xil_printf("The Maximum VCCPAUX is %0d.%03d Volts. \r\n",
				(int)(MaxData), XAdcFractionToInt(MaxData));


	VccPauxRawData = XAdcPs_GetMinMaxMeasurement(XAdcInstPtr,
								XADCPS_MIN_VCCPAUX);
	MinData = XAdcPs_RawToVoltage(VccPauxRawData);
	xil_printf("The Minimum VCCPAUX is %0d.%03d Volts. \r\n",
				(int)(MinData), XAdcFractionToInt(MinData));


	/*
	 * Read the VccPdro Votage Data (Current/Maximum/Minimum) from the
	 * ADC data registers.
	 */
	VccPdroRawData = XAdcPs_GetAdcData(XAdcInstPtr, XADCPS_CH_VCCPDRO);
	VccPintData = XAdcPs_RawToVoltage(VccPdroRawData);
	xil_printf("\r\nThe Current VCCPDDRO is %0d.%03d Volts. \r\n",
			(int)(VccPintData), XAdcFractionToInt(VccPintData));

	VccPdroRawData = XAdcPs_GetMinMaxMeasurement(XAdcInstPtr,
							XADCPS_MAX_VCCPDRO);
	MaxData = XAdcPs_RawToVoltage(VccPdroRawData);
	xil_printf("The Maximum VCCPDDRO is %0d.%03d Volts. \r\n",
			(int)(MaxData), XAdcFractionToInt(MaxData));

	VccPdroRawData = XAdcPs_GetMinMaxMeasurement(XAdcInstPtr,
							XADCPS_MIN_VCCPDRO);
	MinData = XAdcPs_RawToVoltage(VccPdroRawData);
	xil_printf("The Minimum VCCPDDRO is %0d.%03d Volts. \r\n",
			(int)(MinData), XAdcFractionToInt(MinData));
	}
	return XST_SUCCESS;
}

int XAdcGetCurrentTemperature()
{
	XAdcPs *XAdcInstPtr = &XAdcInst;

	/*
	 * Read the on-chip Temperature Data (Current/Maximum/Minimum)
	 * from the ADC data registers.
	 */
	temperature_current = XAdcPs_GetAdcData(XAdcInstPtr, XADCPS_CH_TEMP);
	return XST_SUCCESS;
}

void clear_layer1_all(int frame, int enable)
{
	uint32_t i;

	//destination canvas
	coord_t W;				//destination canvas size width
	coord_t H;				//destination canvas size height

	if((frame != FRAMEBUFFER0) && (frame != FRAMEBUFFER1))
	{
		xil_printf("clear_layer1_all fail, illegal frame = %d\n\r", frame);
		return;
	}

	//destination canvas
	W = LAYER1_WIDTH;		//destination canvas size width
	H = LAYER1_HEIGHT;		//destination canvas size height

	void* addr;
	uint32_t *f_ptr;
	int length;
	length = W;

	addr = gfxAlloc(length * 4);

	f_ptr = addr;
	for(i = 0; i< length; i++)
	{
		if(enable == TRUE)
			f_ptr[i] = 0x00000000;	//100% transparent
		else
		{
			//			   A B G R
			//f_ptr[i] = 0xFFFF0000;	//100% blue
			//f_ptr[i] = 0xFFFF008B;	//100% bluexxxx
			//f_ptr[i] = 0xFF84195E;	//100% purple
			f_ptr[i] = 0x00000000;	//100% transparent
		}
	}

	uint32_t addr0;
	uint32_t addr1;
	addr0 = (uint32_t)addr;
	addr1 = (uint32_t)gdispGetFrameBufferAddr(frame);

	uint32_t addr2;

	for(i = 0; i < H; i++)
	{
		addr2 = (u32)(LAYER0_WIDTH * 4 * (LAYER1_START_Y + i) + addr1 + 4 * LAYER1_START_X);
		dma_copy((u32) addr0, addr2, length);
	}
}

void clear_layer1(int frame)
{
	uint32_t i;

	//destination canvas
	coord_t W = LAYER1_WIDTH;			//destination canvas size width
	//coord_t H = LAYER1_HEIGHT;		//destination canvas size height

	if((frame != FRAMEBUFFER0) && (frame != FRAMEBUFFER1))
	{
		xil_printf("clear_layer1 fail, illegal frame = %d\n\r", frame);
		return;
	}

	void* addr;
	uint32_t *f_ptr;
	int length;
	length = W;

	addr = gfxAlloc(length * 4);

	f_ptr = addr;
	for(i = 0; i< length; i++)
	{
		f_ptr[i] = 0x00000000;	//100% transparent
	}

	uint32_t addr0;
	uint32_t addr1;
	addr0 = (uint32_t)addr;
	addr1 = (uint32_t)gdispGetFrameBufferAddr(frame);

	uint32_t addr2;

	//for(i = 0; i < H; i++)	//clear all
	for(i = pic_dy; i < pic_dy + pic_height; i++)	//clear middle
	{
		addr2 = (u32)(LAYER0_WIDTH * 4 * (LAYER1_START_Y + i) + addr1 + 4 * LAYER1_START_X);
		dma_copy((u32) addr0, addr2, length);
	}
	return;
}

void layer1_blit(struct pic_size s, int frame)
{
	uint32_t i;
	uint32_t j;

	coord_t W = LAYER1_WIDTH;
	//coord_t H = LAYER1_HEIGHT;

	coord_t w = s.w;
	coord_t h = s.h;

	coord_t dx = s.dx;
	coord_t dy = s.dy;

	int alpha_prime = (alpha) << 24;

	if((frame != FRAMEBUFFER0) && (frame != FRAMEBUFFER1))
	{
		xil_printf("layer1_blit fail, illegal frame = %d\n\r", frame);
		return;
	}

	for(j = dy; j < dy + h; j++)
    {
    	for(i = dx; i < dx + w; i++)
    	{
    		surface_1[j * W + i] &= 0x00ffffff;
    		surface_1[j * W + i] |= alpha_prime;
		}
	}

	int length = w;

	uint32_t addr0;
	uint32_t addr1;
	addr0 = (uint32_t)surface_1;
	addr1 = (uint32_t)gdispGetFrameBufferAddr(frame);

	uint32_t addr00;
	uint32_t addr11;

	//xil_printf("\n\r\n\rdx = %d dy = %d w = %d h = %d addr0 = 0x%08x addr1 = 0x%08x\n\r", dx, dy, w, h, addr0, addr1);
	//xil_printf("\n\r\n\rLAYER0_WIDTH = %d LAYER1_WIDTH = %d LAYER1_START_X = %d LAYER1_START_Y = %d\n\r", LAYER0_WIDTH, LAYER1_WIDTH, LAYER1_START_X, LAYER1_START_Y);

	for(i = dy; i < (dy + h); i++)
	{
		addr00 = (u32)(addr0 + LAYER1_WIDTH * (i) * 4 + dx * 4);
		addr11 = (u32)(addr1 + LAYER0_WIDTH * (i + LAYER1_START_Y) * 4 + (LAYER1_START_X + dx) * 4);

		dma_copy((u32) addr00, addr11, length);
	}

	pic_width = w;		//destination canvas start position x
	pic_height = h;		//destination canvas start position y
	pic_dx = dx;		//destination canvas start position x
	pic_dy = dy;		//destination canvas start position y
}

void print_screen_data(int frame)
{
	int i;
	int j;
	int W;
	int H;
	uint32_t addr0;
	uint32_t addr1;

	if((frame != 0) && (frame != 1))
	{
		xil_printf("print_screen_data fail, illegal frame = %d\n\r", frame);
		return;
	}

	addr0 = (uint32_t)gdispGetFrameBufferAddr(frame);

	W = LAYER0_WIDTH;
	H = LAYER0_HEIGHT;
	xil_printf("\n\rframebuffer0 W = %d H = %d\n\r", W, H);

	for(j = 0; j < H; j += 20)
    {
    	for(i = 0; i < W; i += 95)
    	{
    		addr1 = (u32)(addr0 + (j * W + i) * 4);
    		xil_printf("%08x ", Xil_In32(addr1));
    	}
    	xil_printf("\n\r");
	}
	xil_printf("\n\r");

	W = LAYER1_WIDTH;
	H = LAYER1_HEIGHT;
	xil_printf("\n\r\n\rsurface_1 W = %d H = %d\n\r", W, H);
	for(j = 0; j < H; j += 20)
    {
    	for(i = 0; i < W; i += 60)
    	{
    		xil_printf("%08x ", surface_1[j * W + i]);
		}
    	xil_printf("\n\r");
	}
	xil_printf("\n\r");

	W = LAYER1_WIDTH;
	H = LAYER1_HEIGHT;
	xil_printf("\n\rsurface_1c W = %d H = %d\n\r", W, H);
	for(j = 0; j < H; j += 20)
    {
    	for(i = 0; i < W; i += 60)
    	{
    		xil_printf("%08x ", surface_1c[j * W + i]);
		}
    	xil_printf("\n\r");
	}
	xil_printf("\n\r");
}

void preload_picture_to_memory(void)
{
	int status;
	//volatile uint32_t g_ms_tick_tmp1;
	//volatile uint32_t g_ms_tick_tmp2;
	coord_t width = LAYER1_WIDTH;
	coord_t height = LAYER1_HEIGHT;

	//xil_printf("\n\rpreload_picture_to_memory ST\r\n");

	//g_ms_tick_tmp1 = g_ms_tick;

	Xil_DCacheEnable();

	gdispImage *p_Image;
	p_Image = &myImage;

	status = gdispImageOpenFile(p_Image, step_1);
	pixmap_draw(pixmap_1, surface_1, LAYER1_WIDTH, LAYER1_HEIGHT, p_Image, 0, 0, 0, 0, alpha, POSITION_MIDDLE_CENTER);
	pic_sizes[0].w = p_Image->width;
	pic_sizes[0].h = p_Image->height;
	pic_sizes[0].dx = pic_dx;
	pic_sizes[0].dy = pic_dy;
	gdispImageClose(p_Image);
	memset(surface_1a, 0, width * height * 4); // Clear buffer
	memcpy(surface_1a, surface_1, width * height * 4);

	status = gdispImageOpenFile(p_Image, step_2);
	pixmap_draw(pixmap_1, surface_1, LAYER1_WIDTH, LAYER1_HEIGHT, p_Image, 0, 0, 0, 0, alpha, POSITION_MIDDLE_CENTER);
	pic_sizes[1].w = p_Image->width;
	pic_sizes[1].h = p_Image->height;
	pic_sizes[1].dx = pic_dx;
	pic_sizes[1].dy = pic_dy;
	gdispImageClose(p_Image);
	memset(surface_1b, 0, width * height * 4); // Clear buffer
	memcpy(surface_1b, surface_1, width * height * 4);

	status = gdispImageOpenFile(p_Image, step_3);
	pixmap_draw(pixmap_1, surface_1, LAYER1_WIDTH, LAYER1_HEIGHT, p_Image, 0, 0, 0, 0, alpha, POSITION_MIDDLE_CENTER);
	pic_sizes[2].w = p_Image->width;
	pic_sizes[2].h = p_Image->height;
	pic_sizes[2].dx = pic_dx;
	pic_sizes[2].dy = pic_dy;
	gdispImageClose(p_Image);
	memset(surface_1c, 0, width * height * 4); // Clear buffer
	memcpy(surface_1c, surface_1, width * height * 4);

	Xil_DCacheFlush();
	Xil_DCacheDisable();

	//g_ms_tick_tmp2 = g_ms_tick;
	//xil_printf("\n\rpreload_picture_to_memory SP, spend %d msec\r\n", g_ms_tick_tmp2 - g_ms_tick_tmp1);
	return;
}

#ifdef USE_PREVENT_REUSE
void preload_forbid_picture_to_memory(int pic)
{
	int status;
	coord_t width = LAYER1_WIDTH;
	coord_t height = LAYER1_HEIGHT;
	xil_printf("\n\rpreload_forbid_picture_to_memory ST pic = %d\n\r", pic);

	Xil_DCacheEnable();

	gdispImage *p_Image;
	p_Image = &myImage;

	switch(pic)
	{
	case VIDEO_FORBID_ALL:					status = gdispImageOpenFile(p_Image, forbid_1);break;
	case VIDEO_FORBID_USE_2HR:				status = gdispImageOpenFile(p_Image, forbid_8);break;
	case VIDEO_FORBID_RTC_FAIL:				status = gdispImageOpenFile(p_Image, forbid_9);break;
	default:								status = -1;xil_printf("xxxx unknown error status = %d ", (int)flag_video_status);break;
	}

	if(status == 0)
	{
		pixmap_draw(pixmap_1, surface_1, LAYER1_WIDTH, LAYER1_HEIGHT, p_Image, 0, 0, 0, 0, alpha, POSITION_MIDDLE_CENTER);
		pic_sizes[3].w = p_Image->width;
		pic_sizes[3].h = p_Image->height;
		pic_sizes[3].dx = pic_dx;
		pic_sizes[3].dy = pic_dy;
		gdispImageClose(p_Image);
		memset(surface_1d, 0, width * height * 4); // Clear buffer
		memcpy(surface_1d, surface_1, width * height * 4);
	}
	Xil_DCacheFlush();
	Xil_DCacheDisable();
	return;
}
#endif

void dma_restore_picture(int pic)
{
	int i;
	int length = LAYER1_WIDTH;
	coord_t H = LAYER1_HEIGHT;

	uint32_t addr0;
	uint32_t addr1;
	uint32_t addr00;
	uint32_t addr11;

	switch(pic)
	{
	case 0:
		addr0 = (uint32_t)surface_1a;
		break;
	case 1:
		addr0 = (uint32_t)surface_1b;
		break;
	case 2:
		addr0 = (uint32_t)surface_1c;
		break;
	case 3:
		addr0 = (uint32_t)surface_1d;
		break;
	default:
		addr0 = (uint32_t)surface_1c;
		xil_printf("\n\rdma_restore_picture unknown picture, pic = %d\r\n", pic);
		break;
	}

	addr1 = (uint32_t)surface_1;

	//xil_printf("\n\rdma_restore_picture 0x%08x to 0x%08x\r\n", addr0, addr1);

	for(i = 0; i < H; i++)
	{
		addr00 = (u32)(addr0 + LAYER1_WIDTH * (i) * 4);
		addr11 = (u32)(addr1 + LAYER1_WIDTH * (i) * 4);
		dma_copy((u32) addr00, addr11, length);
	}
}

void dma_backup_picture(void)
{
	int i;
	int length = LAYER1_WIDTH;
	coord_t H = LAYER1_HEIGHT;

	uint32_t addr0;
	uint32_t addr1;
	uint32_t addr00;
	uint32_t addr11;

	addr0 = (uint32_t)surface_1;
	addr1 = (uint32_t)surface_1c;

	xil_printf("\n\rdma_backup_picture 0x%08x to 0x%08x\r\n", addr0, addr1);

	for(i = 0; i < H; i++)
	{
		addr00 = (u32)(addr0 + LAYER1_WIDTH * (i) * 4);
		addr11 = (u32)(addr1 + LAYER1_WIDTH * (i) * 4);
		dma_copy((u32) addr00, addr11, length);
	}
}

void print_layer0_data(int frame)
{
	int i;
	int j;
	int W;
	int H;

	if((frame != 0) && (frame != 1))
	{
		xil_printf("print_layer0_data fail, illegal frame = %d\n\r", frame);
		return;
	}

	uint32_t addr0;
	uint32_t addr1;
	addr0 = (uint32_t)gdispGetFrameBufferAddr(frame);
	W = LAYER0_WIDTH;
	H = LAYER0_HEIGHT;
	xil_printf("\n\rframebuffer0 W = %d H = %d\n\r", W, H);
	for(j = 0; j < H; j += 20)
    {
    	for(i = 0; i < W; i += 95)
    	{
    		addr1 = (u32)(addr0 + (j * W + i) * 4);
    		xil_printf("%08x ", Xil_In32(addr1));
    	}
    	xil_printf("\n\r");
	}
	xil_printf("\n\r");
}

void print_surface_1_data()
{
	int i;
	int j;
	int W;
	int H;
	W = LAYER1_WIDTH;
	H = LAYER1_HEIGHT;
	xil_printf("\n\r\n\rsurface_1 W = %d H = %d\n\r", W, H);
	for(j = 0; j < H; j += 20)
    {
    	for(i = 0; i < W; i += 60)
    	{
    		xil_printf("%08x ", surface_1[j * W + i]);
		}
    	xil_printf("\n\r");
	}
	xil_printf("\n\r");
}

void print_surface_1c_data()
{
	int i;
	int j;
	int W;
	int H;
	W = LAYER1_WIDTH;
	H = LAYER1_HEIGHT;
	xil_printf("\n\rsurface_1c W = %d H = %d\n\r", W, H);
	for(j = 0; j < H; j += 20)
    {
    	for(i = 0; i < W; i += 60)
    	{
    		xil_printf("%08x ", surface_1c[j * W + i]);
		}
    	xil_printf("\n\r");
	}
	xil_printf("\n\r");
}

void layer1_blit_corners(int frame)
{
#ifdef USE_COLOR_DEBUG
	return;
#else
	int i;
	coord_t W = LAYER1_WIDTH;
	coord_t H = LAYER1_HEIGHT;
	coord_t h;

	uint32_t addr0;
	uint32_t addr1;
	uint32_t addr2;

	if((frame != FRAMEBUFFER0) && (frame != FRAMEBUFFER1))
	{
		xil_printf("layer1_blit_corners fail, illegal frame = %d\n\r", frame);
		return;
	}

	addr0 = (uint32_t)addr_empty_pic;
	addr1 = (uint32_t)gdispGetFrameBufferAddr(frame);

	int length;

	if(H > 500)
		h = CUT_PIXEL1;
	else
		h = CUT_PIXEL2;

	h = cut_pixel;

	for(i = 0; i < h; i++)
	{
		length = h - i;
		//length = cuts[i];

		addr2 = (u32)(LAYER0_WIDTH * 4 * (LAYER1_START_Y + i) + addr1 + 4 * LAYER1_START_X);
		dma_copy((u32) addr0, addr2, length);

		addr2 = addr2 + (W - length) * 4 ;
		dma_copy((u32) addr0, addr2, length);

		addr2 = (u32)(LAYER0_WIDTH * 4 * (LAYER1_START_Y + H - i) + addr1 + 4 * LAYER1_START_X);
		dma_copy((u32) addr0, addr2, length);

		addr2 = addr2 + (W - length) * 4 ;
		dma_copy((u32) addr0, addr2, length);
	}
	return;
#endif
}

void draw_layer_boundary(void)
{
	int i;
	coord_t tmp1 = LAYER0_WIDTH - LAYER1_WIDTH - BORDER_X;
	coord_t tmp2 = BORDER_Y;
	coord_t tmp3 = LAYER1_WIDTH;
	coord_t tmp4 = LAYER1_HEIGHT;

	xil_printf("\n\rDraw layer boundary\n\r");

	gdispDrawBox(tmp1, tmp2, tmp3, tmp4, Red);

	tmp1 += (LAYER1_WIDTH - pic_width) / 2;
	tmp2 += (LAYER1_HEIGHT - pic_height) / 2;
	tmp3 = pic_width;
	tmp4 = pic_height;

	//gdispDrawBox(tmp1, tmp2, tmp3, tmp4, Blue);		//default picture box
	//xil_printf("gdispDrawBox Blue (%d, %d) (%d, %d)\n\r", tmp1, tmp2, tmp3, tmp4);

	gdispDrawBox(0, 0, LAYER0_WIDTH - 1, LAYER0_HEIGHT - 1, White);							//Layer0
	gdispDrawBox(LAYER1_START_X, LAYER1_START_Y, LAYER1_WIDTH, LAYER1_HEIGHT, Yellow);		//Layer1
	gdispDrawBox(LAYER2_START_X, LAYER2_START_Y, LAYER2_WIDTH, LAYER2_HEIGHT, Yellow);		//Layer2

	for(i = 1;i < 3; i++)
	{
		//gdispDrawBox(LAYER2_START_X + 40 * i , LAYER2_START_Y + 30 * i, LAYER2_WIDTH - 40 * 2 * i, LAYER2_HEIGHT - 30 * 2 * i, Red);	//Layer2
		gdispDrawBox(LAYER2_START_X + 8 * i , LAYER2_START_Y + 6 * i, LAYER2_WIDTH - 8 * 2 * i, LAYER2_HEIGHT - 6 * 2 * i, Red);	//Layer2
	}

	gdispDrawLine(LAYER2_START_X + LAYER2_WIDTH / 2, LAYER2_START_Y, LAYER2_START_X + LAYER2_WIDTH / 2, LAYER2_START_Y + LAYER2_HEIGHT, Red);
	gdispDrawLine(LAYER2_START_X, LAYER2_START_Y + LAYER2_HEIGHT / 2, LAYER2_START_X + LAYER2_WIDTH, LAYER2_START_Y + LAYER2_HEIGHT / 2, Red);

	for(i = 1;i < 3; i++)
	{
		//gdispDrawBox(LAYER1_START_X + 76 * i , LAYER1_START_Y + 57 * i, LAYER1_WIDTH - 76 * 2 * i, LAYER1_HEIGHT - 57 * 2 * i, Red);	//Layer1
		gdispDrawBox(LAYER1_START_X + 15 * i , LAYER1_START_Y + 11 * i, LAYER1_WIDTH - 15 * 2 * i, LAYER1_HEIGHT - 11 * 2 * i, Red);	//Layer1
	}
	gdispDrawLine(LAYER1_START_X + LAYER1_WIDTH / 2, LAYER1_START_Y, LAYER1_START_X + LAYER1_WIDTH / 2, LAYER1_START_Y + LAYER1_HEIGHT, Red);
	gdispDrawLine(LAYER1_START_X, LAYER1_START_Y + LAYER1_HEIGHT / 2, LAYER1_START_X + LAYER1_WIDTH, LAYER1_START_Y + LAYER1_HEIGHT / 2, Red);




	/*
	for(i = 0; i < LAYER1_WIDTH; i += LAYER1_WIDTH / 8)
	{
		gdispDrawLine(i + LAYER1_START_X, 0 + LAYER1_START_Y, i + LAYER1_START_X - 1, LAYER1_HEIGHT + LAYER1_START_Y - 1, Gray);
	}
	for(i = 0; i < LAYER1_HEIGHT; i += LAYER1_HEIGHT / 8)
	{
		gdispDrawLine(0 + LAYER1_START_X, i + LAYER1_START_Y, LAYER1_WIDTH + LAYER1_START_X - 1, i + LAYER1_START_Y - 1, Gray);
	}
	*/

	/*	test draw something
	coord_t width;
	coord_t height;

	// Get the screen size
	width = gdispGetWidth();
	height = gdispGetHeight();

	gdispDrawBox(100, 100, width-100*2, height-100*2, Yellow);
	gdispFillArea(300, 300, width-300*2, height-300*2, Lime);

	gdispDrawLine(100, 100, width-100, height-100, Red);
	gdispDrawLine(width - 100, height - 100, 100, 100, Red);
	gdispDrawLine(width/2, 100, width/2, height-100, Red);
	gdispDrawLine(100, height/2, width-100, height/2, Red);
	*/


}

void update_framebuffer(void)
{
	if(flag_use_2_framebuffers == TRUE)
	{
		gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(next_framebuffer));
	}

	//ShowDateInfo(RecvBuffer);
	update_widget_data(RecvBuffer);

	if(flag_use_2_framebuffers == TRUE)
	{
		switch_to_framebuffer(next_framebuffer);
	}
	return;
}

void switch_to_framebuffer(int frame)
{
	if((frame != FRAMEBUFFER0) && (frame != FRAMEBUFFER1))
	{
		xil_printf("switch_to_framebuffer fail, illegal frame = %d\n\r", frame);
		return;
	}
	current_framebuffer = frame;
	next_framebuffer = 1 - frame;
	uint32_t addr;
	addr = gdispGetFrameBufferAddr(frame);
	Xil_Out32(0x43cc0440, addr);
	//xil_printf("\n\ruse framebuffer %d\n\r", frame);
	return;
}

void GetScuInfo(XScuGic *InstancePtr)
{
	u32 Int_Id;
	//for (Int_Id = 0U; Int_Id<XSCUGIC_MAX_NUM_INTR_INPUTS;Int_Id++)
	for (Int_Id = 0U; Int_Id < 100; Int_Id++)
	{
		xil_printf("Int_Id = %d\tHandler = 0x%08x\tCallBackRef=0x%08x\r\n", Int_Id, InstancePtr->Config->HandlerTable[Int_Id].Handler, InstancePtr->Config->HandlerTable[Int_Id].CallBackRef);
	}
	return;
}


void SetDongleLedRedStatus(int status)
{
	ps_gpio_setup(&periphs_inst, GPIO_IO_KEY, status);
	return;
}

void SetDongleLedGreenStatus(int status)
{
	ps_gpio_setup(&periphs_inst, GPIO_IO_CD, status);
	return;
}

void RequestShowPicture(int pic)
{
	if(flag_use_2_framebuffers == TRUE)
	{
		gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(next_framebuffer));
	}

	if(pic == -1)
	{
		if(flag_use_2_framebuffers == TRUE)
			clear_layer1(next_framebuffer);
		else
			clear_layer1(1 - next_framebuffer);
	}
	else if(pic == 3)
	{
		clear_layer1_all(next_framebuffer, FALSE);
		if(flag_use_2_framebuffers == TRUE)
			clear_layer1_all(1 - next_framebuffer, FALSE);

		dma_restore_picture(pic);

		if(flag_use_2_framebuffers == TRUE)
		{
			layer1_blit(pic_sizes[pic], next_framebuffer);
			layer1_blit_corners(next_framebuffer);
		}
		else
		{
			layer1_blit(pic_sizes[pic], 1 - next_framebuffer);
			layer1_blit_corners(1 - next_framebuffer);
		}
	}
	else
	{
		dma_restore_picture(pic);
		if(flag_use_2_framebuffers == TRUE)
		{
			layer1_blit(pic_sizes[pic], next_framebuffer);
			layer1_blit_corners(next_framebuffer);
		}
		else
		{
			layer1_blit(pic_sizes[pic], 1 - next_framebuffer);
			layer1_blit_corners(1 - next_framebuffer);
		}
	}

	if(flag_use_2_framebuffers == TRUE)
	{
		switch_to_framebuffer(next_framebuffer);
		gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(next_framebuffer));

		if(pic == -1)
		{
			clear_layer1(next_framebuffer);
		}
		else
		{
			dma_restore_picture(pic);
			layer1_blit(pic_sizes[pic], next_framebuffer);
			layer1_blit_corners(next_framebuffer);
		}
		switch_to_framebuffer(next_framebuffer);
	}

	if(pic == -1)
	{
		enable_camera(CAMERA_RUN);
	}
	else if(pic == 2)
	{
		enable_camera(CAMERA_FREEZE);
	}
	else if(pic == 3)
	{
		enable_camera(CAMERA_FORBID);
	}

	return;
}

void RequestShowPicture2(int pic)
{
	if(flag_use_2_framebuffers == TRUE)
	{
		gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(next_framebuffer));
	}

	if(pic == -1)
	{
		if(flag_use_2_framebuffers == TRUE)
			clear_layer1(next_framebuffer);
		else
			clear_layer1(1 - next_framebuffer);
	}
	else if(pic == 3)		//forbid video
	{
		clear_layer1_all(next_framebuffer, FALSE);
		layer1_blit_corners(next_framebuffer);
		if(flag_use_2_framebuffers == TRUE)
		{
			clear_layer1_all(1 - next_framebuffer, FALSE);
			layer1_blit_corners(1 - next_framebuffer);
		}

		dma_restore_picture(pic);

		if(flag_use_2_framebuffers == TRUE)
		{
			layer1_blit(pic_sizes[pic], next_framebuffer);
			//layer1_blit_corners(next_framebuffer);
		}
		else
		{
			layer1_blit(pic_sizes[pic], 1 - next_framebuffer);
			//layer1_blit_corners(1 - next_framebuffer);
		}
	}
	else
	{
		dma_restore_picture(pic);
		if(flag_use_2_framebuffers == TRUE)
		{
			layer1_blit(pic_sizes[pic], next_framebuffer);
			layer1_blit_corners(next_framebuffer);
		}
		else
		{
			layer1_blit(pic_sizes[pic], 1 - next_framebuffer);
			layer1_blit_corners(1 - next_framebuffer);
		}
	}

	add_draw_command(pic, 3);	//3 is dummy now

	if(flag_use_2_framebuffers == TRUE)
	{
		switch_to_framebuffer(next_framebuffer);
		gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(next_framebuffer));

		if(pic == -1)
		{
			clear_layer1(next_framebuffer);
		}
		else
		{
			dma_restore_picture(pic);
			layer1_blit(pic_sizes[pic], next_framebuffer);
			layer1_blit_corners(next_framebuffer);
		}
		switch_to_framebuffer(next_framebuffer);
	}

	if(pic == -1)
	{
		enable_camera(CAMERA_RUN);
	}
	else if(pic == 2)
	{
		enable_camera(CAMERA_FREEZE);
	}
	else if(pic == 3)
	{
		enable_camera(CAMERA_FORBID);
	}

	flag_update_RTC_status = 1;
	return;
}

void init_system()
{
	int i;
	u32 BootModeRegister = 0;

	flag_update_RTC_status = 0;
	flag_camera_video_status = 0;
	flag_update_dongle_status = 0;
	update_usb_status = 0;
	update_usb_descriptor_status = 0;
	usb_reset_status = 0;
	usb_reset_status_old = 0;
	flag_updateConsoleWidgets = FALSE;		//debug message
	flag_updateConsoleWidgets_old = 0;
	flag_is_keyboard_mounted = 0;
	flag_is_keyboard_mounted_old = 0;
	flag_camera_led_status = 0;		//0:off, 1:on
	keyboard_mounted_cnt = 0;
	vendor_id_tmp = 0;
	product_id_tmp = 0;
	going_to_engineering_mode_cnt = 0;
	flag_engineering_mode = FALSE;
	flag_engineering_mode_old = 0;
	dongle_usage_count = 0;
	fw_write_count = 0;
	fan_speed = 0;
	alpha = ALPHA;
	g_metering_mode = 0;	//Auto = 0, Center = 1, Average = 2;
	g_exposure = 3;
	camera_exposure = CAMERA_EXPO_DEFAULT_VALUE;
	flag_setup_exposure = 0;
	g_procedure_started = START_STATUS;
	zoom_cut = ZOOM_CUT;
	if(zoom_cut > 200)
	{
		zoom_cut = 200;
	}
	flag_use_user_brightness = FALSE;
	default_user_brightness = 0;

    xil_printf("\n\n\n\nAries Main Program\n\r");
    xil_printf("Compiled time: %s %s\n\r", __DATE__, __TIME__);

    #if defined(USE_CARRIER_BLACK)
    	xil_printf("CARRIER_BLACK + ");
    #elif defined(USE_CARRIER_RED)
    	xil_printf("CARRIER_RED + ");
	#else
    	xil_printf("xxxx CARRIER_Unknown + ");
	#endif

	#if defined(USE_Z7020)
		xil_printf("USE_Z7020 + ");
	#elif defined(USE_Z7015)
		xil_printf("USE_Z7015 + ");
	#else
		xil_printf("xxxx PZ_Unknown + ");
	#endif

	#ifdef SW_RELEASE
		xil_printf("SW_RELEASE Version\t");
	#else
		xil_printf("Engineering Version\t");
	#endif

	#ifdef USE_IMS_LINK
		xil_printf("USE_IMS_LINK\n\r\n\r");
	#else
		xil_printf("USE_comport\n\r\n\r");
	#endif

	xil_printf("tick(%d) = %d;\t%%%s:%s(%d)\r\n", tick_cnt++, g_ms_tick, __FILE__, __func__, __LINE__);

    addr_empty_pic = (uint32_t)empty_pic;
    addr_tmp_pic = (uint32_t)tmp_pic;

    for(i = 0;i<1216*4;i++)
    {
    	empty_pic[i] = 0xff000000;
    }
    for(i = 0;i<400*4;i++)
    {
    	tmp_pic[i] = 0x55FF0000;
    }
    //xil_printf("addr empty_pic: 0x%08x\r\n", addr_empty_pic);
    //xil_printf("addr   tmp_pic: 0x%08x\r\n", addr_tmp_pic);

	/*
	 * Read bootmode register
	 */
	BootModeRegister = Xil_In32(BOOT_MODE_REG);
	BootModeRegister &= BOOT_MODES_MASK;

	xil_printf("BootModeRegister = 0x%08x = %d\r\n", BootModeRegister, BootModeRegister);
	/*
	if (BootModeRegister == QSPI_MODE) {
		fsbl_printf("Boot mode is QSPI\n\r");
		//InitQspi();
		fsbl_printf("QSPI Init Done \r\n");
	}
	*/

    return;
}


uint8_t keycode_to_ascii2(uint8_t modifier, uint8_t keycode)
{
  // TODO max of keycode_ascii_tbl
  return keycode > 128 ? 0 :
    hid_keycode_to_ascii_tbl [modifier & (KEYBOARD_MODIFIER_LEFTSHIFT | KEYBOARD_MODIFIER_RIGHTSHIFT) ? 1 : 0] [keycode];
}

int process_function_key(uint8_t keycode)
{
	int result = XST_SUCCESS;

	if(keycode == 1)
	{
		xil_printf("====>\tF1\n\r");

		if(flag_modify_pinfo_mode != 0)
		{
			confirm_enter_key(flag_modify_pinfo_mode);
			flag_modify_pinfo_mode = 0;
		}

		result = XST_DEVICE_IS_STOPPED;
		flag_id_ok = FALSE;

		flag_modify_pinfo_mode = KEY_F1;
#ifdef USE_BARCODE_SCANNER
		flag_use_barcode_scanner = TRUE;
#else
		flag_use_barcode_scanner = FALSE;
#endif
		scanner_index = 0;
		int i;
		for(i = 0; i < 20; i++)
		{
			scanner_data[i] = 0;
		}

		memset(p_info_data, '\0', DATA_LENGTH); // Clear buffer
		p_info_data_index = 0;
	}
	else if(keycode == 2)
	{
		xil_printf("====>\tF2\n\r");
		result = XST_DEVICE_IS_STOPPED;
	}
	else if(keycode == 3)
	{
		xil_printf("====>\tF3\n\r");
	}
	else if(keycode == 4)
	{
		xil_printf("====>\tF4\n\r");
		result = XST_DEVICE_IS_STOPPED;
		birth_mm = 0;
		birth_dd = 0;
		birth_yyyy = 0;
		birth_age = 0;

		flag_birth_mm_ok = FALSE;
		flag_birth_dd_ok = FALSE;
		flag_birth_yyyy_ok = FALSE;
	}
	else if(keycode == 5)
	{
		xil_printf("====>\tF5\n\r");
		result = XST_DEVICE_IS_STOPPED;
	}
	else if(keycode == 6)
		xil_printf("====>\tF6\n\r");
	else if(keycode == 7)
		xil_printf("====>\tF7\n\r");
	else if(keycode == 8)
		xil_printf("====>\tF8\n\r");
	else if(keycode == 9)
	{
		xil_printf("====>\tF9\n\r");
		if(flag_engineering_mode == TRUE)
		{
			show_camera_serial(-1);
			show_camera_date(-1);
			if(flag_use_2_framebuffers == TRUE)
			{
				gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(next_framebuffer));
				show_camera_serial(-1);
				show_camera_date(-1);
				gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(1 - next_framebuffer));
			}
			usleep(500000);

			read_camera_info_from_camera_eng();
			show_camera_info_eng();
			show_camera_serial(1);
			show_camera_date(1);
			if(flag_use_2_framebuffers == TRUE)
			{
				gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(next_framebuffer));
				show_camera_serial(1);
				show_camera_date(1);
				gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(1 - next_framebuffer));
			}
		}
	}
	else if(keycode == 10)
		xil_printf("====>\tF10\n\r");
	else if(keycode == 11)
		xil_printf("====>\tF11\n\r");
	else if(keycode == 12)
		xil_printf("====>\tF12\n\r");
	else
	{
		xil_printf("====>\txxxxx keycode = %d\n\r", keycode);
	}
	update_user_data(keycode);

	return result;
}

int process_arrow_key(uint8_t keycode)
{
	int result = XST_SUCCESS;

	if((flag_engineering_mode == TRUE) && (engineering_mode_setup_item != 0))
	{
		if((keycode == KEY_RIGHT) || (keycode == KEY_UP))
		{
			xil_printf("+");
			modify_current_setup_value(1);
			//result = XST_DEVICE_IS_STOPPED;
		}
		else if((keycode == KEY_LEFT) || (keycode == KEY_DOWN))
		{
			xil_printf("-");
			modify_current_setup_value(0);
			//result = XST_DEVICE_IS_STOPPED;
		}
		else
		{
			xil_printf("====>\tarrow key xxxx\n\r");
		}
	}
	else
	{
		if(keycode == KEY_RIGHT)
		{
			xil_printf("====>\tKEY_RIGHT\n\r");
		}
		else if(keycode == KEY_LEFT)
		{
			xil_printf("====>\tKEY_LEFT\n\r");
		}
		else if(keycode == KEY_DOWN)
		{
			xil_printf("====>\tKEY_DOWN\n\r");
		}
		else if(keycode == KEY_UP)
		{
			xil_printf("====>\tKEY_UP\n\r");
		}
		else
		{
			xil_printf("====>\tarrow key xxxx keycode = %d\n\r", keycode);
		}
	}
	return result;
}

int usb_keyboard_send_keycode(uint8_t modifier, uint8_t keycode)
{
	int result = XST_SUCCESS;
	uint8_t ch = keycode_to_ascii2(modifier, keycode);

	if(flag_use_barcode_scanner == TRUE)
	{
		scanner_data[scanner_index] = ch;
		scanner_index++;

		p_info_data[p_info_data_index] = ch;
		p_info_data_index++;

		//check abort signal
	    if((modifier == 0)&&(keycode == 41))
	    {
	    	xil_printf("====>\tESC\n\r");
			restore_old_data(flag_modify_pinfo_mode);
			flag_modify_pinfo_mode = 0;
	    }

		int i;

		if(ch == 0x0D)
		{
			flag_use_barcode_scanner = FALSE;
			//xil_printf("len = %\n\r", scanner_index - 1);
			for(i = 0; i < (scanner_index - 1); i++)
			{
				//xil_printf("i = %d, code = 0x%x\n\r", i, scanner_data[i]);
				//p_info_data[i] = scanner_data[i];
				p_info_data[i] = p_info_data[i];
			}
			flag_id_ok = TRUE;
			confirm_enter_key(KEY_F1);
		}

		if(scanner_index == 20)
		{
			flag_use_barcode_scanner = FALSE;
		}
		return result;
	}

	if(isprint(ch))
	{
		xil_printf("%c",ch);
		if(flag_modify_pinfo_mode != 0)
		{
			update_pinfo_on_widget(ch);
		}
		if((flag_check_engineering_mode == 2) && ch == 'i')
		{
			flag_check_engineering_mode++;
		}
		else if((flag_check_engineering_mode == 3) && ch == 'm')
		{
			flag_check_engineering_mode++;
		}
		else if((flag_check_engineering_mode == 4) && ch == 's')
		{
			flag_engineering_mode = TRUE;
			flag_check_engineering_mode = 0;
			show_engineering_mode();
		}
		else
		{
			flag_check_engineering_mode = 0;
		}
		if((ch == '+') || (ch == '-'))
		{
			if((flag_engineering_mode == TRUE) && (engineering_mode_setup_item != 0))
			{
				if(ch == '+')
				{
					xil_printf("+");
					modify_current_setup_value(1);
				}
				else if(ch == '-')
				{
					xil_printf("-");
					modify_current_setup_value(0);
				}
			}
		}
	}
	else
	{
	    if((modifier == 0) &&(keycode == 44))
	    	xil_printf("====>\tSpace\n\r");
	    else if((modifier == 0) &&(keycode >= 58) && (keycode <= 69))
	    {
	    	result = process_function_key(keycode - 57);
	    }
	    else if((modifier == 0) &&((keycode == 40)||(keycode == 88)))
	    {
	    	xil_printf("====>\tEnter\n\r");
	    	result = XST_DEVICE_IS_STARTED;

	    	if(flag_modify_pinfo_mode != 0	)
	    	{
		    	confirm_enter_key(flag_modify_pinfo_mode);
		    	flag_modify_pinfo_mode = 0;
	    	}
	    	if(flag_engineering_mode == TRUE)
	    	{
				if(engineering_mode_setup_item != 0)
				{
					apply_current_setting();
		    		engineering_mode_setup_item++;
		    		if(engineering_mode_setup_item > 8)
		    		{
		    			confirm_language_item();
		    			engineering_mode_setup_item = 1;
		    		}
		    		keep_current_setup_value(engineering_mode_setup_item);
		    		refresh_current_setup_value();
				}
	    	}
	    }
	    else if((modifier == 0)&&(keycode == 41))
	    {
	    	xil_printf("====>\tESC\n\r");
#ifdef USE_DATA_INPUT
			if(flag_modify_pinfo_mode != 0)
			{
				restore_old_data(flag_modify_pinfo_mode);
				flag_modify_pinfo_mode = 0;
			}
#endif
	    	if(flag_engineering_mode == TRUE)
	    	{
	    		xil_printf("Abort current setting.......\n\r");
	    		if(engineering_mode_setup_item == 8)
	    			confirm_language_item();
	    		engineering_mode_setup_item = 0;
	    	}
	    }
	    else if((modifier == 0)&&(keycode == 42))
	    {
	    	xil_printf("====>\tBackspace\n\r");
#ifdef USE_DATA_INPUT
			if(flag_modify_pinfo_mode != 0)
			{
				update_pinfo_on_widget(ch);
			}
#endif
	    }
	    else if((modifier == 1)&&(keycode == 72))
	    {
	    	xil_printf("====>\tCtrl + Break\n\r");
	    	flag_check_engineering_mode++;
	    }
	    else if((modifier == 0) &&(keycode >= 79) && (keycode <= 82))
	    {
	    	result = process_arrow_key(keycode);
	    }
	    else if((modifier == 0)&&(keycode == 43))
	    {
	    	xil_printf("====>\tTab\n\r");
	    	if(flag_engineering_mode == TRUE)
	    	{
	    		//xil_printf("Jump to next item.......\n\r");
	    		engineering_mode_setup_item++;
	    		if(engineering_mode_setup_item > 8)
	    		{
	    			SelectedLanguage = SelectedLanguage_eng;
	    			confirm_language_item();
	    			engineering_mode_setup_item = 1;
	    		}
	    		keep_current_setup_value(engineering_mode_setup_item);
	    		refresh_current_setup_value();
	    	}
	    }
	    else if((modifier == 0)&&(keycode == 56))
	    	xil_printf("====>\t/\n\r");
	    else if((modifier == 0)&&(keycode == 75))
	    {
	    	xil_printf("====>\tPageUp\n\r");
#ifdef USE_DATA_INPUT
/*
	    	if(p_info_index == 0)
	    		p_info_index = P_INFO_LEN - 1;
	    	else
	    		p_info_index--;
	    	createWidgets();
	    	if(flag_use_2_framebuffers == TRUE)
	    	{
				gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(next_framebuffer));
				createWidgets();
				gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(1 - next_framebuffer));
	    	}
*/
#endif
	    }
	    else if((modifier == 0)&&(keycode == 78))
	    {
	    	xil_printf("====>\tPageDown\n\r");
#ifdef USE_DATA_INPUT
/*
	    	p_info_index++;
	    	p_info_index %= P_INFO_LEN;
	    	createWidgets();
	    	if(flag_use_2_framebuffers == TRUE)
	    	{
				gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(next_framebuffer));
				createWidgets();
				gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(1 - next_framebuffer));
	    	}
*/
#endif
	    }
	    else if((modifier == 0)&&(keycode == 53))
	    	xil_printf("====>\t'\n\r");
	    else if(((modifier == 2)||(modifier == 32))&&(keycode == 53))
	    	xil_printf("====>\t~\n\r");
	    else if((modifier == 1)&&(keycode == 69))
	    	xil_printf("====>\tCtrl + F12\n\r");
	    else
	    {
			xil_printf("====> xxxxxx\tmodifier = %d, keycode = %d\t\tch = 0x%02x = %d\r\n", modifier, keycode, ch, ch);
	    }
	}
	return result;
}

void confirm_enter_key(int flag_modify_pinfo_mode)	//only for function key
{
	if(flag_modify_pinfo_mode == 0)
		return;

	GWidgetInit	wi;
	int OFFSET = WIDTH1;

	// Apply some default values for GWIN
	gwinWidgetClearInit(&wi);
	wi.g.show = TRUE;
	wi.text = "1234567890";

	gwinSetDefaultFont(gdispOpenFont("iskpota232"));

	wi.g.width = WIDTH2; wi.g.height = THICK1 + 5; wi.g.x = OFFSET_X + BORDER_X + OFFSET; wi.g.y = BORDER_Y + THICK1 * (flag_modify_pinfo_mode - KEY_F0);

	if(flag_modify_pinfo_mode >= KEY_F4)
		wi.g.y += THICK1;

	if(flag_modify_pinfo_mode == KEY_F1)
	{
		sprintf((char *)wi.text, "%s   ", p_info_data);

		if(flag_id_ok == TRUE)
		{
			xil_printf("flag_id_ok = TRUE\n\r");
			//int x_st = OFFSET_X + BORDER_X + OFFSET;
			//int y_st = BORDER_Y + THICK1 * 0;

			//gdispFillArea(x_st, y_st, 450, 250, Black);		//draw black id row
			ghLabel2 = gwinLabelCreate(0, &wi);
			gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(next_framebuffer));
			//gdispFillArea(x_st, y_st, 450, 250, Black);		//draw black id row
			ghLabel2 = gwinLabelCreate(0, &wi);
			gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(1 - next_framebuffer));

			//also update widgets2 id
			wi.g.width = CAMERA_INFO_WIDTH1A; wi.g.height = THICK1; wi.g.x = CAMERA_INFO_POS_X1 + CAMERA_INFO_POS_OFFSET1; wi.g.y = CAMERA_INFO_POS_Y1;
			ghLabel1 = gwinLabelCreate(0, &wi);
			gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(next_framebuffer));
			ghLabel1 = gwinLabelCreate(0, &wi);
			gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(1 - next_framebuffer));
		}
		else
		{
			xil_printf("flag_id_ok = FALSE\n\r");
			gdispFillArea(wi.g.x - 5, wi.g.y - 5, WIDTH2 + 5 , 45, Black);		//draw black id row
			gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(next_framebuffer));
			gdispFillArea(wi.g.x - 5, wi.g.y - 5, WIDTH2 + 5, 45, Black);		//draw black id row
			gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(1 - next_framebuffer));

			//also update widgets2 id
			wi.g.width = WIDTH1 + 170; wi.g.height = THICK1; wi.g.x = CAMERA_INFO_POS_X1 + OFFSET; wi.g.y = CAMERA_INFO_POS_Y1;
			gdispFillArea(wi.g.x - 15, wi.g.y - 5, 312, 45, Black);		//draw black id row
			gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(next_framebuffer));
			gdispFillArea(wi.g.x - 15, wi.g.y - 5, 312, 45, Black);		//draw black id row
			gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(1 - next_framebuffer));
		}
	}
	else if(flag_modify_pinfo_mode == KEY_F2)
	{
		sprintf((char *)wi.text, "%s   ", p_info_data);

		ghLabel2 = gwinLabelCreate(0, &wi);
		gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(next_framebuffer));
		ghLabel2 = gwinLabelCreate(0, &wi);
		gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(1 - next_framebuffer));

		//also update widgets2 name
		wi.g.width = CAMERA_INFO_WIDTH1A; wi.g.height = THICK1; wi.g.x = CAMERA_INFO_POS_X1 + CAMERA_INFO_POS_OFFSET1; wi.g.y = CAMERA_INFO_POS_Y2;
		ghLabel1 = gwinLabelCreate(0, &wi);
		gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(next_framebuffer));
		ghLabel1 = gwinLabelCreate(0, &wi);
		gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(1 - next_framebuffer));
	}
	else if(flag_modify_pinfo_mode == KEY_F4)
	{
		p_info_data[2] = p_info_data[3];	///
		p_info_data[3] = p_info_data[4];	//DD
		p_info_data[4] = p_info_data[5];	//DD
		p_info_data[5] = p_info_data[7];	///
		p_info_data[6] = p_info_data[8];	//YY
		p_info_data[7] = p_info_data[9];	//YY
		p_info_data[8] = p_info_data[10];	//YY
		p_info_data[9] = p_info_data[11];	//YY
		p_info_data[10] = '\0';
		p_info_data[11] = '\0';

		sprintf((char *)wi.text, "%s   ", p_info_data);

		birth_age = rtc.tm_year + 1900 - birth_yyyy;

		//xil_printf("get MM/DD/YYYY = %d/%d/%d  age : %d\n\r", birth_mm, birth_dd, birth_yyyy, birth_age);
		//xil_printf("now year : %d\n\r", rtc.tm_year + 1900);

		//update age data
		gdispFillArea(wi.g.x - 5, wi.g.y - 5, 312, 40, Black);		//draw black birthday row
		gdispFillArea(wi.g.x - 5, wi.g.y - 5 + THICK1, 312, 40, Black);		//draw black age row

		gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(next_framebuffer));
		gdispFillArea(wi.g.x - 5, wi.g.y - 5, 312, 40, Black);		//draw black birthday row
		gdispFillArea(wi.g.x - 5, wi.g.y - 5 + THICK1, 312, 40, Black);		//draw black age row

		gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(1 - next_framebuffer));

		if((flag_birth_mm_ok == TRUE)&&(flag_birth_dd_ok == TRUE)&&(flag_birth_yyyy_ok == TRUE))
		{
			//update age data
			updateWidgets_age_data();
			gdispFillArea(wi.g.x - 5, wi.g.y - 5, 312, 40, Black);		//draw black birthday row
			gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(next_framebuffer));
			updateWidgets_age_data();
			gdispFillArea(wi.g.x - 5, wi.g.y - 5, 312, 40, Black);		//draw black birthday row
			gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(1 - next_framebuffer));

			ghLabel2 = gwinLabelCreate(0, &wi);
			gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(next_framebuffer));
			ghLabel2 = gwinLabelCreate(0, &wi);
			gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(1 - next_framebuffer));

			//also update widgets2 birthday
			wi.g.width = CAMERA_INFO_WIDTH1A; wi.g.height = THICK1; wi.g.x = CAMERA_INFO_POS_X1 + CAMERA_INFO_POS_OFFSET1 + 3; wi.g.y = CAMERA_INFO_POS_Y3;
			ghLabel1 = gwinLabelCreate(0, &wi);
			gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(next_framebuffer));
			ghLabel1 = gwinLabelCreate(0, &wi);
			gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(1 - next_framebuffer));
		}
		else
		{
			xil_printf("invalid birthday data\n\r");

			//also update widgets2 birthday
			wi.text = "";
			wi.g.width = CAMERA_INFO_WIDTH1A; wi.g.height = THICK1; wi.g.x = CAMERA_INFO_POS_X1 + CAMERA_INFO_POS_OFFSET1; wi.g.y = CAMERA_INFO_POS_Y3;
			gdispFillArea(wi.g.x, wi.g.y, CAMERA_INFO_WIDTH1A, THICK1, Black);		//draw black birthday row
			gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(next_framebuffer));
			gdispFillArea(wi.g.x, wi.g.y, CAMERA_INFO_WIDTH1A, THICK1, Black);		//draw black birthday row
			gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(1 - next_framebuffer));
		}
	}

	return;
}

void backup_old_data(int flag_modify_pinfo_mode)
{
#ifdef USE_DATA_INPUT
	//TBD
	if(flag_modify_pinfo_mode == 0)
		return;

	if((flag_modify_pinfo_mode == KEY_F1) || (flag_modify_pinfo_mode == KEY_F2) || (flag_modify_pinfo_mode == KEY_F4))
	{
		if(p_info_data_index == 0)
		{


		}
		else
		{
			//default data
		}
		//uint8_t p_info_data[DATA_LENGTH];
		//uint8_t p_info_data_old[DATA_LENGTH];
	}
#endif
	return;
}

void restore_old_data0(int flag_modify_pinfo_mode)
{
#ifdef USE_DATA_INPUT
	if(flag_modify_pinfo_mode == 0)
		return;

	GWidgetInit	wi;
	int OFFSET = WIDTH1;

	// Apply some default values for GWIN
	gwinWidgetClearInit(&wi);
	wi.g.show = TRUE;
	wi.text = "12345678901234567890";

	gwinSetDefaultFont(gdispOpenFont("iskpota232"));

	if(flag_modify_pinfo_mode == KEY_F1)
	{
	wi.g.width = WIDTH2; wi.g.height = THICK1; wi.g.x = OFFSET_X + BORDER_X + OFFSET; wi.g.y = BORDER_Y + THICK1 * 0;
	//wi.text = "";
	//sprintf((char *)wi.text, "%d", p_infos[p_info_index].id_no);
	wi.text = (const char *)p_infos[p_info_index].id_no;
	ghLabel1 = gwinLabelCreate(0, &wi);
	gdispFillArea(wi.g.x - 5, wi.g.y - 5, 312, 50, Black);		//draw black id row
	}

	if(flag_modify_pinfo_mode == KEY_F2)
	{
	wi.g.width = WIDTH2; wi.g.height = THICK1; wi.g.x = OFFSET_X + BORDER_X + OFFSET; wi.g.y = BORDER_Y + THICK1 * 1;
	wi.text = (const char *)p_infos[p_info_index].name;
	ghLabel2 = gwinLabelCreate(0, &wi);
	}

	if(flag_modify_pinfo_mode == KEY_F3)
	{
	wi.g.width = CAMERA_INFO_WIDTH2A; wi.g.height = THICK1; wi.g.x = OFFSET_X + BORDER_X + OFFSET; wi.g.y = BORDER_Y + THICK1 * 3;
	if(p_infos[p_info_index].sex == 1)
		wi.text = "Male";
	else
		wi.text = "Female";
	ghLabel3 = gwinLabelCreate(0, &wi);
	}

	wi.text = "12345678901234567890";

	if(flag_modify_pinfo_mode == KEY_F4)
	{
	wi.g.width = WIDTH2; wi.g.height = THICK1; wi.g.x = OFFSET_X + BORDER_X + OFFSET; wi.g.y = BORDER_Y + THICK1 * 4;
	wi.text = (const char *)p_infos[p_info_index].birthday;
	ghLabel4 = gwinLabelCreate(0, &wi);

	gdispFillArea(wi.g.x - 5, wi.g.y - 5, 312, 50, Black);		//draw black birthday row
	}


	if(flag_modify_pinfo_mode == KEY_F5)
	{
		flag_use_barcode_scanner = FALSE;

		int x_st = OFFSET_X + BORDER_X + OFFSET;
		int y_st = BORDER_Y + THICK1 * 0;

		//gdispFillArea(x_st - 5, y_st - 5, 312, 50, Black);		//draw black id row

		gdispFillArea(x_st, y_st, 312, 45, Black);		//draw black id row
		gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(next_framebuffer));
		gdispFillArea(x_st, y_st, 312, 45, Black);		//draw black id row
		gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(1 - next_framebuffer));

	}

#endif
	return;
}

void restore_old_data(int flag_modify_pinfo_mode)
{
#ifdef USE_DATA_INPUT
	if(flag_modify_pinfo_mode == 0)
		return;

	gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(next_framebuffer));
	restore_old_data0(flag_modify_pinfo_mode);
	gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(1 - next_framebuffer));
	restore_old_data0(flag_modify_pinfo_mode);
#endif
	return;
}

void update_user_data(uint8_t keycode)	//only for function key
{
#ifdef USE_DATA_INPUT
	GWidgetInit	wi;
	int OFFSET = WIDTH1;
	font_t font = gdispOpenFont("iskpota232");

	// Apply some default values for GWIN
	gwinWidgetClearInit(&wi);
	wi.g.show = TRUE;

	gwinSetDefaultFont(gdispOpenFont("iskpota232"));

	if((keycode == 1) || (keycode == 2) || (keycode == 4) || (keycode == 5))
	{
    	confirm_enter_key(flag_modify_pinfo_mode);

		if(keycode == 1)
		{
			xil_printf("F1\n\r");
			flag_modify_pinfo_mode = KEY_F1;
		}
		else if(keycode == 2)
		{
			xil_printf("F2\n\r");
			flag_modify_pinfo_mode = KEY_F2;
		}
		else if(keycode == 4)
		{
			xil_printf("F4\n\r");
			flag_modify_pinfo_mode = KEY_F4;

			wi.g.width = WIDTH2; wi.g.height = THICK1; wi.g.x = OFFSET_X + BORDER_X + OFFSET; wi.g.y = BORDER_Y + THICK1 * (flag_modify_pinfo_mode - KEY_F0) + 5;

			if(flag_modify_pinfo_mode >= KEY_F4)
				wi.g.y += THICK1;
		}
		else if(keycode == 5)
		{
			int i;
			xil_printf("F5, wait for barcode scanner\n\r");

			/*
			int x_st = OFFSET_X + BORDER_X + OFFSET;
			int y_st = BORDER_Y + THICK1 * 0;

			//gdispFillArea(x_st - 5, y_st - 5, 312, 50, Black);		//draw black id row

			gdispFillArea(x_st, y_st, 312, 45, White);		//draw black id row
			gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(next_framebuffer));
			gdispFillArea(x_st, y_st, 312, 45, White);		//draw black id row
			gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(1 - next_framebuffer));
			*/

			//also update widgets2 id
			wi.g.width = CAMERA_INFO_WIDTH1A; wi.g.height = THICK1; wi.g.x = CAMERA_INFO_POS_X1 + OFFSET; wi.g.y = CAMERA_INFO_POS_Y1;
			gdispFillArea(wi.g.x - 10, wi.g.y - 5, CAMERA_INFO_WIDTH1A + 10, 45, Black);		//draw black id row
			gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(next_framebuffer));
			gdispFillArea(wi.g.x - 10, wi.g.y - 5, CAMERA_INFO_WIDTH1A + 10, 45, Black);		//draw black id row
			gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(1 - next_framebuffer));

			flag_modify_pinfo_mode = KEY_F5;
			flag_use_barcode_scanner = TRUE;
			scanner_index = 0;
			for(i = 0; i < 20; i++)
			{
				scanner_data[i] = 0;
			}
		}
		backup_old_data(flag_modify_pinfo_mode);

		memset(p_info_data, '\0', DATA_LENGTH); // Clear buffer
		p_info_data_index = 0;

		wi.g.width = WIDTH2; wi.g.height = THICK1; wi.g.x = OFFSET_X + BORDER_X + OFFSET; wi.g.y = BORDER_Y + THICK1 * (flag_modify_pinfo_mode - KEY_F0) + 5;

		if(flag_modify_pinfo_mode >= KEY_F4)
			wi.g.y += THICK1;

		//gdispFillArea(wi.g.x, wi.g.y, WIDTH2, 30, White);

		if((keycode == 1) || (keycode == 5))
		{
			if (keycode == 1)
				xil_printf("F1\n\r");
			else
				xil_printf("F5\n\r");

			wi.g.x = OFFSET_X + BORDER_X + OFFSET,
			wi.g.y = BORDER_Y + THICK1 * 0;

			gdispFillArea(wi.g.x, wi.g.y + 5, WIDTH2 - 10, 30, White);
			wi.text = "                    ";
			gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(next_framebuffer));
			gdispFillArea(wi.g.x, wi.g.y + 5, WIDTH2 - 10, 30, White);
			wi.text = "                    ";
			gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(1 - next_framebuffer));

			//also update widgets2 id
			wi.g.width = WIDTH1 + 170; wi.g.height = THICK1; wi.g.x = CAMERA_INFO_POS_X1 + OFFSET; wi.g.y = CAMERA_INFO_POS_Y1;
			gdispFillArea(wi.g.x - 5, wi.g.y - 5, 340, 45, Black);		//draw black id row
			gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(next_framebuffer));
			gdispFillArea(wi.g.x - 5, wi.g.y - 5, 340, 45, Black);		//draw black id row
			gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(1 - next_framebuffer));
		}
		else if(keycode == 2)
		{
			xil_printf("F2\n\r");

			wi.g.x = OFFSET_X + BORDER_X + OFFSET,
			wi.g.y = BORDER_Y + THICK1 * 1;

			gdispFillArea(wi.g.x, wi.g.y + 5, WIDTH2 - 10, 35, White);
			wi.text = "                    ";
			gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(next_framebuffer));
			gdispFillArea(wi.g.x, wi.g.y + 5, WIDTH2 - 10, 35, White);
			wi.text = "                    ";
			gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(1 - next_framebuffer));

			//also update widgets2 name
			wi.g.width = CAMERA_INFO_WIDTH1A; wi.g.height = THICK1; wi.g.x = CAMERA_INFO_POS_X1 + CAMERA_INFO_POS_OFFSET1 + 3; wi.g.y = CAMERA_INFO_POS_Y2;
			gdispFillArea(wi.g.x - 5, wi.g.y - 5, 340, 45, Black);		//draw black id row
			gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(next_framebuffer));
			gdispFillArea(wi.g.x - 5, wi.g.y - 5, 340, 45, Black);		//draw black id row
			gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(1 - next_framebuffer));
		}
		else if(keycode == 4)
		{
			xil_printf("F4\n\r");

			font_t font = gdispOpenFont("iskpota232");
			int i;
			unsigned char str1[] = "MM /DD /YYYY";

			gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(next_framebuffer));
			gdispFillArea(wi.g.x - 5, wi.g.y - 5, 312, 40, White);
			gdispFillArea(wi.g.x - 5, wi.g.y - 5 + THICK1, 312, 40, Black);		//draw black age row

			for(i = 0; i < strlen((const char *)str1); i++)
			{
				gdispDrawChar(wi.g.x + 25 * i, wi.g.y, str1[i], font, Black);
				//xil_printf("i = %d char = %c\n\r", i, str1[i]);
			}

			gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(1 - next_framebuffer));
			gdispFillArea(wi.g.x - 5, wi.g.y - 5, 312, 40, White);
			gdispFillArea(wi.g.x - 5, wi.g.y - 5 + THICK1, 312, 40, Black);		//draw black age row

			for(i = 0; i < strlen((const char *)str1); i++)
			{
				gdispDrawChar(wi.g.x + 25 * i, wi.g.y, str1[i], font, Black);
				//xil_printf("i = %d char = %c\n\r", i, str1[i]);
			}

			gdispFillChar(wi.g.x + 25 * 0, wi.g.y, 'M', font, White, Black);

			//draw black widget2 birthday & age

			wi.text = "";
			wi.g.width = CAMERA_INFO_WIDTH1A; wi.g.height = THICK1; wi.g.x = CAMERA_INFO_POS_X1 + CAMERA_INFO_POS_OFFSET1; wi.g.y = CAMERA_INFO_POS_Y3;
			gdispFillArea(wi.g.x, wi.g.y, CAMERA_INFO_WIDTH1A, THICK1, Black);		//draw black birthday row

			wi.g.width = CAMERA_INFO_WIDTH2A; wi.g.height = THICK1; wi.g.x = CAMERA_INFO_POS_X2 + CAMERA_INFO_POS_OFFSET2; wi.g.y = CAMERA_INFO_POS_Y3;
			gdispFillArea(wi.g.x, wi.g.y, CAMERA_INFO_WIDTH2A, THICK1, Black);		//draw black age row

			gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(next_framebuffer));

			wi.g.width = CAMERA_INFO_WIDTH1A; wi.g.height = THICK1; wi.g.x = CAMERA_INFO_POS_X1 + CAMERA_INFO_POS_OFFSET1; wi.g.y = CAMERA_INFO_POS_Y3;
			gdispFillArea(wi.g.x, wi.g.y, CAMERA_INFO_WIDTH1A, THICK1, Black);		//draw black birthday row

			wi.g.width = CAMERA_INFO_WIDTH2A; wi.g.height = THICK1; wi.g.x = CAMERA_INFO_POS_X2 + CAMERA_INFO_POS_OFFSET2; wi.g.y = CAMERA_INFO_POS_Y3;
			gdispFillArea(wi.g.x, wi.g.y, CAMERA_INFO_WIDTH2A, THICK1, Black);		//draw black age row

			gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(1 - next_framebuffer));
		}
		else
		{
			gdispFillArea(wi.g.x, wi.g.y, WIDTH2, 30, White);
			wi.text = "_";
			gdispFillString(wi.g.x, wi.g.y, wi.text, font, Black, White);
			gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(next_framebuffer));
			gdispFillArea(wi.g.x, wi.g.y, WIDTH2, 30, White);
			wi.text = " ";
			gdispFillString(wi.g.x, wi.g.y, wi.text, font, White, Black);
			gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(1 - next_framebuffer));
		}
	}
	else if(keycode == 3)
	{
		confirm_enter_key(flag_modify_pinfo_mode);

		flag_modify_pinfo_mode = KEY_F3;

		wi.g.width = 100; wi.g.height = THICK1; wi.g.x = OFFSET_X + BORDER_X + OFFSET; wi.g.y = BORDER_Y + THICK1 * 3;
		if(p_infos[p_info_index].sex == 1)
		{
			p_infos[p_info_index].sex = 2;
			wi.text = "Female";
		}
		else
		{
			p_infos[p_info_index].sex = 1;
			wi.text = "Male";
		}
		ghLabel3 = gwinLabelCreate(0, &wi);
		gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(next_framebuffer));
		ghLabel3 = gwinLabelCreate(0, &wi);
		gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(1 - next_framebuffer));

		//also update widgets2 sex
		wi.g.width = CAMERA_INFO_WIDTH2A; wi.g.height = THICK1; wi.g.x = CAMERA_INFO_POS_X2 + CAMERA_INFO_POS_OFFSET2; wi.g.y = CAMERA_INFO_POS_Y2;
		ghLabel1 = gwinLabelCreate(0, &wi);
		gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(next_framebuffer));
		ghLabel1 = gwinLabelCreate(0, &wi);
		gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(1 - next_framebuffer));
	}
#endif
	return;
}

void update_pinfo_on_widget(uint8_t ch)
{
	if(flag_modify_pinfo_mode == 0)
	{
		return;
	}

	if(flag_modify_pinfo_mode == KEY_F1)
	{
		xil_printf("1");
		if(ch == 8)		//Backspace
		{
			if(p_info_data_index > 0)
			{
				p_info_data_index--;
				p_info_data[p_info_data_index] = '\0';
			}
		}
		else
		{
			if(p_info_data_index >= DATA_LENGTH)
			{
				xil_printf("XXXXXX\n\r");
				return;
			}

			p_info_data[p_info_data_index] = ch;
			p_info_data_index++;
		}

		GWidgetInit	wi;
		int OFFSET = WIDTH1;

		font_t font = gdispOpenFont("iskpota232");

		// Apply some default values for GWIN
		gwinWidgetClearInit(&wi);
		wi.g.show = TRUE;

		gwinSetDefaultFont(gdispOpenFont("iskpota232"));

		wi.g.width = WIDTH2; wi.g.height = THICK1; wi.g.x = OFFSET_X + BORDER_X + OFFSET; wi.g.y = BORDER_Y + THICK1 * (flag_modify_pinfo_mode - KEY_F0) + 5;

		wi.text = "";
		sprintf((char *)wi.text, "%s", p_info_data);
		//gdispFillString(wi.g.x, wi.g.y, "                                     ", font, White, Black);

		//xil_printf("x= %d, y = %d, s= %s, p_info_data_index = %d\n\r", wi.g.x, wi.g.y, p_info_data, p_info_data_index);
		gdispFillArea(wi.g.x, wi.g.y, 370, 40, Black);

		if(p_info_data_index < DATA_LENGTH)
		{
			gdispFillString(wi.g.x, wi.g.y, wi.text, font, Black, White);
			//flag_id_ok = FALSE;
			flag_id_ok = TRUE;
		}
		else
		{
			gdispFillString(wi.g.x, wi.g.y, wi.text, font, Green, Black);
			flag_id_ok = TRUE;
		}

		gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(next_framebuffer));
		if(p_info_data_index < DATA_LENGTH)
			sprintf((char *)wi.text, "%s_", p_info_data);
		else
			sprintf((char *)wi.text, "%s", p_info_data);
		//gdispFillString(wi.g.x, wi.g.y, "                                     ", font, White, Black);
		gdispFillArea(wi.g.x, wi.g.y, 370, 40, Black);
		if(p_info_data_index < DATA_LENGTH)
			gdispFillString(wi.g.x, wi.g.y, wi.text, font, Black, White);
		else
			gdispFillString(wi.g.x, wi.g.y, wi.text, font, Green, Black);
		gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(1 - next_framebuffer));
	}
	else if(flag_modify_pinfo_mode == KEY_F2)
	{
		xil_printf("2");
		if(ch == 8)		//Backspace
		{
			if(p_info_data_index > 0)
			{
				p_info_data_index--;
				p_info_data[p_info_data_index] = '\0';
			}
		}
		else
		{
			if(p_info_data_index >= DATA_LENGTH)
			{
				xil_printf("XXXXXX\n\r");
				return;
			}

			p_info_data[p_info_data_index] = ch;
			p_info_data_index++;
		}

		GWidgetInit	wi;
		int OFFSET = WIDTH1;

		font_t font = gdispOpenFont("iskpota232");

		// Apply some default values for GWIN
		gwinWidgetClearInit(&wi);
		wi.g.show = TRUE;

		gwinSetDefaultFont(gdispOpenFont("iskpota232"));

		wi.g.width = WIDTH2; wi.g.height = THICK1; wi.g.x = OFFSET_X + BORDER_X + OFFSET; wi.g.y = BORDER_Y + THICK1 * (flag_modify_pinfo_mode - KEY_F0) + 5;

		wi.text = "";
		sprintf((char *)wi.text, "%s", p_info_data);
		//gdispFillString(wi.g.x, wi.g.y, "                                     ", font, White, Black);

		//xil_printf("x= %d, y = %d, s= %s, p_info_data_index = %d\n\r", wi.g.x, wi.g.y, p_info_data, p_info_data_index);
		gdispFillArea(wi.g.x, wi.g.y, 370, 40, Black);

		if(p_info_data_index < DATA_LENGTH)
		{
			gdispFillString(wi.g.x, wi.g.y, wi.text, font, Black, White);
			//flag_id_ok = FALSE;
			flag_id_ok = TRUE;
		}
		else
		{
			gdispFillString(wi.g.x, wi.g.y, wi.text, font, Green, Black);
			flag_id_ok = TRUE;
		}

		gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(next_framebuffer));
		if(p_info_data_index < DATA_LENGTH)
			sprintf((char *)wi.text, "%s_", p_info_data);
		else
			sprintf((char *)wi.text, "%s", p_info_data);
		//gdispFillString(wi.g.x, wi.g.y, "                                     ", font, White, Black);
		gdispFillArea(wi.g.x, wi.g.y, 370, 40, Black);
		if(p_info_data_index < DATA_LENGTH)
			gdispFillString(wi.g.x, wi.g.y, wi.text, font, Black, White);
		else
			gdispFillString(wi.g.x, wi.g.y, wi.text, font, Green, Black);
		gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(1 - next_framebuffer));
	}
	else if(flag_modify_pinfo_mode == KEY_F4)
	{
		//nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn
		GWidgetInit	wi;
		int OFFSET = WIDTH1;

		font_t font = gdispOpenFont("iskpota232");

		// Apply some default values for GWIN
		gwinWidgetClearInit(&wi);
		wi.g.show = TRUE;

		gwinSetDefaultFont(gdispOpenFont("iskpota232"));


		/*
		if(p_info_data_index ==0)
		{
		wi.g.width = WIDTH2; wi.g.height = THICK1; wi.g.x = OFFSET_X + BORDER_X + OFFSET; wi.g.y = BORDER_Y + THICK1 * (flag_modify_pinfo_mode - KEY_F0) + 5;

		if(flag_modify_pinfo_mode >= KEY_F4)
			wi.g.y += THICK1;

		wi.text = "MM/SS/YYYY";
		//sprintf((char *)wi.text, "%s", p_info_data);
		//gdispFillString(wi.g.x, wi.g.y, "                                     ", font, White, Black);

		//xil_printf("x= %d, y = %d, s= %s, p_info_data_index = %d\n\r", wi.g.x, wi.g.y, p_info_data, p_info_data_index);
		gdispFillArea(wi.g.x, wi.g.y, 370, 40, Black);

		gdispFillString(wi.g.x, wi.g.y, wi.text, font, Black, White);
		gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(next_framebuffer));
		//sprintf((char *)wi.text, "%s_", p_info_data);
		//gdispFillString(wi.g.x, wi.g.y, "                                     ", font, White, Black);
		gdispFillArea(wi.g.x, wi.g.y, 370, 40, Black);
		gdispFillString(wi.g.x, wi.g.y, wi.text, font, Black, White);
		gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(1 - next_framebuffer));
		}
*/

		if(ch == 8)		//Backspace
		{
			if(p_info_data_index > 0)
			{
				if((p_info_data_index == 4)||(p_info_data_index == 8))
					p_info_data_index -= 3;
				else
					p_info_data_index--;
				p_info_data[p_info_data_index] = '\0';

				if(p_info_data_index == 0)
				{
					birth_mm %= 10;
					flag_birth_mm_ok = FALSE;
				}
				else if(p_info_data_index == 1)
				{
					birth_mm = (birth_mm / 10) * 10;
					flag_birth_mm_ok = FALSE;
				}
				else if(p_info_data_index == 4)
				{
					birth_dd %= 10;
					flag_birth_dd_ok = FALSE;
				}
				else if(p_info_data_index == 5)
				{
					birth_dd = (birth_dd / 10) * 10;
					flag_birth_dd_ok = FALSE;
				}
				else if(p_info_data_index == 8)
				{
					birth_yyyy %= 1000;
					flag_birth_yyyy_ok = FALSE;
				}
				else if(p_info_data_index == 9)
				{
					birth_yyyy = (birth_yyyy / 1000) * 1000 + birth_mm % 1000;
					flag_birth_yyyy_ok = FALSE;
				}
				else if(p_info_data_index == 10)
				{
					birth_yyyy = (birth_yyyy / 100) * 100 + birth_mm % 100;
					flag_birth_yyyy_ok = FALSE;
				}
				else if(p_info_data_index == 11)
				{
					birth_yyyy = (birth_yyyy / 10) * 10;
					flag_birth_yyyy_ok = FALSE;
				}
			}
		}
		else
		{
			if(p_info_data_index > 11)
			{
				xil_printf("XXXXXX\n\r");
				return;
			}

			if((ch < '0') | (ch > '9'))
			{
				xil_printf("XXXXXX\n\r");
				return;
			}

			if(p_info_data_index == 0)
			{
				if(ch > '1')
				{
					xil_printf("XXXXXX\n\r");
					return;
				}
				else
				{
					birth_mm += (ch - '0') * 10;
					p_info_data[p_info_data_index] = ch;
					p_info_data_index++;
				}
			}
			else if(p_info_data_index == 1)
			{
				if(birth_mm >= 10)
				{
					if(ch > '2')
					{
						xil_printf("XXXXXX\n\r");
						return;
					}
				}
				if((birth_mm == 0) && (ch == '0'))
				{
					xil_printf("XXXXXX\n\r");
					return;
				}

				birth_mm += (ch - '0') * 1;
				p_info_data[p_info_data_index] = ch;
				p_info_data_index += 3;
				p_info_data[2] = ' ';
				p_info_data[3] = '/';
				flag_birth_mm_ok = TRUE;
			}
			else if(p_info_data_index == 4)
			{
				if(ch > '3')
				{
					xil_printf("XXXXXX\n\r");
					return;
				}

				if(birth_mm == 2)
				{
					if(ch > '2')
					{
						xil_printf("XXXXXX\n\r");
						return;
					}
				}
				birth_dd += (ch - '0') * 10;
				p_info_data[p_info_data_index] = ch;
				p_info_data_index++;
			}
			else if(p_info_data_index == 5)
			{
				int dd_tmp = birth_dd + (ch - '0') * 1;

				if(dd_tmp == 0)
				{
					xil_printf("XXXXXX\n\r");
					return;
				}

				if((birth_mm == 1) && (dd_tmp > 31))
				{
					xil_printf("XXXXXX 1\n\r");
					return;
				}
				else if((birth_mm == 2) && (dd_tmp > 29))
				{
					xil_printf("XXXXXX 2\n\r");
					return;
				}
				else if((birth_mm == 3) && (dd_tmp > 31))
				{
					xil_printf("XXXXXX 3\n\r");
					return;
				}
				else if((birth_mm == 4) && (dd_tmp > 30))
				{
					xil_printf("XXXXXX 4\n\r");
					return;
				}
				else if((birth_mm == 5) && (dd_tmp > 31))
				{
					xil_printf("XXXXXX 5\n\r");
					return;
				}
				else if((birth_mm == 6) && (dd_tmp > 30))
				{
					xil_printf("XXXXXX 6\n\r");
					return;
				}
				else if((birth_mm == 7) && (dd_tmp > 31))
				{
					xil_printf("XXXXXX 7\n\r");
					return;
				}
				else if((birth_mm == 8) && (dd_tmp > 31))
				{
					xil_printf("XXXXXX 8\n\r");
					return;
				}
				else if((birth_mm == 9) && (dd_tmp > 30))
				{
					xil_printf("XXXXXX 9\n\r");
					return;
				}
				else if((birth_mm == 10) && (dd_tmp > 31))
				{
					xil_printf("XXXXXX 10\n\r");
					return;
				}
				else if((birth_mm == 11) && (dd_tmp > 30))
				{
					xil_printf("XXXXXX 11\n\r");
					return;
				}
				else if((birth_mm == 12) && (dd_tmp > 31))
				{
					xil_printf("XXXXXX 12\n\r");
					return;
				}

				birth_dd += (ch - '0') * 1;
				p_info_data[p_info_data_index] = ch;
				p_info_data_index += 3;
				p_info_data[6] = ' ';
				p_info_data[7] = '/';
				flag_birth_dd_ok = TRUE;
			}
			else if(p_info_data_index == 8)
			{
				if((ch < '1') ||(ch > '2'))
				{
					xil_printf("XXXXXX\n\r");
					return;
				}
				else
				{
					birth_yyyy += (ch - '0') * 1000;
					p_info_data[p_info_data_index] = ch;
					p_info_data_index++;
				}
			}
			else if(p_info_data_index == 9)
			{
				if((p_info_data[8] == '1') && (ch != '9'))
				{
					xil_printf("XXXXXX\n\r");
					return;
				}
				else if(p_info_data[8] == '2')
				{
					if((ch != '0')&&(ch != '1'))
					{
						xil_printf("XXXXXX\n\r");
						return;
					}
				}
				birth_yyyy += (ch - '0') * 100;
				p_info_data[p_info_data_index] = ch;
				p_info_data_index++;
			}
			else if(p_info_data_index == 10)
			{
				birth_yyyy += (ch - '0') * 10;
				p_info_data[p_info_data_index] = ch;
				p_info_data_index++;
			}
			else if(p_info_data_index == 11)
			{
				birth_yyyy += (ch - '0') * 1;
				p_info_data[p_info_data_index] = ch;
				p_info_data_index++;

				if((birth_mm == 2) && (birth_dd == 29))
				{
					if(((birth_yyyy % 4) == 0) && ((birth_yyyy % 100) != 0))
						flag_birth_yyyy_ok = TRUE;
					else
						flag_birth_yyyy_ok = FALSE;
				}
				else
					flag_birth_yyyy_ok = TRUE;
			}
		}

		int i;


		xil_printf("MM/DD/YYYY = %d/%d/%d\n\r", birth_mm, birth_dd, birth_yyyy);

		//font_t font = gdispOpenFont("iskpota232");
		unsigned char str1[] = "MM /DD /YYYY";

		for(i = 0; i < p_info_data_index; i++)
		{
			str1[i] = p_info_data[i];
		}

		wi.g.width = WIDTH2; wi.g.height = THICK1; wi.g.x = OFFSET_X + BORDER_X + OFFSET; wi.g.y = BORDER_Y + THICK1 * (flag_modify_pinfo_mode - KEY_F0) + 5;

		if(flag_modify_pinfo_mode >= KEY_F4)
			wi.g.y += THICK1;

		gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(next_framebuffer));

		if(p_info_data_index == 12)	//color invert
			gdispFillArea(wi.g.x - 5, wi.g.y - 5, 312, 40, Black);
		else
			gdispFillArea(wi.g.x - 5, wi.g.y - 5, 312, 40, White);

		for(i = 0; i < strlen((const char *)str1); i++)
		{
			if(p_info_data_index == 12)	//color invert
			{
				if(flag_birth_yyyy_ok == TRUE)
					gdispDrawChar(wi.g.x + 25 * i, wi.g.y, str1[i], font, Green);
				else
					gdispDrawChar(wi.g.x + 25 * i, wi.g.y, str1[i], font, Red);
			}
			else
				gdispDrawChar(wi.g.x + 25 * i, wi.g.y, str1[i], font, Black);
			//xil_printf("i = %d char = %c\n\r", i, str1[i]);
		}

		gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(1 - next_framebuffer));

		if(p_info_data_index == 12)	//color invert
			gdispFillArea(wi.g.x - 5, wi.g.y - 5, 312, 40, Black);
		else
			gdispFillArea(wi.g.x - 5, wi.g.y - 5, 312, 40, White);

		for(i = 0; i < strlen((const char *)str1); i++)
		{
			if(p_info_data_index == 12)	//color invert
			{
				if(flag_birth_yyyy_ok == TRUE)
					gdispDrawChar(wi.g.x + 25 * i, wi.g.y, str1[i], font, Green);
				else
					gdispDrawChar(wi.g.x + 25 * i, wi.g.y, str1[i], font, Red);
			}
			else
				gdispDrawChar(wi.g.x + 25 * i, wi.g.y, str1[i], font, Black);
			//xil_printf("i = %d char = %c\n\r", i, str1[i]);
		}

		//xil_printf("p_info_data_index = %d\n\r", p_info_data_index);
		if(p_info_data_index < 12)
			gdispFillChar(wi.g.x + 25 * p_info_data_index, wi.g.y, str1[p_info_data_index], font, White, Black);

		/*
		wi.text = "";
		sprintf((char *)wi.text, "%s", p_info_data);
		//gdispFillString(wi.g.x, wi.g.y, "                                     ", font, White, Black);

		//xil_printf("x= %d, y = %d, s= %s, p_info_data_index = %d\n\r", wi.g.x, wi.g.y, p_info_data, p_info_data_index);
		//gdispFillArea(wi.g.x, wi.g.y, 370, 40, Black);

		gdispFillString(wi.g.x, wi.g.y, wi.text, font, Black, White);
		gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(next_framebuffer));
		sprintf((char *)wi.text, "%s_", p_info_data);
		//gdispFillString(wi.g.x, wi.g.y, "                                     ", font, White, Black);
		//gdispFillArea(wi.g.x, wi.g.y, 370, 40, Black);
		gdispFillString(wi.g.x, wi.g.y, wi.text, font, Black, White);
		gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(1 - next_framebuffer));
*/





	}


	return;
}

int read_data_from_camera_page0(void)
{
	int status;
	xil_printf("\n\rread_data_from_camera_page0\n\r");
	ENABLE_CONFIGURE(1);
	SET_ADDRESS(0);
	//usleep(100);
	status = READ_1PAGE();
	ENABLE_CONFIGURE(0);

	if(status == XST_SUCCESS)
	{
		int i;
		for(i = 0; i < 16; i++)
		{
			camera_data_tmp[i] = page_data[i];
		}
	}
	else
	{
		xil_printf("\n\rread_data_from_camera_page0 fail\n\r");
	}

	xil_printf("\n\rread_data_from_camera_page0x09(serial)\n\r");
	ENABLE_CONFIGURE(1);
	SET_ADDRESS(0x09);
	//usleep(100);
	status = READ_1PAGE();
	ENABLE_CONFIGURE(0);

	if(status == XST_SUCCESS)
	{
		int i;
		for(i = 0; i < 16; i++)
		{
			camera_data_tmp2[i] = page_data[i];
		}
	}
	else
	{
		xil_printf("\n\rread_data_from_camera_page0x09 fail\n\r");
	}

	return status;
}

int read_model_from_camera(void)
{
	int status;
	xil_printf("\n\rread_model_from_camera\n\r");
	ENABLE_CONFIGURE(1);
	SET_ADDRESS(MODEL_PAGE);
	//usleep(100);
	status = READ_1PAGE();
	ENABLE_CONFIGURE(0);

	if(status == XST_SUCCESS)
	{
		int i;
		for(i = 0; i < 16; i++)
		{
			camera_data_model[i] = page_data[i];
		}
	}
	else
	{
		xil_printf("\n\rread_model_from_camera fail\n\r");
	}
	return status;
}

void write_model_to_camera(void)
{
	xil_printf("\n\rwrite_model_to_camera\n\r");
	//xil_printf("\n\rENABLE_CONFIGURE\n\r");
	ENABLE_CONFIGURE(1);
	//xil_printf("\n\rSET_ADDRESS\n\r");
	SET_ADDRESS(MODEL_PAGE);
	usleep(DELAY);
	//xil_printf("\n\rPROG_1PAGE\n\r");
	page_data[15] = 0x33;
	PROG_1PAGE();
	xil_printf("\n\rDISABLE_CONFIGURE\n\r");
	ENABLE_CONFIGURE(0);
	return;
}

int read_serial_from_camera(void)
{
	int status;
	xil_printf("\n\rread_serial_from_camera 0x8 0x9\n\r");

	ENABLE_CONFIGURE(1);
	SET_ADDRESS(SN_PAGE1);
	//usleep(100);
	status = READ_1PAGE();
	ENABLE_CONFIGURE(0);

	if(status == XST_SUCCESS)
	{
		int i;
		for(i = 0; i < 16; i++)
		{
			camera_data_serial1[i] = page_data[i];
		}
	}
	else
	{
		xil_printf("\n\rread_serial_from_camera 1 fail\n\r");
	}

	ENABLE_CONFIGURE(1);
	SET_ADDRESS(SN_PAGE2);
	//usleep(100);
	status = READ_1PAGE();
	ENABLE_CONFIGURE(0);

	if(status == XST_SUCCESS)
	{
		int i;
		for(i = 0; i < 16; i++)
		{
			camera_data_serial2[i] = page_data[i];
		}
	}
	else
	{
		xil_printf("\n\rread_serial_from_camera 2 fail\n\r");
	}

	return status;
}


void write_user_data_to_camera0(void)
{
	xil_printf("\n\rwrite_user_data_to_camera0\n\r");

	//xil_printf("\n\rENABLE_CONFIGURE\n\r");
	ENABLE_CONFIGURE(1);
	//xil_printf("\n\rSET_ADDRESS\n\r");
	SET_ADDRESS(0);
	usleep(DELAY);
	//xil_printf("\n\rPROG_1PAGE\n\r");
	PROG_1PAGE();

	sleep(3);
	usleep(DELAY);

	xil_printf("\n\rDISABLE_CONFIGURE\n\r");
	ENABLE_CONFIGURE(0);
	return;
}


void write_serial_to_camera(void)
{
	int i;

	for(i = 0;i < 16; i++)
	{
		user_camera_data8[i] = 0;
		user_camera_data9[i] = 0;
	}

	srand(rtc.tm_sec * rtc.tm_min);
	for(i = 0;i < 2; i++)
	{
		user_camera_data8[i] = 'A' + rand()%26;							//data prepare to write to flash
	}
	for(i = 2;i < 9; i++)
	{
		user_camera_data8[i] = '0' + rand()%10;							//data prepare to write to flash
	}

	for(i = 0;i < 11; i++)
	{
		user_camera_data9[i] = '0' + rand()%10;
	}

	xil_printf("\n\rcamera erase data\n\r");
	xil_printf("\n\rENABLE_CONFIGURE\n\r");
	ENABLE_CONFIGURE(1);
	xil_printf("\n\rSET_ADDRESS\n\r");
	SET_ADDRESS(SN_PAGE2);
	xil_printf("\n\rERASE_UFM\n\r");
	ERASE_UFM();
	xil_printf("\n\rDISABLE_CONFIGURE\n\r");
	ENABLE_CONFIGURE(0);
	//xil_printf("\n\rwrite_serial_to_camera 111\n\r");

	xil_printf("\n\rsleep st\n\r");
	sleep(1);	//must be 2	???
	//usleep(500000);
	xil_printf("\n\rsleep sp\n\r");
	//xil_printf("\n\rwrite_serial_to_camera\n\r");

	write_user_serial_to_camera();
	sleep(1);
	flag_camera_access = 0;
	return;
}

void write_user_model_to_camera(void)
{
	//xil_printf("\n\rwrite_model_date_to_camera\n\r");
	//write_date_to_camera(DATE_PAGE0);

	xil_printf("\n\rwrite_user_model_to_camera\n\r");
	//xil_printf("\n\rENABLE_CONFIGURE\n\r");
	ENABLE_CONFIGURE(1);
	//xil_printf("\n\rSET_ADDRESS\n\r");
	SET_ADDRESS(MODEL_PAGE);
	usleep(DELAY);
	//xil_printf("\n\rPROG_1PAGE\n\r");
	page_data[12] = 0xE0;
	page_data[13] = 0xE0;
	page_data[14] = 0xE0;
	page_data[15] = 0xE0;
	PROG_1PAGE();
	xil_printf("\n\rDISABLE_CONFIGURE\n\r");
	ENABLE_CONFIGURE(0);
	return;
}

void write_user_serial_to_camera(void)
{
	xil_printf("\n\rwrite_serial_date_to_camera\n\r");
	write_date_to_camera(DATE_PAGE0);

	xil_printf("\n\rwrite_user_serial_to_camera sn1\n\r");
	//xil_printf("\n\rENABLE_CONFIGURE\n\r");
	ENABLE_CONFIGURE(1);
	//xil_printf("\n\rSET_ADDRESS\n\r");
	SET_ADDRESS(SN_PAGE1);
	usleep(DELAY);
	//xil_printf("\n\rPROG_1PAGE\n\r");
	page_data[14] = 0x88;
	page_data[15] = 0x88;
	PROG_1PAGE();
	xil_printf("\n\rDISABLE_CONFIGURE\n\r");
	ENABLE_CONFIGURE(0);

	xil_printf("\n\rwrite_user_serial_to_camera sn2\n\r");
	//xil_printf("\n\rENABLE_CONFIGURE\n\r");
	ENABLE_CONFIGURE(1);
	//xil_printf("\n\rSET_ADDRESS\n\r");
	SET_ADDRESS(SN_PAGE2);
	usleep(DELAY);
	//xil_printf("\n\rPROG_1PAGE\n\r");
	page_data[14] = 0x99;
	page_data[15] = 0x99;
	PROG_1PAGE();
	xil_printf("\n\rDISABLE_CONFIGURE\n\r");
	ENABLE_CONFIGURE(0);
	return;
}

int read_date_from_camera(uint16_t page)
{
	xil_printf("\n\rread_date_from_camera page = 0x%x\n\r", page);
	ENABLE_CONFIGURE(1);
	SET_ADDRESS(page);
	READ_1PAGE();
	ENABLE_CONFIGURE(0);
	if((page_data[12] == 0xAA) && (page_data[13] == 0xBB) && (page_data[14] == 0xCC) && (page_data[15] == 0xDD))
	{
		return 1;
	}
	else
	{
		return 0;
	}
}

int read_data_from_camera(uint16_t page)
{
	xil_printf("\n\rread_data_from_camera page = 0x%x\n\r", page);
	ENABLE_CONFIGURE(1);
	SET_ADDRESS(page);
	READ_1PAGE();
	ENABLE_CONFIGURE(0);
	return 0;
}

void write_date_to_camera(uint16_t page)
{
	u32 year;
	u8 month;
	u8 mday;
	u8 wday;
	u8 hour;
	u8 minutes;
	u8 seconds;

	xil_printf("\n\rwrite_date_to_camera\t%s", asctime(&rtc));

	if(page == DATE_PAGE0)
		xil_printf("\twrite camera DATE_PAGE0\n\r");	//serial date, product time
	else if(page == DATE_PAGE1)
		xil_printf("\twrite camera DATE_PAGE1\n\r");	//use 1 minute
	else if(page == DATE_PAGE3)
		xil_printf("\twrite camera DATE_PAGE3\n\r");	//use 2 hrs
	else if(page == ERROR_DATE)
		xil_printf("\twrite camera ERROR_DATE\n\r");	//error date
	else
		xil_printf("\twrite camera unknown page = %d\n\r", page);

	read_date_from_camera(page);

	if((page_data[12] == 0xAA) && (page_data[13] == 0xBB) && (page_data[14] == 0xCC) && (page_data[15] == 0xDD))
	{
		year = page_data[0] + 1900;
		month = page_data[1];
		mday = page_data[2];
		wday = page_data[3];
		hour = page_data[4];
		minutes = page_data[5];
		seconds = page_data[6];
		debug_console_print("YYYYYYYYYYYYYYYYYY skip");
		xil_printf("xxxxxxxxxxx already have DATA : %02d/%02d/%04ld %d %02d:%02d:%02d skip\n\r", month, mday, year, wday, hour, minutes, seconds);
	}
	else
	{
		xil_printf("no old data\n\r");
		//xil_printf("\n\rENABLE_CONFIGURE\n\r");
		ENABLE_CONFIGURE(1);
		//xil_printf("\n\rSET_ADDRESS\n\r");
		SET_ADDRESS(page);
		usleep(DELAY);

		asctime(&rtc);

		/*
		xil_printf("year = %d\n\r", rtc.tm_year);
		xil_printf("month = %d\n\r", rtc.tm_mon);
		xil_printf("day = %d\n\r", rtc.tm_mday);
		xil_printf("wday = %d\n\r", rtc.tm_wday);
		xil_printf("hour = %d\n\r", rtc.tm_hour);
		xil_printf("minute = %d\n\r", rtc.tm_min);
		xil_printf("second = %d\n\r", rtc.tm_sec);
		*/

		page_data[0] = rtc.tm_year - 100;
		page_data[1] = rtc.tm_mon + 1;
		page_data[2] = rtc.tm_mday;
		page_data[3] = rtc.tm_wday;

		page_data[4] = rtc.tm_hour;
		page_data[5] = rtc.tm_min;
		page_data[6] = rtc.tm_sec;
		page_data[7] = 0;

		page_data[8] = 0;
		page_data[9] = 0;
		page_data[10] = 0;
		page_data[11] = 0;

		page_data[12] = 0xAA;
		page_data[13] = 0xBB;
		page_data[14] = 0xCC;
		page_data[15] = 0xDD;

		//xil_printf("\n\rPROG_1PAGE\n\r");
		PROG_1PAGE();
		xil_printf("\n\rDISABLE_CONFIGURE\n\r");
		ENABLE_CONFIGURE(0);
	}
	return;
}

void write_error_code_to_camera(int error)
{
	int i;
	xil_printf("\n\rwrite_error_code_to_camera, error = %d\t%s", error, asctime(&rtc));
	//xil_printf("\n\rENABLE_CONFIGURE\n\r");
	ENABLE_CONFIGURE(1);
	//xil_printf("\n\rSET_ADDRESS\n\r");
	SET_ADDRESS(ERROR_PAGE);
	usleep(DELAY);

	page_data[0] = 0xEE;
	page_data[1] = 0xCC;
	page_data[2] = 0xDD;
	page_data[3] = 0xEE;

	for(i = 4; i < 8; i++)
	{
		page_data[i] = error;
	}
	//xil_printf("\n\rPROG_1PAGE\n\r");
	PROG_1PAGE();
	xil_printf("\n\rDISABLE_CONFIGURE\n\r");
	ENABLE_CONFIGURE(0);
	//sleep(2);	//must > 1
	write_date_to_camera(ERROR_DATE);
	return;
}

int read_error_code_from_camera(void)
{
	xil_printf("\n\rread_error_code_from_camera page = 0x%x\n\r", ERROR_PAGE);
	ENABLE_CONFIGURE(1);
	SET_ADDRESS(ERROR_PAGE);
	READ_1PAGE();
	ENABLE_CONFIGURE(0);
	if((page_data[0] == 0xEE) && (page_data[1] == 0xCC) && (page_data[2] == 0xDD) && (page_data[3] == 0xEE))
	{
		return page_data[4];
	}
	else if((page_data[0] == 0) && (page_data[1] == 0) && (page_data[2] == 0) && (page_data[3] == 0))
	{
		xil_printf("camera page 0xe no data\n\r");
		return 0;
	}
	else
	{
		xil_printf("unknown data : %02X-%02X-%02X-%02X-%02X-%02X-%02X-%02X-%02X-%02X-%02X-%02X-%02X-%02X-%02X-%02X\n\r",
				page_data[0], page_data[1], page_data[2], page_data[3], page_data[4], page_data[5], page_data[6], page_data[7],
				page_data[8], page_data[9], page_data[10], page_data[11], page_data[12], page_data[13], page_data[14], page_data[15]);
		return 0;
	}
}

void show_camera_serial(int enable)
{
	GWidgetInit	wi;

	gwinWidgetClearInit(&wi);
	wi.g.show = TRUE;

	// Create label
	wi.text = "12345678901234567890123456789012345678901234567890";
	if(enable == 1)
	{
		if(camera_data_serial1[9] == 0xff)
		{
			sprintf((char *)wi.text, "EGD NO:  %c%c%c%c%c%c%c%c%c",
					camera_data_serial1[0], camera_data_serial1[1], camera_data_serial1[2], camera_data_serial1[3],
					camera_data_serial1[4], camera_data_serial1[5], camera_data_serial1[6], camera_data_serial1[7],
					camera_data_serial1[8]);
		}
		else
		{
			sprintf((char *)wi.text, "EGD NO:  %c%c%c%c%c%c%c%c%c%c",
					camera_data_serial1[0], camera_data_serial1[1], camera_data_serial1[2], camera_data_serial1[3],
					camera_data_serial1[4], camera_data_serial1[5], camera_data_serial1[6], camera_data_serial1[7],
					camera_data_serial1[8], camera_data_serial1[9]);
		}
	}
	else if(enable == 0)
	{
		sprintf((char *)wi.text, "EGD NO : --------------------");
	}
	else
	{
		sprintf((char *)wi.text, "EGD NO : xxxxxxxxxxxxxxxxxxxx");
	}
	//wi.g.width = WIDTH3; wi.g.height = THICK1; wi.g.x = CAMERA_INFO_POS_X1; wi.g.y = CAMERA_INFO_POS_Y1;
	wi.g.width = WIDTH2; wi.g.height = THICK1; wi.g.x = BORDER_X; wi.g.y = BORDER_Y + THICK1 * 11;
	ghLabel6 = gwinLabelCreate(0, &wi);

	//also update widgets2 EGD NO
	wi.g.width = CAMERA_INFO_WIDTH1A; wi.g.height = THICK1; wi.g.x = CAMERA_INFO_POS_X1; wi.g.y = CAMERA_INFO_POS_Y4;
	ghLabel6 = gwinLabelCreate(0, &wi);
	return;
}

void show_camera_date(int enable)
{
#ifdef USE_DEBUG_MESSAGE

	GWidgetInit	wi;
	gwinWidgetClearInit(&wi);
	wi.g.show = TRUE;

	// Create label
	wi.text = "1234567890123456789012345678901234567890123456789012345";

	if(enable == 1)
	{
		/*
		xil_printf("david0124: %s:%s(%d) ST camera_status = %d\r\n",__FILE__,__func__,__LINE__, flag_camera_status);

		switch(flag_camera_status)
		{
		case CAMERA_NEW:	xil_printf("david0124: %s:%s(%d) CAMERA_NEW\r\n",__FILE__,__func__,__LINE__);break;
		case CAMERA_1M:		xil_printf("david0124: %s:%s(%d) CAMERA_1M\r\n",__FILE__,__func__,__LINE__);break;
		case CAMERA_2HR:	xil_printf("david0124: %s:%s(%d) CAMERA_2HR\r\n",__FILE__,__func__,__LINE__);break;
		default:			xil_printf("david0124: %s:%s(%d) xxxxxxx\r\n",__FILE__,__func__,__LINE__);break;
		}
		*/

		#ifdef USE_PREVENT_REUSE
		u32 year;
		u8 month;
		u8 mday;
		u8 wday;
		u8 hour;
		u8 minutes;
		u8 seconds;

		//u8 page_data_1m[16];	reserved
		//int i;

		if(flag_camera_status == CAMERA_1M)
		{
			read_date_from_camera(DATE_PAGE1);
		}
		else if(flag_camera_status == CAMERA_2HR)
		{
			/*	reserved
			read_date_from_camera(DATE_PAGE1);
			for(i = 0; i < 16; i++)
			{
				page_data_1m[i] = page_data[i];
			}
			*/
			read_date_from_camera(DATE_PAGE3);
		}

		if((page_data[12] == 0xAA) && (page_data[13] == 0xBB) && (page_data[14] == 0xCC) && (page_data[15] == 0xDD))
		{
			year = page_data[0] + 2000;
			month = page_data[1];
			mday = page_data[2];
			wday = page_data[3];
			hour = page_data[4];
			minutes = page_data[5];
			seconds = page_data[6];
			if(flag_camera_status == CAMERA_1M)
			{
				sprintf((char *)wi.text, "1MIN : %02d/%02d/%04ld %d %02d:%02d:%02d", month, mday, year, wday, hour, minutes, seconds);
			}
			else if(flag_camera_status == CAMERA_2HR)
			{
				sprintf((char *)wi.text, "2HR : %02d/%02d/%04ld %d %02d:%02d:%02d", month, mday, year, wday, hour, minutes, seconds);
			}
			else
			{
				sprintf((char *)wi.text, "NEW");
			}

			/*
			xil_printf("year = %d\n\r", year);
			xil_printf("month = %d\n\r", month);
			xil_printf("day = %d\n\r", mday);
			xil_printf("wday = %d\n\r", wday);
			xil_printf("hour = %d\n\r", hour);
			xil_printf("minute = %d\n\r", minutes);
			xil_printf("second = %d\n\r", seconds);
			*/
		}
		else
		{
			sprintf((char *)wi.text, "NEW");
		}
		#endif
	}
	else if(enable == 0)
	{
		sprintf((char *)wi.text, "-----------------------------------------------");
	}
	else
	{
		sprintf((char *)wi.text, "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx");
	}

	wi.g.width = WIDTH3; wi.g.height = THICK1; wi.g.x = CAMERA_INFO_POS_X1; wi.g.y = CAMERA_INFO_POS_Y2;

	ghLabel6 = gwinLabelCreate(0, &wi);
#else
	//xil_printf("do not define USE_DEBUG_MESSAGE\n");
#endif
	return;
}

void read_camera_info_from_camera_eng(void)
{
	xil_printf("check dongle status\t");
	g_conn_status = psuart0_dongle_ping();
	if(g_conn_status == DONGLE_NONE){			// Nothing is plugged in
		xil_printf("no dongle or camera\n\r");
		show_camera_serial(-1);
		show_camera_date(-1);
		if(flag_use_2_framebuffers == TRUE)
		{
			gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(next_framebuffer));
			show_camera_serial(-1);
			show_camera_date(-1);
			gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(1 - next_framebuffer));
			//show_camera_serial(-1);
			//show_camera_date(-1);
		}
	}
	else if(g_conn_status == CAMERA_NONE){	// Only dongle is plugged in
		xil_printf("dongle plugged\n\r");
		show_camera_serial(0);
		show_camera_date(0);
		if(flag_use_2_framebuffers == TRUE)
		{
			gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(next_framebuffer));
			show_camera_serial(0);
			show_camera_date(0);
			gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(1 - next_framebuffer));
			//show_camera_serial(0);
			//show_camera_date(0);
		}
	}
	else if(g_conn_status == CAMERA_OK){	// Everything is plugged in
		xil_printf("all plugged\n\r");
	}
	else {							// Unknown
		xil_printf("unknown status\n\r");
	}

	dongle_usage_count = check_dongle_usage_count();
	//xil_printf("dongle_usage_count = %d\r\n", dongle_usage_count);
	show_dongle_usage_count_eng(dongle_usage_count);
	if(flag_use_2_framebuffers == TRUE)
	{
		gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(next_framebuffer));
		show_dongle_usage_count_eng(dongle_usage_count);
		gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(1 - next_framebuffer));
	}
	return;
}

void show_camera_info_eng(void)
{
	int flag_camera_model_data = 0;
	int saturation_th2 = 0;
	int saturation_th1 = 0;
	int user_brightness = 0;

//#ifdef USE_PREVENT_REUSE
	int i;
	u8 camera_date_page0[16] = {0};
	u8 camera_date_page1[16] = {0};
	u8 camera_date_page3[16] = {0};
	u8 camera_error_date[16] = {0};
	u8 camera_awb_data0[4] = {0};
	u8 camera_awb_data1[4] = {0};
//#endif

	xil_printf("check dongle status\t");
	g_conn_status = psuart0_dongle_ping();
	if(g_conn_status == DONGLE_NONE){			// Nothing is plugged in
		xil_printf("no dongle or camera\n\r");
	}
	else if(g_conn_status == CAMERA_NONE){	// Only dongle is plugged in
		xil_printf("dongle plugged\n\r");
	}
	else if(g_conn_status == CAMERA_OK){	// Everything is plugged in
		xil_printf("all plugged\n\r");
	}
	else {							// Unknown
		xil_printf("unknown status\n\r");
	}

	if(g_conn_status == CAMERA_OK)
	{
		xil_printf("\n\rshow_camera_info_eng ST, camera exists\n\r");
//#ifdef USE_PREVENT_REUSE

		read_date_from_camera(MODEL_PAGE);
		for(i = 0; i < 16; i++)
		{
			camera_data_model[i] = page_data[i];
			flag_camera_model_data += (int)camera_data_model[i];
		}

		flag_video_status = read_error_code_from_camera();

		read_serial_from_camera();

		read_date_from_camera(DATE_PAGE0);
		for(i = 0; i < 16; i++)
		{
			camera_date_page0[i] = page_data[i];
		}

		read_date_from_camera(DATE_PAGE1);
		for(i = 0; i < 16; i++)
		{
			camera_date_page1[i] = page_data[i];
		}

		read_date_from_camera(DATE_PAGE3);
		for(i = 0; i < 16; i++)
		{
			camera_date_page3[i] = page_data[i];
		}

		read_date_from_camera(ERROR_DATE);
		for(i = 0; i < 16; i++)
		{
			camera_error_date[i] = page_data[i];
		}

		read_data_from_camera(AWB_PAGE0);
		for(i = 0; i < 4; i++)
		{
			camera_awb_data0[i] = page_data[i];
		}

		read_data_from_camera(AWB_PAGE1);
		camera_awb_data1[0] = page_data[3];
		camera_awb_data1[1] = page_data[6];
		camera_awb_data1[2] = page_data[9];
		camera_awb_data1[3] = page_data[12];

		read_data_from_camera(USER_PAGE1);
		if((page_data[0] == 0x00) && (page_data[1] == 0x00) && (page_data[2] == 0x00) && (page_data[3] == 0x00))
		{
			xil_printf("page %d, no saturation data\n\r", USER_PAGE1);
		}
		else
		{
			xil_printf("data: %02x%02x%02x%02x %02x%02x%02x%02x %02x%02x%02x%02x %02x%02x%02x%02x\n\r",
					page_data[0], page_data[1], page_data[2], page_data[3],
					page_data[4], page_data[5], page_data[6], page_data[7],
					page_data[8], page_data[9], page_data[10], page_data[11],
					page_data[12], page_data[13], page_data[14], page_data[15]);
			if(page_data[0] != 0xDA)
			{
				xil_printf("no valid data, header is 0x%02x\n\r", page_data[0]);
			}
			else
			{
				if((page_data[7] == 0x58) && (page_data[8] == 0x03))
					saturation_th2 = page_data[9];
				if((page_data[10] == 0x58) && (page_data[11] == 0x04))
					saturation_th1 = page_data[12];
			}
		}

		read_data_from_camera(USER_PAGE2);
		if((page_data[1] == 0xAA) && (page_data[2] == 0xBB))
		{
			user_brightness = page_data[3];
			xil_printf("user_brightness = %d\n\r", user_brightness);
		}
		else
		{
			user_brightness = 0;
			xil_printf("no user_brightness data\n\r");
		}
//#endif
	}
	else
	{
		xil_printf("\n\rshow_camera_info_eng ST, no camera\n\r");
	}

//#ifdef USE_PREVENT_REUSE
	u32 year;
	u8 month;
	u8 mday;
	u8 wday;
	u8 hour;
	u8 minutes;
	u8 seconds;

	GWidgetInit	wi;
	gwinWidgetClearInit(&wi);
	wi.g.show = TRUE;

	// Create label
	wi.text = "12345678901234567890123456789012345678901234567890";
	switch(flag_video_status)
	{
	case VIDEO_OK:							sprintf((char *)wi.text, "VIDEO_OK");break;
	case VIDEO_FORBID_ALL:					sprintf((char *)wi.text, "VIDEO_FORBID_ALL");break;
	case VIDEO_FORBID_USE_2HR:				sprintf((char *)wi.text, "VIDEO_FORBID_USE_2HR");break;
	case VIDEO_FORBID_RTC_FAIL:				sprintf((char *)wi.text, "VIDEO_FORBID_RTC_FAIL");break;
	default:								sprintf((char *)wi.text, "unknown status : %d", (int)flag_video_status);break;
	}
	wi.g.width = WIDTH3; wi.g.height = THICK1; wi.g.x = COLUMN3; wi.g.y = ROW7;
	ghLabel6 = gwinLabelCreate(0, &wi);

	if(g_conn_status == CAMERA_OK)
	{
		if(flag_camera_model_data == 0)
		{
			//sprintf((char *)wi.text, "Model : -----------------------------");
			sprintf((char *)wi.text, "Model : Opal 1.0.0");
		}
		else
		{
			sprintf((char *)wi.text, "Model : %c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c", camera_data_model[0], camera_data_model[1], camera_data_model[2], camera_data_model[3], camera_data_model[4], camera_data_model[5], camera_data_model[6], camera_data_model[7],
					camera_data_model[8], camera_data_model[9], camera_data_model[10], camera_data_model[11], camera_data_model[12], camera_data_model[13], camera_data_model[14], camera_data_model[15]);
		}
		wi.g.width = WIDTH3; wi.g.height = THICK1; wi.g.x = COLUMN3; wi.g.y = ROW1;
		ghLabel6 = gwinLabelCreate(0, &wi);

		if(camera_data_serial1[9] == 0xff)
			sprintf((char *)wi.text, "S/N 1 : %c%c%c%c%c%c%c%c%c", camera_data_serial1[0], camera_data_serial1[1], camera_data_serial1[2], camera_data_serial1[3], camera_data_serial1[4], camera_data_serial1[5], camera_data_serial1[6], camera_data_serial1[7], camera_data_serial1[8]);
		else
			sprintf((char *)wi.text, "S/N 1 : %c%c%c%c%c%c%c%c%c%c", camera_data_serial1[0], camera_data_serial1[1], camera_data_serial1[2], camera_data_serial1[3], camera_data_serial1[4], camera_data_serial1[5], camera_data_serial1[6], camera_data_serial1[7], camera_data_serial1[8], camera_data_serial1[9]);

		wi.g.width = WIDTH3; wi.g.height = THICK1; wi.g.x = COLUMN3; wi.g.y = ROW2;
		ghLabel6 = gwinLabelCreate(0, &wi);

		sprintf((char *)wi.text, "S/N 2 : %c%c%c%c-%c%c%c-%c%c%c%c", camera_data_serial2[0], camera_data_serial2[1], camera_data_serial2[2], camera_data_serial2[3], camera_data_serial2[4], camera_data_serial2[5], camera_data_serial2[6], camera_data_serial2[7], camera_data_serial2[8], camera_data_serial2[9], camera_data_serial2[10]);
		wi.g.width = WIDTH3; wi.g.height = THICK1; wi.g.x = COLUMN3; wi.g.y = ROW3;
		ghLabel6 = gwinLabelCreate(0, &wi);

		if((camera_date_page0[12] == 0xAA) && (camera_date_page0[13] == 0xBB) && (camera_date_page0[14] == 0xCC) && (camera_date_page0[15] == 0xDD))
		{
			year = camera_date_page0[0] + 2000;
			month = camera_date_page0[1];
			mday = camera_date_page0[2];
			wday = camera_date_page0[3];
			hour = camera_date_page0[4];
			minutes = camera_date_page0[5];
			seconds = camera_date_page0[6];
			sprintf((char *)wi.text, "Product : %02d/%02d/%04ld %d %02d:%02d:%02d", month, mday, year, wday, hour, minutes, seconds);
		}
		else
		{
			sprintf((char *)wi.text, "Product : ---------------------------");
		}
		wi.g.width = WIDTH3; wi.g.height = THICK1; wi.g.x = COLUMN3; wi.g.y = ROW4;
		ghLabel6 = gwinLabelCreate(0, &wi);

		if((camera_awb_data0[0] == 0x00) && (camera_awb_data0[1] == 0x00) && (camera_awb_data0[2] == 0x00) && (camera_awb_data0[3] == 0x00))
		{
			/*
			sprintf((char *)wi.text, "AWB : -----------------------------");
			wi.g.width = WIDTH3 + 170; wi.g.height = THICK1; wi.g.x = COLUMN3; wi.g.y = ROW9;
			ghLabel6 = gwinLabelCreate(0, &wi);
			*/
		}
		else
		{
				int data_r0 = camera_awb_data0[0]<<8 | camera_awb_data0[1];
				int data_b0 = camera_awb_data0[2]<<8 | camera_awb_data0[3];

				sprintf((char *)wi.text, "AWB : R : 0x%04X = %4d  B : 0x%04X = %4d ", data_r0, data_r0, data_b0, data_b0);
			wi.g.width = WIDTH3 + 170; wi.g.height = THICK1; wi.g.x = COLUMN3; wi.g.y = ROW9;
			ghLabel6 = gwinLabelCreate(0, &wi);

				xil_printf("\n\rcamera AWB data R : 0x%04x = %4d  B : 0x%04x = %4d ", data_r0, data_r0, data_b0, data_b0);
		}

		if((camera_awb_data1[0] == 0x00) && (camera_awb_data1[1] == 0x00) && (camera_awb_data1[2] == 0x00) && (camera_awb_data1[3] == 0x00))
		{
			if((camera_awb_data0[0] == 0x00) && (camera_awb_data0[1] == 0x00) && (camera_awb_data0[2] == 0x00) && (camera_awb_data0[3] == 0x00))
			{
				sprintf((char *)wi.text, "AWB : -----------------------------");
				wi.g.width = WIDTH3 + 170; wi.g.height = THICK1; wi.g.x = COLUMN3; wi.g.y = ROW9;
				ghLabel6 = gwinLabelCreate(0, &wi);
			}
		}
		else
		{
				int data_r1 = camera_awb_data1[0]<<8 | camera_awb_data1[1];
				int data_b1 = camera_awb_data1[2]<<8 | camera_awb_data1[3];

				sprintf((char *)wi.text, "AWB : R : 0x%04X = %4d  B : 0x%04X = %4d ", data_r1, data_r1, data_b1, data_b1);
			wi.g.width = WIDTH3 + 170; wi.g.height = THICK1; wi.g.x = COLUMN3; wi.g.y = ROW9;
			ghLabel6 = gwinLabelCreate(0, &wi);

				xil_printf("\n\rcamera AWB data R : 0x%04x = %4d  B : 0x%04x = %4d ", data_r1, data_r1, data_b1, data_b1);
		}

		if((saturation_th2 == 0x00) && (saturation_th1 == 0x00))
		{
			sprintf((char *)wi.text, "Saturation : ----------------------");
			wi.g.width = WIDTH3 + 170; wi.g.height = THICK1; wi.g.x = COLUMN3; wi.g.y = ROW10;
			ghLabel6 = gwinLabelCreate(0, &wi);
		}
		else
		{
			sprintf((char *)wi.text, "Saturation : TH2 : 0x%02X = %3d  TH1 : 0x%02X = %3d ", saturation_th2, saturation_th2, saturation_th1, saturation_th1);
			wi.g.width = WIDTH3 + 170; wi.g.height = THICK1; wi.g.x = COLUMN3; wi.g.y = ROW10;
			ghLabel6 = gwinLabelCreate(0, &wi);
			xil_printf("\n\rcamera Saturation data TH2 : 0x%02x = %3d  TH1 : 0x%02x = %3d ", saturation_th2, saturation_th2, saturation_th1, saturation_th1);
		}

		if(user_brightness == 0x00)
		{
			sprintf((char *)wi.text, "Brightness : ----------------------");
			wi.g.width = WIDTH3; wi.g.height = THICK1; wi.g.x = COLUMN3; wi.g.y = ROW11;
			ghLabel6 = gwinLabelCreate(0, &wi);
		}
		else
		{
			sprintf((char *)wi.text, "Brightness : 0x%02X = %d ", user_brightness, user_brightness);
			wi.g.width = WIDTH3; wi.g.height = THICK1; wi.g.x = COLUMN3; wi.g.y = ROW11;
			ghLabel6 = gwinLabelCreate(0, &wi);
			xil_printf("\n\rcamera Brightness : 0x%02x = %d ", user_brightness, user_brightness);
		}
	}
	else
	{
		sprintf((char *)wi.text, "Model : -----------------------------");
		wi.g.width = WIDTH3; wi.g.height = THICK1; wi.g.x = COLUMN3; wi.g.y = ROW1;
		ghLabel6 = gwinLabelCreate(0, &wi);

		sprintf((char *)wi.text, "SN1 : ------------------------------");
		wi.g.width = WIDTH3; wi.g.height = THICK1; wi.g.x = COLUMN3; wi.g.y = ROW2;
		ghLabel6 = gwinLabelCreate(0, &wi);

		sprintf((char *)wi.text, "SN2 : ------------------------------");
		wi.g.width = WIDTH3; wi.g.height = THICK1; wi.g.x = COLUMN3; wi.g.y = ROW3;
		ghLabel6 = gwinLabelCreate(0, &wi);

		sprintf((char *)wi.text, "Product : ---------------------------");
		wi.g.width = WIDTH3; wi.g.height = THICK1; wi.g.x = COLUMN3; wi.g.y = ROW4;
		ghLabel6 = gwinLabelCreate(0, &wi);

		sprintf((char *)wi.text, "AWB : -----------------------------");
		wi.g.width = WIDTH3 + 170; wi.g.height = THICK1; wi.g.x = COLUMN3; wi.g.y = ROW9;
		ghLabel6 = gwinLabelCreate(0, &wi);
	}

	if((camera_date_page1[12] == 0xAA) && (camera_date_page1[13] == 0xBB) && (camera_date_page1[14] == 0xCC) && (camera_date_page1[15] == 0xDD))
	{
		year = camera_date_page1[0] + 2000;
		month = camera_date_page1[1];
		mday = camera_date_page1[2];
		wday = camera_date_page1[3];
		hour = camera_date_page1[4];
		minutes = camera_date_page1[5];
		seconds = camera_date_page1[6];
		sprintf((char *)wi.text, "1MIN : %02d/%02d/%04ld %d %02d:%02d:%02d", month, mday, year, wday, hour, minutes, seconds);
	}
	else
	{
		sprintf((char *)wi.text, "1MIN : -----------------------------");
	}
	wi.g.width = WIDTH3; wi.g.height = THICK1; wi.g.x = COLUMN3; wi.g.y = ROW5;
	ghLabel6 = gwinLabelCreate(0, &wi);

	//wi.text = "";
	if((camera_date_page3[12] == 0xAA) && (camera_date_page3[13] == 0xBB) && (camera_date_page3[14] == 0xCC) && (camera_date_page3[15] == 0xDD))
	{
		year = camera_date_page3[0] + 2000;
		month = camera_date_page3[1];
		mday = camera_date_page3[2];
		wday = camera_date_page3[3];
		hour = camera_date_page3[4];
		minutes = camera_date_page3[5];
		seconds = camera_date_page3[6];
		sprintf((char *)wi.text, "2HR : %02d/%02d/%04ld %d %02d:%02d:%02d", month, mday, year, wday, hour, minutes, seconds);
	}
	else
	{
		sprintf((char *)wi.text, "2HR : ------------------------");
	}
	wi.g.width = WIDTH3; wi.g.height = THICK1; wi.g.x = COLUMN3; wi.g.y = ROW6;
	ghLabel6 = gwinLabelCreate(0, &wi);

	//wi.text = "";
	if((camera_error_date[12] == 0xAA) && (camera_error_date[13] == 0xBB) && (camera_error_date[14] == 0xCC) && (camera_error_date[15] == 0xDD))
	{
		year = camera_error_date[0] + 2000;
		month = camera_error_date[1];
		mday = camera_error_date[2];
		wday = camera_error_date[3];
		hour = camera_error_date[4];
		minutes = camera_error_date[5];
		seconds = camera_error_date[6];
		sprintf((char *)wi.text, "Expired : %02d/%02d/%04ld %d %02d:%02d:%02d", month, mday, year, wday, hour, minutes, seconds);
	}
	else
	{
		sprintf((char *)wi.text, "----- : ------------------------");
	}
	wi.g.width = WIDTH3; wi.g.height = THICK1; wi.g.x = COLUMN3; wi.g.y = ROW8;
	ghLabel6 = gwinLabelCreate(0, &wi);

	if(flag_use_2_framebuffers == TRUE)
	{
		gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(next_framebuffer));

		// Create label

		//wi.text = "";
		switch(flag_video_status)
		{
		case VIDEO_OK:							sprintf((char *)wi.text, "VIDEO_OK");break;
		case VIDEO_FORBID_ALL:					sprintf((char *)wi.text, "VIDEO_FORBID_ALL");break;
		case VIDEO_FORBID_USE_2HR:				sprintf((char *)wi.text, "VIDEO_FORBID_USE_2HR");break;
		case VIDEO_FORBID_RTC_FAIL:				sprintf((char *)wi.text, "VIDEO_FORBID_RTC_FAIL");break;
		default:								sprintf((char *)wi.text, "unknown status : %d", (int)flag_video_status);break;
		}
		wi.g.width = WIDTH3; wi.g.height = THICK1; wi.g.x = COLUMN3; wi.g.y = ROW7;
		ghLabel6 = gwinLabelCreate(0, &wi);

		//wi.text = "12345678901234567890123456789012345678901234567890";
		if(g_conn_status == CAMERA_OK)
		{
			if(flag_camera_model_data == 0)
			{
				//sprintf((char *)wi.text, "Model : -----------------------------");
				sprintf((char *)wi.text, "Model : Opal 1.0.0");
			}
			else
			{
				sprintf((char *)wi.text, "Model : %c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c", camera_data_model[0], camera_data_model[1], camera_data_model[2], camera_data_model[3], camera_data_model[4], camera_data_model[5], camera_data_model[6], camera_data_model[7],
						camera_data_model[8], camera_data_model[9], camera_data_model[10], camera_data_model[11], camera_data_model[12], camera_data_model[13], camera_data_model[14], camera_data_model[15]);
			}
			wi.g.width = WIDTH3; wi.g.height = THICK1; wi.g.x = COLUMN3; wi.g.y = ROW1;
			ghLabel6 = gwinLabelCreate(0, &wi);

			if(camera_data_serial1[9] == 0xff)
				sprintf((char *)wi.text, "S/N 1 : %c%c%c%c%c%c%c%c%c", camera_data_serial1[0], camera_data_serial1[1], camera_data_serial1[2], camera_data_serial1[3], camera_data_serial1[4], camera_data_serial1[5], camera_data_serial1[6], camera_data_serial1[7], camera_data_serial1[8]);
			else
				sprintf((char *)wi.text, "S/N 1 : %c%c%c%c%c%c%c%c%c%c", camera_data_serial1[0], camera_data_serial1[1], camera_data_serial1[2], camera_data_serial1[3], camera_data_serial1[4], camera_data_serial1[5], camera_data_serial1[6], camera_data_serial1[7], camera_data_serial1[8], camera_data_serial1[9]);

			wi.g.width = WIDTH3; wi.g.height = THICK1; wi.g.x = COLUMN3; wi.g.y = ROW2;
			ghLabel6 = gwinLabelCreate(0, &wi);

			sprintf((char *)wi.text, "S/N 2 : %c%c%c%c-%c%c%c-%c%c%c%c", camera_data_serial2[0], camera_data_serial2[1], camera_data_serial2[2], camera_data_serial2[3], camera_data_serial2[4], camera_data_serial2[5], camera_data_serial2[6], camera_data_serial2[7], camera_data_serial2[8], camera_data_serial2[9], camera_data_serial2[10]);
			wi.g.width = WIDTH3; wi.g.height = THICK1; wi.g.x = COLUMN3; wi.g.y = ROW3;
			ghLabel6 = gwinLabelCreate(0, &wi);

			if((camera_date_page0[12] == 0xAA) && (camera_date_page0[13] == 0xBB) && (camera_date_page0[14] == 0xCC) && (camera_date_page0[15] == 0xDD))
			{
				year = camera_date_page0[0] + 2000;
				month = camera_date_page0[1];
				mday = camera_date_page0[2];
				wday = camera_date_page0[3];
				hour = camera_date_page0[4];
				minutes = camera_date_page0[5];
				seconds = camera_date_page0[6];
				sprintf((char *)wi.text, "Product : %02d/%02d/%04ld %d %02d:%02d:%02d", month, mday, year, wday, hour, minutes, seconds);
			}
			else
			{
				sprintf((char *)wi.text, "Product : ---------------------------");
			}
			wi.g.width = WIDTH3; wi.g.height = THICK1; wi.g.x = COLUMN3; wi.g.y = ROW4;
			ghLabel6 = gwinLabelCreate(0, &wi);

			if((camera_awb_data0[0] == 0x00) && (camera_awb_data0[1] == 0x00) && (camera_awb_data0[2] == 0x00) && (camera_awb_data0[3] == 0x00))
			{
				/*
				sprintf((char *)wi.text, "AWB : -----------------------------");
				wi.g.width = WIDTH3 + 170; wi.g.height = THICK1; wi.g.x = COLUMN3; wi.g.y = ROW9;
				ghLabel6 = gwinLabelCreate(0, &wi);
				*/
			}
			else
			{
				int data_r0 = camera_awb_data0[0]<<8 | camera_awb_data0[1];
				int data_b0 = camera_awb_data0[2]<<8 | camera_awb_data0[3];

				sprintf((char *)wi.text, "AWB : R : 0x%04X = %4d  B : 0x%04X = %4d ", data_r0, data_r0, data_b0, data_b0);
				wi.g.width = WIDTH3 + 170; wi.g.height = THICK1; wi.g.x = COLUMN3; wi.g.y = ROW9;
				ghLabel6 = gwinLabelCreate(0, &wi);

				xil_printf("\n\rcamera AWB data R : 0x%04x = %4d  B : 0x%04x = %4d ", data_r0, data_r0, data_b0, data_b0);
			}

			if((camera_awb_data1[0] == 0x00) && (camera_awb_data1[1] == 0x00) && (camera_awb_data1[2] == 0x00) && (camera_awb_data1[3] == 0x00))
			{
				if((camera_awb_data0[0] == 0x00) && (camera_awb_data0[1] == 0x00) && (camera_awb_data0[2] == 0x00) && (camera_awb_data0[3] == 0x00))
				{
					sprintf((char *)wi.text, "AWB : -----------------------------");
					wi.g.width = WIDTH3 + 170; wi.g.height = THICK1; wi.g.x = COLUMN3; wi.g.y = ROW9;
					ghLabel6 = gwinLabelCreate(0, &wi);
				}
			}
			else
			{
				int data_r1 = camera_awb_data1[0]<<8 | camera_awb_data1[1];
				int data_b1 = camera_awb_data1[2]<<8 | camera_awb_data1[3];

				sprintf((char *)wi.text, "AWB : R : 0x%04X = %4d  B : 0x%04X = %4d ", data_r1, data_r1, data_b1, data_b1);
				wi.g.width = WIDTH3 + 170; wi.g.height = THICK1; wi.g.x = COLUMN3; wi.g.y = ROW9;
				ghLabel6 = gwinLabelCreate(0, &wi);

				xil_printf("\n\rcamera AWB data R : 0x%04x = %4d  B : 0x%04x = %4d ", data_r1, data_r1, data_b1, data_b1);
			}

			if((saturation_th2 == 0x00) && (saturation_th1 == 0x00))
			{
				sprintf((char *)wi.text, "Saturation : ----------------------");
				wi.g.width = WIDTH3 + 170; wi.g.height = THICK1; wi.g.x = COLUMN3; wi.g.y = ROW10;
				ghLabel6 = gwinLabelCreate(0, &wi);
			}
			else
			{
				sprintf((char *)wi.text, "Saturation : TH2 : 0x%02X = %3d  TH1 : 0x%02X = %3d ", saturation_th2, saturation_th2, saturation_th1, saturation_th1);
				wi.g.width = WIDTH3 + 170; wi.g.height = THICK1; wi.g.x = COLUMN3; wi.g.y = ROW10;
				ghLabel6 = gwinLabelCreate(0, &wi);
				xil_printf("\n\rcamera Saturation data TH2 : 0x%02x = %3d  TH1 : 0x%02x = %3d ", saturation_th2, saturation_th2, saturation_th1, saturation_th1);
			}

			if(user_brightness == 0x00)
			{
				sprintf((char *)wi.text, "Brightness : ----------------------");
				wi.g.width = WIDTH3; wi.g.height = THICK1; wi.g.x = COLUMN3; wi.g.y = ROW11;
				ghLabel6 = gwinLabelCreate(0, &wi);
			}
			else
			{
				sprintf((char *)wi.text, "Brightness : 0x%02X = %d ", user_brightness, user_brightness);
				wi.g.width = WIDTH3; wi.g.height = THICK1; wi.g.x = COLUMN3; wi.g.y = ROW11;
				ghLabel6 = gwinLabelCreate(0, &wi);
				xil_printf("\n\rcamera Brightness : 0x%02x = %d ", user_brightness, user_brightness);
			}
		}
		else
		{
			sprintf((char *)wi.text, "Model : -----------------------------");
			wi.g.width = WIDTH3; wi.g.height = THICK1; wi.g.x = COLUMN3; wi.g.y = ROW1;
			ghLabel6 = gwinLabelCreate(0, &wi);

			sprintf((char *)wi.text, "SN1 : ------------------------------");
			wi.g.width = WIDTH3; wi.g.height = THICK1; wi.g.x = COLUMN3; wi.g.y = ROW2;
			ghLabel6 = gwinLabelCreate(0, &wi);

			sprintf((char *)wi.text, "SN2 : ------------------------------");
			wi.g.width = WIDTH3; wi.g.height = THICK1; wi.g.x = COLUMN3; wi.g.y = ROW3;
			ghLabel6 = gwinLabelCreate(0, &wi);

			sprintf((char *)wi.text, "Product : ---------------------------");
			wi.g.width = WIDTH3; wi.g.height = THICK1; wi.g.x = COLUMN3; wi.g.y = ROW4;
			ghLabel6 = gwinLabelCreate(0, &wi);

			sprintf((char *)wi.text, "AWB : -----------------------------");
			wi.g.width = WIDTH3 + 170; wi.g.height = THICK1; wi.g.x = COLUMN3; wi.g.y = ROW9;
			ghLabel6 = gwinLabelCreate(0, &wi);
		}

		if((camera_date_page1[12] == 0xAA) && (camera_date_page1[13] == 0xBB) && (camera_date_page1[14] == 0xCC) && (camera_date_page1[15] == 0xDD))
		{
			year = camera_date_page1[0] + 2000;
			month = camera_date_page1[1];
			mday = camera_date_page1[2];
			wday = camera_date_page1[3];
			hour = camera_date_page1[4];
			minutes = camera_date_page1[5];
			seconds = camera_date_page1[6];
			sprintf((char *)wi.text, "1MIN : %02d/%02d/%04ld %d %02d:%02d:%02d", month, mday, year, wday, hour, minutes, seconds);
		}
		else
		{
			sprintf((char *)wi.text, "1MIN : -----------------------------");
		}
		wi.g.width = WIDTH3; wi.g.height = THICK1; wi.g.x = COLUMN3; wi.g.y = ROW5;
		ghLabel6 = gwinLabelCreate(0, &wi);

		//wi.text = "";
		if((camera_date_page3[12] == 0xAA) && (camera_date_page3[13] == 0xBB) && (camera_date_page3[14] == 0xCC) && (camera_date_page3[15] == 0xDD))
		{
			year = camera_date_page3[0] + 2000;
			month = camera_date_page3[1];
			mday = camera_date_page3[2];
			wday = camera_date_page3[3];
			hour = camera_date_page3[4];
			minutes = camera_date_page3[5];
			seconds = camera_date_page3[6];
			sprintf((char *)wi.text, "2HR : %02d/%02d/%04ld %d %02d:%02d:%02d", month, mday, year, wday, hour, minutes, seconds);
		}
		else
		{
			sprintf((char *)wi.text, "2HR : ------------------------");
		}
		wi.g.width = WIDTH3; wi.g.height = THICK1; wi.g.x = COLUMN3; wi.g.y = ROW6;
		ghLabel6 = gwinLabelCreate(0, &wi);

		//wi.text = "";
		if((camera_error_date[12] == 0xAA) && (camera_error_date[13] == 0xBB) && (camera_error_date[14] == 0xCC) && (camera_error_date[15] == 0xDD))
		{
			year = camera_error_date[0] + 2000;
			month = camera_error_date[1];
			mday = camera_error_date[2];
			wday = camera_error_date[3];
			hour = camera_error_date[4];
			minutes = camera_error_date[5];
			seconds = camera_error_date[6];
			sprintf((char *)wi.text, "Expired : %02d/%02d/%04ld %d %02d:%02d:%02d", month, mday, year, wday, hour, minutes, seconds);
		}
		else
		{
			sprintf((char *)wi.text, "----- : ------------------------");
		}
		wi.g.width = WIDTH3; wi.g.height = THICK1; wi.g.x = COLUMN3; wi.g.y = ROW8;
		ghLabel6 = gwinLabelCreate(0, &wi);

		gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(1 - next_framebuffer));
	}
//#endif
	xil_printf("\n\rshow_camera_info_eng SP\n\r");
	return;
}

void keep_current_setup_value(int item)
{
	if(item == 1)
		year_eng = rtc.tm_year;
	else if(item == 2)
		month_eng = rtc.tm_mon + 1;
	else if(item == 3)
		date_eng = rtc.tm_mday;
	else if(item == 4)
		day_eng = rtc.tm_wday;
	else if(item == 5)
		hour_eng = rtc.tm_hour;
	else if(item == 6)
		minutes_eng = rtc.tm_min;
	else if(item == 7)
		seconds_eng = rtc.tm_sec;
	else if(item == 8)
		SelectedLanguage_eng = SelectedLanguage;
	else
	{
		xil_printf("keep_current_setup_value unknown item = %d xxxx\n\r", item);
	}
	return;
}

void modify_current_setup_value(int add)
{
	if(engineering_mode_setup_item == 1)
	{
		if(add == 1)
		{
			year_eng++;
			if(year_eng > 200)
				year_eng = 200;
		}
		else
		{
			if(year_eng > 0)
				year_eng--;
		}
	}
	else if(engineering_mode_setup_item == 2)
	{
		if(add == 1)
		{
			month_eng++;
			if(month_eng > 12)
				month_eng = 1;
		}
		else
		{
			if(month_eng > 1)
				month_eng--;
			else
				month_eng = 12;
		}
	}
	else if(engineering_mode_setup_item == 3)
	{
		if(add == 1)
		{
			date_eng++;
			if(date_eng > 31)
				date_eng = 1;
		}
		else
		{
			if(date_eng > 1)
				date_eng--;
			else
				date_eng = 31;
		}
	}
	else if(engineering_mode_setup_item == 4)
	{
		if(add == 1)
		{
			day_eng++;
			if(day_eng > 6)
				day_eng = 0;
		}
		else
		{
			if(day_eng > 0)
				day_eng--;
			else
				day_eng = 6;
		}
	}
	else if(engineering_mode_setup_item == 5)
	{
		if(add == 1)
		{
			hour_eng++;
			if(hour_eng > 23)
				hour_eng = 0;
		}
		else
		{
			if(hour_eng > 0)
				hour_eng--;
			else
				hour_eng = 23;
		}
	}
	else if(engineering_mode_setup_item == 6)
	{
		if(add == 1)
		{
			minutes_eng++;
			if(minutes_eng > 59)
				minutes_eng = 0;
		}
		else
		{
			if(minutes_eng > 0)
				minutes_eng--;
			else
				minutes_eng = 59;
		}
	}
	else if(engineering_mode_setup_item == 7)
	{
		if(add == 1)
		{
			seconds_eng++;
			if(seconds_eng > 59)
				seconds_eng = 0;
		}
		else
		{
			if(seconds_eng > 0)
				seconds_eng--;
			else
				seconds_eng = 59;
		}
	}
	else if(engineering_mode_setup_item == 8)
	{
		if(add == 1)
		{
			SelectedLanguage_eng++;
			if(SelectedLanguage_eng > 2)
				SelectedLanguage_eng = 0;
		}
		else
		{
			if(SelectedLanguage_eng > 0)
				SelectedLanguage_eng--;
			else
				SelectedLanguage_eng = 2;
		}
	}
	else
	{
		xil_printf("modify_current_setup_value unknown item = %d xxxx\n\r", engineering_mode_setup_item);
	}
	refresh_current_setup_value();
	return;
}

void refresh_current_setup_value0(void)
{
    char str[40];
	font_t font = gdispOpenFont("iskpota232");

	if(flag_engineering_mode == TRUE)
	{
	    if(engineering_mode_setup_item == 1)
	    {
	    	sprintf(str, "%ld", year_eng + 1900);
			gdispFillArea(COLUMN1 + 120, ROW1, 100, 40, Black);
			gdispFillString(COLUMN1 + 120, ROW1, str, font, White, Red);
	    }
	    else if(engineering_mode_setup_item == 2)
	    {
	    	sprintf(str, "%d", month_eng);
			gdispFillArea(COLUMN1 + 120, ROW2, 100, 40, Black);
			gdispFillString(COLUMN1 + 120, ROW2, str, font, White, Red);
	    }
	    else if(engineering_mode_setup_item == 3)
	    {
	    	sprintf(str, "%d", date_eng);
	    	gdispFillArea(COLUMN1 + 120, ROW3, 100, 40, Black);
	    	gdispFillString(COLUMN1 + 120, ROW3, str, font, White, Red);
	    }
	    else if(engineering_mode_setup_item == 4)
	    {
			switch(day_eng)
			{
			case 0:		sprintf(str, "%s", "Sun");	break;
			case 1:		sprintf(str, "%s", "Mon");	break;
			case 2:		sprintf(str, "%s", "Tue");	break;
			case 3:		sprintf(str, "%s", "Wed");	break;
			case 4:		sprintf(str, "%s", "Thu");	break;
			case 5:		sprintf(str, "%s", "Fri");	break;
			case 6:		sprintf(str, "%s", "Sat");	break;
			case 7:		sprintf(str, "%s", "Sun");	break;
			default:	sprintf(str, "%s", "Mon");	break;
			}
			gdispFillArea(COLUMN1 + 120, ROW4, 100, 40, Black);
	    	gdispFillString(COLUMN1 + 120, ROW4, str, font, White, Red);
	    }
	    else if(engineering_mode_setup_item == 5)
	    {
	    	sprintf(str, "%d", hour_eng);
	    	gdispFillArea(COLUMN1 + 120, ROW5, 100, 40, Black);
	    	gdispFillString(COLUMN1 + 120, ROW5, str, font, White, Red);
	    }
	    else if(engineering_mode_setup_item == 6)
	    {
	    	sprintf(str, "%d", minutes_eng);
	    	gdispFillArea(COLUMN1 + 120, ROW6, 100, 40, Black);
	    	gdispFillString(COLUMN1 + 120, ROW6, str, font, White, Red);
	    }
	    else if(engineering_mode_setup_item == 7)
	    {
	    	sprintf(str, "%d", seconds_eng);
	    	gdispFillArea(COLUMN1 + 120, ROW7, 100, 40, Black);
	    	gdispFillString(COLUMN1 + 120, ROW7, str, font, White, Red);
	    }
	    else if(engineering_mode_setup_item == 8)
	    {
			switch(SelectedLanguage_eng)
			{
			case 0:		sprintf(str, "%s", "T. Chinese");	break;
			case 1:		sprintf(str, "%s", "S. Chinese");	break;
			case 2:		sprintf(str, "%s", "English");		break;
			default:	sprintf(str, "%s", "xxx");		break;
			}
			gdispFillArea(COLUMN4, ROW1, 150, 40, Black);
	    	gdispFillString(COLUMN4, ROW1, str, font, White, Red);
	    }
	}
	return;
}

void refresh_current_setup_value(void)
{
	refresh_current_setup_value0();
	if(flag_use_2_framebuffers == TRUE)
	{
		gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(next_framebuffer));
		refresh_current_setup_value0();
		gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(1 - next_framebuffer));
	}
	return;
}

void apply_current_setting(void)
{
	u8 type;
	int data;

	if(engineering_mode_setup_item == 1)
	{
		type = RTC_YEAR;
		data = (u8)(year_eng - 100);
	}
	else if(engineering_mode_setup_item == 2)
	{
		type = RTC_MON;
		data = month_eng;
	}
	else if(engineering_mode_setup_item == 3)
	{
		type = RTC_MD;
		data = date_eng;
	}
	else if(engineering_mode_setup_item == 4)
	{
		type = RTC_WD;
		data = day_eng;
	}
	else if(engineering_mode_setup_item == 5)
	{
		type = RTC_HH;
		data = hour_eng;
	}
	else if(engineering_mode_setup_item == 6)
	{
		type = RTC_MM;
		data = minutes_eng;
	}
	else if(engineering_mode_setup_item == 7)
	{
		type = RTC_SS;
		data = seconds_eng;
	}
	else if(engineering_mode_setup_item == 8)
	{
		SelectedLanguage = SelectedLanguage_eng;
	}
	else
	{
		xil_printf("apply_current_setting unknown item = %d xxxx\n\r", engineering_mode_setup_item);
		return;
	}
	if(engineering_mode_setup_item < 8)
		XIicPs_SetRTCData(&Iic, type, data);
	return;
}

void confirm_language_item(void)
{
    char str[40];
	font_t font = gdispOpenFont("iskpota232");

	switch(SelectedLanguage)
	{
	case 0:		sprintf(str, "%s", "T. Chinese");	break;
	case 1:		sprintf(str, "%s", "S. Chinese");	break;
	case 2:		sprintf(str, "%s", "English");		break;
	default:	sprintf(str, "%s", "xxx");			break;
	}
	gdispFillArea(COLUMN4, ROW1, 150, 40, Black);
	gdispDrawString(COLUMN4, ROW1, str, font, Red);
	gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(next_framebuffer));
	gdispFillArea(COLUMN4, ROW1, 150, 40, Black);
	gdispDrawString(COLUMN4, ROW1, str, font, Red);
	gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(1 - next_framebuffer));
	return;
}

#ifdef USE_PREVENT_REUSE
void forbid_video(int forbid_id)
{
	char str[40];
	switch(flag_video_status)
	{
	case VIDEO_OK:							sprintf(str, "VIDEO_OK\n");break;
	case VIDEO_FORBID_ALL:					sprintf(str, "VIDEO_FORBID_ALL\n");break;
	case VIDEO_FORBID_USE_2HR:				sprintf(str, "VIDEO_FORBID_USE_2HR\n");break;
	case VIDEO_FORBID_RTC_FAIL:				sprintf(str, "VIDEO_FORBID_RTC_FAIL\n");break;
	default:								sprintf(str, "unknown video status : %d\n", (int)flag_video_status);break;
	}
	debug_console_print(str);
	flag_forbid_video = TRUE;
	flag_forbid_video_old = TRUE;
	xil_printf("forbid_video flag_video_status = %d\n\r", flag_video_status);
	preload_forbid_picture_to_memory(flag_video_status);
	RequestShowPicture2(3);
	show_forbid_message(flag_video_status);
	if(flag_video_status != VIDEO_FORBID_RTC_FAIL)
		flag_updateShowCameraDate = 1;
	return;
}

void show_forbid_message(int forbid_id)
{
	if(flag_video_status == VIDEO_FORBID_RTC_FAIL)
		return;

	int status;
	char str1[40];
	char str2[40];
	char str3[40];

	font_t font = gdispOpenFont("iskpota232");

	if((camera_data_serial1[0] == 0x00) &&(camera_data_serial1[1] == 0x00))
	{
		status = read_serial_from_camera();			//camera 0xA
	}

	if(camera_data_serial1[9] == 0xff)	//9B
	{
		xil_printf("\n\rS/N: %c%c%c%c%c%c%c%c%c   %c%c%c%c-%c%c%c-%c%c%c%c\n\r\n\r",
				camera_data_serial1[0], camera_data_serial1[1], camera_data_serial1[2], camera_data_serial1[3],
				camera_data_serial1[4], camera_data_serial1[5], camera_data_serial1[6], camera_data_serial1[7],
				camera_data_serial1[8], camera_data_serial2[0], camera_data_serial2[1], camera_data_serial2[2],
				camera_data_serial2[3], camera_data_serial2[4], camera_data_serial2[5], camera_data_serial2[6],
				camera_data_serial2[7], camera_data_serial2[8], camera_data_serial2[9], camera_data_serial2[10]);

		sprintf(str1, "S/N: %c%c%c%c%c%c%c%c%c   %c%c%c%c-%c%c%c-%c%c%c%c\n\r",
				camera_data_serial1[0], camera_data_serial1[1], camera_data_serial1[2], camera_data_serial1[3],
				camera_data_serial1[4], camera_data_serial1[5], camera_data_serial1[6], camera_data_serial1[7],
				camera_data_serial1[8], camera_data_serial2[0], camera_data_serial2[1], camera_data_serial2[2],
				camera_data_serial2[3], camera_data_serial2[4], camera_data_serial2[5], camera_data_serial2[6],
				camera_data_serial2[7], camera_data_serial2[8], camera_data_serial2[9], camera_data_serial2[10]);
	}
	else		//10B
	{
		xil_printf("\n\rS/N: %c%c%c%c%c%c%c%c%c%c   %c%c%c%c-%c%c%c-%c%c%c%c\n\r\n\r",
				camera_data_serial1[0], camera_data_serial1[1], camera_data_serial1[2], camera_data_serial1[3],
				camera_data_serial1[4], camera_data_serial1[5], camera_data_serial1[6], camera_data_serial1[7],
				camera_data_serial1[8], camera_data_serial1[9], camera_data_serial2[0], camera_data_serial2[1], camera_data_serial2[2],
				camera_data_serial2[3], camera_data_serial2[4], camera_data_serial2[5], camera_data_serial2[6],
				camera_data_serial2[7], camera_data_serial2[8], camera_data_serial2[9], camera_data_serial2[10]);

		sprintf(str1, "S/N: %c%c%c%c%c%c%c%c%c%c   %c%c%c%c-%c%c%c-%c%c%c%c\n\r",
				camera_data_serial1[0], camera_data_serial1[1], camera_data_serial1[2], camera_data_serial1[3],
				camera_data_serial1[4], camera_data_serial1[5], camera_data_serial1[6], camera_data_serial1[7],
				camera_data_serial1[8], camera_data_serial1[9], camera_data_serial2[0], camera_data_serial2[1], camera_data_serial2[2],
				camera_data_serial2[3], camera_data_serial2[4], camera_data_serial2[5], camera_data_serial2[6],
				camera_data_serial2[7], camera_data_serial2[8], camera_data_serial2[9], camera_data_serial2[10]);
	}

	u32 year;
	u8 month;
	u8 mday;
	u8 wday;
	u8 hour;
	u8 minutes;
	u8 seconds;

	read_date_from_camera(DATE_PAGE1);
	if((page_data[12] == 0xAA) && (page_data[13] == 0xBB) && (page_data[14] == 0xCC) && (page_data[15] == 0xDD))
	{
		year = page_data[0] + 2000;
		month = page_data[1];
		mday = page_data[2];
		wday = page_data[3];
		hour = page_data[4];
		minutes = page_data[5];
		seconds = page_data[6];
		//sprintf((char *)wi.text, "1MIN : %02d/%02d/%04ld %d %02d:%02d:%02d", month, mday, year, wday, hour, minutes,seconds);
		xil_printf("START : %02d/%02d/%04ld %d %02d:%02d:%02d\n\r", month, mday, year, wday, hour, minutes, seconds);

		//sprintf(str2, "START : %02d/%02d/%04ld %d %02d:%02d:%02d", month, mday, year, wday, hour, minutes, seconds);
		switch(wday)
		{
		case 0:		sprintf(str2, "START : %02d/%02d/%04ld %s %02d:%02d:%02d", month, mday, year, "Sun", hour, minutes, seconds);break;
		case 1:		sprintf(str2, "START : %02d/%02d/%04ld %s %02d:%02d:%02d", month, mday, year, "Mon", hour, minutes, seconds);break;
		case 2:		sprintf(str2, "START : %02d/%02d/%04ld %s %02d:%02d:%02d", month, mday, year, "Tue", hour, minutes, seconds);break;
		case 3:		sprintf(str2, "START : %02d/%02d/%04ld %s %02d:%02d:%02d", month, mday, year, "Wed", hour, minutes, seconds);break;
		case 4:		sprintf(str2, "START : %02d/%02d/%04ld %s %02d:%02d:%02d", month, mday, year, "Thu", hour, minutes, seconds);break;
		case 5:		sprintf(str2, "START : %02d/%02d/%04ld %s %02d:%02d:%02d", month, mday, year, "Fri", hour, minutes, seconds);break;
		case 6:		sprintf(str2, "START : %02d/%02d/%04ld %s %02d:%02d:%02d", month, mday, year, "Sat", hour, minutes, seconds);break;
		case 7:		sprintf(str2, "START : %02d/%02d/%04ld %s %02d:%02d:%02d", month, mday, year, "Sun", hour, minutes, seconds);break;
		}

		/*
		xil_printf("year = %d\n\r", year);
		xil_printf("month = %d\n\r", month);
		xil_printf("day = %d\n\r", mday);
		xil_printf("wday = %d\n\r", wday);
		xil_printf("hour = %d\n\r", hour);
		xil_printf("minute = %d\n\r", minutes);
		xil_printf("second = %d\n\r", seconds);
		*/
	}
	else
	{
		//sprintf((char *)wi.text, "XXXXX");
		xil_printf("xxxxxxx unknown data\n\r");
	}

	read_date_from_camera(DATE_PAGE3);
	if((page_data[12] == 0xAA) && (page_data[13] == 0xBB) && (page_data[14] == 0xCC) && (page_data[15] == 0xDD))
	{
		year = page_data[0] + 2000;
		month = page_data[1];
		mday = page_data[2];
		wday = page_data[3];
		hour = page_data[4];
		minutes = page_data[5];
		seconds = page_data[6];
		//sprintf((char *)wi.text, "2HR : %02d/%02d/%04ld %d %02d:%02d:%02d", month, mday, year, wday, hour, minutes, seconds);
		xil_printf("2HR : %02d/%02d/%04ld %d %02d:%02d:%02d\n\r", month, mday, year, wday, hour, minutes, seconds);

		//sprintf(str3, "2HR : %02d/%02d/%04ld %d %02d:%02d:%02d", month, mday, year, wday, hour, minutes, seconds);
		switch(wday)
		{
		case 0:		sprintf(str3, "2HR : %02d/%02d/%04ld %s %02d:%02d:%02d", month, mday, year, "Sun", hour, minutes, seconds);break;
		case 1:		sprintf(str3, "2HR : %02d/%02d/%04ld %s %02d:%02d:%02d", month, mday, year, "Mon", hour, minutes, seconds);break;
		case 2:		sprintf(str3, "2HR : %02d/%02d/%04ld %s %02d:%02d:%02d", month, mday, year, "Tue", hour, minutes, seconds);break;
		case 3:		sprintf(str3, "2HR : %02d/%02d/%04ld %s %02d:%02d:%02d", month, mday, year, "Wed", hour, minutes, seconds);break;
		case 4:		sprintf(str3, "2HR : %02d/%02d/%04ld %s %02d:%02d:%02d", month, mday, year, "Thu", hour, minutes, seconds);break;
		case 5:		sprintf(str3, "2HR : %02d/%02d/%04ld %s %02d:%02d:%02d", month, mday, year, "Fri", hour, minutes, seconds);break;
		case 6:		sprintf(str3, "2HR : %02d/%02d/%04ld %s %02d:%02d:%02d", month, mday, year, "Sat", hour, minutes, seconds);break;
		case 7:		sprintf(str3, "2HR : %02d/%02d/%04ld %s %02d:%02d:%02d", month, mday, year, "Sun", hour, minutes, seconds);break;
		}

		/*
		xil_printf("year = %d\n\r", year);
		xil_printf("month = %d\n\r", month);
		xil_printf("day = %d\n\r", mday);
		xil_printf("wday = %d\n\r", wday);
		xil_printf("hour = %d\n\r", hour);
		xil_printf("minute = %d\n\r", minutes);
		xil_printf("second = %d\n\r", seconds);
		*/
	}

	gdispDrawString(1100 - 20, 557 - 20, str1, font, White);
	if((page_data[12] == 0xAA) && (page_data[13] == 0xBB) && (page_data[14] == 0xCC) && (page_data[15] == 0xDD))
	{
		gdispDrawString(1100 - 20, 585 - 15, str2, font, White);
		gdispDrawString(1100 - 20, 613 - 10, str3, font, White);
	}

	if(flag_use_2_framebuffers == TRUE)
	{
		gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(next_framebuffer));
		gdispDrawString(1100 - 20, 557 - 20, str1, font, White);
		if((page_data[12] == 0xAA) && (page_data[13] == 0xBB) && (page_data[14] == 0xCC) && (page_data[15] == 0xDD))
		{
			gdispDrawString(1100 - 20, 585 - 15, str2, font, White);
			gdispDrawString(1100 - 20, 613 - 10, str3, font, White);
		}
	}
	return;
}
#endif

void ims_printf0( const char8 *ctrl1)
{
	/*
	char8 *ctrl = (char8 *)ctrl1;

    //va_start( argp, ctrl1);

    while ((ctrl != NULL) && (*ctrl != (char8)0)) {
*/
        /* move format string chars to buffer until a  */
        /* format control is found.                    */
	/*
        if (*ctrl != '%') {
			ctrl += 1;
            continue;
        }
    }

    xil_printf(ctrl1);
    */

	GWidgetInit	wi;

	gwinWidgetClearInit(&wi);
	wi.g.show = TRUE;

	// Create label
	wi.text = "";
	sprintf((char *)wi.text, "%s", ctrl1);
	wi.g.width = WIDTH3; wi.g.height = THICK1; wi.g.x = CAMERA_INFO_POS_X1; wi.g.y = CAMERA_INFO_POS_Y1 + THICK1;
	ghLabel6 = gwinLabelCreate(0, &wi);

    return;
}

void ims_printf( const char8 *ctrl1)
{
	xil_printf("ims_printf XXXXXXXXXXXXXXXXXXXXXXXx\n\r");
	gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(next_framebuffer));
	ims_printf0(ctrl1);
	gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(1 - next_framebuffer));
	ims_printf0(ctrl1);
    return;
}

void enable_camera(int enable)
{
	unsigned char DongleData;
	unsigned int DongleAddr;

	if(enable == CAMERA_RUN)
	{
		xil_printf("enable(CAMERA_RUN)\n\r");
		DongleAddr = 0x0100;
		DongleData = dongle_read_data(DongleAddr);
		xil_printf("david0513: %s:%s(%d) addr = 0x%04x value=0x%02x\r\n",__FILE__,__func__,__LINE__,DongleAddr,DongleData);
		if(DongleData != 1)
		{
			xil_printf("to CAMERA_RUN\n\r");
			DongleData = 1;
			dongle_write_data(DongleAddr, DongleData);
		}
		else
			xil_printf("already CAMERA_RUN\n\r");

		DongleAddr = 0x5080;
		DongleData = dongle_read_data(DongleAddr);
		xil_printf("david0513: %s:%s(%d) addr = 0x%04x value=0x%02x\r\n",__FILE__,__func__,__LINE__,DongleAddr,DongleData);
		if(DongleData != 0)
		{
			DongleData = 0;
			usleep(2000);
			xil_printf("david0513: %s:%s(%d) addr = 0x%04x value=0x%02x\r\n",__FILE__,__func__,__LINE__,DongleAddr,DongleData);
			xil_printf("to clear color bar\n\r");
			dongle_write_data(DongleAddr, DongleData);
		}
		else
			xil_printf("already clear color bar\n\r");
	}
	else if(enable == CAMERA_FREEZE)
	{
		xil_printf("enable(CAMERA_FREEZE)\n\r");
		DongleAddr = 0x0100;
		DongleData = dongle_read_data(DongleAddr);
		xil_printf("david0513: %s:%s(%d) addr = 0x%04x value=0x%02x\r\n",__FILE__,__func__,__LINE__,DongleAddr,DongleData);
#ifdef FREEZE_WHEN_STOP
		if(DongleData != 0)
		{
			DongleData = 0;		//stopped
			xil_printf("david0513: %s:%s(%d) addr = 0x%04x value=0x%02x\r\n",__FILE__,__func__,__LINE__,DongleAddr,DongleData);
			xil_printf("to CAMERA_FREEZE\n\r");
			dongle_write_data(DongleAddr, DongleData);
		}
		else
			xil_printf("already CAMERA_FREEZE\n\r");
#else
		if(DongleData != 1)
		{
			DongleData = 1;		//running
			xil_printf("david0513: %s:%s(%d) addr = 0x%04x value=0x%02x\r\n",__FILE__,__func__,__LINE__,DongleAddr,DongleData);
			xil_printf("to CAMERA_FREEZE but always running\n\r");
			dongle_write_data(DongleAddr, DongleData);
		}
		else
			xil_printf("already running mode\n\r");
#endif
	}
	else if(enable == CAMERA_FORBID)
	{
		xil_printf("enable(CAMERA_FORBID)\n\r");
#ifdef USE_PREVENT_REUSE
		if(flag_forbid_video != TRUE)
		{
			xil_printf("\n\rdavid0513: %s:%s(%d) xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\r\n\n\r",__FILE__,__func__,__LINE__);
		}
#endif
		DongleAddr = 0x5080;
		DongleData = dongle_read_data(DongleAddr);
		xil_printf("david0513: %s:%s(%d) addr = 0x%04x value=0x%02x\r\n",__FILE__,__func__,__LINE__,DongleAddr,DongleData);
		//xil_printf("addr = 0x%x, data = 0x%x test pattern registers\n\r", DongleAddr, DongleData);
		usleep(2000);
		DongleData = (1<<7) | (0 << 2);
		xil_printf("david0513: %s:%s(%d) addr = 0x%04x value=0x%02x\r\n",__FILE__,__func__,__LINE__,DongleAddr,DongleData);
		xil_printf("to color bar forbid\n\r");
		//dongle_write_data(DongleAddr, DongleData);
	}
	return;
}

void read_camera_fpga(uint16_t page)
{
	int i;
	xil_printf("\n\rread_camera_fpga, page = 0x%x = %d\n\r", page, page);
	ENABLE_CONFIGURE(1);
	SET_ADDRESS(page);
	//usleep(100);
	READ_1PAGE();
	ENABLE_CONFIGURE(0);

	xil_printf("DATA : %02X-%02X-%02X-%02X-%02X-%02X-%02X-%02X-%02X-%02X-%02X-%02X-%02X-%02X-%02X-%02X\n\r",
			page_data[0], page_data[1], page_data[2], page_data[3], page_data[4], page_data[5], page_data[6], page_data[7],
			page_data[8], page_data[9], page_data[10], page_data[11], page_data[12], page_data[13], page_data[14], page_data[15]);

	//return;

	if(page == SN_PAGE2)
	{
		//xil_printf("S/N : %02X%02X-%02X%02X-%02X%02X-%02X%02X\n\r", page_data[0], page_data[1], page_data[2], page_data[3], page_data[4], page_data[5], page_data[6], page_data[7]);
	}
	else
	{
		for(i = 0; i < 0x10; i++)
		{
			if(isprint(RecvBuffer[i]))
				xil_printf("%c", page_data[i]);
			else
			{
				xil_printf("^");
				//xil_printf("%02x", page_data[i]);
			}
			xil_printf("%02x ", page_data[i]);
		}
		xil_printf("\n\r");
	}
	return;
}

void debug_console_init(void)
{
#ifdef USE_DEBUG_CONSOLE
	/* Set a font */
	//gwinSetDefaultFont(gdispOpenFont("DejaVuSans24_aa"));
	gwinSetDefaultFont(gdispOpenFont("iskpota232"));

	/* create the console window */
	GWindowInit		wi0;
	GWindowInit		wi1;

	gwinClearInit(&wi0);
	gwinClearInit(&wi1);
	wi0.show = TRUE;
	wi1.show = TRUE;
	wi0.x = 20;
	wi1.x = 20;
	wi0.y = 580;
	wi1.y = 580;
	wi0.width = 660;
	wi1.width = 660;
	wi0.height = 490;
	wi1.height = 490;

	xil_printf("W = %d, H = %d\n\r", wi0.width, wi0.height);
	gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(0));
	GW0a = gwinConsoleCreate(0, &wi0);
	/* Set the fore- and background colors for the console */
	//gwinSetColor(GW0a, White);
	//gwinSetBgColor(GW0a, Black);
	gwinClear(GW0a);

	gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(1));
	GW1a = gwinConsoleCreate(0, &wi1);
	/* Set the fore- and background colors for the console */
	//gwinSetColor(GW1a, White);
	//gwinSetBgColor(GW1a, Black);
	gwinClear(GW1a);
#endif
	return;
}

void debug_console_print(const char8 *ctrl1)
{
#ifdef USE_DEBUG_CONSOLE
	if(flag_enable_debug_console == TRUE)
	{
		gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(0));
		gwinSetColor(GW0a, White);
		gwinSetBgColor(GW0a, Purple);
		gwinPrintf(GW0a, ctrl1);
		gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(1));
		gwinSetColor(GW1a, White);
		gwinSetBgColor(GW1a, Purple);
		gwinPrintf(GW1a, ctrl1);
	}
#endif
	return;
}

void debug_console_close(void)
{
#ifdef USE_DEBUG_CONSOLE
	gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(0));
	gwinSetBgColor(GW0a, Black);
	gwinClear(GW0a);
	gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(1));
	gwinSetBgColor(GW1a, Black);
	gwinClear(GW1a);
#endif
	return;
}

unsigned long get_total_sec(struct tm t)
{
	/*
	xil_printf("tm_year = %d\n\r", t.tm_year);
	xil_printf("tm_mon = %d\n\r", t.tm_mon);
	xil_printf("tm_mday = %d\n\r", t.tm_mday);
	xil_printf("tm_hour = %d\n\r", t.tm_hour);
	xil_printf("tm_min = %d\n\r", t.tm_min);
	xil_printf("tm_sec = %d\n\r", t.tm_sec);
	*/
	unsigned long total_sec = 0;
	int yday;
	total_sec += t.tm_sec;
	total_sec += t.tm_min * 60;
	total_sec += t.tm_hour * 60 * 60;
	switch(t.tm_mon + 1)
	{
		case 1:		yday = t.tm_mday;break;
		case 2:		yday = t.tm_mday + 31;break;
		case 3:		yday = t.tm_mday + 31 + 28;break;
		case 4:		yday = t.tm_mday + 31 + 28 + 31;break;
		case 5:		yday = t.tm_mday + 31 + 28 + 31 + 30;break;
		case 6:		yday = t.tm_mday + 31 + 28 + 31 + 30 + 31;break;
		case 7:		yday = t.tm_mday + 31 + 28 + 31 + 30 + 31 + 30;break;
		case 8:		yday = t.tm_mday + 31 + 28 + 31 + 30 + 31 + 30 + 31;break;
		case 9:		yday = t.tm_mday + 31 + 28 + 31 + 30 + 31 + 30 + 31 + 31;break;
		case 10:	yday = t.tm_mday + 31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30;break;
		case 11:	yday = t.tm_mday + 31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31;break;
		case 12:	yday = t.tm_mday + 31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31 + 30;break;
		default:	yday = t.tm_mday;break;
	}
	//xil_printf("david0109 year = %d\n\r", t.tm_year);
	//xil_printf("yday1 = %d\n\r", yday);
	if(((t.tm_year % 4) == 0)&&((t.tm_year % 100) != 0))
	{
		if(t.tm_mon > 1)
			yday++;
	}
	yday += (t.tm_year - 120) * 365;
	//xil_printf("yday2 = %d\n\r", yday);
	total_sec += (yday - 1) * 60 * 60 * 24;
	return total_sec;
}

int diff_time(struct tm t1, struct tm t2)
{
	unsigned long total_sec1 = 0;
	unsigned long total_sec2 = 0;

	total_sec1 = get_total_sec(t1);
	//xil_printf("total_sec1 = %ld\n\r", total_sec1);

	total_sec2 = get_total_sec(t2);
	//xil_printf("total_sec2 = %ld\n\r", total_sec2);

	if(total_sec1 > total_sec2)
	{
		//xil_printf("tmp1 = %ld\n\r", total_sec1 - total_sec2);
		return (total_sec1 - total_sec2);
	}
	else
	{
		//xil_printf("tmp2 = %ld\n\r", total_sec2 - total_sec1);
		return (total_sec2 - total_sec1);
	}
}

void print_time_clear(void)
{
#ifdef USE_PREVENT_REUSE
	/*	need to change location
	gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(next_framebuffer));
	gdispFillArea(CAMERA_INFO_POS_X1, CAMERA_INFO_POS_Y4, WIDTH2 + 100, THICK1, Black);
	gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(1 - next_framebuffer));
	gdispFillArea(CAMERA_INFO_POS_X1, CAMERA_INFO_POS_Y4, WIDTH2 + 100, THICK1, Black);

	gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(next_framebuffer));
	gdispFillArea(CAMERA_INFO_POS_X1, CAMERA_INFO_POS_Y3, WIDTH1 * 2, THICK1, Black);
	gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(1 - next_framebuffer));
	gdispFillArea(CAMERA_INFO_POS_X1, CAMERA_INFO_POS_Y3, WIDTH1 * 2, THICK1, Black);
	*/

	//xil_printf("print_time_clear, draw black\n\r");
	gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(next_framebuffer));
	gdispFillArea(CAMERA_INFO_POS_X2 + 100, CAMERA_INFO_POS_Y1, CAMERA_INFO_WIDTH3, THICK1, Black);
	gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(1 - next_framebuffer));
	gdispFillArea(CAMERA_INFO_POS_X2 + 100, CAMERA_INFO_POS_Y1, CAMERA_INFO_WIDTH3, THICK1, Black);
#endif
	return;
}

#ifdef USE_PREVENT_REUSE
unsigned long get_camera_use_time(void)
{
	struct tm rtc_base;
	struct tm rtc_camera;
	unsigned long difftime_now = 0;
	unsigned long difftime_camera = 0;
	unsigned long difftime = 0;
	int ret = 1;

/*
	xil_printf("now data: %d/%d/%d %d %02d:%02d:%02d\r\n",
		rtc.tm_year + 2000, rtc.tm_mon + 1, rtc.tm_mday, rtc.tm_wday, rtc.tm_hour, rtc.tm_min, rtc.tm_sec);
*/

	rtc_base.tm_year   = 120;
	rtc_base.tm_mon    = 0;	//Jan
	rtc_base.tm_mday   = 1;
	rtc_base.tm_wday   = 1;
	rtc_base.tm_hour   = 0;
	rtc_base.tm_min    = 0;
	rtc_base.tm_sec    = 0;

	difftime_now = diff_time(rtc, rtc_base);

/*
	xil_printf("old data: %d/%d/%d %d %02d:%02d:%02d\r\n",
			rtc_base.tm_year, rtc_base.tm_mon + 1, rtc_base.tm_mday, rtc_base.tm_wday, rtc_base.tm_hour, rtc_base.tm_min, rtc_base.tm_sec);
	xil_printf("difftime_now = %ld\n\r", difftime_now);
*/

	u32 year;
	u8 month;
	u8 mday;
	u8 wday;
	u8 hour;
	u8 minutes;
	u8 seconds;

	ret = read_date_from_camera(DATE_PAGE1);	//camera 0xB
	if(ret == 1)
	{
		flag_camera_status = CAMERA_1M;
		year = page_data[0];
		month = page_data[1];
		mday = page_data[2];
		wday = page_data[3];
		hour = page_data[4];
		minutes = page_data[5];
		seconds = page_data[6];

		//xil_printf("USED : %02d/%02d/%04ld %d %02d:%02d:%02d\n\r", month, mday, year + 2000, wday, hour, minutes, seconds);

		/*
		xil_printf("year = %d\n\r", year);
		xil_printf("month = %d\n\r", month);
		xil_printf("day = %d\n\r", mday);
		xil_printf("wday = %d\n\r", wday);
		xil_printf("hour = %d\n\r", hour);
		xil_printf("minute = %d\n\r", minutes);
		xil_printf("second = %d\n\r", seconds);
		*/

		rtc_camera.tm_year   = year + 100;
		rtc_camera.tm_mon    = month - 1;
		rtc_camera.tm_mday   = mday;
		rtc_camera.tm_wday   = wday;
		rtc_camera.tm_hour   = hour;
		rtc_camera.tm_min    = minutes;
		rtc_camera.tm_sec    = seconds;

/*
		xil_printf("new data: %d/%d/%d %d %02d:%02d:%02d\r\n",
				rtc_camera.tm_year + 1900, rtc_camera.tm_mon + 1, rtc_camera.tm_mday, rtc_camera.tm_wday, rtc_camera.tm_hour, rtc_camera.tm_min, rtc_camera.tm_sec);

		xil_printf("base data: %d/%d/%d %d %02d:%02d:%02d\r\n",
				rtc_base.tm_year + 1900, rtc_base.tm_mon + 1, rtc_base.tm_mday, rtc_base.tm_wday, rtc_base.tm_hour, rtc_base.tm_min, rtc_base.tm_sec);
*/
		difftime_camera = diff_time(rtc_camera, rtc_base);
		if(difftime_now < difftime_camera)
		{
			difftime = 0;
			xil_printf("time skew, let difftime = %ld\n\r", difftime);
		}
		else
		{
			difftime = difftime_now - difftime_camera;
			//xil_printf("difftime_now = %ld\n\r", difftime_now);
			//xil_printf("difftime_camera = %ld\n\r", difftime_camera);
			//xil_printf("difftime = %ld\n\r", difftime);
		}
	}
	else
	{
		//xil_printf("New camera\r\n");
		flag_camera_status = CAMERA_NEW;
		difftime = 0;
	}
	return difftime;
}

void print_time0(unsigned long s)
{
	xil_printf("david0529: %s:%s(%d) ST\r\n",__FILE__,__func__,__LINE__);
	GWidgetInit	wi;

	// Apply some default values for GWIN
	gwinWidgetClearInit(&wi);
	wi.g.show = TRUE;
	wi.text = "1234567890123456789012345678901234567890";

	//wi.g.width = WIDTH2; wi.g.height = THICK1; wi.g.x = CAMERA_INFO_POS_X1; wi.g.y = CAMERA_INFO_POS_Y4;
	wi.g.width = WIDTH2; wi.g.height = THICK1; wi.g.x = BORDER_X; wi.g.y = BORDER_Y + THICK1 * 9;

	if(s >= 86400)
	{
		//xil_printf("%ld Days, %ld Hours, %ld Minutes, %ld Seconds\n\r", s/86400, (s%86400)/3600, ((s%86400)%3600)/60, ((s%86400)%3600)%60);
		//xil_printf("%ldd%ldh%ldm%lds\n\r", s/86400, (s%86400)/3600, ((s%86400)%3600)/60, ((s%86400)%3600)%60);
		sprintf((char *)wi.text, "%ldd %ldh %ldm %lds  /  %d min", s/86400, (s%86400)/3600, ((s%86400)%3600)/60, ((s%86400)%3600)%60, TWO_HOURS);
		//sprintf((char *)wi.text, "%ldd %ldh %ldm", s/86400, (s%86400)/3600, ((s%86400)%3600)/60);
	}
	else if(s >= 3600)
	{
		//xil_printf("%ld Hours, %ld Minutes, %ld Seconds\n\r", (s%86400)/3600, ((s%86400)%3600)/60, ((s%86400)%3600)%60);
		//xil_printf("%ldh%ldm%lds\n\r", (s%86400)/3600, ((s%86400)%3600)/60, ((s%86400)%3600)%60);
		sprintf((char *)wi.text, "%ldh %ldm %lds  /  %d min", (s%86400)/3600, ((s%86400)%3600)/60, ((s%86400)%3600)%60, TWO_HOURS);
		//sprintf((char *)wi.text, "%ldh %ldm", (s%86400)/3600, ((s%86400)%3600)/60);
	}
	else if(s >= 60)
	{
		//xil_printf("%ld Minutes, %ld Seconds\n\r", ((s%86400)%3600)/60, ((s%86400)%3600)%60);
		//xil_printf("%ldm%lds\n\r", ((s%86400)%3600)/60, ((s%86400)%3600)%60);
		sprintf((char *)wi.text, "%ldm %lds  /  %d min", ((s%86400)%3600)/60, ((s%86400)%3600)%60, TWO_HOURS);
		//sprintf((char *)wi.text, "%ld min  /  %d min", ((s%86400)%3600)/60, TWO_HOURS);
	}
	else if(s > 0)
	{
		//xil_printf("%ld Seconds\n\r", ((s%86400)%3600)%60);
		//xil_printf("%lds\n\r", ((s%86400)%3600)%60);
		sprintf((char *)wi.text, "%lds  /  %d min", ((s%86400)%3600)%60, TWO_HOURS);
		//sprintf((char *)wi.text, "0 m");
	}
	else
	{
		sprintf((char *)wi.text, "               ", ((s%86400)%3600)%60, TWO_HOURS);
	}
	/*
	if(s >= 86400)
		xil_printf("%d Days, ", s/86400);
	if(s >= 3600)
		xil_printf("%d Hours, ", (s%86400)/3600);
	if(s >= 60)
		xil_printf("%d Minutes, ", ((s%86400)%3600)/60);
	xil_printf("%d Seconds\n\r", ((s%86400)%3600)%60);
	*/
	ghLabel6 = gwinLabelCreate(0, &wi);
	//xil_printf("^%lds ", s);
	return;
}

void print_time(unsigned long s)
{
	xil_printf("david0529: %s:%s(%d) ST\r\n",__FILE__,__func__,__LINE__);
	if(flag_use_2_framebuffers == TRUE)
	{
		gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(next_framebuffer));
	}
	print_time0(s);

	if(flag_use_2_framebuffers == TRUE)
	{
		//switch_to_framebuffer(next_framebuffer);
		gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(1 - next_framebuffer));
		print_time0(s);
	}
	return;
}

int get_camera_status(void)
{
	int camera_status;
	int ret = 1;
	ret = read_date_from_camera(DATE_PAGE1);	//camera 0xB
	if(ret == 1)
	{
		camera_status = CAMERA_1M;
		ret = read_date_from_camera(DATE_PAGE3);	//camera 0xD
		if(ret == 1)
		{
			camera_status = CAMERA_2HR;
		}
		else
		{
			camera_status = CAMERA_1M;
		}
	}
	else
		camera_status = CAMERA_NEW;
	xil_printf("get_camera_status return status = %d\n\r", camera_status);
	return camera_status;
}
#endif

void check_draw_command()
{
	if((draw_command_index != -1) && (draw_command_index != 1) && (draw_command_index != 2) && (draw_command_index != 3))
	{
		return;
	}
	if(flag_use_2_framebuffers == TRUE)
	{
		gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(next_framebuffer));

		if(draw_command_index == -1)
		{
			clear_layer1(next_framebuffer);
		}
		else
		{
			dma_restore_picture(draw_command_index);
			layer1_blit(pic_sizes[draw_command_index], next_framebuffer);
			layer1_blit_corners(next_framebuffer);
		}
#ifdef USE_PREVENT_REUSE
		if(draw_command_index == 3)
		{
			show_forbid_message(flag_video_status);
		}
#endif
		gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(1 - next_framebuffer));
		draw_command_index = 0;
	}
}

void add_draw_command(int cmd, int pic)
{
	draw_command_index = cmd;
	//draw_command_pic = pic;
}

void updateShowCameraDate(void)
{
	xil_printf("\n\rupdateShowCameraDate\n\r");
	show_camera_date(1);
	if(flag_use_2_framebuffers == TRUE)
	{
		gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(next_framebuffer));
		show_camera_date(1);
		gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(1 - next_framebuffer));
		show_camera_date(1);
	}
	return;
}

int check_camera_reuse(void)
{
#ifdef USE_PREVENT_REUSE
	xil_printf("\n\rcheck_camera_reuse ST\r\n");
	flag_camera_status = get_camera_status();
	//xil_printf("check_camera_reuse  flag_camera_status = %d\n\r", flag_camera_status);
	if((flag_camera_status < CAMERA_NEW) || (flag_camera_status > CAMERA_USED))
	{
		xil_printf("xxxxxxxxxxxxx  unknown flag_camera_status = %d\n\r", flag_camera_status);
	}

	if(flag_camera_status == CAMERA_NEW)
	{
		xil_printf("check 1: CAMERA_NEW\n\r");
		debug_console_print("CAMERA_NEW\n\r");
		g_updated = 1;
		g_procedure_started = STOP;
		flag_forbid_video = FALSE;
		flag_camera_invalid = FALSE;
		camera_use_time = 0;
		camera_use_time_this = 0;
		xil_printf("david0529: %s:%s(%d) ST\r\n",__FILE__,__func__,__LINE__);
		print_time(camera_use_time_this);
	}
	else
	{
		xil_printf("check 1 : CAMERA_NOT_NEW\n\r");
		flag_video_status = read_error_code_from_camera();
		if(flag_video_status != VIDEO_OK)
		{
			xil_printf("check 2 : Forbid video, error code written in camera = %d........\n\r", flag_video_status);
			flag_forbid_video = TRUE;
			forbid_video(flag_video_status);

			flag_camera_status = get_camera_status();	//for display message
			if((flag_camera_status < 0) || (flag_camera_status > 3))
			{
				xil_printf("xxxxxxxxxxxxx  unknown flag_camera_status = %d\n\r", flag_camera_status);
			}
		}
		else
		{
			xil_printf("check 2 : no error code\n\r");

			camera_use_time = get_camera_use_time();
			camera_use_time_this = camera_use_time + 60;

			//xil_printf("\n\rcamera_use_time_this = %ld", camera_use_time_this);

			xil_printf("\n\rCamera use time : ");
			xil_printf("david0529: %s:%s(%d) ST\r\n",__FILE__,__func__,__LINE__);
			print_time(camera_use_time_this);

			if(camera_use_time_this >= (TWO_HOURS + 1) * 60)
			{
				xil_printf("check 3 : Forbid video, use too long, time = %ld........\n\r", camera_use_time_this);
				flag_camera_invalid = TRUE;
				flag_video_status = VIDEO_FORBID_USE_2HR;
				flag_forbid_video = TRUE;
				forbid_video(flag_video_status);
				write_error_code_to_camera(flag_video_status);
				flag_updateShowCameraDate = 1;
			}
		}
	}

	if(flag_forbid_video == FALSE)
	{
		if(g_procedure_started == STOP)
		{
			enable_camera(CAMERA_FREEZE);
		}
		else
		{
			enable_camera(CAMERA_RUN);
		}

		if(flag_forbid_video_old == TRUE)
		{
			flag_forbid_video_old = FALSE;
			clear_layer1_all(current_framebuffer, TRUE);
			if(flag_use_2_framebuffers == TRUE)
				clear_layer1_all(next_framebuffer, TRUE);
			layer1_blit_corners(current_framebuffer);
			if(flag_use_2_framebuffers == TRUE)
				layer1_blit_corners(next_framebuffer);
			if(g_procedure_started == STOP)
			{
				RequestShowPicture2(2);
			}
		}
		xil_printf("\n\rcheck 4 : camera ok\n\r");
		/*
		xil_printf("\n\rTurn on camera LED h\n\r");
		ps_gpio_setup(&periphs_inst, GPIO_CAM_LED, 1);
		flag_camera_led_status = 1;
		psuart0_exposure(g_exposure);
		*/
	}
	else
	{
		xil_printf("\n\rcheck 4 : camera reuse, forbid video\n\r");
		xil_printf("\n\rTurn off camera LED\n\r");
		ps_gpio_setup(&periphs_inst, GPIO_CAM_LED, 0);
		flag_camera_led_status = 0;
	}

	read_serial_from_camera();
	show_camera_serial(1);
	if(flag_use_2_framebuffers == TRUE)
	{
		gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(next_framebuffer));
		show_camera_serial(1);
		gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(1 - next_framebuffer));
		show_camera_serial(1);
	}

	show_camera_date(1);
	if(flag_use_2_framebuffers == TRUE)
	{
		gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(next_framebuffer));
		show_camera_date(1);
		gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(1 - next_framebuffer));
		show_camera_date(1);
	}
	xil_printf("check_camera_reuse SP\r\n");
	check_use_time_seconds = 0;
	flag_show_print_time = FALSE;

	if(flag_forbid_video == TRUE)
	{
		xil_printf("\n\rTurn off camera LED r\n\r");
		ps_gpio_setup(&periphs_inst, GPIO_CAM_LED, 0);
		flag_camera_led_status = 0;
	}
	else
	{
#ifndef USE_AUTO_LIGHT
		xil_printf("\n\rTurn on camera LED r\n\r");
		ps_gpio_setup(&periphs_inst, GPIO_CAM_LED, 1);
		flag_camera_led_status = 1;
#else
		xil_printf("\n\rTurn off camera LED r2\n\r");
		ps_gpio_setup(&periphs_inst, GPIO_CAM_LED, 0);
		flag_camera_led_status = 0;
#endif
	}
	return flag_forbid_video;
#else
	return 0;
#endif
}

void check_camera_reuse_clear(void)
{
	show_camera_serial(0);
	show_camera_date(0);
	if(flag_use_2_framebuffers == TRUE)
	{
		gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(next_framebuffer));
		show_camera_serial(0);
		show_camera_date(0);
		gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(1 - next_framebuffer));
		show_camera_serial(0);
		show_camera_date(0);
	}
	return;
}

//#ifdef USE_IMS_LINK
u16 CalcCheckSum(u8 *pData, u16 len)
{
    u8 i = 0,sum = 0;
    for (; i < len; i++)
    {
        sum += (u8) pData[i];
    }
    sum = (sum^0xFF) + 1;
    return (sum&0xFF);
}

void Send_IMS_Data_Cmd(u8 cmd1, u8 cmd2, u8 cmd3)
{
	int i;
	u8 UartTxBuf[5];

	UartTxBuf[0] = 0xA1;
	UartTxBuf[1] = cmd1;
	UartTxBuf[2] = cmd2;
	UartTxBuf[3] = cmd3;
	UartTxBuf[4] = CalcCheckSum(UartTxBuf, 4);

	for(i=0;i<5;i++)
	{
		xil_printf("%c", UartTxBuf[i]);
	}

	/*	debug
	char str[40];
	sprintf(str, "send %02x %02x %02x %02x %02x\n\r", UartTxBuf[0], UartTxBuf[1], UartTxBuf[2], UartTxBuf[3], UartTxBuf[4]);
	debug_console_print(str);
	*/
}
//#endif

void check_awb_data(void)
{
	xil_printf("\n\rcheck_awb_data read awb page data page = 0x%x\n\r", AWB_PAGE0);
	ENABLE_CONFIGURE(1);
	SET_ADDRESS(AWB_PAGE0);
	READ_1PAGE();
	ENABLE_CONFIGURE(0);
	if((page_data[0] == 0x00) && (page_data[1] == 0x00) && (page_data[2] == 0x00) && (page_data[3] == 0x00))
	{
		xil_printf("no awb data\n\r");
		return;
	}
	else
	{
		unsigned int DongleAddr;
		unsigned char DongleData;

		int data_r = page_data[0]<<8 | page_data[1];
		int data_b = page_data[2]<<8 | page_data[3];
		xil_printf("\ncamera AWB data R : 0x%04x = %4d  B : 0x%04x = %4d ", data_r, data_r, data_b, data_b);

		DongleAddr = 0x521A;
		DongleData = page_data[0];
		dongle_write_data(DongleAddr, DongleData);
		DongleAddr = 0x521B;
		DongleData = page_data[1];
		dongle_write_data(DongleAddr, DongleData);
		DongleAddr = 0x521E;
		DongleData = page_data[2];
		dongle_write_data(DongleAddr, DongleData);
		DongleAddr = 0x521F;
		DongleData = page_data[3];
		dongle_write_data(DongleAddr, DongleData);

		xil_printf("apply awb data OK\n\r");
	}
}

void apply_camera_ufm_data(void)
{
	//XGpioPs *Gpio = periphs_inst.p_ps_gpio_inst;

	flag_use_user_brightness = FALSE;
	xil_printf("\n\rapply_camera_ufm_data ST\n\r");
	xil_printf("tick(%d) = %d;\t%%%s:%s(%d) UFM ST\r\n", tick_cnt++, g_ms_tick, __FILE__, __func__, __LINE__);
	int page = 0;
	for(page = AWB_PAGE1; page < (USER_PAGE1 + 10); page++)
	{
		xil_printf("\n\rread page data, page = 0x%2x = %d\n\r", page, page);
		ENABLE_CONFIGURE(1);
		SET_ADDRESS(page);
		READ_1PAGE();
		ENABLE_CONFIGURE(0);

		if((page_data[0] == 0x00) && (page_data[1] == 0x00) && (page_data[2] == 0x00) && (page_data[3] == 0x00))
		{
			xil_printf("page %d, no data\n\r", page);
		}
		else if(page == USER_PAGE2)
		{
			xil_printf("page %d, data exists\n\r", USER_PAGE2);

			if((page_data[1] == 0xAA) && (page_data[2] == 0xBB))
			{
				flag_use_user_brightness = TRUE;
				default_user_brightness = page_data[3];

				xil_printf("default_user_brightness = %d\n\r", default_user_brightness);
			}
			else
			{
				xil_printf("data wrong\n\r");
			}
		}
		else
		{
			xil_printf("data: %02x%02x%02x%02x %02x%02x%02x%02x %02x%02x%02x%02x %02x%02x%02x%02x\n\r",
					page_data[0], page_data[1], page_data[2], page_data[3],
					page_data[4], page_data[5], page_data[6], page_data[7],
					page_data[8], page_data[9], page_data[10], page_data[11],
					page_data[12], page_data[13], page_data[14], page_data[15]);
			if(page_data[0] != 0xDA)
			{
				xil_printf("no valid data, header is 0x%02x\n\r", page_data[0]);
			}
			int i;
			unsigned int DongleAddr;
			unsigned char DongleData;
			for(i = 0; i < 5; i++)
			{
				xil_printf("cmd : %02x %02x %02x\n\r", page_data[3 * i + 1], page_data[3 * i + 2], page_data[3 * i + 3]);
				if(page_data[3 * i + 1] == 0)
					xil_printf("no command\n\r");
				else if(page_data[3 * i + 1] == 0xFF)
				{
					xil_printf("special command\n\r");
					if(page_data[3 * i + 2] == 0x00)
					{
						//LED
						if(page_data[3 * i + 3] == 0x00)
						{
							xil_printf("\n\rTurn on camera LED -\n\r");
							ps_gpio_setup(&periphs_inst, GPIO_CAM_LED, 1);
							flag_camera_led_status = 1;
						}
						else if(page_data[3 * i + 3] == 0x01)
						{
							xil_printf("\n\rTurn off camera LED -\n\r");
							ps_gpio_setup(&periphs_inst, GPIO_CAM_LED, 0);
							flag_camera_led_status = 0;
						}
						else
						{
							//unknown
						}
					}
					else if(page_data[3 * i + 2] == 0x01)
					{
						//meter
						if((page_data[3 * i + 3] >= 0) && (page_data[3 * i + 3] <= 2))
						{
							g_metering_mode = page_data[3 * i + 3];
							setup_panel_metering_led(g_metering_mode);
						}
					}
					else if(page_data[3 * i + 2] == 0x02)
					{
						//exposure
						if((page_data[3 * i + 3] >= 1) && (page_data[3 * i + 3] <= 5))
						{
							//setupgpio
							g_exposure = page_data[3 * i + 3];

							xil_printf("setup exposure = %d\r\n", g_exposure);

							if((g_exposure < 1) || (g_exposure > 5))
							{
								xil_printf("illegal brightness setup = %d\r\n", g_exposure);
							}
							else
							{
								psuart0_exposure(g_exposure);
							}
						}
						else
						{
							//unknown
						}

					}


				}
				else
				{
					DongleAddr = page_data[3 * i + 1]<<8 | page_data[3 * i + 2];
					DongleData = page_data[3 * i + 3];

					xil_printf("write address 0x%04x data 0x%02x = %3d\n\r\n\r", DongleAddr, DongleData, DongleData);

					dongle_write_data(DongleAddr, DongleData);
				}
			}
		}

	}
	if(flag_use_user_brightness == TRUE)
	{
		xil_printf("tick(%d) = %d;\t%%%s:%s(%d) Apply Gamma data\r\n", tick_cnt++, g_ms_tick, __FILE__, __func__, __LINE__);
		apply_gamma_data();
	}
	xil_printf("tick(%d) = %d;\t%%%s:%s(%d) UFM SP\r\n", tick_cnt++, g_ms_tick, __FILE__, __func__, __LINE__);
}

u8 gamma_22[16] = {0x2C, 0x2F, 0x3A, 0x4E, 0x5F, 0x6C, 0x76, 0x7F, 0x87, 0x8F, 0x99, 0xA4, 0xB3, 0xC5, 0xD7, 0x21};
u8 gamma_23[16] = {0x2C, 0x31, 0x3E, 0x52, 0x63, 0x70, 0x7A, 0x83, 0x8B, 0x93, 0x9C, 0xA7, 0xB6, 0xC7, 0xD8, 0x1F};
u8 gamma_24[16] = {0x2C, 0x33, 0x41, 0x55, 0x67, 0x74, 0x7E, 0x87, 0x8F, 0x96, 0x9F, 0xAA, 0xB8, 0xC9, 0xDA, 0x1E};

void apply_gamma_data(void)
{
	xil_printf("\n\rapply_gamma_data ST\n\r");
	int i;
	unsigned int DongleAddr;
	unsigned char DongleData;

	DongleAddr = 0x5000;
	DongleData = 0xFD;
	dongle_write_data(DongleAddr, DongleData);

	DongleAddr = 0x5002;
	DongleData = 0x88;
	dongle_write_data(DongleAddr, DongleData);

	DongleAddr = 0x5300;
	DongleData = 0x03;
	dongle_write_data(DongleAddr, DongleData);

	for(i = 0; i < 16; i++)
	{
			DongleAddr = 0x5301 + i;
			DongleData = gamma_24[i];

			xil_printf("write address 0x%04x data 0x%02x = %3d\n\r\n\r", DongleAddr, DongleData, DongleData);

			dongle_write_data(DongleAddr, DongleData);
	}
	xil_printf("\n\rapply_gamma_data SP\n\r");
}

//#ifdef USE_COLOR_DEBUG
void clear_layer1_allt(int frame)
{
	uint32_t i;
	uint32_t x_st;
	uint32_t y_st;

	//destination canvas
	coord_t width = 512;
	coord_t height = 100;

	if((frame != FRAMEBUFFER0) && (frame != FRAMEBUFFER1))
	{
		xil_printf("clear_layer1_all fail, illegal frame = %d\n\r", frame);
		return;
	}

	void* addr_r;
	void* addr_g;
	void* addr_b;
	void* addr_gray;

	uint32_t *f_ptr1;
	uint32_t *f_ptr2;
	uint32_t *f_ptr3;
	uint32_t *f_ptr4;

	uint32_t addr0;
	uint32_t addr1;
	uint32_t addr2;

	addr1 = (uint32_t)gdispGetFrameBufferAddr(frame);

	int length;
	length = width;

	addr_r = gfxAlloc(length * 4);
	addr_g = gfxAlloc(length * 4);
	addr_b = gfxAlloc(length * 4);
	addr_gray = gfxAlloc(length * 4);

	f_ptr1 = addr_r;
	f_ptr2 = addr_g;
	f_ptr3 = addr_b;
	f_ptr4 = addr_gray;



	for(i = 0; i < length; i++)
	{
		f_ptr1[i] = 0xFF000000 + 0x00000001 * (int)(i % 256);	//Red
		f_ptr2[i] = 0xFF000000 + 0x00000100 * (int)(i % 256);	//Green
		f_ptr3[i] = 0xFF000000 + 0x00010000 * (int)(i % 256);	//Blue
		f_ptr4[i] = 0xFF000000 + 0x00010101 * (int)(i % 256);	//Gray
	}

	x_st = 50;
	y_st = 120 + 110 * 0;
	addr0 = (uint32_t)addr_r;
	for(i = 0; i < height; i++)
	{
		addr2 = (u32)(LAYER0_WIDTH * 4 * (y_st + i) + addr1 + 4 * x_st);
		dma_copy((u32) addr0, addr2, length);
	}
	y_st = 120 + 110 * 1;
	addr0 = (uint32_t)addr_g;
	for(i = 0; i < height; i++)
	{
		addr2 = (u32)(LAYER0_WIDTH * 4 * (y_st + i) + addr1 + 4 * x_st);
		dma_copy((u32) addr0, addr2, length);
	}

	y_st = 120 + 110 * 2;

	addr0 = (uint32_t)addr_b;


	for(i = 0; i < height; i++)
	{
		addr2 = (u32)(LAYER0_WIDTH * 4 * (y_st + i) + addr1 + 4 * x_st);
		dma_copy((u32) addr0, addr2, length);
	}
	y_st = 120 + 110 * 3;

	addr0 = (uint32_t)addr_gray;
	for(i = 0; i < height; i++)
	{
		addr2 = (u32)(LAYER0_WIDTH * 4 * (y_st + i) + addr1 + 4 * x_st);
		dma_copy((u32) addr0, addr2, length);
	}

}

void clear_layer1_allt2(int frame)
{
	uint32_t i;
	uint32_t x_st;
	uint32_t y_st;

	//destination canvas
	coord_t width = 512;
	coord_t height = 100;

	if((frame != FRAMEBUFFER0) && (frame != FRAMEBUFFER1))
	{
		xil_printf("clear_layer1_all fail, illegal frame = %d\n\r", frame);
		return;
	}

	void* addr_r;
	void* addr_g;
	void* addr_b;
	void* addr_gray;

	uint32_t *f_ptr1;
	uint32_t *f_ptr2;
	uint32_t *f_ptr3;
	uint32_t *f_ptr4;

	uint32_t addr0;
	uint32_t addr1;
	uint32_t addr2;

	addr1 = (uint32_t)gdispGetFrameBufferAddr(frame);

	int length;
	length = width;

	addr_r = gfxAlloc(length * 4);
	addr_g = gfxAlloc(length * 4);
	addr_b = gfxAlloc(length * 4);
	addr_gray = gfxAlloc(length * 4);

	f_ptr1 = addr_r;
	f_ptr2 = addr_g;
	f_ptr3 = addr_b;
	f_ptr4 = addr_gray;

	for(i = 0; i < length; i++)
	{
		f_ptr1[i] = 0xFF000000 + 0x00000001 * (int)((i/16)*16 % 256);	//Red
		f_ptr2[i] = 0xFF000000 + 0x00000100 * (int)((i/16)*16 % 256);	//Green
		f_ptr3[i] = 0xFF000000 + 0x00010000 * (int)((i/16)*16 % 256);	//Blue
		f_ptr4[i] = 0xFF000000 + 0x00010101 * (int)((i/16)*16 % 256);	//Gray
	}

	x_st = 50;
	y_st = 120 + 110 * 0;
	y_st += 500;
	addr0 = (uint32_t)addr_r;
	for(i = 0; i < height; i++)
	{
		addr2 = (u32)(LAYER0_WIDTH * 4 * (y_st + i) + addr1 + 4 * x_st);
		dma_copy((u32) addr0, addr2, length);
	}
	y_st = 120 + 110 * 1;
	y_st += 500;
	addr0 = (uint32_t)addr_g;
	for(i = 0; i < height; i++)
	{
		addr2 = (u32)(LAYER0_WIDTH * 4 * (y_st + i) + addr1 + 4 * x_st);
		dma_copy((u32) addr0, addr2, length);
	}

	y_st = 120 + 110 * 2;
	y_st += 500;

	addr0 = (uint32_t)addr_b;


	for(i = 0; i < height; i++)
	{
		addr2 = (u32)(LAYER0_WIDTH * 4 * (y_st + i) + addr1 + 4 * x_st);
		dma_copy((u32) addr0, addr2, length);
	}
	y_st = 120 + 110 * 3;
	y_st += 500;

	addr0 = (uint32_t)addr_gray;
	for(i = 0; i < height; i++)
	{
		addr2 = (u32)(LAYER0_WIDTH * 4 * (y_st + i) + addr1 + 4 * x_st);
		dma_copy((u32) addr0, addr2, length);
	}

	length = LAYER1_WIDTH;
	int ww = length / 8;

	void* addr_color;
	uint32_t *f_ptr_color;
	addr_color = gfxAlloc(length * 4);
	f_ptr_color = addr_color;

	for(i = 0; i < length; i++)
	{
		if((i/ww) == 0)
			f_ptr_color[i] = 0xFFFFFFFF;	//ABGR
		else if((i/ww) == 1)
			f_ptr_color[i] = 0xFF00FFFF;
		else if((i/ww) == 2)
			f_ptr_color[i] = 0xFFFFFF00;
		else if((i/ww) == 3)
			f_ptr_color[i] = 0xFF00FF00;
		else if((i/ww) == 4)
			f_ptr_color[i] = 0xFFFF00FF;
		else if((i/ww) == 5)
			f_ptr_color[i] = 0xFF0000FF;
		else if((i/ww) == 6)
			f_ptr_color[i] = 0xFFFF0000;
		else if((i/ww) == 7)
			f_ptr_color[i] = 0xFF000000;
		else
			f_ptr_color[i] = 0xFF00FF00;
	}

	x_st = LAYER1_START_X;
	y_st = 120 + 110 * 1;
	y_st += 200;

	addr0 = (uint32_t)addr_color;
	for(i = 0; i < height; i++)
	{
		addr2 = (u32)(LAYER0_WIDTH * 4 * (y_st + i) + addr1 + 4 * x_st);
		dma_copy((u32) addr0, addr2, length);
	}

	int hh = 50;
	int tmp = 0;

	length = 16 * 17 * 4;

	void* addr_color3;
	uint32_t *f_ptr_color3;
	addr_color3 = gfxAlloc(length * 4);
	f_ptr_color3 = addr_color3;

	x_st = LAYER1_START_X;
	height = hh - 2;

	y_st = 120 + 110 * 2 + hh * 0;
	y_st += 200;
	for(i = 0; i < length; i++)
	{
		tmp = (((i/4)/8)*8+0)%257;
		if (tmp == 256)
			tmp = 255;
		if (tmp == 7)
			tmp = 128;

		f_ptr_color3[i] = 0xFF000000 + 0x00000001 * tmp;	//Red
	}
	addr0 = (uint32_t)addr_color3;
	for(i = 0; i < height; i++)
	{
		addr2 = (u32)(LAYER0_WIDTH * 4 * (y_st + i) + addr1 + 4 * x_st);
		dma_copy((u32) addr0, addr2, length);
	}

	xil_printf("\n\rG\n\r");
	y_st += 50;
	for(i = 0; i < length; i++)
	{
		tmp = (((i/4)/8)*8+0)%257;
		if (tmp == 256)
			tmp = 255;
		if (tmp == 7)
			tmp = 128;

		tmp = 255 - tmp;
		xil_printf("%3d ", tmp);

		f_ptr_color3[i] = 0xFF000000 + 0x00000100 * tmp;	//Green
	}
	addr0 = (uint32_t)addr_color3;
	for(i = 0; i < height; i++)
	{
		addr2 = (u32)(LAYER0_WIDTH * 4 * (y_st + i) + addr1 + 4 * x_st);
		dma_copy((u32) addr0, addr2, length);
	}
	xil_printf("\n\rB\n\r");

	y_st += 50;
	for(i = 0; i < length; i++)
	{
		tmp = (((i/4)/8)*8+0)%257;
		if (tmp == 256)
			tmp = 255;
		if (tmp == 7)
			tmp = 128;

		xil_printf("%3d ", tmp);

		f_ptr_color3[i] = 0xFF000000 + 0x00010000 * tmp;	//Blue
	}
	addr0 = (uint32_t)addr_color3;
	for(i = 0; i < height; i++)
	{
		addr2 = (u32)(LAYER0_WIDTH * 4 * (y_st + i) + addr1 + 4 * x_st);
		dma_copy((u32) addr0, addr2, length);
	}
	xil_printf("\n\r");


	y_st += 50;
	for(i = 0; i < length; i++)
	{
		tmp = (((i/4)/8)*8+0)%257;
		if (tmp == 256)
			tmp = 255;
		if (tmp == 7)
			tmp = 128;

		f_ptr_color3[i] = 0xFF000000 + 0x00010000 * tmp;	//Blue
	}
	addr0 = (uint32_t)addr_color3;
	for(i = 0; i < height; i++)
	{
		addr2 = (u32)(LAYER0_WIDTH * 4 * (y_st + i) + addr1 + 4 * x_st);
		dma_copy((u32) addr0, addr2, length);
	}


	xil_printf("\n\r");


	//-----------

	length = 16 * 17 * 4;

	void* addr_color2;
	uint32_t *f_ptr_color2;
	addr_color2 = gfxAlloc(length * 4);
	f_ptr_color2 = addr_color2;
	//int hh = 50;

	x_st = LAYER1_START_X;
	height = hh - 2;

	y_st = 120 + 110 * 2 + hh * 0;
	y_st += 500;
	for(i = 0; i < length; i++)
	{
		if(i >= (16*16*4))
			f_ptr_color2[i] = 0xFF000000 + 0x000000FF;	//Red
		else
			f_ptr_color2[i] = 0xFF000000 + (0x00000001 * (int)(((i/4)/16)*16 % 256) + 128)%256;	//Red
	}
	addr0 = (uint32_t)addr_color2;
	for(i = 0; i < height; i++)
	{
		addr2 = (u32)(LAYER0_WIDTH * 4 * (y_st + i) + addr1 + 4 * x_st);
		dma_copy((u32) addr0, addr2, length);
	}

	y_st = 120 + 110 * 2 + hh * 1;
	y_st += 500;
	for(i = 0; i < length; i++)
	{
		if(i >= (16*16*4))
			f_ptr_color2[i] = 0xFF000000 + 0x0000FF00;	//Green
		else
			f_ptr_color2[i] = 0xFF000000 + 0x00000100 * (int)(((i/4)/16)*16 % 256);	//Green
	}
	addr0 = (uint32_t)addr_color2;
	for(i = 0; i < height; i++)
	{
		addr2 = (u32)(LAYER0_WIDTH * 4 * (y_st + i) + addr1 + 4 * x_st);
		dma_copy((u32) addr0, addr2, length);
	}
	y_st = 120 + 110 * 2 + hh * 2;
	y_st += 500;
	for(i = 0; i < length; i++)
	{
		if(i >= (16*16*4))
			f_ptr_color2[i] = 0xFF000000 + 0x00FF0000;	//Blue
		else
			f_ptr_color2[i] = 0xFF000000 + 0x00010000 * (int)(((i/4)/16)*16 % 256);	//Blue
	}
	addr0 = (uint32_t)addr_color2;
	for(i = 0; i < height; i++)
	{
		addr2 = (u32)(LAYER0_WIDTH * 4 * (y_st + i) + addr1 + 4 * x_st);
		dma_copy((u32) addr0, addr2, length);
	}
	y_st = 120 + 110 * 2 + hh * 3;
	y_st += 500;
	for(i = 0; i < length; i++)
	{
		if(i >= (16*16*4))
			f_ptr_color2[i] = 0xFF000000 + 0x00FFFFFF;	//White
		else
			f_ptr_color2[i] = 0xFF000000 + 0x00010101 * (int)(((i/4)/16)*16 % 256);	//Gray
	}
	addr0 = (uint32_t)addr_color2;
	for(i = 0; i < height; i++)
	{
		addr2 = (u32)(LAYER0_WIDTH * 4 * (y_st + i) + addr1 + 4 * x_st);
		dma_copy((u32) addr0, addr2, length);
	}

}

void draw_color0(void)
{
	coord_t width = 512;
	coord_t height = 100;

	int i;
	int x_st;
	int y_st;

	x_st = 50;
	y_st = 120;
	gdispFillArea(x_st + width + 20, y_st + 110 * 0, 50, 100, Red);
	gdispFillArea(x_st + width + 20, y_st + 110 * 1, 50, 100, Lime);
	gdispFillArea(x_st + width + 20, y_st + 110 * 2, 50, 100, Blue);
	gdispFillArea(x_st + width + 20, y_st + 110 * 3, 50, 100, White);

	for(i = 0; i < 5; i++)
	{
		gdispDrawBox(x_st - 10 + i, y_st - 10 + i, width + 20 - i * 2, height * 4 + 50 - i * 2, White);
	}


	x_st = 50;
	y_st = 620;
	gdispFillArea(x_st + width + 20, y_st + 110 * 0, 50, 100, Red);
	gdispFillArea(x_st + width + 20, y_st + 110 * 1, 50, 100, Lime);
	gdispFillArea(x_st + width + 20, y_st + 110 * 2, 50, 100, Blue);
	gdispFillArea(x_st + width + 20, y_st + 110 * 3, 50, 100, White);

	for(i = 0; i < 5; i++)
	{
		gdispDrawBox(x_st - 10 + i, y_st - 10 + i, width + 20 - i * 2, height * 4 + 50 - i * 2, White);
	}

	x_st = 0;
	y_st = 0;
	for(i = 0; i < 10; i += 2)
	{
		y_st = 0;
		gdispDrawLine(x_st + i, y_st, x_st + i, y_st + 1000, Red);

		y_st = 1001;
		gdispDrawLine(x_st + i, y_st, x_st + i, y_st + 78, Green);


		y_st = 1079;
		gdispDrawLine(x_st + i, y_st, x_st + i, y_st + 0, Blue);
	}


	x_st = LAYER1_START_X;
	y_st = 690;

	xil_printf("x_st = %d,  y_st = %d\n\r", x_st, y_st);

	gdispDrawLine(x_st, y_st, x_st + length , y_st, Red);

	gdispDrawLine(x_st, y_st+50, x_st + length , y_st+50, Red);

	for(i = 0; i <= 32; i++)
	{
		gdispDrawLine(x_st + 32*i, y_st, x_st + 32*i, y_st + 50, Red);



	}


}

void draw_color()
{
	clear_layer1_allt(current_framebuffer);
	if(flag_use_2_framebuffers == TRUE)
		clear_layer1_allt(next_framebuffer);

	clear_layer1_allt2(current_framebuffer);
	if(flag_use_2_framebuffers == TRUE)
		clear_layer1_allt2(next_framebuffer);

	gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(next_framebuffer));
	draw_color0();
	gdispSetuGFXFrameBufferAddr(gdispGetFrameBufferAddr(1 - next_framebuffer));
	draw_color0();
	return;
}
//#endif

void show_environment_parameters(void)
{
	int ratio1;
	int ratio2;
	xil_printf("\n\rXPAR_CPU_CORTEXA9_CORE_CLOCK_FREQ_HZ = %d\n\r", XPAR_CPU_CORTEXA9_CORE_CLOCK_FREQ_HZ);
	xil_printf("COUNTS_PER_SECOND = %d\n\r", COUNTS_PER_SECOND);
	ratio1 = XPAR_CPU_CORTEXA9_CORE_CLOCK_FREQ_HZ / COUNTS_PER_SECOND;

	ratio2 = (XPAR_CPU_CORTEXA9_CORE_CLOCK_FREQ_HZ % COUNTS_PER_SECOND)/(COUNTS_PER_SECOND/100000000);

	xil_printf("ratio = %d.%08d\n\r", ratio1, ratio2);


}


typedef unsigned int	UINT;
typedef unsigned char	BYTE;
typedef unsigned short	WORD;
typedef unsigned long	DWORD;
typedef unsigned long long QWORD;
#define FF_MAX_SS		512

/* Type of file size variables */

#if FF_FS_EXFAT
typedef QWORD FSIZE_t;
#else
typedef DWORD FSIZE_t;
#endif





static FIL fil;		/* File object */
//static FATFS fatfs;


static char buffera[32];
static char *boot_file = buffera;
u32 FlashReadBaseAddress = 0;


#define	FA_READ				0x01
/* File function return code (FRESULT) */

/******************************************************************************/
/**
*
* This function copies a string to another, the source string must be null-
* terminated.
*
* @param 	Dest is starting address for the destination string
* @param 	Src is starting address for the source string
*
* @return	Starting address for the destination string
*
****************************************************************************/
char *strcpy_rom(char *Dest, const char *Src)
{
	unsigned i;
	for (i=0; Src[i] != '\0'; ++i)
		Dest[i] = Src[i];
	Dest[i] = '\0';
	return Dest;
}



u32 InitSD(const char *filename)
{
	xil_printf("david0919: %s:%s(%d) ST\r\n",__FILE__,__func__,__LINE__);
	FRESULT rc = 0;
	//TCHAR *path = "0:/"; /* Logical drive number is 0 */
	//char *path = "0:/"; /* Logical drive number is 0 */

	/* Register volume work area, initialize device */
	//rc = f_mount(&fatfs, path, 0);
	//rc = f_mount(&fatfs, path);
	xil_printf("SD: rc= %.8x\n\r", rc);

	xil_printf("david0919: %s:%s(%d) SD: rc= %.8x\r\n",__FILE__,__func__,__LINE__, rc);

	if (rc != FR_OK) {
		return XST_FAILURE;
	}

	strcpy_rom(buffera, filename);
	boot_file = (char *)buffera;
	FlashReadBaseAddress = XPAR_PS7_SD_0_BASEADDR;


	xil_printf("\n\r");
	int i;
	for(i = 0;i<32;i++)
	{
		xil_printf("%2X ", buffera[i]);
		if((i%8)==7)
			xil_printf("\n\r");
	}
	xil_printf("\n\r");

	xil_printf("\n\r");
	for(i = 0;i<32;i++)
	{
		xil_printf("%2C ", buffera[i]);
		if((i%8)==7)
			xil_printf("\n\r");
	}
	xil_printf("\n\r");

	rc = f_open(&fil, boot_file, FA_READ);
	if (rc) {
		xil_printf("SD: Unable to open file %s: %d\n", boot_file, rc);
		return XST_FAILURE;
	}
	xil_printf("david0919: %s:%s(%d) SP\r\n",__FILE__,__func__,__LINE__);
	return XST_SUCCESS;

}


/******************************************************************************/
/**
*
* This function provides the SD FLASH interface for the Simplified header
* functionality.
*
* @param	SourceAddress is address in FLASH data space
* @param	DestinationAddress is address in OCM data space
* @param	LengthBytes is the number of bytes to move
*
* @return
*		- XST_SUCCESS if the write completes correctly
*		- XST_FAILURE if the write fails to completes correctly
*
* @note		None.
*
****************************************************************************/
u32 SDAccess( u32 SourceAddress, u32 DestinationAddress, u32 LengthBytes)
{

	FRESULT rc;	 /* Result code */
	UINT br;

	rc = f_lseek(&fil, SourceAddress);
	if (rc) {
		xil_printf("SD: Unable to seek to %lx\n\r", SourceAddress);
		return XST_FAILURE;
	}

	rc = f_read(&fil, (void*)DestinationAddress, LengthBytes, &br);

	if (rc) {
		xil_printf("*** ERROR: f_read returned %d\r\n", rc);
	}

	return XST_SUCCESS;

} /* End of SDAccess */


/******************************************************************************/
/**
*
* This function closes the file object
*
* @param	None
*
* @return	None.
*
* @note		None.
*
****************************************************************************/
void ReleaseSD(void) {

	f_close(&fil);
	return;


}


u32 loadFileFromSD(char filename[], u32 *dst)
{
    FIL fil;        /* File object */
    //FATFS fatfs;
    char buffer[32];
    char *boot_file = buffer;

    // Copy from InitSD
    FRESULT rc = 0;
    //char *path = "0:/"; /* Logical drive number is 0 */

    /* Register volume work area, initialize device */
    //rc = f_mount(&fatfs, path, 0);
    //rc = f_mount(&fatfs, path);
    xil_printf("SD: rc= %.8x\n\r", rc);

    if (rc != FR_OK) {
        return XST_FAILURE;
    }

    strcpy_rom(buffer, filename);
    boot_file = (char *)buffer;

    rc = f_open(&fil, boot_file, FA_READ);
    if (rc) {
        xil_printf("SD: Unable to open file %s: %d\n", boot_file, rc);
        return XST_FAILURE;
    }

    xil_printf("clust = %d\n\r", fil.clust);
    //xil_printf("sect = %d\n\r", fil.sect);
    xil_printf("dir_sect = %d\n\r", fil.dir_sect);
    xil_printf("dir_ptr = %d\n\r", fil.dir_ptr);

    //xil_printf("sclust = %d\n\r", fil.obj.sclust);
    //xil_printf("objsize = %d\n\r", fil.obj.objsize);


    // Copy from SDAccess
    UINT br;

    rc = f_lseek(&fil, 0);
    if (rc) {
        xil_printf("SD: Unable to seek to %x\n", 0);
        return XST_FAILURE;
    }

    xil_printf("\n\r");
    int j;
    for(j = 0;j<4;j++)
    {
		rc = f_read(&fil, (void*)dst, 32, &br);

		//xil_printf("j = %d\n\r", j);
		int i;
		for(i = 0;i<8;i++)
		{
			xil_printf("%2X %2X %2X %2X ", (dst[i]>>0)&0xFF, (dst[i]>>8)&0xFF, (dst[i]>>16)&0xFF, (dst[i]>>24)&0xFF);
			if((i%4)==3)
				xil_printf("\n\r");
		}
		/*
		xil_printf("\n\r");

		for(i = 0;i<8;i++)
		{
			xil_printf("%2C %2C %2C %2C ", (dst[i]>>0)&0xFF, (dst[i]>>8)&0xFF, (dst[i]>>16)&0xFF, (dst[i]>>24)&0xFF);
			if((i%4)==3)
				xil_printf("\n\r");
		}
		xil_printf("\n\r");
		*/
    }
    xil_printf("\n\r");

    if (rc) {
        xil_printf("*** ERROR: f_read returned %d\r\n", rc);
        return XST_FAILURE;
    }

    //Xil_DCacheInvalidateRange(dst, fil.fsize);

    rc = f_close(&fil);
    if(rc)
    {
    	xil_printf(" ERROR : f_close returned %d\r\n", rc);
    	return XST_FAILURE;
    }
    return XST_SUCCESS;
}

int SD_Init(void)
{
	FRESULT rc = 0;
	//rc = f_mount(&fatfs,"",0);
	//rc = f_mount(&fatfs,"");
	if(rc)
	{
		xil_printf("ERROR : f_mount returned %d\r\n",rc);
		return XST_FAILURE;
	}
	return XST_SUCCESS;
}

int SD_Transfer_write(char *FileName,u32 SourceAddress,u32 ByteLength)
{
	FIL fil;
	FRESULT rc;
	UINT bw;
	rc = f_open(&fil,FileName,FA_CREATE_ALWAYS | FA_WRITE);
	if(rc)
	{
		xil_printf("ERROR : f_open returned %d\r\n",rc);
		return XST_FAILURE;
	}
	rc = f_lseek(&fil, 0);
	if(rc)
	{
		xil_printf("ERROR : f_lseek returned %d\r\n",rc);
		return XST_FAILURE;
	}
	rc = f_write(&fil,(void*) SourceAddress,ByteLength,&bw);
	if(rc)
	{
		xil_printf("ERROR : f_write returned %d\r\n", rc);
		return XST_FAILURE;
	}
	rc = f_close(&fil);
	if(rc)
	{
		xil_printf("ERROR : f_close returned %d\r\n",rc);
		return XST_FAILURE;
	}
	return XST_SUCCESS;
}

void yuv2rgb(u8 Y, u8 U, u8 V)
{
	u8 R;
	u8 G;
	u8 B;
	float R2;
	float G2;
	float B2;

    R2 = (float)Y + 1.4075 * ((float)V - 128);
    G2 = (float)Y - 0.3455 * ((float)U - 128) - (0.7169 * ((float)V - 128));
    B2 = (float)Y + 1.7790 * ((float)U - 128);

    if(R2>255)
    	R = 255;
    else if(R2 < 0)
    	R = 0;
    else
    	R = (u8)R2;

    if(G2>255)
    	G = 255;
    else if(G2 < 0)
    	G = 0;
    else
    	G = (u8)G2;

    if(B2>255)
    	B = 255;
    else if(B2 < 0)
    	B = 0;
    else
    	B = (u8)B2;

    xil_printf("%02x%02x%02x => %02x%02x%02x = %3d %3d %3d\n\r", Y, U, V, R, G, B, R, G, B);

}

void Save_Image_To_SD()
{
	int i;
	u32 reg;
	u32 value = 0;
	int Y1;
	int Y2;
	int U;
	int V;
	//int A = 0xAA;
	u8 R1;
	u8 G1;
	u8 B1;
	u8 R2;
	u8 G2;
	u8 B2;
	float RR;
	float GG;
	float BB;
	int j;
	int k;
	int ww = 640;
	int hh = 480;
	int stride = 2048;
	//u8 src_str_r[64 * 4];
	u8 src_str[64 * 4];
	//FIL fil_raw;
	FIL fil_bmp;
	FRESULT rc;
	UINT bw;
    //char filename_raw[40];
    char filename_bmp[40];
    int h_res = 0x0EC4;
    int v_res = 0x0EC4;
    int size = ww * hh * 4 + 0x36;
    u8 header[0x36];

    SD_Init();

	//reg = 0x32500000;
	reg = (&periphs_inst)->fb_camera_freeze_start_addr;		//0x32500000;
	//xil_printf("reg = 0x%08x\n\r", reg);

	sprintf(filename_bmp, "IMG%02d%02d.bmp", rtc.tm_min, rtc.tm_sec);
	//xil_printf("reg = 0x%08x\n\r", reg);

	/*
	sprintf(filename_raw, "RAW%02d%02d.bin", rtc.tm_min, rtc.tm_sec);
    xil_printf("filename_raw : %s\n\r", filename_raw);
	rc = f_open(&fil_raw, filename_raw, FA_CREATE_ALWAYS | FA_WRITE);
	if(rc)
	{
		xil_printf("ERROR : f_open returned %d\r\n",rc);
		return;
	}
	rc = f_lseek(&fil_raw, 0);
	if(rc)
	{
		xil_printf("ERROR : f_lseek returned %d\r\n",rc);
		return;
	}
	*/

	//sprintf(filename_bmp, "IMG%02d%02da.bmp", rtc.tm_min, rtc.tm_sec);
    xil_printf("filename_bmp : %s\n\r", filename_bmp);
	rc = f_open(&fil_bmp, filename_bmp, FA_CREATE_ALWAYS | FA_WRITE);
	if(rc)
	{
		xil_printf("ERROR : f_open returned %d\r\n",rc);
		return;
	}
	rc = f_lseek(&fil_bmp, 0);
	if(rc)
	{
		xil_printf("ERROR : f_lseek returned %d\r\n",rc);
		return;
	}

    for (i = 0; i < 0x36; i++)
    {
        header[i] = 0;
    }

    header[0] = 'B';
    header[1] = 'M';
    header[2] = (size % 256);
    header[3] = ((size / 256) % 256);
    header[4] = ((size / 256 / 256) % 256);
    header[5] = ((size / 256 / 256) % 256);
    header[10] = 0x36;
    header[14] = 0x28;

    header[18] = (ww % 256);
    header[19] = ((ww / 256) % 256);
    header[20] = ((ww / 256 / 256) % 256);
    header[21] = ((ww / 256 / 256) % 256);

    header[22] = (hh % 256);
    header[23] = ((hh / 256) % 256);
    header[24] = ((hh / 256 / 256) % 256);
    header[25] = ((hh / 256 / 256) % 256);

    header[26] = 0x01;
    header[28] = 0x20;

    header[38] = (h_res % 256);
    header[39] = ((h_res / 256) % 256);
    header[40] = ((h_res / 256 / 256) % 256);
    header[41] = ((h_res / 256 / 256) % 256);

    header[42] = (v_res % 256);
    header[43] = ((v_res / 256) % 256);
    header[44] = ((v_res / 256 / 256) % 256);
    header[45] = ((v_res / 256 / 256) % 256);

    rc = f_write(&fil_bmp,(void*) header, 0x36,&bw);

    for(k = (hh - 1); k >= 0; k--)
	{
		for(j = 0; j < 10; j++)
		{
			for(i = 0; i < 32; i++)
			{
				value = Xil_In32(reg + k * stride + j * 32 * 4 + i * 4);

	            Y2 = (value >> 16) & 0xff;
	            V = (value >> 24) & 0xff;
	            U = (value >> 8) & 0xff;
	            Y1 = value & 0xff;

	            /*
	            src_str_r[i * 8 + 0] = Y1;
	            src_str_r[i * 8 + 1] = U;
	            src_str_r[i * 8 + 2] = V;
	            src_str_r[i * 8 + 3] = 0xA1;
	            src_str_r[i * 8 + 4] = Y2;
	            src_str_r[i * 8 + 5] = U;
	            src_str_r[i * 8 + 6] = V;
	            src_str_r[i * 8 + 7] = 0xA2;
	             */

	            RR = (float)Y1 + 1.4075 * ((float)V - 128);
	            GG = (float)Y1 - 0.3455 * ((float)U - 128) - (0.7169 * ((float)V - 128));
	            BB = (float)Y1 + 1.7790 * ((float)U - 128);

	            if(RR > 255)
	            	R1 = 255;
	            else if(RR < 0)
	            	R1 = 0;
	            else
	            	R1 = (u8)RR;

	            if(GG > 255)
	            	G1 = 255;
	            else if(GG < 0)
	            	G1 = 0;
	            else
	            	G1 = (u8)GG;

	            if(BB > 255)
	            	B1 = 255;
	            else if(BB < 0)
	            	B1 = 0;
	            else
	            	B1 = (u8)BB;

	            RR = (float)Y2 + 1.4075 * ((float)V - 128);
	            GG = (float)Y2 - 0.3455 * ((float)U - 128) - (0.7169 * ((float)V - 128));
	            BB = (float)Y2 + 1.7790 * ((float)U - 128);

	            if(RR > 255)
	            	R2 = 255;
	            else if(RR < 0)
	            	R2 = 0;
	            else
	            	R2 = (u8)RR;

	            if(GG > 255)
	            	G2 = 255;
	            else if(GG < 0)
	            	G2 = 0;
	            else
	            	G2 = (u8)GG;

	            if(BB > 255)
	            	B2 = 255;
	            else if(BB < 0)
	            	B2 = 0;
	            else
	            	B2 = (u8)BB;

	            src_str[i * 8 + 0] = B1;
	            src_str[i * 8 + 1] = G1;
	            src_str[i * 8 + 2] = R1;
	            src_str[i * 8 + 3] = 0xBB;
	            src_str[i * 8 + 4] = B2;
	            src_str[i * 8 + 5] = G2;
	            src_str[i * 8 + 6] = R2;
	            src_str[i * 8 + 7] = 0xBB;

			}

			/*
			rc = f_write(&fil_raw, (void*) src_str_r, 64 * 4, &bw);
			if(rc)
			{
				xil_printf("ERROR : f_write returned %d\r\n", rc);
				return;
			}
			*/

			rc = f_write(&fil_bmp, (void*) src_str, 64 * 4, &bw);
			if(rc)
			{
				xil_printf("ERROR : f_write returned %d\r\n", rc);
				return;
			}
		}
	}

    /*
	rc = f_close(&fil_raw);
	if(rc)
	{
		xil_printf("ERROR : f_close returned %d\r\n",rc);
		return;
	}
	*/

	rc = f_close(&fil_bmp);
	if(rc)
	{
		xil_printf("ERROR : f_close returned %d\r\n",rc);
		return;
	}





}

void draw_layer2_boundary(void)
{
	int i;
	int x_st = LAYER2_START_X;
	int y_st = LAYER2_START_Y;
	int w = LAYER2_WIDTH - 1;
	int h = LAYER2_HEIGHT;


	for(i = 0; i < 8; i ++)
	{
		//up
		gdispDrawLine(x_st, y_st + i, 		x_st + w, y_st + i, Black);
		//down
		gdispDrawLine(x_st, y_st + h - i,	x_st + w, y_st + h - i, Black);

	}

	for(i = 0; i < 6; i ++)
	{
		//left
		gdispDrawLine(x_st + i,		y_st, x_st + i,		y_st + h, Black);
		//right
		gdispDrawLine(x_st + w - i,	y_st, x_st + w - i,	y_st + h, Black);
	}


	for(i = 0; i < 11; i ++)
	{
		//upper-left
		gdispDrawLine(x_st + 90 + i, y_st, x_st + 0, y_st + 90 + i, Gray);

		//upper-right
		gdispDrawLine(x_st + w - 90 - i, y_st, x_st + w, y_st + 90 + i, Gray);

		//lower-left
		gdispDrawLine(x_st + i - i, y_st + h - 90 - i, x_st + 90 + i, y_st + h, Gray);

		//lower-right
		gdispDrawLine(x_st + w - i + i, y_st + h - 90 - i, x_st + w - 90 - i, y_st + h, Gray);
	}


}

void print_cs_data(unsigned int DongleAddr)
{
	unsigned char DongleData;
	DongleData = dongle_read_data(DongleAddr);
	if(DongleAddr == 0x4A00)
		xil_printf("0x%04x ----  ", DongleAddr);
	else
		xil_printf("0x%04x 0x%02x  ", DongleAddr, DongleData);
}


void gpio_test()
{

    //-------------------------------------------JACKY ADD---------------------------------------------
	   #define GPIO_CHANNEL1 1
	   #define GPIO_CHANNEL2 2
	   static XScuGic intc;
	   static XGpio video_path_camera_in_CDR_VIdeo_In_AXI4_rdy_CDR_Registers_axi_gpio_NFrameReady_Gpio;
	//-------------------------------------------------------------------------------------------------

	   {
	      u32 status;

	      print("\r\nRunning GpioOutputExample() for video_path_camera_in_CDR_VIdeo_In_AXI4_rdy_CDR_Registers_axi_gpio_SDK_NFrames...\r\n");

	      status = GpioOutputExample(XPAR_VIDEO_PATH_CAMERA_IN_CDR_VIDEO_IN_AXI4_RDY_CDR_REGISTERS_AXI_GPIO_SDK_NFRAMES_DEVICE_ID,8, 250);

	      if (status == 0) {
	         print("GpioOutputExample PASSED.\r\n");
	      }
	      else {
	         print("GpioOutputExample FAILED.\r\n");
	      }
	   }


	   {
	      u32 status;

	      print("\r\nRunning GpioInputExample() for video_path_camera_in_CDR_VIdeo_In_AXI4_rdy_CDR_Registers_axi_gpio_NFrameReady...\r\n");

	      u32 DataRead;

	      status = GpioInputExample(XPAR_VIDEO_PATH_CAMERA_IN_CDR_VIDEO_IN_AXI4_RDY_CDR_REGISTERS_AXI_GPIO_NFRAMESREADY_DEVICE_ID, &DataRead);

	      if (status == 0) {
	         xil_printf("GpioInputExample PASSED. Read data:0x%X\r\n", DataRead);
	      }
	      else {
	         print("GpioInputExample FAILED.\r\n");
	      }
	   }
	   {

	      int Status;

	      u32 DataRead;

	      print(" Press button to Generate Interrupt\r\n");

	      Status = GpioIntrExample(&intc, &video_path_camera_in_CDR_VIdeo_In_AXI4_rdy_CDR_Registers_axi_gpio_NFrameReady_Gpio, \
	                               XPAR_VIDEO_PATH_CAMERA_IN_CDR_VIDEO_IN_AXI4_RDY_CDR_REGISTERS_AXI_GPIO_NFRAMESREADY_DEVICE_ID, \
	                               XPAR_FABRIC_VIDEO_PATH_CAMERA_IN_CDR_VIDEO_IN_AXI4_RDY_CDR_REGISTERS_AXI_GPIO_NFRAMESREADY_IP2INTC_IRPT_INTR, \
	                               GPIO_CHANNEL1, &DataRead);

	      if (Status == 0 ){
	             if(DataRead == 0)
	                print("No button pressed. \r\n");
	             else
	                print("Gpio Interrupt Test PASSED. \r\n");
	      }
	      else {
	         print("Gpio Interrupt Test FAILED.\r\n");
	      }

	   }

	return;


}

void print_time_eng(unsigned long s)
{
	char str[60];

	if(s >= 86400)
	{
		//xil_printf("%ld Days, %ld Hours, %ld Minutes, %ld Seconds\n\r", s/86400, (s%86400)/3600, ((s%86400)%3600)/60, ((s%86400)%3600)%60);
		//xil_printf("%ldd%ldh%ldm%lds\n\r", s/86400, (s%86400)/3600, ((s%86400)%3600)/60, ((s%86400)%3600)%60);
		sprintf(str, "%ld day, %ld hr, %ld min, %ld sec", s/86400, (s%86400)/3600, ((s%86400)%3600)/60, ((s%86400)%3600)%60);
		//sprintf((char *)wi.text, "%ldd %ldh %ldm", s/86400, (s%86400)/3600, ((s%86400)%3600)/60);
	}
	else if(s >= 3600)
	{
		//xil_printf("%ld Hours, %ld Minutes, %ld Seconds\n\r", (s%86400)/3600, ((s%86400)%3600)/60, ((s%86400)%3600)%60);
		//xil_printf("%ldh%ldm%lds\n\r", (s%86400)/3600, ((s%86400)%3600)/60, ((s%86400)%3600)%60);
		sprintf(str, "%ld hr, %ld min, %ld sec", (s%86400)/3600, ((s%86400)%3600)/60, ((s%86400)%3600)%60);
		//sprintf((char *)wi.text, "%ldh %ldm", (s%86400)/3600, ((s%86400)%3600)/60);
	}
	else if(s >= 60)
	{
		//xil_printf("%ld Minutes, %ld Seconds\n\r", ((s%86400)%3600)/60, ((s%86400)%3600)%60);
		//xil_printf("%ldm%lds\n\r", ((s%86400)%3600)/60, ((s%86400)%3600)%60);
		sprintf(str, "%ld min, %ld sec", ((s%86400)%3600)/60, ((s%86400)%3600)%60);
		//sprintf((char *)wi.text, "%ld min  /  %d min", ((s%86400)%3600)/60);
	}
	else
	{
		//xil_printf("%ld Seconds\n\r", ((s%86400)%3600)%60);
		//xil_printf("%lds\n\r", ((s%86400)%3600)%60);
		sprintf(str, "%ld sec", ((s%86400)%3600)%60);
		//sprintf((char *)wi.text, "0 m");
	}
	/*
	if(s >= 86400)
		xil_printf("%d Days, ", s/86400);
	if(s >= 3600)
		xil_printf("%d Hours, ", (s%86400)/3600);
	if(s >= 60)
		xil_printf("%d Minutes, ", ((s%86400)%3600)/60);
	xil_printf("%d Seconds\n\r", ((s%86400)%3600)%60);
	*/

	font_t font = gdispOpenFont("iskpota232");
	gdispDrawString(COLUMN2 + 150, ROW11, str, font, Red);

	//xil_printf("^%lds ", s);
	return;
}

void print_time_s2hms(unsigned long s)
{
	if(s >= 86400)
	{
		xil_printf("%ld Days, %ld Hours, %ld Minutes, %ld Seconds\n\r", s/86400, (s%86400)/3600, ((s%86400)%3600)/60, ((s%86400)%3600)%60);
		//xil_printf("%ldd%ldh%ldm%lds\n\r", s/86400, (s%86400)/3600, ((s%86400)%3600)/60, ((s%86400)%3600)%60);
	}
	else if(s >= 3600)
	{
		xil_printf("%ld Hours, %ld Minutes, %ld Seconds\n\r", (s%86400)/3600, ((s%86400)%3600)/60, ((s%86400)%3600)%60);
		//xil_printf("%ldh%ldm%lds\n\r", (s%86400)/3600, ((s%86400)%3600)/60, ((s%86400)%3600)%60);
	}
	else if(s >= 60)
	{
		xil_printf("%ld Minutes, %ld Seconds\n\r", ((s%86400)%3600)/60, ((s%86400)%3600)%60);
		//xil_printf("%ldm%lds\n\r", ((s%86400)%3600)/60, ((s%86400)%3600)%60);
	}
	else
	{
		xil_printf("%ld Seconds\n\r", ((s%86400)%3600)%60);
		//xil_printf("%lds\n\r", ((s%86400)%3600)%60);
	}
	//xil_printf("^%lds ", s);
	return;
}

//void show_engineering_mode0(void);
void clear_engineering_mode0(void)
{
	// Clear Message
	RequestShowPicture2(-1);


	//TBD



	return;

	//int x,y;
	coord_t width;
	coord_t height;
	// Get the screen size
	width = gdispGetWidth();
	height = gdispGetHeight();

	for (coord_t x = 0; x < width; x += 100)
	{
		for (coord_t y = 0; y < height; y += 100)
		{
			//gdispDrawPixel(x, y, Gray);
		}
	}

	gdispDrawBox(300, 100, width - 100 * 2 - 200, height - 100 * 2, Yellow);
	gdispDrawLine(COLUMN2 - 20, 100, COLUMN2 - 20, height - 100, Yellow);
	gdispDrawLine(COLUMN3 - 20, 100, COLUMN3 - 20, height - 100, Yellow);
	gdispDrawLine(COLUMN4 - 20, 100, COLUMN4 - 20, height - 100, Yellow);
	gdispDrawLine(300, ROW1 - 20, width - 100 - 1, ROW1 - 20, Yellow);
	gdispDrawLine(COLUMN4 - 20, ROW4 - 20, width - 100 - 1, ROW4 - 20, Yellow);
	gdispDrawLine(COLUMN4 - 20, ROW5 - 20, width - 100 - 1, ROW5 - 20, Yellow);

	/*
	for (coord_t x = 100; x < (height - 100); x += 100)
	{
		gdispDrawLine(100, x, width - 100, x, Yellow);
	}
	for (coord_t x = 100; x < (width - 100); x += 100)
	{
		gdispDrawLine(x, 100, x, height - 100, Yellow);
	}
	*/

	font_t font = gdispOpenFont("iskpota232");
	gdispFillString(300, 50, "Engineering Mode", font, White, Magenta);

	//font = gdispOpenFont("DejaVu*");
	gdispFillString(COLUMN1, ROW0, "Time", font, White, Olive);
	gdispFillString(COLUMN2, ROW0, "Info", font, White, Olive);
	gdispFillString(COLUMN3, ROW0, "Camera", font, White, Olive);
	gdispFillString(COLUMN4, ROW0, "Language", font, White, Olive);
	gdispFillString(COLUMN4, ROW4, "Misc", font, White, Olive);


	xil_printf("year : %d\n\r", rtc.tm_year);
	xil_printf("month : %d\n\r", rtc.tm_mon);
	xil_printf("mday : %d\n\r", rtc.tm_mday);
	xil_printf("wday : %d\n\r", rtc.tm_wday);
	xil_printf("hour : %d\n\r", rtc.tm_hour);
	xil_printf("minute : %d\n\r", rtc.tm_min);
	xil_printf("second : %d\n\r", rtc.tm_sec);

    char str[40];
    sprintf(str, "%d", rtc.tm_year + 2000);
	gdispDrawString(COLUMN1, ROW1, "Year :", font, Red);
	gdispDrawString(COLUMN1 + 120, ROW1, str, font, Red);

    sprintf(str, "%d", rtc.tm_mon + 1);
	gdispDrawString(COLUMN1, ROW2, "Month :", font, Red);
	gdispDrawString(COLUMN1 + 120, ROW2, str, font, Red);

    sprintf(str, "%d", rtc.tm_mday);
	gdispDrawString(COLUMN1, ROW3, "Day :", font, Red);
	gdispDrawString(COLUMN1 + 120, ROW3, str, font, Red);

	switch(rtc.tm_wday)
	{
	case 0:		sprintf(str, "%s", "Sun");	break;
	case 1:		sprintf(str, "%s", "Mon");	break;
	case 2:		sprintf(str, "%s", "Tue");	break;
	case 3:		sprintf(str, "%s", "Wed");	break;
	case 4:		sprintf(str, "%s", "Thu");	break;
	case 5:		sprintf(str, "%s", "Fri");	break;
	case 6:		sprintf(str, "%s", "Sat");	break;
	case 7:		sprintf(str, "%s", "Sun");	break;
	default:	sprintf(str, "%s", "Mon");	break;
	}
	gdispDrawString(COLUMN1 + 120, ROW4, str, font, Red);

	sprintf(str, "%d", rtc.tm_hour);
	gdispDrawString(COLUMN1, ROW5, "Hour :", font, Red);
	gdispDrawString(COLUMN1 + 120, ROW5, str, font, Red);
    sprintf(str, "%d", rtc.tm_min);
	gdispDrawString(COLUMN1, ROW6, "Minute :", font, Red);
	gdispDrawString(COLUMN1 + 120, ROW6, str, font, Red);
    sprintf(str, "%d", rtc.tm_sec);
	gdispDrawString(COLUMN1, ROW7, "Second :", font, Red);
	gdispDrawString(COLUMN1 + 120, ROW7, str, font, Red);

	const char * const txt1 = __DATE__;
	const char * const txt2 = __TIME__;

	xil_printf("\n\rread_model_from_main_board\n\r");

	int state;
	state = XIicPs_ReadEepromData(29, 0, 50, RecvBuffer);
	if(state == XST_FAILURE)
	{
		xil_printf("xxxxxxx I2C fail, try again\n\r");
		usleep(1000);
		state = XIicPs_ReadEepromData(29, 0, 50, RecvBuffer);
	}

	/*
	int i;
	xil_printf("data: \t0x");
	for (i = 0; i < 50; i++) {
		xil_printf("%02x ", RecvBuffer[i]);
	}
	xil_printf("\n\r");
	 */

	sprintf(str, "MB : %C%C%C%C%C%C%C%C%C%C%C%C%C", RecvBuffer[0], RecvBuffer[1], RecvBuffer[2], RecvBuffer[3], RecvBuffer[4], RecvBuffer[5], RecvBuffer[6], RecvBuffer[7], RecvBuffer[8], RecvBuffer[9], RecvBuffer[10], RecvBuffer[11], RecvBuffer[12]);
	gdispDrawString(COLUMN2, ROW2, str, font, Red);

	sprintf(str, "SN1 : %C%C%C%C%C%C%C%C%C%C%C%C%C", RecvBuffer[13], RecvBuffer[14], RecvBuffer[15], RecvBuffer[16], RecvBuffer[17], RecvBuffer[18], RecvBuffer[19], RecvBuffer[20], RecvBuffer[21], RecvBuffer[22], RecvBuffer[23], RecvBuffer[24], RecvBuffer[25]);
	gdispDrawString(COLUMN2, ROW3, str, font, Red);

	sprintf(str, "SN2 : %C%C%C%C%C%C%C%C%C%C%C%C%C%C%C%C%C%C%C%C%C%C%C%C", RecvBuffer[26], RecvBuffer[27], RecvBuffer[28], RecvBuffer[29], RecvBuffer[30], RecvBuffer[31], RecvBuffer[32], RecvBuffer[33], RecvBuffer[34], RecvBuffer[35], RecvBuffer[36], RecvBuffer[37], RecvBuffer[38], RecvBuffer[39], RecvBuffer[40], RecvBuffer[41], RecvBuffer[42], RecvBuffer[43], RecvBuffer[44], RecvBuffer[45], RecvBuffer[46], RecvBuffer[47], RecvBuffer[48], RecvBuffer[49]);
	gdispDrawString(COLUMN2, ROW4, str, font, Red);

	gdispDrawString(COLUMN2, ROW1, "IMS HW v3", font, Red);
	gdispDrawString(COLUMN2 + 200, ROW1, "Freeze : Ctrl + F12", font, Red);
	gdispDrawString(COLUMN2, ROW5, "Aries 1.0.0", font, Red);
	gdispDrawString(COLUMN2, ROW6, txt1, font, Red);
	gdispDrawString(COLUMN2 + 180, ROW6, txt2, font, Red);
	/*
    sprintf(str, "%d x %d", width, height);
    gdispDrawString(COLUMN2, ROW6, str, font, Red);
    */

#ifdef SW_RELEASE
	gdispDrawString(COLUMN2, ROW7, "SW_RELEASE", font, Red);
#else
	gdispDrawString(COLUMN2, ROW7, "Engineering", font, Red);
	#ifdef USE_IMS_LINK
		gdispDrawString(COLUMN2 + 180, ROW7, "USE_IMS_LINK", font, Red);
	#else
		gdispDrawString(COLUMN2 + 180, ROW7, "USE_comport", font, Red);
	#endif
#endif

		u32 addr;
		u32 value = 0;

		addr = REGISTER_BOOT_MODE;
		value = ReadRegister(addr);
		u32 boot_mode;
		boot_mode = value&0xf;
		//xil_printf("REGISTER_BOOT_MODE : 0x%08x, boot_mode = %d\t", value, boot_mode);
		gdispDrawString(COLUMN2, ROW8, "Boot mode :", font, Red);
		switch(boot_mode)
		{
		case 0:		gdispDrawString(COLUMN2 + 180, ROW8, "JTAG Mode", font, Red);break;
		case 1:		gdispDrawString(COLUMN2 + 180, ROW8, "QSPI Mode", font, Red);break;
		case 4:		gdispDrawString(COLUMN2 + 180, ROW8, "NAND Mode", font, Red);break;
		case 5:		gdispDrawString(COLUMN2 + 180, ROW8, "SD Mode", font, Red);break;
		default:	gdispDrawString(COLUMN2 + 180, ROW8, "Unknown Mode", font, Red);break;
		}

		sprintf(str, "Bootup : %s", asctime(&rtc_bootup));
		gdispDrawString(COLUMN2, ROW9, str, font, Red);

		unsigned long difftime_bootup = 0;
		difftime_bootup = diff_time(rtc, rtc_bootup);
		//xil_printf("Bootup ellapsed : %ld sec\r\n", difftime_bootup);

		sprintf(str, "Ellapsed :");
		gdispDrawString(COLUMN2, ROW11, str, font, Red);

		print_time_eng(difftime_bootup);

	switch(SelectedLanguage)
	{
	case 0:		sprintf(str, "%s", "T. Chinese");	break;
	case 1:		sprintf(str, "%s", "S. Chinese");	break;
	case 2:		sprintf(str, "%s", "English");		break;
	default:	sprintf(str, "%s", "xxx");			break;
	}
	gdispDrawString(COLUMN4, ROW1, str, font, Red);
	gdispFillString(COLUMN3 + 130, ROW12, "F9 : Refresh", font, White, Gray);

    return;



}

void setup_camera_exposure(int setup)
{
	flag_camera_access = 1;
	if(setup == CAMERA_EXPO_DEFAULT)	//default
	{
		camera_exposure = CAMERA_EXPO_DEFAULT_VALUE;
	}
	else if(setup == CAMERA_EXPO_INC)	//increase
	{
		if(camera_exposure < 100)
			camera_exposure += 4;
	}
	else if(setup == CAMERA_EXPO_DEC)	//decrease
	{
		if(camera_exposure > 20)
			camera_exposure -= 4;
	}
	else
	{
		camera_exposure = CAMERA_EXPO_DEFAULT_VALUE;
	}
	unsigned int reg;

	reg = 0x3A03;dongle_write_data(reg, (unsigned char)camera_exposure);
	usleep(500000);
	reg = 0x3A04;dongle_write_data(reg, camera_exposure - 10);

	xil_printf("camera_exposure = %d\r\n", (unsigned char)camera_exposure);
	usleep(500000);
	flag_camera_access = 0;
	return;
}

void my_XTime_GetTime(XTime *Xtime_Global)
{
	u32 low;
	u32 high;

	//xil_printf("XTime_GetTime\n\r");

	/* Reading Global Timer Counter Register */
	do
	{
		high = Xil_In32(GLOBAL_TMR_BASEADDR + GTIMER_COUNTER_UPPER_OFFSET);
		low = Xil_In32(GLOBAL_TMR_BASEADDR + GTIMER_COUNTER_LOWER_OFFSET);
	} while(Xil_In32(GLOBAL_TMR_BASEADDR + GTIMER_COUNTER_UPPER_OFFSET) != high);

	*Xtime_Global = (((XTime) high) << 32U) | (XTime) low;

	xil_printf("Addr GLOBAL_TMR_BASEADDR = 0x%08x\n\r", GLOBAL_TMR_BASEADDR);
	xil_printf("Addr GTIMER_COUNTER_UPPER_OFFSET = 0x%08x\n\r", GTIMER_COUNTER_UPPER_OFFSET);
	xil_printf("Addr GTIMER_COUNTER_LOWER_OFFSET = 0x%08x\n\r", GTIMER_COUNTER_LOWER_OFFSET);

	xil_printf("UPPER = 0x%08x  LOWER = 0x%08x\n\r", high, low);
}

#define COUNTS_PER_SECOND          (XPAR_CPU_CORTEXA9_CORE_CLOCK_FREQ_HZ / 2)
#define COUNTS_PER_USECOND  (XPAR_CPU_CORTEXA9_CORE_CLOCK_FREQ_HZ / (2U*1000000U))

void XTime_GetStartTime(XTime *Xtime_Global)
{
	u32 start_time;
	u32 low;
	u32 high;

	/* Reading Global Timer Counter Register */
	do
	{
		high = Xil_In32(GLOBAL_TMR_BASEADDR + GTIMER_COUNTER_UPPER_OFFSET);
		low = Xil_In32(GLOBAL_TMR_BASEADDR + GTIMER_COUNTER_LOWER_OFFSET);
	} while(Xil_In32(GLOBAL_TMR_BASEADDR + GTIMER_COUNTER_UPPER_OFFSET) != high);

	start_time = (u32)(((((XTime) high) << 32U) | (XTime) low)/COUNTS_PER_USECOND/1000);

	xil_printf("start_time =    %u ms = 0x%x\n\r", start_time, start_time);
	xil_printf("Start Time = %d.%03d sec\n\r", start_time/1000, start_time%1000);

	int s = start_time/1000;

	xil_printf("System up time :\t");
	if(s >= 86400)
		xil_printf("%d Days, ", s/86400);
	if(s >= 3600)
		xil_printf("%d Hours, ", (s%86400)/3600);
	if(s >= 60)
		xil_printf("%d Minutes, ", ((s%86400)%3600)/60);
	xil_printf("%d.%03d Seconds\n\r", ((s%86400)%3600)%60, start_time%1000);


	xil_printf("System up time :\t");
	if(s >= 86400)
		xil_printf("%d day, %d hr, %d min, %d sec\n\r", s/86400, (s%86400)/3600, ((s%86400)%3600)/60, ((s%86400)%3600)%60);
	else if(s >= 3600)
		xil_printf("%d hr, %d min, %d sec\n\r", (s%86400)/3600, ((s%86400)%3600)/60, ((s%86400)%3600)%60);
	else if(s >= 60)
		xil_printf("%d min, %d sec\n\r", ((s%86400)%3600)/60, ((s%86400)%3600)%60);
	else
		xil_printf("%d sec\n\r", ((s%86400)%3600)%60);

}

uint32_t check_camera_status()
{
	unsigned char DongleData;
	unsigned int DongleAddr;

	DongleAddr = 0x300a;
	DongleData = dongle_read_data(DongleAddr);
	xil_printf("addr = 0x%04x, data = 0x%02x\tCHIP ID H\n\r", DongleAddr, DongleData);

	if(DongleData == 0x76)
		return SENSOR_OK;
	else
		return SENSOR_FAIL;
}

void restore_camera_setup()
{



}
