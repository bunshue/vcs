// *****************************************************
// Dependencies
// *****************************************************
#include "xil_cache.h"
#include "platform.h"
#include "main.h"
#include "xuartps_hw.h"
#include "periphs.h"
#include "mixer.h"
#include "gpio.h"
#include "ulpi.h"
#include "sleep.h"

static const char ims_logo[] = "ims-small-logo.png";
static const char step_1[] = "step1.png";
static const char step_2[] = "step2.png";

void pixmap_draw(GDisplay* pixmap, pixel_t* surface, coord_t pm_width, coord_t pm_height, gdispImage *p_Image, uint32_t pm_sx, uint32_t pm_sy, uint32_t img_sx, uint32_t img_sy);

volatile uint32_t g_ms_tick = 0;
uint32_t g_conn_status = 2;
uint32_t g_conn_status_old = 3;

static gdispImage myImage;
static GDisplay* pixmap_1;
static pixel_t* surface_1;
static GDisplay* pixmap_2;
static pixel_t* surface_2;

void main_loop(void);

// *****************************************************
// Main program entry point
// *****************************************************
int main()
{
	// Local variables
	int status = 0;
	coord_t swidth, sheight;
	gdispImage *p_Image = &myImage;

	// Setup UART and caches
    init_platform();

    xil_printf("Aries Main Program\n\r");

    // Initialize peripherals
    status = periphs_init
    (
    	&periphs_inst,
		XPAR_PS7_GPIO_0_DEVICE_ID,
		XPAR_VIDEO_PATH_VIDEO_OUT_VIDEO_LOCK_MONITOR_VS_MIXER_SW_RST_DEVICE_ID,
		XPAR_PS7_SCUGIC_0_DEVICE_ID,
		XPAR_PS7_SCUTIMER_0_DEVICE_ID,
		XPAR_PS7_UART_0_DEVICE_ID,
		XPAR_VIDEO_PATH_V_TPG_0_DEVICE_ID,
		XPAR_VIDEO_PATH_CAMERA_SCALER_FREEZE_V_PROC_SS_1_DEVICE_ID,
		XPAR_VIDEO_PATH_FRAMEBUFFER_AXI_VDMA_CAMERA_DEVICE_ID,
		XPAR_VIDEO_PATH_FRAMEBUFFER_AXI_VDMA_CAMERA_FREEZE_DEVICE_ID,
		XPAR_VIDEO_PATH_OUTPUT_MIXER_V_MIX_0_DEVICE_ID,
		XPAR_VIDEO_PATH_VIDEO_OUT_V_TC_TFP410_DEVICE_ID,
		XPAR_VIDEO_PATH_VIDEO_OUT_V_TC_CH7038_DEVICE_ID,
		XPAR_PS7_USB_0_DEVICE_ID,
    	FRAMEBUFFER_CAMERA_START_ADDR,
		FRAMEBUFFER_CAMERA_FREEZE_START_ADDR,
		FRAMEBUFFER_GUI_START_ADDR
    );
	if (status != 0)
    {
		xil_printf("Initialization failed.\n\r");
		return -1;
    }

    // Initialize uGFX
    gfxInit();
    xil_printf("gfxInit() complete\r\n");
	// Background process
	xil_printf("Initialization complete. Switching to background process.\n\r");

	// Set up pixmap for layer 1
    pixmap_1 = gdispPixmapCreate(LAYER1_WIDTH, LAYER1_HEIGHT);
    surface_1 = gdispPixmapGetBits(pixmap_1);
    // Draw transparency required on layer 1
    pixmap_draw(pixmap_1, surface_1, LAYER1_WIDTH, LAYER1_HEIGHT, NULL, 0, 0, 0, 0);

	// Set up pixmap for layer 2
    pixmap_2 = gdispPixmapCreate(LAYER2_WIDTH, LAYER2_HEIGHT);
    surface_2 = gdispPixmapGetBits(pixmap_2);
    // Draw transparency required on layer 2
    pixmap_draw(pixmap_2, surface_2, LAYER2_WIDTH, LAYER2_HEIGHT, NULL, 0, 0, 0, 0);

	// Open image for layer 3
	// Get the display dimensions
	swidth = gdispGetWidth();
	xil_printf("swidth: %d\r\n", swidth);
	sheight = gdispGetHeight();
	xil_printf("sheight: %d\r\n", sheight);

	// Set up IO for our image
	status = gdispImageOpenFile(p_Image, ims_logo);
	status = gdispImageDraw(p_Image, swidth-p_Image->width-BORDER_X*2, sheight-p_Image->height-BORDER_Y*2, p_Image->width, p_Image->height, 0, 0);
	gdispImageClose(p_Image);

	// Blit surface_1 to the real display at the new position
	gdispBlitArea(LAYER0_WIDTH-LAYER1_WIDTH-BORDER_X, BORDER_Y, LAYER1_WIDTH, LAYER1_HEIGHT, surface_1);

	// Blit surface_2 to the real display at the new position
	gdispBlitArea(BORDER_X, LAYER0_HEIGHT-LAYER2_HEIGHT-BORDER_Y, LAYER2_WIDTH, LAYER2_HEIGHT, surface_2);

	Xil_DCacheFlush();

	// Set up Mixer Layers
	RunMixer(periphs_inst.p_vid_output_mixer_l2_inst);

	Xil_DCacheFlush();

	keyboard_host_app_init(); // Keyboard Host Init
	//mouse_host_app_init(); // Mouse Host Init
	Xil_DCacheFlush(); // Flush DCache after USB Init();
	//Xil_DCacheInvalidate();
	Xil_DCacheDisable();
	main_loop();

    cleanup_platform();
    return 0;
}

void main_loop()
{
	char c[1]  = {0};
	gdispImage *p_Image;

	// Main loop
	while (1)
	{
		uint32_t status;
		//xil_printf("What would you like to do? Press 'p' to print available commands.\n\r");
		c[0] = XUartPs_RecvByte(XPAR_PS7_UART_1_BASEADDR);
		//XUartPs_Recv(g_psuart1_config->BaseAddress, &c[0], 1);
		
		//xil_printf("ping.\n\r");
		g_conn_status = psuart0_dongle_ping();

		if(g_conn_status_old != g_conn_status)
		{
			if(g_conn_status == DONGLE_NONE)
			{
				xil_printf("no dongle or camera step_1\n\r");
				xil_printf("no dongle or camera\n\r");
				// Show Message to plug in dongle
				XVMix_LayerDisable(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_1);
				p_Image = &myImage;
				status = gdispImageOpenFile(p_Image, step_1);
				pixmap_draw(pixmap_1, surface_1, LAYER1_WIDTH, LAYER1_HEIGHT, p_Image, 0, 0, 0, 0);
				gdispBlitArea(LAYER0_WIDTH-LAYER1_WIDTH-BORDER_X, BORDER_Y, LAYER1_WIDTH, LAYER1_HEIGHT, surface_1);
				Xil_DCacheFlush();
				gdispImageClose(p_Image);
			}
			else if (g_conn_status == CAMERA_NONE)
			{
				xil_printf("\n\r\n\rdongle only step_2\n\r");
				// Dongle plugged
				xil_printf("dongle plugged\n\r");
				XVMix_LayerDisable(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_1);
				p_Image = &myImage;
				status = gdispImageOpenFile(p_Image, step_2);
				pixmap_draw(pixmap_1, surface_1, LAYER1_WIDTH, LAYER1_HEIGHT, p_Image, 0, 0, 0, 0);
				gdispBlitArea(LAYER0_WIDTH-LAYER1_WIDTH-BORDER_X, BORDER_Y, LAYER1_WIDTH, LAYER1_HEIGHT, surface_1);
				Xil_DCacheFlush();
				gdispImageClose(p_Image);
			}
			else	//CAMERA_OK
			{
				xil_printf("\n\r\n\rdongle+camera step_3 --------------\n\r");

				Xil_DCacheEnable();
				xil_printf("update remove picture\r\n");
				pixmap_draw(pixmap_1, surface_1, LAYER1_WIDTH, LAYER1_HEIGHT, NULL, 0, 0, 0, 0);
				gdispBlitArea(LAYER0_WIDTH-LAYER1_WIDTH-BORDER_X, BORDER_Y, LAYER1_WIDTH, LAYER1_HEIGHT, surface_1);
				Xil_DCacheFlush();
				Xil_DCacheDisable();

				if(XVMix_IsLayerEnabled(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_1) == 0)
				{
					XVMix_LayerEnable(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_1);
				}
				if(XVMix_IsLayerEnabled(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_2) == 0)
				{
					XVMix_LayerEnable(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_2);
				}
				Xil_DCacheFlush();
				psuart0_exposure(3);
			}
			g_conn_status_old = g_conn_status;
		}

		//  Run USB Host Task Handlers
	    keyboard_host_app_task(NULL); // Keyboard tasks
	    //mouse_host_app_task(NULL); // Mouse Tasks
		//Xil_DCacheFlush();

		switch (c[0])
		{
			case 'p':
				xil_printf("\n\r");
				xil_printf("------------- Aries Demo -------------\n\r");
				xil_printf("'1' = Toggle Layer 1\n\r");
				xil_printf("'2' = Toggle Layer 2\n\r");
				xil_printf("'3' = Toggle Layer 3\n\r");
				xil_printf("'n' = Set to new scaler datapath\n\r");
				xil_printf("'t' = Enable/bypass camera TPG\n\r");
				xil_printf("'y' = Enable/bypass GUI TPG\n\r");
				xil_printf("'u' = Park Camera Freeze VDMA\n\r");
				xil_printf("'s' = Set output frame size\n\r");
				xil_printf("'p' = Print this menu\n\r");
				xil_printf("---------------------------------------\n\r");
				xil_printf("\n\r");
				break;
			case '1':
				xil_printf("Enabling/bypassing Layer 1.\n\r");
				status = XVMix_IsLayerEnabled(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_1);
				if(status) { // Enabled
					XVMix_LayerDisable(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_1);
				} else {
					XVMix_LayerEnable(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_1);
				}
				break;
			case '2':
				xil_printf("Enabling/bypassing Layer 2.\n\r");
				status = XVMix_IsLayerEnabled(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_2);
				if(status) { // Enabled
					XVMix_LayerDisable(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_2);
				} else {
					XVMix_LayerEnable(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_2);
				}
				break;
			case '3':
				xil_printf("Enabling/bypassing Layer 3.\n\r");
				status = XVMix_IsLayerEnabled(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_3);
				if(status) { // Enabled
					XVMix_LayerDisable(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_3);
				} else {
					XVMix_LayerEnable(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_3);
				}
				break;
			case 't':
				xil_printf("Enabling/bypassing camera TPG.\n\r");
				//periphs_toggle_camera_tpg(&periphs_inst);
				break;
			case 'y':
				xil_printf("Enabling/bypassing GUI TPG.\n\r");
				periphs_toggle_GUI_tpg(&periphs_inst);
				break;
			case 'u':
				xil_printf("Park/Unpark Camera Freeze VDMA.\n\r");
				periphs_toggle_camera_freeze_vdma(&periphs_inst);
				// Determine if we're in TPG or passthrough mode
				if (periphs_inst.enable_camera_freeze_vdma == PERIPHS_SEL_ENABLE_PARK)
				{
					XVMix_LayerEnable(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_2);
				}
				else
				{
					XVMix_LayerDisable(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_2);
				}
			case 'd':
				g_ms_tick = 0;
				xil_printf("sleep 60 sec ST tick = %d\n\r", g_ms_tick);
				sleep(60);
				xil_printf("sleep 60 sec SP tick = %d\n\r", g_ms_tick);
				break;
			case 0:
				break;
			case 0x0D:
			case ' ':
				xil_printf("\n\r\n\r\n\r\n\r");
				break;
			default:
				xil_printf("\n\r---- unknown ---- c[0] = 0x%x", c[0]);
				if(isprint(c[0]))
					xil_printf("\t%c\n\r", c[0]);
				else
					xil_printf("\n\r");
				break;

	}
	}
}

void pixmap_draw(GDisplay* pixmap, pixel_t* surface, coord_t pm_width, coord_t pm_height, gdispImage *p_Image, uint32_t pm_sx, uint32_t pm_sy, uint32_t img_sx, uint32_t img_sy)
{
	uint32_t i, j, status;
	//color_t color = 0;

	//xil_printf("enter pixmap_draw\r\n");
	// Clear pixmap with 0
	memset(surface, 0, pm_width*pm_height*4); // Clear buffer

	// Overlay file is necessary
	if(p_Image != NULL) {
		// Load image
		status = gdispGImageDraw(pixmap, p_Image, (pm_width-p_Image->width) >> 1, (pm_height-p_Image->height) >> 1, p_Image->width, p_Image->height, 0, 0);
		//xil_printf("status draw: %d\r\n", status);
	}

    // Draw transparency required on layer 1
    for(j = 0; j < pm_height; j++) {
    	for(i = 0; i < pm_width; i++) {

    		if((j > (1.5*(pm_height >> 3)-1)) && (j < (pm_height-1.5*(pm_height >> 3)))) {
    			//color = gdisp_lld_get_pixel_color(pixmap);
    			//xil_printf("color: %x\r\n", color);
    			if(surface[j*pm_width + i] == 0) {
    				surface[j*pm_width + i] = ABGR2COLOR(0x00, 0x00, 0x00, 0x00);
    			}
//    			else {
    				//surface[j*pm_width + i] = ABGR2COLOR(0x00, 0x00, 0x00, 0x00);
    			//}

    		}
    		else {

				if(j < 1.5*(pm_height >> 3)) { // Top lines

					if (  (i < (1.5*(pm_height >> 3)-j)) || (i > ((pm_width-1.5*(pm_height >> 3))-1+j)    )  ) {
    					surface[j*pm_width + i] = ABGR2COLOR(0x80, 0xff, 0xff, 0xff);
    					//xil_printf("c: %x\r\n", surface_1[j*PIXMAP_WIDTH_1 + i]);
    				}
    				else {
    	    			//if(surface[j*pm_width + i] == 0) {
    	    				surface[j*pm_width + i] = ABGR2COLOR(0x00, 0x00, 0x00, 0x00);
    	    			//}
    				}

				}
				else { // Bottom lines

					if( (i < (j+1.5*(pm_height >> 3)-pm_height) ) || i > ((pm_width-(1.5*(pm_height >> 3)-(pm_height-j)))-1) ){
						surface[j*pm_width + i] = ABGR2COLOR(0x80, 0xff, 0xff, 0xff);
					}
					else {
    	    			if(surface[j*pm_width + i] == 0) {
    	    				surface[j*pm_width + i] = ABGR2COLOR(0x00, 0x00, 0x00, 0x00);
    	    			}
					}
				}
     		}
    	}
    }
}

// uGFX SystemTick
systemticks_t gfxSystemTicks(void)
{
	return g_ms_tick;
}

systemticks_t gfxMillisecondsToTicks(delaytime_t ms)
{
	return ms;
}
/////////////////////////////////////

uint32_t tusb_tick_get(void)
{
  //return system_ticks;
  return g_ms_tick;
}


