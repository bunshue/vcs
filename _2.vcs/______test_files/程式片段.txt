
try by sugar
C#如何獲取遠程磁盤上的剩余空間
http://www.aspphp.online/bianchen/dnet/cxiapu/cxprm/201701/191690.html


1.對於那種明知道跨線程調用不會帶來錯誤的，可以設置Form控件不檢查跨線程調用錯誤，這樣就不報錯了。
在Form1構造方法中：
C#代碼 
CheckForIllegalCrossThreadCalls = false; 


//發送資料到剪貼簿
Clipboard.SetText(textBox1.Text);
MessageBox.Show("已成功將文本框內容復制到剪貼板!");


//從剪貼簿取得資料

            try
            {
                IDataObject iData = Clipboard.GetDataObject();
                if (iData.GetDataPresent(DataFormats.Text))
                {
                    //MessageBox.Show((string)iData.GetData(DataFormats.Text));
                    textBox2.Text = (string)iData.GetData(DataFormats.UnicodeText);
                }
                else
                {
                    MessageBox.Show("目前剪貼板中數據不可轉換為文本", "錯誤");
                }
            }
            
C# MD5摘要算法、哈希算法，
MD5即Message-Digest Algorithm 5（信息-摘要算法5），用於確保信息傳輸完整一致。是計算機廣泛使用的雜湊算法之一（又譯摘要算法、哈希算法）



            
            

//-------------------------------------------------------------

//C#--遍歷文件夾實例


                //實例化DirectoryInfo對象
                DirectoryInfo dinfo = new DirectoryInfo(textBox1.Text);
                //獲取指定目錄下的所有子目錄及文件類型
                FileSystemInfo[] fsinfos = dinfo.GetFileSystemInfos();
                foreach (FileSystemInfo fsinfo in fsinfos)
                {
                    if (fsinfo is DirectoryInfo)    //判斷是否文件夾
                    {
                        //使用獲取的文件夾名稱實例化DirectoryInfo對象
                        DirectoryInfo dirinfo = new DirectoryInfo(fsinfo.FullName);
                        //為ListView控件添加文件夾信息
                        listView1.Items.Add(dirinfo.Name);
                        listView1.Items[listView1.Items.Count - 1].SubItems.Add(dirinfo.FullName);
                        listView1.Items[listView1.Items.Count - 1].SubItems.Add("");
                        listView1.Items[listView1.Items.Count - 1].SubItems.Add(dirinfo.CreationTime.ToShortDateString());
                    }
                    else
                    {
                        //使用獲取的文件名稱實例化FileInfo對象
                        FileInfo finfo = new FileInfo(fsinfo.FullName);
                        //為ListView控件添加文件信息
                        listView1.Items.Add(finfo.Name);
                        listView1.Items[listView1.Items.Count - 1].SubItems.Add(finfo.FullName);
                        listView1.Items[listView1.Items.Count - 1].SubItems.Add(finfo.Length.ToString());
                        listView1.Items[listView1.Items.Count - 1].SubItems.Add(finfo.CreationTime.ToShortDateString());
                    }
                }







//MD5加密
//MD5加密是不可以逆的，只能將字串轉為MD5值，不能將MD5值轉回字串。

static void Main(string[] args)
    {
        //202cb962ac59075b964b07152d234b70
        //202cb962ac5975b964b7152d234b70   ToString x引數
        //202cb962ac59075b964b07152d234b70  ToString x2引數

        // 3244185981728979115075721453575112   ToString  沒加引數
        //ToString引數需要到百度拿來用
        string s = GetMD5("123");
        Console.WriteLine(s);
        Console.ReadKey();
    }

    public static string GetMD5(string str)
    {
        //建立MD5物件
        MD5 md5 = MD5.Create();
        //開始加密
        //需要將字串轉為位元組陣列
        byte[] buffer = Encoding.Default.GetBytes(str);
        //返回一個加密好的位元組陣列
       byte[] MD5Buffer = md5.ComputeHash(buffer);

        //將位元組陣列轉換成字串
        //位元組陣列---字串
        //1.將位元組陣列中每個元素按照自定的編碼格式解析成字串
        //2.直接將陣列ToString();
        //3.將位元組陣列中的每個元素ToString()
        //  return Encoding.Default.GetString(MD5Buffer);
        string strNew = " ";
        for (int i = 0; i < MD5Buffer.Length; i++)
        {
            //ToString("x") 加x引數將十進位制轉為十六進位制，屬於ToString的方法
            strNew += MD5Buffer[i].ToString("x2");
        }
        return strNew;
    }
    
    

/// <summary>
/// MD5加密
/// </summary>
/// <param name="str"></param>
/// <returns></returns>
        public string UserMd5(string str)
        {
         
       
            string cl = str;
            string pwd = "";
            MD5 md5 = MD5.Create();//实例化一个md5对像
            // 加密后是一个字节类型的数组，这里要注意编码UTF8/Unicode等的选择　
            byte[] s = md5.ComputeHash(Encoding.UTF8.GetBytes(cl));
          
            // 通过使用循环，将字节类型的数组转换为字符串，此字符串是常规字符格式化所得
            for (int i = 0; i < s.Length; i++)
            {
                // 将得到的字符串使用十六进制类型格式。格式后的字符是小写的字母，如果使用大写（X）则格式后的字符是大写字符

                pwd = pwd + s[i].ToString("x");
		pwd = pwd + s[i].ToString("x2");
            }
            return pwd;
        }
    }

//wenweifeng 加密出来的WEB是:E28ACEB82C41284D13A50962E1C00D56



C#设置窗体透明，控件不透明


        private void Form1_Load(object sender, EventArgs e)
        {
            //方法1    
            //例：窗体的透明度为50% 
            //this.Opacity = 0.5; 
            
            //方法2，我用的方法2，窗体透明控件不透明了
            // TransparencyKey只支持透明或不透明，不支持过度色，比如PNG图片中的从不透明到透明的过渡色会显示出讨厌的效果
            this.BackColor = Color.Black;
            this.TransparencyKey = Color.Black;
 
        }


emule
http://www.ed2k.online/tushu/jsjwl/16725.html


ed2k://|file|[www.ed2k.online][C#%E5%85%A8%E8%83%BD%E9%80%9F%E6%9F%A5%E5%AE%9D%E5%85%B8].%E6%98%8E%E6%97%A5%E7%A7%91%E6%8A%80%E7%AD%89.%E6%89%AB%E6%8F%8F%E7%89%88.pdf|255157709|83403adcb05aaf95a0a0ef19846a00aa|h=pk25dcx3grk63emqyukmuh2eb6zuhpg5|/







用C#實現全屏幕截圖


今天一位同事想寫一個全屏幕截圖的代碼。當然要實現的第一步是能夠獲取整個屏幕的位圖，記得Win32 API的CreateDC, BitBlt等函數可以使用。於是上網查了下，果然屏幕截圖用這些函數。但winform已經可以把API都忘記了，所以得尋找一個無Win32 API的實現方式。綜合了網上的實現，以及自己的一些設計，實現思路如下：

1. 開始截圖時，創建一個與屏幕大小一樣的位圖，然後用Graphics.CopyFromScreen()把屏幕位圖拷貝到該位圖上。這是很關鍵的一步，這樣所有的操作就都可以在該位圖上進行了，而無實際屏幕無關了。
    int width = Screen.PrimaryScreen.Bounds.Width;

    int height = Screen.PrimaryScreen.Bounds.Height;

    Bitmap bmp = new Bitmap(width, height);

    using (Graphics g = Graphics.FromImage(bmp))
    {
    g.CopyFromScreen(0, 0, 0, 0, new Size(width, height));
    }






    2. 接下來為了方便在這之上進行截圖，有一個很重要的設計實現方式：用全屏幕窗體代替現有真實屏幕，這樣就可以把截圖過程的所有操作都在那個窗體上實現（該窗體設置成無邊框，高寬等於屏幕大小即可），另外為了顯示掩蔽效果（只能正常顯示選擇的部分屏幕內容，而其實部分用一個如半透明層覆蓋），就添加一層半透明位置位圖。具體代碼如下：

    public partial class FullScreenForm : Form
    {
	    private Rectangle rectSelected = Rectangle.Empty;
	
	    private bool isClipping = false;
	
	    private Bitmap screen;
	
	    private Bitmap coverLayer = null;
	
	    private Color coverColor;
	
	    private Brush rectBrush = null;
	
	    private Bitmap resultBmp = null;
	
	    public FullScreenForm(Bitmap screen)
	    {
		    InitializeComponent();
		
		    int width = Screen.PrimaryScreen.Bounds.Width;
		
		    int height = Screen.PrimaryScreen.Bounds.Height;
		
		    coverLayer = new Bitmap(width, height);
		
		    coverColor = Color.FromArgb(50, 200, 0, 0);
		
		    rectBrush = new SolidBrush(coverColor);
		
		    using (Graphics g = Graphics.FromImage(coverLayer)) {
		
		    g.Clear(coverColor);
	    }
	
	    this.Bounds = new Rectangle(0, 0, width, height);
	
	    this.screen = screen;
	
	    this.DoubleBuffered = true;
    }

    protected override void OnMouseDown(MouseEventArgs e)
    {
	    if (e.Button == MouseButtons.Left)
	    {
		    isClipping = true;
		    rectSelected.Location = e.Location;
	    }
	    else if (e.Button == MouseButtons.Right)
	    {
	    	this.DialogResult = DialogResult.OK;
	    }
    }

    protected override void OnMouseMove(MouseEventArgs e)
    {
	    if (e.Button == MouseButtons.Left & & isClipping)
	    {
		    rectSelected.Width = e.X - rectSelected.X;
		    rectSelected.Height = e.Y - rectSelected.Y;
		    this.Invalidate();
	    }
    }

    protected override void OnMouseUp(MouseEventArgs e)
    {
	    if (e.Button == MouseButtons.Left && isClipping)
	    {
		    rectSelected.Width = e.X - rectSelected.X;
		    rectSelected.Height = e.Y - rectSelected.Y;
		    this.Invalidate();
		    resultBmp = new Bitmap(rectSelected.Width, rectSelected.Height);
		    using (Graphics g = Graphics.FromImage(resultBmp))
		    {
		    	g.DrawImage(screen,new Rectangle(0, 0, rectSelected.Width, rectSelected.Height), rectSelected, GraphicsUnit.Pixel);
		    }
		    this.DialogResult = DialogResult.OK;
	    }
    }

    protected override void OnPaint(PaintEventArgs e)
    {
	    Graphics g = e.Graphics;
	    g.DrawImage(screen, 0, 0);
	    g.DrawImage(coverLayer, 0, 0);
	    PaintRectangle();
    }

    protected override void OnPaintBackground(PaintEventArgs e)
    {
    }

    protected override void OnKeyDown(KeyEventArgs e)
    {
	    if (e.KeyCode == Keys.Escape)
	    {
	    	this.DialogResult = DialogResult.Cancel;
	    }
    }

    private void PaintRectangle()
    {
	    using (Graphics g = Graphics.FromImage(coverLayer))
	    {
		    g.Clear(coverColor);
		    GraphicsPath path = new GraphicsPath();
		    path.AddRectangle(this.Bounds);
		    path.AddRectangle(rectSelected);
		    g.FillPath(rectBrush, path);
		    g.DrawRectangle(Pens.Blue, rectSelected);
	    }
    }

    public Bitmap ResultBitmap
    {
    	get { return resultBmp; }
    }
    
    

}

    
    


/*
XmlDocument 用來存放XML文件的類別

XmlElement 存取節點屬性的類別

XmlNode 選取節點的類別


使用XmlDocument.CreateElement 方法建立節點
*/
			
       


byte[]與Image Image與 byte[] 之間的轉換

/// <summary>
/// 將byte[]轉換為Image
/// </summary>
/// <param name="bytes">字節數組</param>
/// <returns>Image</returns>
public Image ReadImage(byte[] bytes)
{
     MemoryStream ms=new MemoryStream(bytes,0,bytes.Length);
     BinaryFormatter bf = new BinaryFormatter();
     object obj=bf.Deserialize(ms);  
　　ms.Close();
　　return (Image)obj;
}
/// <summary>
/// 將Image轉換為byte[]
/// </summary>
/// <param name="image">Image</param>
/// <returns>byte[]</returns>
public byte[] ConvertImage(Image image)
{
     MemoryStream ms=new MemoryStream();
     BinaryFormatter bf = new BinaryFormatter();
     bf.Serialize(ms,(object)image);
     ms.Close();
     return ms.ToArray();
}




C# GUID介紹和的使用，

GUID（全局統一標識符）是指在一台機器上生成的數字，它保證對在同一時空中的所有機器都是唯一的。通常平台會提供生成GUID的API。生成算法很有意思，用到了以太網卡地址、納秒級時間、芯片ID碼和許多可能的數字。GUID的唯一缺陷在於生成的結果串會比較大。

GUID永遠是方便的; 對於程序開發的各個方面，.NET Framework簡化了建立和處理GUID數值的過程。在.NET程序需要的地方，這一功能很容易地生成唯一的數值。

 

1. 一個GUID為一個128位的整數(16字節)，在使用唯一標識符的情況下，你可以在所有計算機和網絡之間使用這一整數。

2. GUID 的格式為“xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx”，其中每個 x 是 0-9 或 a-f 范圍內的一個十六進制的數字。例如：337c7f2b-7a34-4f50-9141-bab9e6478cc8 即為有效的 GUID 值。

3. 世界上（Koffer注：應該是地球上）的任何兩台計算機都不會生成重復的 GUID 值。GUID 主要用於在擁有多個節點、多台計算機的網絡或系統中，分配必須具有唯一性的標識符。

4. 在 Windows 平台上，GUID 應用非常廣泛：注冊表、類及接口標識、數據庫、甚至自動生成的機器名、目錄名等。





//拜列轉字串(16進制)

	static int buffersize = 18;   //十六進制數的大小（假設為6Byte）
	byte[] buffer = new Byte[buffersize];   //創建緩沖區
	
	private void button1_Click(object sender, EventArgs e)
	{
	    serialPort1.Read(buffer, 0, buffersize);
	    string ss;
	    ss = byteToHexStr(buffer); //用到函數byteToHexStr
	    textBox2.Text = ss;
	    serialPort1.Close();
	    MessageBox.Show("數據接收成功！", "系統提示");
	}
	
	//字節數組轉16進制字符串
	public static string byteToHexStr(byte[] bytes)
	{
	    string returnStr = "";
	    if (bytes != null)
	    {
	        for (int i = 0; i < bytes.Length; i++)
	        {
	            returnStr += bytes[i].ToString("X2");
	        }
	    }
	    return returnStr;
	}
	
	
	 
	



其實在ASP.Net編程中，不用調用md5.ASP來加密數據。在DotNet中有自帶的類：System.Web.Security.HashPassWordForStoringInConfigFile()

public string md5(string str,int code)
{
if(code==16) //16位MD5加密（取32位加密的9~25字符）
{
return System.Web.Security.FormsAuthentication.HashPassWordForStoringInConfigFile(str,"MD5").ToLower().Substring(8,16) ;
}

if(code==32) //32位加密
{
return System.Web.Security.FormsAuthentication.HashPassWordForStoringInConfigFile(str,"MD5").ToLower();
}

return "00000000000000000000000000000000";
}


c#畫三角形、並填充顏色
目前知道有兩種方法：畫多邊形、GraphicsPath。但是用畫多邊形的方式畫三角形不太好。老畫不正的，截圖放大就明顯了。

	Point point1 = new Point(0, 0);
	Point point2 = new Point(11, 0);
	Point point3 = new Point(5, 8);
	Point[] pntArr = {point1, point2, point3};
	
	e.Graphics.FillPolygon(Brushes.Red, pntArr);





C#計算文件的MD5值實例
MD5 是 Message Digest Algorithm 5（信息摘要算法）的縮寫，MD5 一種散列(Hash)技術，廣泛用於加密、解密、數據簽名和數據完整性校驗等方面。




C# 條形碼操作【源碼下載】

http://www.aspphp.online/bianchen/dnet/cxiapu/cxprm/201701/185924.html









this.toolStripStatusLabel3.Text = DateTime.Now.DayOfWeek.ToString();
this.textBox1.SelectedText = DateTime.Now.ToString();
this.textBox1.Text += DateTime.Now;


//c#記事本實現代碼




目前大部分數碼相機都將所拍照的圖像保存成JPG格式，
而像拍照日期這樣的 信息統稱為EXIF信息。
EXIF是英文ExchangeableImageFile(可交換圖像文件)的 縮寫




            //獲取本代碼所在的文件作為臨時文件，用於獲取屬性列表
            string tempFile = System.Reflection.Assembly.GetExecutingAssembly().FullName;


new vcs data

不寫注釋是流氓，名字瞎起是扯淡


C#讀取exe版本號

	using System.Reflection;
	using System.IO;
	...
	
	Assembly currentAssembly = Assembly.LoadFile(currentAssemblyPath);
	Assembly updatedAssembly = Assembly.LoadFile(updatedAssemblyPath);
	
	AssemblyName currentAssemblyName = currentAssembly.GetName();
	AssemblyName updatedAssemblyName = updatedAssembly.GetName();
	
	// 比較版本號
	if (updatedAssemblyName.Version.CompareTo(currentAssemblyName.Version) <= 0)
	{
	    // 不需要更新
	    return;
	}
	
	using System.Reflection;
	using System.IO;
	...
	
	AssemblyName currentAssemblyName = AssemblyName.GetAssemblyName(currentAssemblyPath);
	AssemblyName updatedAssemblyName = AssemblyName.GetAssemblyName(updatedAssemblyPath);
	
	// 比較版本
	if (updatedAssemblyName.Version.CompareTo(currentAssemblyName.Version) <= 0)
	{
	    // 不需要更新
	    return;
	}
	
	// 更新
	File.Copy(updatedAssemblyPath, currentAssemblyPath, true);
	


C#對注冊表的操作

C#中提供的與注冊表相關的最主要的是兩個類：

Registry 和 RegistryKey，這兩個類屬於Microsoft.Win32命名空間

 

Registry類包含5個公共的靜態域，分別代表5個基本主鍵分別是：

Registry.ClassesRoot

Registry.CurrentUser

Registry.LocalMachine

Registry.Users

Registry.Current Config

這5個類分別對應注冊表的第二級目錄的五個預定義主鍵

 

RegistryKey類中提供了對注冊表操作的方法

CreateSubKey //建立一個子鍵

OpenSubKey //打開一個子鍵

DeleteKey //刪除一個子鍵

DeleteKeyTree//刪除一個鍵及其下的全部鍵

GetValue //獲取鍵值

SetValue //設置鍵值



//獲取某文件夾所有文件
public static string[] GetFiles(string Path)
{
	return Directory.GetFiles(Path);
}

//讀取文件內容到字符串 www.2cto.com
public static string OpenFile(string Path)
{
	return File.ReadAllText(Path);
}


檢測 USB 設備撥插的 C# 類庫：USBClassLibrary

private void USBPort_USBDeviceAttached(objectsender, USBClass.USBDeviceEventArgs e)
{
	if (!MyUSBDeviceConnected)
	{
		if(USBClass.GetUSBDevice(MyDeviceVID, MyDevicePID, ref USBDeviceProperties, false))
		{
			//My Device is connected
			MyUSBDeviceConnected = true;
		}
	}
}

private void USBPort_USBDeviceRemoved(objectsender, USBClass.USBDeviceEventArgs e)
{
	if(!USBClass.GetUSBDevice(MyDeviceVID, MyDevicePID, ref USBDeviceProperties, false))
	{
		//My Device is removed 
		MyUSBDeviceConnected = false;
	}
}



C# TabControl標簽的隱藏
	當你想要隱藏的時候
	
	if (this.tabMain.TabPages[ "tabpageThePage "] != null)
	
	{
	
	this.tabMain.TabPages.Remove(tabpageThePage);
	
	}
	
	當你想要顯示的時候
	
	if (this.tabMain.TabPages[ "tabpageThePage "] == null)
	
	{
	
	this.tabMain.TabPages.Add(tabpageThePage);
	
	}


c#畫三角形、並填充顏色

代碼 1     Point point1 = new Point(0, 0);
2     Point point2 = new Point(11, 0);
3     Point point3 = new Point(5, 8);
4     Point[] pntArr = {point1, point2, point3};
5 
6     e.Graphics.FillPolygon(Brushes.Red, pntArr);


代碼  1                 int len = 10;                       
 2                 int x = 0;
 3                 int y = 0;
 4                 Point[] pntArr = new Point[3];
 5                 pntArr[0] = new Point(x, y);
 6                 pntArr[1] = new Point(x - len, y);
 7                 pntArr[2] = new Point(x - len / 2, (int)(len * Math.Sqrt(3) / 2 + y));
 8               &nbs 




C# 控制台如何播放音頻文件，
using System.Reflection;
using System.Media;
 
 10             string namespaceName = Assembly.GetExecutingAssembly().GetName().Name.ToString();  
11             Assembly assembly = Assembly.GetExecutingAssembly();
12             SoundPlayer sp = new SoundPlayer(assembly.GetManifestResourceStream(namespaceName + ".Resources" + ".STEAMBLO.WAV"));
13             Console.Write("快看，輪船到了~！");
14             sp.Play();
string namespaceName = Assembly.GetExecutingAssembly().GetName().Name.ToString();   這段代碼是獲取前文檔命名空間的名稱的，也就是對應的“ThePlay”。

Assembly assembly = Assembly.GetExecutingAssembly();   獲取包含當前執行的代碼的程序集。
SoundPlayer sp = new SoundPlayer(assembly.GetManifestResourceStream(namespaceName + ".Resources" + ".STEAMBLO.WAV"));   
namespaceName 是上面獲取的空間名稱，Resource是音頻文件夾的名稱，STEAMBLO.WAV 是對應的音頻文件！ 區分大小寫！ 不然會導致獲取為空！ 遺憾的是，只支持.wav格式的音頻文件！

什麼？還是播放不了？





        protected override void OnPaintBackground(PaintEventArgs e)
        {
            //不進行背景的繪制
        }


                //創建一個進程
                Process pc = new Process();
                pc.StartInfo.FileName = command;
                pc.StartInfo.UseShellExecute = false;
                pc.StartInfo.RedirectStandardOutput = true;
                pc.StartInfo.RedirectStandardError = true;
                pc.StartInfo.CreateNoWindow = true;

                //啟動進程
                pc.Start();

                //准備讀出輸出流和錯誤流
                string outputData = string.Empty;
                string errorData = string.Empty;
                pc.BeginOutputReadLine();
                pc.BeginErrorReadLine();

                pc.OutputDataReceived += (ss, ee) =>
                {
                    outputData += ee.Data;
                };

                pc.ErrorDataReceived += (ss, ee) =>
                {
                    errorData += ee.Data;
                };

                //等待退出
                pc.WaitForExit();

                //關閉進程
                pc.Close();


//字符串轉數組
string mystring="this is a string"
char[] mychars=mystring.ToCharArray();

//foreach循環處理char數組
foreach(char mychar in mystring)
{
Console.WriteLine(mychar);
}
mystring.Length //獲取元素的個數 


        
        

c# 控件閃爍處理方法
如果你在Form中繪圖的話，不論是不是采用的雙緩存，都會看到圖片在更新的時候都會不斷地閃爍，解決方法就是在這個窗體的構造函數中增加以下三行代碼：

請在構造函數裡面底下加上如下幾行：
SetStyle(ControlStyles.UserPaint, true);
SetStyle(ControlStyles.AllPaintingInWmPaint, true); // 禁止擦除背景.
SetStyle(ControlStyles.DoubleBuffer, true); // 雙緩沖
參數說明：

UserPaint
如果為 true，控件將自行繪制，而不是通過操作系統來繪制。此樣式僅適用於派生自 Control 的類。

AllPaintingInWmPaint
如果為 true，控件將忽略 WM_ERASEBKGND 窗口消息以減少閃爍。僅當 UserPaint 位設置為 true 時，才應當應用該樣式。

DoubleBuffer
如果為 true，則繪制在緩沖區中進行，完成後將結果輸出到屏幕上。雙重緩沖區可防止由控件重繪引起的閃爍。要完全啟用雙重緩沖，還必須將 UserPaint 和 AllPaintingInWmPaint 樣式位設置為 true。


/// <summary>
/// 根據url獲取遠程html源碼
/// </summary>
/// <param name="url">搜索url</param>
/// <returns>返回DownloadData</returns>
public static string GetSearchHtml(string url)
{
    WebClient MyWebClient = new WebClient();
    MyWebClient.Credentials = CredentialCache.DefaultCredentials;   //獲取或設置用於對向Internet資源的請求進行身份驗證的網絡憑據。
    Byte[] pageData = MyWebClient.DownloadData(url);                //從指定url下載數據
    return Encoding.UTF8.GetString(pageData);                       //獲取網站頁面采用的是UTF-8
}




C# 關閉窗體立即停止進程
C#在關閉窗體的時候，有時線程還在後台執行，沒有及時退出。
處理方案：
　　為Form添加FormClosing事件，加入以下語句，在退出時，殺死本進程。
System.Diagnostics.Process.GetCurrentProcess().Kill();  



C#的WebBrowser控件浏覽網頁
        private void toolStripButton1_Click(object sender, EventArgs e)
        {
            string add = "";
            if (!(txtUrl.Text.Trim().StartsWith("http://")))
            {
                add = "http://" + txtUrl.Text.Trim();
                txtUrl.Text = add;
            }
            webBrowser1.Url = new Uri(add);
        }


//初始化加載皮膚 
            skinEngine1.SkinFile = "MacOS.ssk"; 

 skinEngine1.SkinFile = "PageColor.ssk"; 


objStreamWriter = new StreamWriter(objFileStream, System.Text.Encoding.Unicode); 



   private DataSet ReadExcel(string strFileName, string sheetName)//使用OLE操作數據庫的方法讀取excel數據，導入到系統 
        { 
            if (strFileName == string.Empty) 
            { 
                return null; 
            } 
            else 
            { 
                string strConnection = "Provider=Microsoft.Jet.OLEDB.4.0;Data Source = " + strFileName + ";Extended Properties = Excel 8.0"; 
                OleDbConnection oleConnection = new OleDbConnection(strConnection); 
                oleConnection.Open(); 
                DataSet dsRead = new DataSet(); 
                OleDbDataAdapter oleAdper = new OleDbDataAdapter(" SELECT *  FROM [" + sheetName + "$]", oleConnection); 
                oleAdper.Fill(dsRead, "result"); 
                oleConnection.Close(); 
                return dsRead;  
            }                                      
        } 
        
        
        
        
        
        
        
        

C#:判斷當前程序是否通過管理員運行，

public bool IsAdministrator()
{
WindowsIdentity current = WindowsIdentity.GetCurrent();
WindowsPrincipal windowsPrincipal = new WindowsPrincipal(current);
return windowsPrincipal.IsInRole(WindowsBuiltInRole.Administrator);
}


C# 文件創建時間，修改時間，

System.IO.FileInfo fi = new System.IO.FileInfo(@"D:\site\EKECMS\skin\Grey\default#.html");
Response.Write("修改時間：" + fi.LastWriteTime.ToString() + "<br>");
Response.Write("創建時間：" + fi.CreationTime.ToString() + "<br>");

//在代碼中設置控件的padding 設置Label的字體
如果要在代碼中設置margin，可以使用如下代碼：
this.label1.Padding = new Padding(20,8,20,8);
或者=new Padding(20);

設置Label的字體代碼：
this.label1.Font = new Font(label1.Font.FontFamily,10f);

設置Label的背景色代碼：
this.label1.BackColor = Color.FromArgb(((int)(((byte)(226)))), ((int)(((byte)(238)))), ((int)(((byte)(255)))));



在不設置Cookie、PostData的情況下要獲得一個頁面 的HTML的方法很簡單：

public static string GetHtml(string URL)
　 　　　{
　　　　　　WebRequest wrt;
　　　　　　wrt = WebRequest.Create(URL);
　　　　　　wrt.Credentials = CredentialCache.DefaultCredentials;
　　　　　　WebResponse wrp;
　　　 　　　wrp = wrt.GetResponse();
　　　　　　return new StreamReader (wrp.GetResponseStream(), Encoding.Default).ReadToEnd();
　　　　} 



地支時間與現在時間的對應關系：

【子時】夜半，又名子夜、中夜：十二時辰的第一個時辰。（23時至次日01時）。

【丑時】雞鳴，又名荒雞：十二時辰的第二個時辰。（01時至03時）。

【寅時】平旦，又稱黎明、早晨、日旦等：時是夜與日的交替之際。（03時至05時）。

【卯時】日出，又名日始、破曉、旭日等：指太陽剛剛露臉，冉冉初升的那段時間。（05 時至07時）。

【辰時】食時，又名早食等：古人“朝食”之時也就是吃早飯時間，（07時至 09時）。

【巳時】隅中，又名日禺等：臨近中午的時候稱為隅中。（09時至11時）。

【午時】日中，又名日正、中午等：（11時至13時）。

【未時】日昳，又名日跌、日央等：太陽偏西為日跌。（13時至15時）。

【申時】哺時，又名日鋪、夕食等：（15時至17時）。

【酉時】日入，又名日落、日沉、傍晚：意為太陽落山的時候。（17時至19時）。　

【戌時】黃昏，又名日夕、日暮、日晚等：此時太陽已經落山，天將黑未黑。天地昏黃，萬物朦胧 ，故稱黃昏。（19時至21時）。

【亥時】人定，又名定昏等：此時夜色已深，人們也已經停止活動，安歇睡眠了。人定也就是人靜 。（21時至23時）。




開關檔案 使用指定的編碼
StreamWriter outStream = new StreamWriter( filepath,false,System.Text.Encoding.GetEncoding( 950 ) );
using ( StreamReader sr = new StreamReader( filepath,System.Text.Encoding.GetEncoding( 936 ) ) )




//Winform中如何讀取局域網路由的IP地址代碼
System.Net.WebClient client = new System.Net.WebClient();
client.Encoding = System.Text.Encoding.Default;
string lip = client.DownloadString("http://www.ip138.com/ip2city.asp");
string sip = reply.Substring(reply.IndexOf("您的IP地址是"), reply.IndexOf("</center>") - reply.IndexOf("您的IP地址是"));
MessageBox.Show(sip);


C#之讀取web上的xml
string　sURL　=　"http://localhost:9058/GameServerInfo/XMLFile.xml";
XDocument　oXDoc　=　XDocument.Load(sURL);

用C＃實現在客戶區拖動窗體



C# WindowsMediaPlayer 的一些用法

播放單首歌曲

                player.URL = 

添加多首歌曲到播放列表

            IWMPPlaylist playList = player.playlistCollection.newPlaylist(); 
 (DataRow drItem = player.newMedia(drItem[].ToString()); 
=

 或者直接在當前列表上添加

 (DataRow drItem = player.newMedia(drItem[].ToString()); 


設置播放器音量

 player.settings.volume=;


 設置循環播放

player.settings.setMode(, );

 

設置隨機播放


  player.settings.setMode(, );




C#調用默認浏覽器打開網頁的幾種方法




方法一：從注冊表中讀取默認浏覽器可執行文件路徑

 

        private void button1_Click(object sender, EventArgs e)
        {
            //從注冊表中讀取默認浏覽器可執行文件路徑
            RegistryKey key = Registry.ClassesRoot.OpenSubKey(@httpshellopencommand);
            string s = key.GetValue().ToString();

            //s就是你的默認浏覽器，不過後面帶了參數，把它截去，不過需要注意的是：不同的浏覽器後面的參數不一樣！
            //D:Program Files (x86)GoogleChromeApplicationchrome.exe -- %1
            System.Diagnostics.Process.Start(s.Substring(0, s.Length - 8), http://blog.csdn.net/testcs_dn);
        }
方法二：
        private void button2_Click(object sender, EventArgs e)
        {
            //調用系統默認的浏覽器 
            System.Diagnostics.Process.Start(explorer.exe, http://blog.csdn.net/testcs_dn);
        }
方法三：
        private void button3_Click(object sender, EventArgs e)
        {
            //調用系統默認的浏覽器 
            System.Diagnostics.Process.Start(http://blog.csdn.net/testcs_dn);
        }

方法四：調用IE浏覽器


從原理上來講，方法二和方法三應該是一樣的，不過方法三的代碼更短一點。 




命令行msinfo32


三、添加office相關引用
Microsoft.Office.Interop.Word 12.0.0.0





using System.Data.OleDb;
using System.Data.SqlClient;
using System.IO;
using Microsoft.Office.Core;
using Word=Microsoft.Office.Interop.Word;
using System.Reflection;

如果其路徑包含後綴名的話，要取得後綴名，只需要一行代碼即可：
1 var ext = System.IO.Path.GetExtension("C:\\soar.jpg");






用C#獲取硬盤ID編號
在軟件產品中常常需要制作軟件注冊碼，而根據硬件產品編號制作注冊碼是一個不錯得選擇。可以使用讀取注冊表的方式獲得第一塊硬盤的編號。 主要程序代碼。

private void button1_Click(object sender, EventArgs e)
{
    textBox1.Text = Registry.GetValue("HKEY_Local_Machine\\HardWare\\Devicemap\\Scsi\\Scsi port 0\\Scsi Bus 0\\Target Id 1\\Logical Unit Id 0","Identifier","cuowu").ToString();
}



            richTextBox1.Text += "string.PadLeft 字串統一長度或補字元\n";
            int a = 15;
            string s1 = a.ToString().PadLeft(10, '-');
            richTextBox1.Text += s1 + "\n";

            string s2 = string.Format("{0:00000}", Convert.ToInt16(a));
            richTextBox1.Text += s2 + "\n";





            //System.Text.StringBuilder("")
            //字元串相加，（+號是不是也一樣？）
            System.Text.StringBuilder sb = new System.Text.StringBuilder("");
            sb.Append("AB");
            sb.Append("CD");
            sb.Append("EFG");

            richTextBox1.Text += sb + "\n";



設定資料到剪貼簿
                Clipboard.SetText(textBox1.Text);
                MessageBox.Show("已成功將文本框內容復制到剪貼板!");
                
從剪貼簿取得資料
            string txt2 = textBox2.Text;
            try
            {
                IDataObject iData = Clipboard.GetDataObject();
                if (iData.GetDataPresent(DataFormats.Text))
                {
                    //MessageBox.Show((string)iData.GetData(DataFormats.Text));
                    textBox2.Text = (string)iData.GetData(DataFormats.UnicodeText);
                }
                else
                {
                    MessageBox.Show("目前剪貼板中數據不可轉換為文本", "錯誤");
                }
            }
            
                            

String.Format是將指定的 String類型的數據中的每個格式項替換為相應對象的值的文本等效項。 
如:

（1）
string p1 = "Jackie";
string p2 = "Aillo";
Response.Write(String.Format("Hello {0}, I'm {1}", p1, p2));
（2）
Response.Write(String.Format("Hello {0}, I'm {1}", "Jackie", "Aillo"));


求取字母的ASCII值

            Console.Write("輸入一個字符："); 
            char c = Console.ReadKey().KeyChar; 
            Console.WriteLine("\r\n字符{0}的ASCII值是：{1}", c, (int)c); 
            Console.ReadKey(false); 



DataGridView 指定欄位排序

// 根據 資料行1 (Name) 做 大到小 排序
dataGridView1.Sort(dataGridView1.Columns[1], System.ComponentModel.ListSortDirection.Descending); 

// 根據 資料行1 (Name) 做 小到大 排序 
dataGridView1.Sort(dataGridView1.Columns[1], System.ComponentModel.ListSortDirection.Ascending); 



    
    
            //                    來源位置             目的位置      要傳輸的區域大小  判斷在像素複製作業中來源色彩如何與目的色彩結合以產生最後的色彩
            //g.CopyFromScreen(new Point(x_st, y_st), new Point(0, 0), new Size(w, h), CopyPixelOperation.SourceInvert);
            //g.CopyFromScreen(new Point(x_st, y_st), new Point(0, 0), new Size(w, h));
            g.CopyFromScreen(new Point(pt.X - w / 2, pt.Y - h / 2), new Point(0, 0), new Size(w, h));


//隨機生成四位驗證碼（0~9，a~Z）
            int LEN = 4;
            Random r = new Random();
            string code = "0123456789abcdefghjklmnopqistuvwxyzABCDEFGHIJKLMNOPQISTUVWXYZ";
            string captcha = "";
            for (int i = 0; i < LEN; i++)
            {
                int ra = r.Next(code.Length);
                captcha = code.Substring(ra, 1) + captcha;
            }
            richTextBox1.Text += captcha + "\n";
            
            
using System.Reflection;
            //取得 namespaceName
            string namespaceName = Assembly.GetExecutingAssembly().GetName().Name.ToString();

            richTextBox1.Text += namespaceName + "\n";

            richTextBox1.Text += Assembly.GetExecutingAssembly().Location + "\n";


//播放音樂
using System.Media;
            string filename = @"C:\______test_files\_wav\start.wav";
            SoundPlayer sp = new SoundPlayer(filename);
            sp.Play();
        
        
      //挪用體系默許的閱讀器 
      System.Diagnostics.Process.Start( "http://www.谷歌.cn");  


            string foldername = @"C:\______test_files\_pic";
            DirectoryInfo TheFolder = new DirectoryInfo(foldername);

            richTextBox1.Text += "遍歷文件夾\n";
            //遍歷文件夾
            foreach (DirectoryInfo NextFolder in TheFolder.GetDirectories())
            {
                this.listBox1.Items.Add(NextFolder.Name);
                richTextBox1.Text += NextFolder.Name+"\n";
            }
            richTextBox1.Text += "\n";

            richTextBox1.Text += "遍歷文件\n";
            foreach (FileInfo NextFile in TheFolder.GetFiles())
            {
                this.listBox2.Items.Add(NextFile.Name);
                richTextBox1.Text += NextFile.Name + "\n";
            }
            richTextBox1.Text += "\n";



16進制與字符串、字節數組之間的轉換。，

1.將十進制數的字符串轉化成十六進制數的字符串

//十進制轉二進制
Console.WriteLine("十進制166的二進制表示: "+Convert.ToString(166, 2));
//十進制轉八進制
Console.WriteLine("十進制166的八進制表示: "+Convert.ToString(166, 8));
//十進制轉十六進制
Console.WriteLine("十進制166的十六進制表示: "+Convert.ToString(166, 16));
    
//二進制轉十進制
Console.WriteLine("二進制 111101 的十進制表示: "+Convert.ToInt32("111101", 2));
//八進制轉十進制
Console.WriteLine("八進制 44 的十進制表示: "+Convert.ToInt32("44", 8));
//十六進制轉十進制
Console.WriteLine("十六進制 CC的十進制表示: "+Convert.ToInt32("CC", 16));

2.16進制與字符串、字節數組之間的轉換

            richTextBox1.Text += "取得網頁資料\n";
            string strUrl = "https://www.google.com.tw/"; //獲得IP的網址了

            Uri uri = new Uri(strUrl);
            System.Net.WebRequest wr = System.Net.WebRequest.Create(uri);
            System.IO.Stream s = wr.GetResponse().GetResponseStream();
            System.IO.StreamReader sr = new System.IO.StreamReader(s, Encoding.Default);
            string all = sr.ReadToEnd(); //讀取網站的數據
            richTextBox1.Text += all + "\n";



 C# 修改啟始Form [複製鏈接]
打開program.cs，修改Application.Run(new Form1());，將Form1改為要啟始的頁面即可!


網際網路時間伺服器，
從原來的 time.windows.com 改為 time.nist.gov，


C# 播放 wav 或音樂檔方式

在 C# 內播放 wav或音樂檔案方式，可使用下面範例實現
Sample Code

System.Media.SoundPlayer sp = new System.Media.SoundPlayer();
sp.SoundLocation = @"C:\Wave音效檔\DoReMe.wav";
sp.Play(); // 撥放
..
..
..
sp.Stop(); // 停止

 
 
 



//如何取得網路上的圖片並顯示 
            string url = @"https://upload.wikimedia.org/wikipedia/commons/0/0f/Ic-photo-intel-D4004.png";
            this.pictureBox1.Image = ReadImageFromUrl(url);

        private Image ReadImageFromUrl(string urlImagePath)
        {
            Uri uri = new Uri(urlImagePath);
            WebRequest webRequest = WebRequest.Create(uri);
            Stream stream = webRequest.GetResponse().GetResponseStream();
            Image res = Image.FromStream(stream);
            return res;

        }



3. 如何为一个窗体设置一个默认按钮？（How to set the default button for a form?）

form1.AcceptButton = button1;

4. 如何为一个窗体设置一个取消按钮？（How to set the Cancel button for a form?）

form1.CancelButton = button1;

5. 如何阻止一个窗体标题显示在任务栏上？（How to prevent a form from being shown in the taskbar?）

设置窗体的ShowIntaskbar属性为False

9. 如何获取应用程序当前执行的路径？（How to get the path to my running EXE?）

string appPath = Application.ExecutablePath; 

23. 如何使Windows Form上的Panel或者Label控件半透明？（How to make a Panel or Label semi-transparent on a Windows Form? ）

通过设置控件背景色的alpha值
panel1.BackColor = Color.FromA#41ccd4;
注意：在设计时手动输入这些值，不要用颜色选取


設定倒數計時
        DateTime dtTarget;
        private void Form1_Load(object sender, EventArgs e)
        {
            //dtTarget = DateTime.Now.AddHours(2);  //設定兩小時後
            dtTarget = new DateTime(2021, 9, 30, 12, 0, 0);   //設定特定時間

            timer1.Start();
        }

        private void timer1_Tick(object sender, EventArgs e)
        {
            TimeSpan diffTime = dtTarget.Subtract(DateTime.Now);

            string diffHour = Convert.ToString(diffTime.Hours);
            string diffMin = Convert.ToString(diffTime.Minutes);
            string diffSec = Convert.ToString(diffTime.Seconds);
            label1.Text = "距離 " + dtTarget.ToString() + " 還有 " + diffHour + " 時 " + diffMin + " 分 " + diffSec + " 秒";

        }


        //執行時期 顯示 屬性編輯視窗
        private void Form1_Load(object sender, EventArgs e)
        {
            PropertyGrid PG = new PropertyGrid();
            Form PGForm = new Form();
            PGForm.Owner = this;
            PGForm.StartPosition = FormStartPosition.Manual;
            PGForm.Left = this.Left + this.Width;
            PGForm.Top = this.Top;
            PGForm.ShowInTaskbar = false;
            PGForm.Controls.Add(PG);
            PG.Dock = DockStyle.Fill;
            PG.SelectedObject = this.label1;  //選擇要顯示的控件名稱
            PGForm.Text = "Label 屬性編輯視窗";
            PGForm.Show();
        }



驗證台灣手機號碼
            bool match;
            match = System.Text.RegularExpressions.Regex.IsMatch(textBox1.Text, @"^09[0-9]{8}$");
            if (match == true)
            {
                richTextBox1.Text += "OK\n";
                     
            }
            else
            {
                richTextBox1.Text += "NG\n";
            }



陣列
一群資料型態相同的變數集合在一起

反向運算子



要顯示 & 以 ＆amp;取代
要顯示 < 以 ＆lt;取代
要顯示 > 以 ＆gt;取代
要顯示 " 以 ＆quot;取代
要顯示 ' 以 ＆apos;取代

Unicode中文字碼（CJK Unified Ideographs；中日韓統一表意文字）的範圍落在0x4E00至0x9FFF（UTF-32），但迄今（Unicode v11.0）最末的0x9FF0～0x9FFF這16個字仍是空白。


#define abs(a, b)	(((a) > (b)) ? (a - b) : (b - a))

printf("function: %s:%s(%d) debug message\r\n",__FILE__,__func__,__LINE__);
       

內建函式

if(isprint(ch))
系統時間

函式 abs dec2hex hex2dec print9X9_Table

VC#
資料型態	string(字串) bool(布耳)
各種控件	button richtextbox picturebox timer

ENUM的用法
        // 定義WeekDays列舉內容7個成員
        // 用來表示一星期的星期日到星期六的列舉常數值
        enum WeekDays : int
        {
            Monday = 1,      	// 星期一
            Tuesday = 2,         // 星期二
            Wednesday = 3,       // 星期三
            Thursday = 4,        // 星期四
            Friday = 5,          // 星期五
            Saturday = 6,        // 星期六
            Sunday = 7           // 星期日
        };

        static void Main(string[] args)
        {
            // 取出WeekDays.Wednesday列舉常數值之後再轉成整數
            Console.WriteLine("星期三列舉常數值：{0}", (int)WeekDays.Wednesday);
            Console.WriteLine("星期五列舉常數值：{0}", (int)WeekDays.Friday);
            Console.Read();
        }
        

colsole mode的scanf        
        
            // 宣告字串資料型別ProductName變數，用來存放品名
            string ProductName;
            // 宣告整數資料型別Price變數，用來存放單價
            int Price;
            Console.Write("請輸入品名：");        // 印出 "請輸入品名："
            // 由鍵盤輸入品名資料並按 [Enter]鍵，即將品名存放至ProductName變數
            ProductName = Console.ReadLine();
            Console.Write("請輸入單價：");         // 印出 "請輸入單價："
            // 由鍵盤輸入單價並按 [Enter]鍵，將單價轉成整數之後
            // 再將單價放至Price變數
            Price = int.Parse(Console.ReadLine());
            Console.WriteLine("品名：{0}　單價：{1}　這筆記錄儲存成功",ProductName, Price);
            Console.Read();

console mode讀取double數字
            double netIncome;
            int taxRate;

            Console.Write("請輸入全年綜合所得淨額(單位:萬元) : ");
            netIncome = double.Parse(Console.ReadLine());

console mode讀取字串
            // 宣告Ans字串變數用來存放使用者由鍵盤輸入的答案
            string Ans = Console.ReadLine();
                        
struct用法

        // 定義Product產品結構資料型別
        struct Product
        {
            // Product產品結構內含No編號欄位、Name品名欄位、Price單價欄位
            public string No, Name;
            public int Price;
       }

       static void Main(string[] args)
        {
            // 宣告game結構變數為Product結構型別
             Product game;
            // 設定game.No編號欄位的值為 "G01"
            game.No = "G01";
            // 設定game.Name品名欄位的值為"XBox One"
            game.Name = "XBox One";
            // 設定game.Price單價欄位的值為10000
            game.Price = 10000;
            Product cookie;        // 宣告cookie結構變數為Product結構型別
            Console.Write(" 請輸入產品編號：");
            // 由鍵盤輸入編號再指定給cookie.No編號欄位
            cookie.No = Console.ReadLine();
            Console.Write(" 請輸入產品名稱：");
            // 由鍵盤輸入品名再指定給cookie.Name品名欄位
            cookie.Name = Console.ReadLine();
            Console.Write(" 請輸入產品單價：");
            // 由鍵盤輸入單價並轉成整數再指定給cookie.Price單價欄位
            cookie.Price = int.Parse(Console.ReadLine());
            Console.WriteLine();
            Console.WriteLine(" ====== 產品單價清單 ====== ");
            Console.WriteLine();
            // 印出game及cookie結構的編號、品名及單價
            Console.WriteLine(" 產品編號：{0} ", game.No);
            Console.WriteLine(" 產品名稱：{0} ", game.Name);
            Console.WriteLine(" 產品單價：{0} ", game.Price);
            Console.WriteLine(" 產品編號：{0} ", cookie.No);
            Console.WriteLine(" 產品名稱：{0} ", cookie.Name);
            Console.WriteLine(" 產品單價：{0} ", cookie.Price);
            Console.Read();
        }



        
        
        
#include <stdio.h>
int main(int argc,char* argv[])
{



    /*
	int i;

	time_t time_ptr;

	printf("david: This is a c template.\n");

	printf("function: %s:%s(%d) debug message\r\n",__FILE__,__func__,__LINE__);


	time(&time_ptr);

	printf("現在時間 : %s\n", asctime(localtime(&time_ptr)));
*/


    time_t t1 = time(NULL);
    struct tm *nPtr = localtime(&t1);
    char *now = asctime(nPtr);

    printf("現在時間 : %s\n", now);
    printf("len = %d\n",sizeof(now));

    int i;

    for(i=0;i<sizeof(now);i++)
    {
        printf("%c\n", now[i]);


    }



    //srand(123);
    srand(now[0]);

    for(i=0;i<10;i++)
    {
        printf("%c\n", 'A' + rand() % 26);

    }

	return 0;
}
        
        
        
        



Display_Cam1

            //pictureBox1.Image = (Bitmap)eventArgs.Frame.Clone();
            bm = (Bitmap)eventArgs.Frame.Clone();
            //bm.RotateFlip(RotateFlipType.RotateNoneFlipY);    //反轉
            pictureBox1.Image = bm;

            GC.Collect();       //回收資源

//--------------------------

            //录像
            //pictureBox1.Image = (Bitmap)eventArgs.Frame.Clone();
            bm = (Bitmap)eventArgs.Frame.Clone();
            //bm.RotateFlip(RotateFlipType.RotateNoneFlipY);    //反轉
			
            Graphics g = Graphics.FromImage(image);
			
			
										SolidBrush drawBrush = new SolidBrush(Color.Yellow);

										Font drawFont = new Font("Arial", 6, System.Drawing.FontStyle.Bold, GraphicsUnit.Millimeter);
										int xPos = image.Width - (image.Width - 15);
										int yPos = 10;
										//写到屏幕上的时间
										string drawDate = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss");

										g.DrawString(drawDate, drawFont, drawBrush, xPos, yPos);

            ////创建文件路径
            string fileFullPath = videoPath + "V1" + DateTime.Now.ToString("yyyy-MM-dd-HH-mm-ss");

            if (stopREC)
            {
                stopREC = true;
                createNewFile = true;  //这里要设置为true表示要创建新文件
                if (videoWriter != null)
                    videoWriter.Close();
            }
            else
            {
										//开始录像
										if (createNewFile)
										{

											createNewFile = false;
											if (videoWriter != null)
											{
												videoWriter.Close();
												videoWriter.Dispose();
											}
											richTextBox1.Text += "開啟檔案 : " + fileFullPath + "\n";

											videoWriter = new VideoFileWriter();
											//这里必须是全路径，否则会默认保存到程序运行根据录下了
											videoWriter.Open(fileFullPath, image.Width, image.Height, 30, VideoCodec.MPEG4);
											videoWriter.WriteVideoFrame(image);
										}
										else
										{
											videoWriter.WriteVideoFrame(image);
										}
            }



fileFullPath : C:\_git\vcs\_2.vcs\my_vcs_lesson_c_example\_video\OperateCamera\bin\Debug\V12021-08-20-15-39-07





關掉AForge的VSP
        // Close currently open camera if any
        private void CloseCamera()
        {
            if (videoSource != null)
            {
                videoSourcePlayer.VideoSource = null;

                videoSource.SignalToStop();
                videoSource.WaitForStop();
                videoSource = null;
            }
        }		




			

                string appDir = Path.GetDirectoryName(Assembly.GetCallingAssembly().GetName().CodeBase);
                path = Path.Combine(appDir, path);

        private static string FFMPEG_EXE_PATH = CheckRelativePath(@"ffmpeg\ffmpeg.exe");
        private static string FFPROBE_EXE_PATH = CheckRelativePath(@"ffmpeg\ffprobe.exe");

            string cmdParams = String.Format("-hide_banner -ss {0} -i {1} -r 1 -t 1 -f image2 {2}", atPositioin, filename, tmpFileName);

                // Execute command to let FFMPEG extract the frame
                Execute(FFMPEG_EXE_PATH, cmdParams);

        private static string Execute(string exePath, string parameters)
        {
            string result = String.Empty;

            using (Process p = new Process())
            {
                p.StartInfo.UseShellExecute = false;
                p.StartInfo.CreateNoWindow = true;
                p.StartInfo.RedirectStandardOutput = true;
                p.StartInfo.FileName = exePath;
                p.StartInfo.Arguments = parameters;
                p.Start();
                p.WaitForExit();

                result = p.StandardOutput.ReadToEnd();
            }

            return result;
        }



在 C# 中使用 File.ReadAllText() 方法將檔案讀取為字串
string text = File.ReadAllText(@"C:\File\file.txt");
Console.WriteLine(text);

在 C# 中使用 StreamReader.ReadToEnd() 方法將檔案讀取為字串
StreamReader fileReader = new StreamReader(@"C:\File\file.txt");
string text = fileReader.ReadToEnd();
Console.WriteLine(text);			

使用 C# 中的 FileInfo.Length 屬性獲取檔案大小



            FileInfo fileinfo = new FileInfo("dark.jpg");
            Console.WriteLine(fileinfo.Length);
FileInfo 類提供了用於在 C# 中建立，開啟，複製，刪除和移動檔案的方法。


在 C# 中使用 BitConverter.ToString() 方法將字串轉換為十六進位制

            string decString = "0123456789";
            byte[] bytes = Encoding.Default.GetBytes(decString);
            string hexString = BitConverter.ToString(bytes);
            hexString = hexString.Replace("-", "");
            Console.WriteLine(hexString);



在 C# 中使用 String.Format() 方法將字串轉換為十六進位制
            string decString = "0123456789";
            var hexString = string.Join("",
                decString.Select(c => String.Format("{0:X2}", Convert.ToInt32(c))));
            Console.WriteLine(hexString);


Process.Start("http://www.mrbccd.com");

//打开注册表
string regeditstr = Environment.GetEnvironmentVariable("WinDir");//WinDir系统环境变量的名称
Process.Start(regeditstr + "\\regedit.exe");//打开注册表


//開啟檔案總管到指定的目錄
string Path = @"C:\dddddddddd";
Process.Start("explorer.exe", Path);

Process.Start(textBox1.Text);//打开文件夹进行查看

richTextBox1.Text += "在任務欄中顯示\n";
this.ShowInTaskbar = true;

richTextBox1.Text += "不在任務欄中顯示\n";
this.ShowInTaskbar = false;


this.StartPosition = FormStartPosition.CenterScreen;//視窗居中顯示


MainMenu選了之後會有打勾記號

        // On Size menu item popup
        private void sizeItem_Popup(object sender, System.EventArgs e)
        {
            normalSizeItem.Checked = (pictureBox.SizeMode == PictureBoxSizeMode.Normal);
            stretchedSizeItem.Checked = (pictureBox.SizeMode == PictureBoxSizeMode.StretchImage);
            centeredSizeItem.Checked = (pictureBox.SizeMode == PictureBoxSizeMode.CenterImage);
        }



richTextBox1.Text += "測試使用WindowsMediaPlayerClass\n";
WindowsMediaPlayerClass c;
IWMPMedia m;

c = new WindowsMediaPlayerClass();
m = c.newMedia(mp3_filename);
richTextBox1.Text += "歌手名:\t" + m.getItemInfo("Author") + "\n" + "歌  名:\t" + m.getItemInfo("Title") + "\n";


getItemInfo Author Title

// Store the current media object.
var cm = Player.currentMedia;

// Get the number of attributes for the current media. 
var atCount = cm.attributeCount;

// Loop through the attribute list.
for(var i=0; i < atCount; i++){

   // Print each attribute index and name.   
   myText.value += "Attribute " + i +": ";
   myText.value += cm.getAttributeName(i);
   myText.value += "\n";
}




//添加列表
WC = new WMPLib.WindowsMediaPlayerClass();
MC = WC.newMedia(str);
this.axWindowsMediaPlayer1.currentPlaylist.appendItem(MC);
richTextBox1.Text += "add " + str + "\n";




            /*  無法依子目錄排序 廢棄
            if (path == String.Empty)
                path = search_path;

            //C# 取得資料夾下的所有檔案(包括子目錄)
            string[] files = Directory.GetFiles(path, filetype2, System.IO.SearchOption.AllDirectories);
            foreach (string filename in files)
            {
                //richTextBox1.Text += filename + "\n";
                FileInfo fi = new FileInfo(filename);
                richTextBox1.Text += fi.Name + "\n";
            }
            */



string newID = id.Insert(6, "19");


        private void button1_Click(object sender, EventArgs e)
        {
            richTextBox1.Text += "檢查IP合法性\n";
            string[] lines = new string[4];
            string s = ".";
            string ip = "192.168.0.123";

            lines = ip.Split(s.ToCharArray(), 4);

            for (int i = 0; i < 4; i++)
            {
                if (Convert.ToInt32(lines[i]) >= 255)
                {
                    richTextBox1.Text += "不合法\n";
                    return;
                }
            }
            richTextBox1.Text += "合法\n";
			

        }




如何清除播放清單

顯示播放清單的內容

播放清單移除特定檔案






        public override string show()
        {
            return base.show() +
                   ": 寬 = " + width +
                   ", 高 = " + height;
        }
		
        public string listing()
        {
            string res = "";

            for (int i = 0; i < count; i++)
            {   // polymorphism
                Shape s = shapeArray[i];
                res += s.show() + ", 面積 = " + s.area() +
                       "\r\n-----------------------\r\n";
            }

            return res;
        }




計算程式執行的時間

int URms = System.Environment.TickCount;

XXXXXXXXX

Console.WriteLine("花費 {0} ms 完成!!!", Environment.TickCount - URms);






//紀錄開始的時間
Stopwatch sw = new Stopwatch();//引用stopwatch物件

sw.Reset();//時間歸零
sw.Start();
sw.Stop();

            label1.Text = "經過時間: " 
                + sw.Elapsed.Hours.ToString().PadLeft(2,'0') + ":"
                + sw.Elapsed.Minutes.ToString().PadLeft(2, '0') + ":"
                + sw.Elapsed.Seconds.ToString().PadLeft(2, '0');
				
				

做一個我的 Transform範例

角度-180~+180
正弦值 -1~+1

xmin = -180;
xmax = 180;
ymin = -1;
ymax = 1;
xmargin = 10;
ymargin = 0.2;

顯示區域寬度W  if 720
顯示區域高度H  if 360

xratio = W/(xmax-xmin+xmargin*2);     //2 倍
yratio = H/(ymax-ymin+ymargin*2);     //180 倍

x=xmin:1:xmax;
y=sind(x);

先不考慮margin  把圖畫在中間

畫x時 每點相距 2 pixel

畫y時 要放大180倍

for(i=0; i<360;i++)
{
 x_new = x_old*2;
 y_new = y_old*180;
}


            e.Graphics.Clear(picGraph.BackColor);
            if (Balance.Count < 2) return;

            e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;

            // Scale to make the data fit.
            float xmin = -1;
            float xmax = Contributions.Count + 1;
            float ymax = Balance.Max(pt => pt.Y);
            float ymin = -ymax * 0.05f;
            RectangleF rect = new RectangleF(xmin, ymin, xmax - xmin, ymax - ymin);
            PointF[] pts =
            {
                new PointF(0, picGraph.ClientSize.Height),
                new PointF(picGraph.ClientSize.Width, picGraph.ClientSize.Height),
                new PointF(0, 0),
            };
            Transform = new Matrix(rect, pts);
            e.Graphics.Transform = Transform;




        string drap_setup_filename = "drap_setup.ini";

        void update_setup_file()
        {
            richTextBox2.Text += "update_setup_file ST\n";
            richTextBox2.Text += "length of old_search_path = " + old_search_path.Count.ToString() + "\n";

            {
                StreamWriter sw = File.CreateText(drap_setup_filename);
                string content = "";
                //定義系統版本
                Version ver = Environment.OSVersion.Version;
                //Major主版本號,Minor副版本號
                if (ver.Major == 6 && ver.Minor == 1)
                {
                    //Windows7
                    content += "\"C:\\Program Files\\DAUM\\PotPlayer\\PotPlayerMini.exe\"\n";
                }
                else
                {
                    //Windows10
                    content += "\"C:\\Program Files (x86)\\DAUM\\PotPlayer\\PotPlayerMini.exe\"\n";
                }
                content += "\"C:\\Program Files (x86)\\AIMP\\AIMP.exe\"\n";
                content += "\"C:\\Program Files (x86)\\ACDSee32\\ACDSee32.exe\"\n";
                content += "\"C:\\Program Files (x86)\\IDM Computer Solutions\\UltraEdit-32\\uedit32.exe\"\n";
                content += SelectedLanguage.ToString() + "\n";
                content += comboBox1.SelectedIndex.ToString() + "\n";
                if (cb_video_only.Checked == true)
                    content += "1\n";
                else
                    content += "0\n";
                if (cb_video_l.Checked == true)
                    content += "1\n";
                else
                    content += "0\n";
                if (cb_video_m.Checked == true)
                    content += "1\n";
                else
                    content += "0\n";
                if (cb_video_s.Checked == true)
                    content += "1\n";
                else
                    content += "0\n";
                if (cb_file_size.Checked == true)
                    content += "1\n";
                else
                    content += "0\n";
                if (cb_file_l.Checked == true)
                    content += "1\n";
                else
                    content += "0\n";
                if (cb_file_m.Checked == true)
                    content += "1\n";
                else
                    content += "0\n";
                if (cb_file_s.Checked == true)
                    content += "1\n";
                else
                    content += "0\n";
                if (cb_generate_text.Checked == true)
                    content += "1\n";
                else
                    content += "0\n";

                /*
                //Major主版本號,Minor副版本號
                if (ver.Major == 6 && ver.Minor == 1)
                {
                    //Windows7
                    video_player_path = @"C:\Program Files\DAUM\PotPlayer\PotPlayerMini.exe";
                }
                else
                {
                    //Windows10
                    video_player_path = @"C:\Program Files (x86)\DAUM\PotPlayer\PotPlayerMini.exe";
                }
                audio_player_path = @"C:\Program Files (x86)\AIMP\AIMP.exe";
                picture_viewer_path = @"C:\Program Files (x86)\ACDSee32\ACDSee32.exe";
                text_editor_path = @"C:\Program Files (x86)\IDM Computer Solutions\UltraEdit-32\uedit32.exe";
                */

                richTextBox2.Text += "目前共有 " + listBox1.Items.Count.ToString() + " 條搜尋路徑\n";

                if (listBox1.Items.Count == 0)
                {
                    content += "C:\\______test_files\n";
                    old_search_path.Add("C:\\______test_files");
                }
                else
                {
                    for (int i = 0; i < listBox1.Items.Count; i++)
                    {
                        richTextBox2.Text += listBox1.Items[i] + "\n";
                        content += listBox1.Items[i] + "\n";
                    }
                }
                content += "\n";

                sw.WriteLine(content, Encoding.UTF8);
                sw.Close();
            }
        }

        void Read_Setup_File()
        {
            int i;
            int tmp;
            if (File.Exists(drap_setup_filename) == false)
            {
                richTextBox2.Text += "檔案 " + drap_setup_filename + " 不存在，製作一個。\n";
                update_setup_file();
            }
            else
            {
                richTextBox2.Text += "檔案 " + drap_setup_filename + " 存在, 開啟，並讀入設定\n";
                string line;
                StreamReader sr = new StreamReader(drap_setup_filename, Encoding.UTF8);
                i = 0;
                while (!sr.EndOfStream)
                {               // 每次讀取一行，直到檔尾
                    line = sr.ReadLine().Trim();            // 讀取文字到 line 變數
                    richTextBox2.Text += "第 " + i.ToString() + " 行資料 : " + line + "\n";
                    switch (i)
                    {
                        case 0:
                            video_player_path = line;
                            break;
                        case 1:
                            audio_player_path = line;
                            break;
                        case 2:
                            picture_viewer_path = line;
                            break;
                        case 3:
                            text_editor_path = line;
                            break;
                        case 4:
                            SelectedLanguage = int.Parse(line);
                            break;
                        case 5:
                            tmp = int.Parse(line);
                            comboBox1.SelectedIndex = tmp;
                            break;
                        case 6:
                            tmp = int.Parse(line);
                            if (tmp == 1)
                                cb_video_only.Checked = true;
                            else
                                cb_video_only.Checked = false;
                            break;
                        case 7:
                            tmp = int.Parse(line);
                            if (tmp == 1)
                                cb_video_l.Checked = true;
                            else
                                cb_video_l.Checked = false;
                            break;
                        case 8:
                            tmp = int.Parse(line);
                            if (tmp == 1)
                                cb_video_m.Checked = true;
                            else
                                cb_video_m.Checked = false;
                            break;
                        case 9:
                            tmp = int.Parse(line);
                            if (tmp == 1)
                                cb_video_s.Checked = true;
                            else
                                cb_video_s.Checked = false;
                            break;
                        case 10:
                            tmp = int.Parse(line);
                            if (tmp == 1)
                                cb_file_size.Checked = true;
                            else
                                cb_file_size.Checked = false;
                            break;
                        case 11:
                            tmp = int.Parse(line);
                            if (tmp == 1)
                                cb_file_l.Checked = true;
                            else
                                cb_file_l.Checked = false;
                            break;
                        case 12:
                            tmp = int.Parse(line);
                            if (tmp == 1)
                                cb_file_m.Checked = true;
                            else
                                cb_file_m.Checked = false;
                            break;
                        case 13:
                            tmp = int.Parse(line);
                            if (tmp == 1)
                                cb_file_s.Checked = true;
                            else
                                cb_file_s.Checked = false;
                            break;
                        case 14:
                            tmp = int.Parse(line);
                            if (tmp == 1)
                                cb_generate_text.Checked = true;
                            else
                                cb_generate_text.Checked = false;
                            break;
                        case 15:
                            search_path = line;
                            break;
                        default:
                            break;
                    }
                    if (i >= 15)
                    {
                        if (line.Length > 0)
                        {
                            richTextBox2.Text += "加入路徑 : " + line + "\n";
                            old_search_path.Add(line);
                        }
                        else
                        {
                            richTextBox2.Text += "空行\n";
                        }
                    }
                    i++;
                }
                sr.Close();
            }
        }





從顏色的名稱 取得顏色的分量
				
				
    Color slateBlue = Color.FromName("SlateBlue");
    byte g = slateBlue.G;
    byte b = slateBlue.B;
    byte r = slateBlue.R;
    byte a = slateBlue.A;
    string text = String.Format("Slate Blue has these ARGB values: Alpha:{0}, " +
        "red:{1}, green: {2}, blue {3}", new object[]{a, r, g, b});
    e.Graphics.DrawString(text, 
        new Font(this.Font, FontStyle.Italic), 
        new SolidBrush(slateBlue), 
        new RectangleF(new PointF(0.0F, 0.0F), this.Size));
        				