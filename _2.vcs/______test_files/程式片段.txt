

            //磁盤配額的wmi版本(C#)

            try
            {
                ManagementClass mc1 = new ManagementClass("Win32_DiskQuota");
                ManagementObject quota = mc1.CreateInstance();
                quota["Limit"] = 400000000;
                quota["WarningLimit"] = 200000000;
                // Get user account object 
                ManagementObject account = new
                ManagementObject("Win32_Account.Domain=TODAY20040216,Name=ASPNET");
                account.Get();
                // get disk object 
                ManagementObject disk = new
                ManagementObject("Win32_LogicalDisk.DeviceId='F:'");
                disk.Get();
                quota["QuotaVolume"] = disk;
                quota["User"] = account;
                quota.Put(); // commit 

                ManagementClass mc2 = new ManagementClass("Win32_DiskQuota");
                Console.WriteLine(mc2.SystemProperties);
                foreach (ManagementObject o in mc2.GetInstances())
                {
                    Console.WriteLine("Next : {0}", o.Path);
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine("error:" + ex);
            } 
            

private void AboutBox_Load(object sender, EventArgs e)
{
　AssemblyInfoClass myAssembly = new AssemblyInfoClass();
　labelProductName.Text = "產品名稱：" + myAssembly.Product;
　labelVersion.Text = "版本：" + myAssembly.Version;
　labelCopyright.Text = "版權宣告：" + myAssembly.Copyright;
　labelCompanyName.Text = "公司名稱：" + myAssembly.Company;
　textBoxDescription.Text = "細部描述：" +
　myAssembly.Description;
}


string newName = Guid.NewGuid().ToString();


C# 之程序退出的方法，
	1.this.Close();   只是關閉當前窗口，若不是主窗體的話，是無法退出程序的，另外若有托管線程（非主線程），也無法干淨地退出；
	2.Application.Exit();  強制所有消息中止，退出所有的窗體，但是若有托管線程（非主線程），也無法干淨地退出；
	3.Application.ExitThread(); 強制中止調用線程上的所有消息，同樣面臨其它線程無法正確退出的問題；
	4.System.Environment.Exit(0);   這是最徹底的退出方式，不管什麼線程都被強制退出，把程序結束的很干淨。



通過C#還可以指定當前線程的運行在哪個CPU上。
 
System.Diagnostics.Process p = Process.GetCurrentProcess(); 
p.ProcessorAffinity = (IntPtr)0x0001; 

Process.ProcessorAffinity 設置當前CPU的屏蔽字，0x0001表示選用一號CPU，0x0002表示選用2號CPU。


直接把DataTable的資料貼到DataGridView上

	//C#之界面上依次出現表格（DataTable和DataGridView提高）
	
	C#之界面上依次出現表格（DataTable和DataGridView提高）
	
	效果圖：
	
	在textBox控件中輸入信息，點擊增加
	
	\
	
	出現如圖：
	
	\
	
	繼續：
	
	\
	
	代碼（沒用csdn插入代碼功能是插入的代碼增刪改不能選中，特別費事，所以下面代碼可能會看的有點亂）：
	
	//創建坡口形式選擇數據表
	dt = new DataTable();
	
	//建九列
	
	dt.Columns.Add("name", typeof(System.String));
	dt.Columns.Add("sex", typeof(System.String));
	dt.Columns.Add("age", typeof(System.String));
	
	//將MongoDB中數據插入到該一行對應的各列中（我這裡是數據存入MongoDB中，在之前取出bson,然後foreach）
	foreach (BsonDocument result in resultList)
	{
	//建一行
	DataRow dr = dt.NewRow();
	//行信息
	dr[0] = 你的數據
	dr[1] = 你的數據
	dr[2] = 你的數據
	//將上述該行加入DataTable中
	dt.Rows.Add(dr);
	
	//綁定在sorce上
	dataGridView1.DataSource = dt;
	
	









使用C# 讀取XML
代碼如下：

XmlReader xmlRead =new XmlTextReader ("C:/XMLWebServicesSBS/xml2/xml/XMLFile1.xml");
    DataSet ds=new DataSet ();
    //ds.ReadXml ("C:/XMLWebServicesSBS/xml2/xml/XMLFile1.xml");
    ds.ReadXml (xmlRead);

this.DataGrid1 .DataSource =ds;
this.DataGrid1 .DataBind ();




//C# 播放聲音
﻿﻿

1.播放系統事件聲音
　　 System.Media.SystemSounds.Asterisk.Play();
　　 System.Media.SystemSounds.Beep.Play();
　　 System.Media.SystemSounds.Exclamation.Play();
　　 System.Media.SystemSounds.Hand.Play();
　　 System.Media.SystemSounds.Question.Play();

2.使用System.Media.SoundPlayer播放.wav格式聲音
　　 SoundPlayer player = new SoundPlayer();
player.SoundLocation = Application.StartupPath + "\\" + "sounds/WallHit.wav";
player.Load(); //同步加載聲音
player.Play(); //啟用新線程播放
//player.PlayLooping(); //循環播放模式
//player.PlaySync(); //UI線程播放

3.利用Windows Media Player

加載COM組件:ToolBox->Choose Items->COM Components->Windows Media Player

把Windows Media Player控件拖放到Winform窗體中，把axWindowsMediaPlayer1中URL屬性設置為MP3或是AVI的文件路徑。


4.MCI Command String多媒體設備的程序接口

using System.Runtime.InteropServices;
　　public static uint SND_ASYNC = 0x0001;
　　public static uint SND_FILENAME = 0x00020000;
　　[DllImport("winmm.dll")]
　　public static extern uint mciSendString(string lpstrCommand,
　　string lpstrReturnString, uint uReturnLength, uint hWndCallback);
　　public void Play()
　　{
　　　　mciSendString(@"close temp_alias", null, 0, 0);
　　　　mciSendString(@"open " "路徑.mp3"" alias temp_alias", null, 0, 0);
　　　　mciSendString("play temp_alias repeat", null, 0, 0);
　　}

關於MCI Command String多媒體設備的程序接口的詳細資料，可以參看http://blog.csdn.net/psongchao/article/details/1487788

  
  



Path.Combine
            //string directory = System.AppDomain.CurrentDomain.BaseDirectory;
            //this.iniFilePath = Path.Combine(directory, "config.ini");



//            return String.Format("{0}-{1}-{2}-{3}-{4}", x1, x2, x3, x4, x5);


            string md5 = Safety.MD5(key);


public class Safety
{
       public static string MD5(string str)
       {
              string strResult = "";
              MD5 md5 = System.Security.Cryptography.MD5.Create();
              byte[] bData = md5.ComputeHash(Encoding.Unicode.GetBytes(str));
              for (int i = 0; i < bData.Length; i++)
              {
                     strResult = strResult + bData[i].ToString("X");
              }
              return strResult;
       }
}



//C#最簡單的文本加密，

private char[] TextEncrypt(string content, string secretKey)
{
    char[] data = content.ToCharArray();
    char[] key = secretKey.ToCharArray();

    for (int i = 0; i < data.Length; i++)
    {
        data[i] ^= key[i % key.Length];
    }

    return data;
}

private string TextDecrypt(char[] data, string secretKey)
{
    char[] key = secretKey.ToCharArray();

    for (int i = 0; i < data.Length; i++)
    {
        data[i] ^= key[i % key.Length];
    }

    return new string(data);
}

/*
上面是最簡單的加密和解密文本的函數，不需要任何庫文件支持，只是把原文和密鑰進行字節的異或，想要把密文翻譯回來，很簡單，拿著密文和密鑰重新異或一次就可以。

如果密鑰正確的話，就會回來正確的原始文本，如果密鑰錯誤的話，翻譯回來的就會是一堆的亂碼。

所以也起到了最簡單的加密功能。
*/



//C#獲取機器碼

1 /// <summary>   
 2     /// 機器碼   
 3     /// </summary>   
 4    public class MachineCode   
 5     {   
 6         ///   <summary>    
 7         ///   獲取cpu序列號        
 8         ///   </summary>    
 9         ///   <returns> string </returns>    
10         public string GetCpuInfo()   
11         {   
12             string cpuInfo = " ";   
13             using (ManagementClass cimobject = new ManagementClass("Win32_Processor"))   
14             {   
15                 ManagementObjectCollection moc = cimobject.GetInstances();   
16   
17                 foreach (ManagementObject mo in moc)   
18                 {   
19                     cpuInfo = mo.Properties["ProcessorId"].Value.ToString();   
20                     mo.Dispose();   
21                 }   
22             }   
23             return cpuInfo.ToString();   
24         }   
25   



C#如何取硬件標志

  //取機器名 
  public string GetHostName()
  {
   return System.Net.Dns.GetHostName(); 
  }

  //取CPU編號
  public String GetCpuID() 
  {
   try
   {
    ManagementClass mc = new ManagementClass("Win32_Processor");
    ManagementObjectCollection moc = mc.GetInstances();

    String strCpuID = null ;
    foreach( ManagementObject mo in moc ) 
    {
     strCpuID = mo.Properties["ProcessorId"].Value.ToString();
     break; 
    }
    return strCpuID;
   }
   catch
   {
    return "";
   }

  }//end method

  //取第一塊硬盤編號
  public String GetHardDiskID() 
  {
   try
   {
    ManagementObjectSearcher searcher = new ManagementObjectSearcher("Select * FROM Win32_PhysicalMedia");
    String strHardDiskID = null ;
    foreach(ManagementObject mo in searcher.Get()) 
    {    
     strHardDiskID = mo["SerialNumber"].ToString().Trim();
     break;          
    }
    return strHardDiskID ;
   }
   catch
   {
    return "";
   }
  }//end 


用C#和WMI獲取邏輯驅動器詳細信息
	
	SelectQuery selectQuery = new SelectQuery("win32_logicaldisk");
	
	　　或者使用wql查詢來創建查詢類的實例，代碼如下：
	
	SelectQuery selectQuery = new SelectQuery("select * from win32_logicaldisk");
	
	　　或者只獲取類的部分屬性，代碼如下：
	
	SelectQuery selectQuery = new SelectQuery("select Name,DriveType from win32_logicaldisk");
	
	
	SelectQuery selectQuery = new SelectQuery("select * from win32_logicaldisk");
	
	ManagementObjectSearcher searcher = new ManagementObjectSearcher(selectQuery);
	　　int i=0;
	foreach (ManagementObject disk in searcher.Get()) {
	　//獲取驅動器盤符
	　listView1.Items.Add(disk["Name"].ToString());
	}








C# 獲得主板參數程序代碼
public static void Mainboard(out string[] 制造商, out string[] 型號)
{
        ManagementObjectSearcher searcher = new ManagementObjectSearcher("SELECT * FROM Win32_BaseBoard");
        制造商 = new string[searcher.Get().Count];
        型號 = new string[searcher.Get().Count];
        int i = 0;
        foreach (ManagementObject share in searcher.Get())
        {
                制造商[i] = share.GetPropertyValue("Manufacturer").ToString();
                型號[i] = share.GetPropertyValue("Product").ToString();
                i ;
        }
} 


C# 獲得主板序列號程序代碼

C# 獲得主板序列號程序代碼如下：
public static void MainboardSerialNumber(out string[] 序列號)
{
        ManagementObjectSearcher searcher = new ManagementObjectSearcher("Select * From Win32_BIOS");
        序列號 = new string[searcher.Get().Count];
        int i = 0;
        foreach (ManagementObject share in searcher.Get())
        {
                序列號[i] = share.GetPropertyValue("SerialNumber").ToString();
                i ;
        }
}


C# 獲得網卡參數程序代碼

C# 獲得網卡參數程序代碼如下：
public static void NetworkAdapter(out string[] 制造商, out string[] MAC地址)
{
        ManagementObjectSearcher searcher = new ManagementObjectSearcher("SELECT * FROM Win32_NetworkAdapter");
        制造商 = new string[searcher.Get().Count];
        MAC地址 = new string[searcher.Get().Count];
        int i = 0;
        foreach (ManagementObject share in searcher.Get())
        {
                try
                {
                        制造商[i] = share.GetPropertyValue("Manufacturer").ToString();
                        MAC地址[i] = share.GetPropertyValue("MACAddress").ToString();
                }
                        catch (System.Exception er)
                {
                }
                i ;
        }
} 



C# 獲得硬盤參數程序代碼
public static void HardDisk(out string[] 制造商, out string[] 型號, out string[] 序列號)
{
        ManagementObjectSearcher searcher = new ManagementObjectSearcher("SELECT * FROM Win32_DiskDrive");
        制造商 = new string[searcher.Get().Count];
        型號 = new string[searcher.Get().Count];
        序列號 = new string[searcher.Get().Count];
        int i = 0;
        foreach (ManagementObject share in searcher.Get())
        {
                try
                        {
                        制造商[i] = share.GetPropertyValue("Manufacturer").ToString();
                        型號[i] = share.GetPropertyValue("Model").ToString();
                        序列號[i] = share.GetPropertyValue("Signature").ToString();
                }
                catch (System.Exception er)
                {
                }
                i ;
        }
} 





C#讀取U盤序列號

	
	private List<string> _serialNumber = new List<string>();
	
	/// <summary>
	/// 調用這個函數將本機所有U盤序列號存儲到_serialNumber中
	/// </summary>
	private void matchDriveLetterWithSerial()
	{
	    string[] diskArray;
	    string driveNumber;
	    var searcher = new ManagementObjectSearcher("SELECT * FROM Win32_LogicalDiskToPartition");
	    foreach (ManagementObject dm in searcher.Get())
	    {
	        getValueInQuotes(dm["Dependent"].ToString());
	        diskArray = getValueInQuotes(dm["Antecedent"].ToString()).Split(,);
	        driveNumber = diskArray[0].Remove(0, 6).Trim();
	        var disks = new ManagementObjectSearcher("SELECT * FROM Win32_DiskDrive");
	        foreach (ManagementObject disk in disks.Get())
	        {
	            if (disk["Name"].ToString() == ("\\.\PHYSICALDRIVE" + driveNumber) & disk["InterfaceType"].ToString() == "USB")
	            {
	                _serialNumber.Add(parseSerialFromDeviceID(disk["PNPDeviceID"].ToString()));
	            }
	        }
	    }
	}
	
	private static string parseSerialFromDeviceID(string deviceId)
	{
	    var splitDeviceId = deviceId.Split(\);
	    var arrayLen = splitDeviceId.Length - 1;
	    var serialArray = splitDeviceId[arrayLen].Split(&);
	    var serial = serialArray[0];
	    return serial;
	}
	




用WMI查serial port可否知道是ims的comport，
若可以知道，直接連線看看～～～





//c#實現md5加密



1. 首先創建MD5的哈希算法。

((HashAlgorithm)System.Security.Cryptogrophy.CryptoConfig.CreateFromName("MD5")).ComputeHash(System.Text.UTF8.GetBytes(input))

2.計算哈希值

使用方法:ComputeHash(byte[] value);

3.轉化成字符串.

1protected virtual string HashMD5(string input)
2　　　　{
3　　　　　　byte[] result = ((HashAlgorithm)System.Security.Cryptography.CryptoConfig.CreateFromName("MD5")).ComputeHash(System.Text.Encoding.UTF8.GetBytes(input));
4　　　　　　StringBuilder output = new StringBuilder(16);
5
6　　　　　　for (int i = 0; i < result.Length; i++)
7　　　　　　{
8　　　　　　　　// convert from hexa-decimal to character
9　　　　　　　　output.Append((result[i]).ToString( "x2", System.Globalization.CultureInfo.InvariantCulture));
10　　　　　　}
11　　　　　　return output.ToString();
12　　　　}
13




使用C# 讀取XML 到DataGridView
代碼如下：

XmlReader xmlRead =new XmlTextReader ("C:/XMLWebServicesSBS/xml2/xml/XMLFile1.xml");
    DataSet ds=new DataSet ();
    //ds.ReadXml ("C:/XMLWebServicesSBS/xml2/xml/XMLFile1.xml");
    ds.ReadXml (xmlRead);

this.DataGrid1 .DataSource =ds;
this.DataGrid1 .DataBind ();


比較兩個檔案
if(FileCompare(this.TextBox1.Text，this.TextBox2.Text))


private bool FileCompare(string file1，string file2)
{
	//　判斷相同的文件是否被參考兩次。
	if(file1 == file2)
	{
		return true；
	}
	int file1byte = 0；
	int file2byte = 0；
	using(FileStream fs1 = new FileStream(file1，FileMode.Open)，
	fs2 = new FileStream(file2，FileMode.Open))
	{
	//　檢查文件大小。如果兩個文件的大小並不相同，則視為不相同。
	if(fs1Length != fs2.Length)
	{
	// 關閉文件。
	fs1.Close()；
	fs2.Close()；
	return false；
	}
	//　逐一比較兩個文件的每一個字節，直到發現不相符或已到達文件尾端為止。
	do
	{
	// 從每一個文件讀取一個字節。
	file1byte = fs1.ReadByte()；
	file2byte = fs2.ReadByte()；
	}
	while ((file1byte == file2byte) && (file1byte != -1))；
	// 關閉文件。
	fs1.Close()；
	fs2.Close()；
	}
	//　返回比較的結果。在這個時候，只有當兩個文件的內容完全相同時，
	"file1byte" 才會等於 "file2byte"。
	return ((file1byte - file2byte) == 0)；
}



C#使用Process類調用外部exe程序
Process p = Process.Start("notepad.exe");
p.WaitForExit();//關鍵，等待外部程序退出後才能往下執行 







ListView添加內容範例
        /// <summary>
        /// listview1 顯示搜索主機
        /// </summary>
        private void listLanHost()
        {
            listView1.View = View.List;

            ListViewItem aa;
            for (int i = 0; i < 255; i++)
            {
                if (LanHost[i, 0] != "")
                {
                    aa = new ListViewItem();
                    aa.Text = LanHost[i, 1];
                    aa.Tag = LanHost[i, 0];
                    listView1.Items.Add(aa);
                }
            }

        }
        
        
        
        


//計算耗時任務所需的秒數

　　public int GetTimeSpan(DateTime dtStart, DateTime dtEnd)

　　{

　　TimeSpan tsStart = new TimeSpan(dtStart.Ticks);

　　TimeSpan tsEnd = new TimeSpan(dtEnd.Ticks);

　　TimeSpan ts = tsEnd.Subtract(tsStart).Duration();//秒

　　//dateDiff = ts.Days.ToString() + "天" + ts.Hours.ToString() + "小時" + ts.Minutes.ToString() + "分鐘" + ts.Seconds.ToString() + "秒";

　　return ts.Seconds;

　　}      


MemoryStream 可以seek
                    MemoryStream ms = new MemoryStream();
                    XmlWt = new XmlTextWriter(ms, Encoding.Unicode);
                    //獲取ds中的數據
                    dt.WriteXml(XmlWt);
                    int count = (int)ms.Length;
                    byte[] temp = new byte[count];
                    ms.Seek(0, SeekOrigin.Begin);
                    ms.Read(temp, 0, count);
                    //返回Unicode編碼的文本

                        ms.Close();
                        ms.Dispose();
                        
     MemoryStream stream = null;
     XmlTextWriter writer = null;
     try
     {
         stream = new MemoryStream();
         writer = new XmlTextWriter(stream, Encoding.Default);
         xmlDS.WriteXml(writer);
         int count = (int)stream.Length;
         byte[] arr = new byte[count];
         stream.Seek(0, SeekOrigin.Begin);
         stream.Read(arr, 0, count);
         UTF8Encoding utf = new UTF8Encoding();
         return utf.GetString(arr).Trim();
         

c# 獲取網頁源碼 by WebClient


private string GetWebClient(string url)
{
string strHTML = "";
WebClient myWebClient = new WebClient();
Stream myStream = myWebClient.OpenRead(url);
StreamReader sr = new StreamReader(myStream, System.Text.Encoding.GetEncoding("utf-8"));
strHTML = sr.ReadToEnd();
myStream.Close();
return strHTML;
}

c# 獲取網頁源碼 by WebRequest

private string GetWebRequest(string url)
{
Uri uri = new Uri(url);
WebRequest myReq = WebRequest.Create(uri);
WebResponse result = myReq.GetResponse();
Stream receviceStream = result.GetResponseStream();
StreamReader readerOfStream = new StreamReader(receviceStream, System.Text.Encoding.GetEncoding("utf-8"));
string strHTML = readerOfStream.ReadToEnd();
readerOfStream.Close();
receviceStream.Close();
result.Close();
return strHTML;
}


c# 獲取網頁源碼 by HttpWebRequest

private string GetHttpWebRequest(string url)
{
Uri uri = new Uri(url);
HttpWebRequest myReq = (HttpWebRequest)WebRequest.Create(uri);
myReq.UserAgent = "User-Agent:Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.2; .NET CLR 1.0.3705";
myReq.Accept = "*/*";
myReq.KeepAlive = true;
myReq.Headers.Add("Accept-Language", "zh-cn,en-us;q=0.5");
HttpWebResponse result = (HttpWebResponse)myReq.GetResponse();
Stream receviceStream = result.GetResponseStream();
StreamReader readerOfStream = new StreamReader(receviceStream, System.Text.Encoding.GetEncoding("utf-8"));
string strHTML = readerOfStream.ReadToEnd();
readerOfStream.Close();
receviceStream.Close();
result.Close();
return strHTML;
}
//注意"utf-8"應與指定網頁的編碼對應。
//可以看到HttpWebRequest 方式最復雜，但確提供了更多的選擇性。
//有的網站檢測客戶端的UserAgent！如163.com，你如果使用WebClient WebRequest方式獲取時，將獲取到的是錯誤提示頁面內容。
//而通過HttpWebRequest 就沒問題。


//創建一個讀取器
StreamReader sr = new StreamReader("templog.txt");
//一次性讀取完
Console.WriteLine(sr.ReadToEnd());
Console.ReadLine(); 


//C#：使用MD5對用戶密碼加密與解密

    C#中常涉及到對用戶密碼的加密於解密的算法，其中使用MD5加密是最常見的的實現方式。本文總結了通用的算法並結合了自己的一點小經驗，分享給大家。

一.使用16位、32位、64位MD5方法對用戶名加密

1）16位的MD5加密

/// <summary>
/// 16位MD5加密
/// </summary>
/// <param name="password"></param>
/// <returns></returns>
public static string MD5Encrypt16(string password)
{
    var md5 = new MD5CryptoServiceProvider();
    string t2 = BitConverter.ToString(md5.ComputeHash(Encoding.Default.GetBytes(password)), 4, 8);
    t2 = t2.Replace("-", "");
    return t2;
}

2）32位的MD5加密

/// <summary>
/// 32位MD5加密
/// </summary>
/// <param name="password"></param>
/// <returns></returns>
public static string MD5Encrypt32(string password)
{
    string cl = password;
    string pwd = "";
    MD5 md5 = MD5.Create(); //實例化一個md5對像
    // 加密後是一個字節類型的數組，這裡要注意編碼UTF8/Unicode等的選擇　
    byte[] s = md5.ComputeHash(Encoding.UTF8.GetBytes(cl));
    // 通過使用循環，將字節類型的數組轉換為字符串，此字符串是常規字符格式化所得
    for (int i = 0; i < s.Length; i++)
    {
        // 將得到的字符串使用十六進制類型格式。格式後的字符是小寫的字母，如果使用大寫（X）則格式後的字符是大寫字符 
        pwd = pwd + s[i].ToString("X");
    }
    return pwd;
}

3）64位的MD5加密

public static string MD5Encrypt64(string password)
{
    string cl = password;
    //string pwd = "";
    MD5 md5 = MD5.Create(); //實例化一個md5對像
    // 加密後是一個字節類型的數組，這裡要注意編碼UTF8/Unicode等的選擇　
    byte[] s = md5.ComputeHash(Encoding.UTF8.GetBytes(cl));
    return Convert.ToBase64String(s);
}

4）使用MD5為用戶密碼加密

/// <summary>
/// 加密用戶密碼
/// </summary>
/// <param name="password">密碼</param>
/// <param name="codeLength">加密位數</param>
/// <returns>加密密碼</returns>
public static string md5(string password, int codeLength)
{
    if (!string.IsNullOrEmpty(password))
    {
        // 16位MD5加密（取32位加密的9~25字符）  
        if (codeLength == 16)
        {
            return System.Web.Security.FormsAuthentication.HashPasswordForStoringInConfigFile(password, "MD5").ToLower().Substring(8, 16);
        }

        // 32位加密
        if (codeLength == 32)
        {
            return System.Web.Security.FormsAuthentication.HashPasswordForStoringInConfigFile(password, "MD5").ToLower();
        }
    }
    return string.Empty;
}

      由於MD5是不可逆的，所以加密之後就無法解密，取用戶名和密碼時候，需要再加密一邊用戶輸入的數據與數據庫中已加密的數據進行比對。如果比對結果一致，則可以判定登陸成功！代碼如下所示：

/// <summary>
/// 登陸
/// </summary>
public Model.UserInfo UserLogOn(string USERID, string pwd, out string statusCode)
{
    //假設已經通過用戶ID獲取到UserInfo的Model對象
    Model.UserInfo model = GetModel(USERID);
    if (model != null)
    {
        if (model.PASSWORD == MD5Encrypt64(pwd))
        {
            statusCode = "登陸成功";
        }
        else {
            statusCode = “密碼錯誤”；
        }
    }
    else
    {
        statusCode = "用戶不存在！";
        model = null;
    }   
    return model;
}

5）通過DESCryptoServiceProvider對象對字符串進行加密解密

/// <summary>
/// DES數據加密
/// </summary>
/// <param name="targetValue">目標值</param>
/// <param name="key">密鑰</param>
/// <returns>加密值</returns>
public static string Encrypt(string targetValue, string key)
{
    if (string.IsNullOrEmpty(targetValue))
    {
        return string.Empty;
    }

    var returnValue = new StringBuilder();
    var des = new DESCryptoServiceProvider();
    byte[] inputByteArray = Encoding.Default.GetBytes(targetValue);
    // 通過兩次哈希密碼設置對稱算法的初始化向量   
    des.Key = Encoding.ASCII.GetBytes(FormsAuthentication.HashPasswordForStoringInConfigFile
                                            (FormsAuthentication.HashPasswordForStoringInConfigFile(key, "md5").
                                                Substring(0, 8), "sha1").Substring(0, 8));
    // 通過兩次哈希密碼設置算法的機密密鑰   
    des.IV = Encoding.ASCII.GetBytes(FormsAuthentication.HashPasswordForStoringInConfigFile
                                            (FormsAuthentication.HashPasswordForStoringInConfigFile(key, "md5")
                                                .Substring(0, 8), "md5").Substring(0, 8));
    var ms = new MemoryStream();
    var cs = new CryptoStream(ms, des.CreateEncryptor(), CryptoStreamMode.Write);
    cs.Write(inputByteArray, 0, inputByteArray.Length);
    cs.FlushFinalBlock();
    foreach (byte b in ms.ToArray())
    {
        returnValue.AppendFormat("{0:X2}", b);
    }
    return returnValue.ToString();
}

此種算法可以通過加密密鑰進行解密，解密方法如下：

/// <summary>
/// DES數據解密
/// </summary>
/// <param name="targetValue"></param>
/// <param name="key"></param>
/// <returns></returns>
public static string Decrypt(string targetValue, string key)
{
    if (string.IsNullOrEmpty(targetValue))
    {
        return string.Empty;
    }
    // 定義DES加密對象
    var des = new DESCryptoServiceProvider();
    int len = targetValue.Length / 2;
    var inputByteArray = new byte[len];
    int x, i;
    for (x = 0; x < len; x++)
    {
        i = Convert.ToInt32(targetValue.Substring(x * 2, 2), 16);
        inputByteArray[x] = (byte)i;
    }
    // 通過兩次哈希密碼設置對稱算法的初始化向量   
    des.Key = Encoding.ASCII.GetBytes(FormsAuthentication.HashPasswordForStoringInConfigFile
                                            (FormsAuthentication.HashPasswordForStoringInConfigFile(key, "md5").
                                                Substring(0, 8), "sha1").Substring(0, 8));
    // 通過兩次哈希密碼設置算法的機密密鑰   
    des.IV = Encoding.ASCII.GetBytes(FormsAuthentication.HashPasswordForStoringInConfigFile
                                            (FormsAuthentication.HashPasswordForStoringInConfigFile(key, "md5")
                                                .Substring(0, 8), "md5").Substring(0, 8));
    // 定義內存流
    var ms = new MemoryStream();
    // 定義加密流
    var cs = new CryptoStream(ms, des.CreateDecryptor(), CryptoStreamMode.Write);
    cs.Write(inputByteArray, 0, inputByteArray.Length);
    cs.FlushFinalBlock();
    return Encoding.Default.GetString(ms.ToArray());
}






         #region MD5加密
         /// <summary>
         /// MD5加密
         /// </summary>
         /// <param name="input">需要加密的字符串</param>
         /// <returns></returns>
         public static string MD5Encrypt(string input)
         {
             return MD5Encrypt(input, new UTF8Encoding());
         }
 
         /// <summary>
         /// MD5加密
         /// </summary>
         /// <param name="input">需要加密的字符串</param>
         /// <param name="encode">字符的編碼</param>
         /// <returns></returns>
         public static string MD5Encrypt(string input, Encoding encode)
         {
             MD5 md5 = new MD5CryptoServiceProvider();
             byte[] t = md5.ComputeHash(encode.GetBytes(input));
             StringBuilder sb = new StringBuilder(32);
             for (int i = 0; i < t.Length; i++)
                 sb.Append(t[i].ToString("x").PadLeft(2, '0'));
             return sb.ToString();
         }
 
         /// <summary>
         /// MD5對文件流加密
         /// </summary>
         /// <param name="sr"></param>
         /// <returns></returns>
         public static string MD5Encrypt(Stream stream)
         {
             MD5 md5serv = MD5CryptoServiceProvider.Create();
             byte[] buffer = md5serv.ComputeHash(stream);
             StringBuilder sb = new StringBuilder();
             foreach (byte var in buffer)
                 sb.Append(var.ToString("x2"));
             return sb.ToString();
         }
 
         /// <summary>
         /// MD5加密(返回16位加密串)
         /// </summary>
         /// <param name="input"></param>
         /// <param name="encode"></param>
         /// <returns></returns>
         public static string MD5Encrypt16(string input, Encoding encode)
         {
             MD5CryptoServiceProvider md5 = new MD5CryptoServiceProvider();
             string result = BitConverter.ToString(md5.ComputeHash(encode.GetBytes(input)), 4, 8);
             result = result.Replace("-", "");
             return result;
         }
         #endregion
         
         

關於發郵件的服務器的端口號

即：25是默認端口，可能因為spam等原因用不了，這時可以考慮587.一般對於非加密的請求587都能用。

修改端口號為587後，果然OK。



25/587/2525
465/25025

         
         
         

         /// <summary>
        /// 實現bitmap到ico的轉換
        /// </summary>
        /// <param name="bitmap">原圖</param>
        /// <returns>轉換後的指定大小的圖標</returns>
        private Icon ConvertBitmap2Ico(Bitmap bitmap)
        {
            Bitmap icoBitmap = new Bitmap(bitmap, size);//創建制定大小的原位圖

            //獲得原位圖的圖標句柄
            IntPtr hIco = icoBitmap.GetHicon();
            //從圖標的指定WINDOWS句柄創建Icon
            Icon icon = Icon.FromHandle(hIco);

            return icon;
        }
        
        
            string m_fileName = DateTime.Now.ToFileTime().ToString() + ".jpg";
            richTextBox1.Text += m_fileName + "\n";

 toolStripStatusLabel1.Text = "當前時間:" + DateTime.Now.ToLongTimeString(); 
 
 
 
            Process[] processes = System.Diagnostics.Process.GetProcessesByName(Application.CompanyName);
            if (processes.Length > 1)
            {
                MessageBox.Show("應用程序已經在運行中。");
                Thread.Sleep(1000);
                System.Environment.Exit(1);
            }
            else
            {
                Application.EnableVisualStyles();
                Application.SetCompatibleTextRenderingDefault(false);
                Application.Run(new FrmServiceSetup());
            }
            
            
           
                string location = System.Reflection.Assembly.GetExecutingAssembly().Location;
                string serviceFileName = location.Substring(0, location.LastIndexOf('\\')) + "\\" + serviceName + ".exe";
 
            
        /// 日志信息
        public static void WriteLog(string ex)
        {
            if (myPath == "" || myName == "")
                return;

            string Year = DateTime.Now.Year.ToString();
            string Month = DateTime.Now.Month.ToString().PadLeft(2, '0');
            string Day = DateTime.Now.Day.ToString().PadLeft(2, '0');

            //年月日文件夾是否存在，不存在則建立
            if (!Directory.Exists(myPath + "\\LogFiles\\" + Year + "_" + Month + "\\" + Year + "_" + Month + "_" + Day))
            {
                Directory.CreateDirectory(myPath + "\\LogFiles\\" + Year + "_" + Month + "\\" + Year + "_" + Month + "_" + Day);
            }

            //寫入日志UNDO,Exception has not been handle
            string LogFile = myPath + "\\LogFiles\\" + Year + "_" + Month + "\\" + Year + "_" + Month + "_" + Day + "\\" + myName;
            if (!File.Exists(LogFile))
            {
                System.IO.StreamWriter myFile;
                myFile = System.IO.File.AppendText(LogFile);
                myFile.Close();
            }

            while (true)
            {
                try
                {
                    StreamWriter sr = File.AppendText(LogFile);
                    sr.WriteLine(DateTime.Now.ToString("HH:mm:ss") + "  " + ex);
                    sr.Close();
                    break;
                }
                catch (Exception e)
                {
                    System.Threading.Thread.Sleep(50);
                    continue;
                }
            }

        }

    }
}

            
            
            
            
            

C#殺死進程

private void KillProcess(string processName)
        {
            System.Diagnostics.Process myproc = new System.Diagnostics.Process();
            //得到所有打開的進程
            try
            {
                foreach (Process thisproc in Process.GetProcessesByName("WINPROJ"))
                {
                    if (!thisproc.CloseMainWindow())
                    {
                        thisproc.Kill();
                    }
                }
            }
            catch (System.Exception ex )
            {
                ScriptManager.RegisterStartupScript(this.btnUpload, GetType(), "dis", "alert(進程殺死失敗);", true);
            }
        }
    



        //獲取窗體的進程標識ID
        public static int GetPid(string windowTitle)
        {
            int rs = 0;
            Process[] arrayProcess = Process.GetProcesses();
            foreach (Process p in arrayProcess)
            {
                if (p.MainWindowTitle.IndexOf(windowTitle) != -1)
                {
                    rs = p.Id;
                    break;
                }
            }
            return rs;
        }

        //根據進程名獲取PID
        public static int GetPidByProcessName(string processName, ref IntPtr baseAddress)
        {
            Process[] arrayProcess = Process.GetProcessesByName(processName);
            foreach (Process p in arrayProcess)
            {
                baseAddress = p.MainModule.BaseAddress;
                return p.Id;
            }

            return 0;
        }

        //根據進程名獲取PID
        public static int GetPidByProcessName(string processName)
        {
            Process[] arrayProcess = Process.GetProcessesByName(processName);
            foreach (Process p in arrayProcess)
            {
                return p.Id;
            }

            return 0;
        }
        



//???
　　 Random　rd　=　new　Random();
　　 textBlock1.Foreground　=　new　SolidColorBrush(
　　　　 Color.FromRgb(
　　　　　　 (byte)rd.Next(0,255),
　　　　　　 (byte)rd.Next(0,　255),
　　　　　　 (byte)rd.Next(0,　255))
　　　　　　 );





//C#抓屏(截屏)

class ScreenShot
　　{
　　　　public static void CaptureImage(Point SourcePoint, Point DestinationPoint, Rectangle SelectionRectangle, string FilePath)
　　　　{
　　　　　　using (Bitmap bitmap = new Bitmap(SelectionRectangle.Width, SelectionRectangle.Height))
　　　　　　{
　　　　　　　　using (Graphics g = Graphics.FromImage(bitmap))
　　　　　　　　{
　　　　　　　　　　g.CopyFromScreen(SourcePoint, DestinationPoint, SelectionRectangle.Size);
　　　　　　　　}
　　　　　　　　bitmap.Save(FilePath, ImageFormat.Bmp);
　　　　　　}
　　　　}
　　}


using System.Drawing.Imaging;


private void button1_Click(object sender, EventArgs e)
　　　　{
　　　　　　saveFileDialog1.DefaultExt = "bmp";
　　　　　　saveFileDialog1.Filter = "bmp files (*.bmp)|*.bmp";
　　　　　　saveFileDialog1.Title = "導出地圖為...";
　　　　　　saveFileDialog1.ShowDialog();
　　　　　　if (saveFileDialog1.FileName.Length > 0)
　　　　　　{
　　　　　　　　ScreenPath = saveFileDialog1.FileName;
　　　　　　}
　　　　　　else
　　　　　　{
　　　　　　　　return;
　　　　　　}
　　　　　　this.Refresh();
　　　　　　//3個參數：獲得控件所在屏幕坐標，目標坐標點為(0,0)，獲得控件大小。
　　　　　　ScreenShot.CaptureImage(axMapControl1.PointToScreen(Point.Empty), Point.Empty, new Rectangle(axMapControl1.Location, axMapControl1.Size), ScreenPath);　　　　
　　　　}





　　6、System.Text.StringBuilder("")

　　字符串相加，（+號是不是也一樣？）

　　如：

System.Text.StringBuilder sb = new System.Text.StringBuilder("");
sb.Append("中華");
sb.Append("人民");
sb.Append("共和國");




C#自定義直線箭頭大小
發現原來可以自定義箭頭的大小的，放著以備以後使用。

System.Drawing.Drawing2D.AdjustableArrowCap lineCap = new System.Drawing.Drawing2D.AdjustableArrowCap(6, 6, true);
Pen RedPen=new Pen(Color.Red,2);
RedPen.CustomEndCap = lineCap;

然後用RedPen繪圖就可以了！






            
            

先使用無符號字節數組存放數據庫對應的數據集中表的image類型字段的值。例如：

byte[] bytes= (byte[]) image類型字段值



一、獲取程序集版本

label版本.Text = System.Reflection.Assembly.GetExecutingAssembly().GetName().Version.ToString();

二、獲取文件版本

using System.Diagnostics;
FileVersionInfo myFileVersion = FileVersionInfo.GetVersionInfo (System.Windows.Forms.Application.ExecutablePath);
label版本.Text = myFileVersion.FileVersion; 





C#自定義直線箭頭大小

最近再搞個畫圖的程序，直線的方向一直弄不好，直線太細了，看不清楚箭頭的，直線太粗了，又看著惡心。

發現原來可以自定義箭頭的大小的，放著以備以後使用。

System.Drawing.Drawing2D.AdjustableArrowCap lineCap = new System.Drawing.Drawing2D.AdjustableArrowCap(6, 6, true);
Pen RedPen=new Pen(Color.Red,2);
RedPen.CustomEndCap = lineCap;

然後用RedPen繪圖就可以了！


//在C#中調用windows API函數

using System.Runtime.InteropServices;

/// <summary>
/// 打開和關閉CD托盤.
/// </summary>
[DllImport("winmm.dll" , EntryPoint="mciSendString", CharSet=CharSet.Auto)]
public static extern int mciSendString (string lpstrCommand,string lpstrReturnstring ,int uReturnLength,int hwndCallback);

/// <summary>
/// 顯示和隱藏鼠標指針.
/// </summary>
[DllImport("user32.dll", EntryPoint="ShowCursor", CharSet=CharSet.Auto)]
public static extern int ShowCursor(int bShow);

/// <summary>
/// 清空回收站.
/// </summary>
[DllImport("shell32.dll", EntryPoint="SHEmptyRecycleBin", CharSet=CharSet.Auto)]
public static extern long SHEmptyRecycleBin(IntPtr hwnd, string pszRootPath, long dwFlags);

/// <summary>
/// 打開浏覽器
/// </summary>
[DllImport("shell32.dll", EntryPoint="ShellExecute", CharSet=CharSet.Auto)]
public static extern int ShellExecute(IntPtr hwnd,string lpOperation,string lpFile,string lpParameters,string lpDirectory,int nShowCmd);

/// <summary>
/// 最大化窗口，最小化窗口，正常大小窗口；
/// </summary>
[DllImport("user32.dll", EntryPoint="ShowWindow", CharSet=CharSet.Auto)]
public static extern int ShowWindow(IntPtr hwnd,int nCmdShow);



//打開CD托盤：
long lngReturn = ApiCalls.mciSendString("set CDAudio door open", strReturn, 127, 0);
//關閉CD托盤：
long lngReturn = ApiCalls.mciSendString("set CDAudio door closed", strReturn, 127, 0);
//在應用程序窗體中顯示鼠標指針：
ApiCalls.ShowCursor(1);
//在應用程序窗體中隱藏鼠標指針：
ApiCalls.ShowCursor(0);
//清空回收站：
ApiCalls.SHEmptyRecycleBin(Form.ActiveForm.Handle,"",0x00000000);
//打開浏覽器窗口，textBox1.Text中表示要訪問的URL地址：
Long lngReturn= ApiCalls.ShellExecute(Form.ActiveForm.Handle,"Open",textBox1.Text,"","",1);
//最大化窗口：
ApiCalls.ShowWindow(Form.ActiveForm.Handle,3);
//最小化窗口：
ApiCalls.ShowWindow(Form.ActiveForm.Handle,2);
//恢復正常大小窗口：
ApiCalls.ShowWindow(Form.ActiveForm.Handle,1);
 


//隨機顏色如下

public static Color GetRandomColor()
{
    Random randomFirst = new Random((int)DateTime.Now.Ticks); 
    System.Threading.Thread.Sleep(300);
    Random randomSencond = new Random((int)DateTime.Now.Ticks);
    System.Threading.Thread.Sleep(300);
    Random randomThird = new Random((int)DateTime.Now.Ticks);
    int intRed = randomFirst.Next(256);
    int intGreen = randomSencond.Next(256);
    int intBlue = randomThird.Next(256);
    return Color.FromArgb(intRed, intGreen, intBlue);
}
        
        
//C#獲取圖片的指定部分

        /// <summary>
        /// http://www.cnblogs.com/KissKnife/archive/2007/10/13/923352.Html
        /// 獲取圖片指定部分
        /// </summary>
        /// <param name="pPath">圖片路徑</param>
        /// <param name="pPartStartPointX">目標圖片開始繪制處的坐標X值(通常為0)</param>
        /// <param name="pPartStartPointY">目標圖片開始繪制處的坐標Y值(通常為0)</param>
        /// <param name="pPartWidth">目標圖片的寬度</param>
        /// <param name="pPartHeight">目標圖片的高度</param>
        /// <param name="pOrigStartPointX">原始圖片開始截取處的坐標X值</param>
        /// <param name="pOrigStartPointY">原始圖片開始截取處的坐標Y值</param>
        static System.Drawing.Bitmap GetPart(string pPath, int pPartStartPointX, int pPartStartPointY, int pPartWidth, int pPartHeight, int pOrigStartPointX, int pOrigStartPointY)
        ...{
            System.Drawing.Image originalImg = System.Drawing.Image.FromFile(pPath);

            System.Drawing.Bitmap partImg = new System.Drawing.Bitmap(pPartWidth, pPartHeight);
            System.Drawing.Graphics graphics = System.Drawing.Graphics.FromImage(partImg);
            System.Drawing.Rectangle destRect = new System.Drawing.Rectangle(new System.Drawing.Point(pPartStartPointX, pPartStartPointY), new System.Drawing.Size(pPartWidth, pPartHeight));//目標位置
            System.Drawing.Rectangle origRect = new System.Drawing.Rectangle(new System.Drawing.Point(pOrigStartPointX, pOrigStartPointY), new System.Drawing.Size(pPartWidth, pPartHeight));//原圖位置（默認從原圖中截取的圖片大小等於目標圖片的大小）

            graphics.DrawImage(originalImg, destRect, origRect, System.Drawing.GraphicsUnit.Pixel);

            return partImg;
        }








//給圖片添加版權信息(C#)
//創建一張位圖

Bitmap bitmap=new Bitmap(this.pictureBox2.Width,this.pictureBox2.Height,System.Drawing.Imaging.PixelFormat.Format24bppRgb);

//根據位圖獲取畫布

Graphics g=Graphics.FromImage(bitmap);

//清空畫布並用透明色填充

g.Clear(Color.Transparent);

//將另一幅圖片畫到畫布上

g.DrawImage(this.pictureBox1.Image,0,0);

//寫版權信息到圖片上。

g.DrawString(this.textBox2.Text,new Font("黑體",15),new SolidBrush(Color.Red),new Rectangle(20,20,100,100));

//顯示

this.pictureBox2.Image=bitmap;

//保存圖片

bitmap.Save("c:\\abc.bmp",System.Drawing.Imaging.ImageFormat.Bmp);







　　本文將介紹在．Net中如何使用代碼畫圖表，就像用MS Excel產生的圖表一樣。也可以畫像DataGrid一樣的表格。
　　在．Net中，微軟給我們提供了畫圖類（System.Drawing.Imaging），在該類中畫圖的準系統都有。比如：直線、折線、矩形、多邊形、橢圓形、扇形、曲線等等，因此一般的圖形都可以直接通過代碼畫出來。接下來介紹一些畫圖函數：
Bitmap bMap=new Bitmap(500,500)　//定義映像大小；
bMap.Save(Stream,ImageCodecInfo) //將映像儲存到指定的輸出資料流；
Graphics gph //定義或建立GDI繪圖對像；
PointF cPt　//定義二維平面中x,y座標；
DrawString(string,Font,Brush,PonitF) //用指定的Brush和Font對像在指定的矩形或點繪製指定的字串；
DrawLine(Pen,Ponit,Ponit) //用指定的筆(Pen)對像繪製指定兩點之間直線；
DrawPolygon(Pen,Ponit[]) //用指定的筆(Pen)對像繪製指定多邊形，比如三角形，四邊形等等；
FillPolygon(Brush,Ponit[]) //用指定的刷子(Brush)對像填充指定的多邊形；
DrawEllipse(Pen,x,y,Width,Height) //用指定的筆繪製一個邊框定義的橢圓；
FillEllipse(Brush,x,y,Width,Height) //用指定的刷子填充一個邊框定義的橢圓；
DrawRectangle(Pen,x,y,Width,Height) //用指定的筆繪製一個指定座標點、寬度、高度的矩形；
DrawPie(Pen,x,y,Width,Height,startAngle,sweepAngle) //用指定的筆繪製一個指定座標點、寬度、高度以及兩條射線組成的扇形；






ADO.Net方面的：
八、連接Access數據庫：
using System;
using System.Data;
using System.Data.OleDb;

class TestADO
{
    static void Main(string[] args)
    {
        string strDSN = Provider=Microsoft.Jet.OLEDB.4.0;Data Source=c:\test.mdb;
        string strSQL = SELECT * FROM employees ;

        OleDbConnection conn = new OleDbConnection(strDSN);
        OleDbCommand cmd = new OleDbCommand( strSQL, conn );
        OleDbDataReader reader = null;
        try
        {
            conn.Open();
            reader = cmd.ExecuteReader();
            while (reader.Read() )
            {
                Console.WriteLine(First Name:{0}, Last Name:{1}, reader[FirstName], reader[LastName]);
            }
        }
        catch (Exception e)
        {
            Console.WriteLine(e.Message);
        }
        finally
        {
            conn.Close();
        }
    }
} 

九、連接SQL Server數據庫：
using System;
using System.Data.SqlClIEnt;

public class TestADO
{
    public static void Main()
    {
        SqlConnection conn = new SqlConnection(Data Source=localhost; Integrated Security=SSPI; Initial Catalog=pubs);

SqlCommand  cmd = new SqlCommand(SELECT * FROM employees, conn);
        try
        {        
            conn.Open();

            SqlDataReader reader = cmd.ExecuteReader();            
            while (reader.Read())
            {
                Console.WriteLine(First Name: {0}, Last Name: {1}, reader.GetString(0), reader.GetString(1));
            }
        
            reader.Close();
            conn.Close();
        }
        catch(Exception e)
        {
            Console.WriteLine(Exception Occured -->> {0},e);
        }        
    }
}

十、從SQL內讀數據到XML：
using System;
using System.Data;
using System.XML;
using System.Data.SqlClIEnt; 
using System.IO; 

public class TestWriteXML
{ 
    public static void Main()
    { 

        String strFileName=c:/temp/output.XML;

        SqlConnection conn = new SqlConnection(server=localhost;uid=sa;pwd=;database=db);

        String strSql = SELECT FirstName, LastName FROM employees; 

        SqlDataAdapter adapter = new SqlDataAdapter(); 

        adapter.SelectCommand = new SqlCommand(strSql,conn);

        // Build the DataSet
        DataSet ds = new DataSet();

        adapter.Fill(ds, employees);

        // Get a FileStream object
        FileStream fs = new FileStream(strFileName,FileMode.OpenOrCreate,FileAccess.Write);

        // Apply the WriteXml method to write an XML document
        ds.WriteXML(fs);

        fs.Close();

    }
}

十一、用ADO添加數據到數據庫中：
using System;
using System.Data;   
using System.Data.OleDb;   

class TestADO
{  
    static void Main(string[] args)  



{  
        string strDSN = Provider=Microsoft.Jet.OLEDB.4.0;DataSource=c: est.mdb;  
        string strSQL = INSERT INTO Employee(FirstName, LastName) VALUES(''FirstName'', ''LastName'') ;  
                   
        // create Objects of ADOConnection and ADOCommand   
        OleDbConnection conn = new OleDbConnection(strDSN);  
        OleDbCommand cmd = new OleDbCommand( strSQL, conn );  
        try  
        {  
            conn.Open();  
            cmd.ExecuteNonQuery();  
        }  
        catch (Exception e)  
        {  
            Console.WriteLine(Oooops. I did it again: {0}, e.Message);  
        }  
        finally  
        {  
            conn.Close();  
        }          
    } 
}  

十 二、使用OLEConn連接數據庫：
using System;
using System.Data;   
using System.Data.OleDb;   

class TestADO
{  
    static void Main(string[] args)  
    {  
        string strDSN = Provider=Microsoft.Jet.OLEDB.4.0;DataSource=c: est.mdb;  
        string strSQL = SELECT * FROM employee ;  

        OleDbConnection conn = new OleDbConnection(strDSN);
        OleDbDataAdapter cmd = new OleDbDataAdapter( strSQL, conn ); 

        conn.Open();
        DataSet ds = new DataSet();
        cmd.Fill( ds, employee );
        DataTable dt = ds.Tables[0];

        foreach( DataRow dr in dt.Rows )
        {
            Console.WriteLine(First name: + dr[FirstName].ToString() + Last name: + dr[LastName].ToString());
        }
        conn.Close();  
    } 
}  
十三、讀取表的屬性：

using System;
using System.Data;   
using System.Data.OleDb;   

class TestADO
{  
    static void Main(string[] args)  
    {  
        string strDSN = Provider=Microsoft.Jet.OLEDB.4.0;DataSource=c: est.mdb;  
        string strSQL = SELECT * FROM employee ;  

        OleDbConnection conn = new OleDbConnection(strDSN);
        OleDbDataAdapter cmd = new OleDbDataAdapter( strSQL, conn ); 

        conn.Open();
        DataSet ds = new DataSet();
        cmd.Fill( ds, employee );
        DataTable dt = ds.Tables[0];

        Console.WriteLine(FIEld Name DataType Unique AutoIncrement AllowNull);
        Console.WriteLine(==================================================================);
        foreach( DataColumn dc in dt.Columns )
        {
            Console.WriteLine(dc.ColumnName+ , +dc.DataType + ,+dc.Unique + ,+dc.AutoIncrement+ ,+dc.AllowDBNull );
        }
        conn.Close();  
    } 
} 


十六、運行時顯示自己定義的圖標：
//load icon and set to form
System.Drawing.Icon ico = new System.Drawing.Icon(@c: empapp.ico);
this.Icon = ico;


網絡方面的：
十八、取得IP地址：
using System;
using System.Net;

class GetIP
{
     public static void Main()
     {
         IPHostEntry ipEntry = Dns.GetHostByName (localhost);
         IPAddress [] IpAddr = ipEntry.AddressList;
         for (int i = 0; i < IpAddr.Length; i++)
         { 
             Console.WriteLine (IP Address {0}: {1} , i, IpAddr.ToString ());
         }
    }
}
十九、取得機器名稱：
using System;
using System.Net;

class GetIP
{
    public static void Main()
    {
          Console.WriteLine (Host name : {0}, Dns.GetHostName());
    }
}

二十、發送郵件：
using System;
using System.Web;
using System.Web.Mail;

public class TestSendMail
{
    public static void Main()
    {
        try
        {
            // Construct a new mail message 
            MailMessage message = new MailMessage();
            message.From = from@domain.com;
            message.To   =  pengyun@cobainsoft.com;
            message.Cc   = ;
            message.Bcc  = ;
            message.Subject = Subject;
            message.Body = Content of message;
            
            //if you want attach file with this mail, add the line below
            message.Attachments.Add(new MailAttachment(c:\attach.txt, MailEncoding.Base64));

 
            // Send the message
            SmtpMail.Send(message);  
            System.Console.WriteLine(Message has been sent);
        }

        catch(Exception ex)
        {
            System.Console.WriteLine(ex.Message.ToString());
        }

    }
}

十一、根據IP地址得出機器名稱：
using System;
using System.Net;

class ResolveIP
{
     public static void Main()
     {
         IPHostEntry ipEntr.Resolve(172.29.9.9);
         Console.WriteLine (Host name : {0}, ipEntry.HostName);         
     }
}

XML方面的：

二十三、讀取XML文件：
using System;
using System.XML;  

class TestReadXML
{
    public static void Main()
    {
        
        XmlTextReader reader  = new XmlTextReader(C:\test.XML);
        reader.Read();
        
        while (reader.Read())
        {            
            reader.MoveToElement();
            Console.WriteLine(XMLTextReader PropertIEs Test);
            Console.WriteLine(===================);  

            // Read this propertIEs of element and display them on console
            Console.WriteLine(Name: + reader.Name);
            Console.WriteLine(Base URI: + reader.BaseURI);
            Console.WriteLine(Local Name: + reader.LocalName);
            Console.WriteLine(Attribute Count: + reader.AttributeCount.ToString());
            Console.WriteLine(Depth: + reader.Depth.ToString());

            Console.WriteLine(Line Number: + reader.LineNumber.ToString());
            Console.WriteLine(Node Type: + reader.NodeType.ToString());
            Console.WriteLine(Attribute Count: + reader.Value.ToString());
      &nbsp; }        
    }               
} 
二十四、寫XML文件：
using System; 
using System.XML; 

public class TestWriteXMLFile 
{ 
    public static int Main(string[] args) 
    { 
        try 
        {  
            // Creates an XML file is not exist 
            XmlTextWriter writer = new XmlTextWriter(C:\temp\xmltest.XML, null); 

           // Starts a new document 
            writer.WriteStartDocument(); 
            //Write comments 
            writer.WriteComment(Commentss: XMLWriter Test Program); 
            writer.WriteProcessingInstruction(Instruction,Person Record); 
            // Add elements to the file 
            writer.WriteStartElement(p, person, urn:person); 
            writer.WriteStartElement(LastName,); 
            writer.WriteString(Chand); 
            writer.WriteEndElement(); 
            writer.WriteStartElement(FirstName,); 
            writer.WriteString(Mahesh); 
            writer.WriteEndElement(); 
            writer.WriteElementInt16(age,, 25); 
            // Ends the document 
            writer.WriteEndDocument(); 
        } 
        catch (Exception e) 
        {  
            Console.WriteLine (Exception: {0}, e.ToString()); 
        } 
        return 0; 
    } 
} 


Web Service方面的：
二十五、一個Web Service的小例子：
<% @WebService Language=C# Class=TestWS %>

using System.Web.Services;

public class TestWS : System.Web.Services.WebService
{
    [WebMethod()]
    public string StringFromWebService()
    {
        return This is a string from web service.;
    }
} 




//將圖片放入byte數組

Image image = Image.FromFile(file);
System.IO.MemoryStream s = new System.IO.MemoryStream();
image.Save(s, image.RawFormat);
Byte[] bfye = s.ToArray();





        private string GetDriveData(long data)//将磁盘大小的单位由byte转化为G
        {
            return (data / Convert.ToDouble(1024) / Convert.ToDouble(1024) / Convert.ToDouble(1024)).ToString("0.00");
        }

          

 
 


C# 控制台程序設置字體顏色


Console.BackgroundColor = ConsoleColor.Blue; //設置背景色
Console.ForegroundColor = ConsoleColor.White; //設置前景色，即字體顏色
Console.WriteLine(“第一行白藍.”);

Console.ResetColor(); //將控制台的前景色和背景色設為默認值
Console.BackgroundColor = ConsoleColor.Green;
Console.ForegroundColor = ConsoleColor.DarkGreen;
string value = “第三行 綠暗綠”;
Console.WriteLine(value.PadRight(Console.WindowWidth-value.Length)); //設置一整行的背景色

        
       /// <summary>
        /// 性能計數器，用於獲取CPU空閒百分比
        /// </summary>
        private static PerformanceCounter mIdle = new PerformanceCounter("Processor", "% Processor Time", "Idle");
        private Label label1;
        /**/
        /// <summary>
        /// 性能計數器，用於獲取CPU總利用率
        /// </summary>
        private static PerformanceCounter mTotal = new PerformanceCounter("Processor", "% Processor Time", "_Total");
 string  nVal = mTotal.NextValue().ToString();
 //PerformanceCounter cpuCounter;
            //PerformanceCounter ramCounter;

            //cpuCounter = new PerformanceCounter();

            //cpuCounter.CategoryName = "Processor";
            //cpuCounter.CounterName = "% Processor Time";
            //cpuCounter.InstanceName = "_Total";
            //ramCounter = new PerformanceCounter("Memory", "Available MBytes");


//當前程序的路徑
System.AppDomain.CurrentDomain.BaseDirectory.ToString();





//BinaryWrite
MemoryStream ms = new MemoryStream();
BinaryWrite(ms.ToArray());


Application.StartupPath：獲取啟動了應用程序的可執行文件的路徑，不包括可執行文件的名稱。
Application.ExecutablePath：獲取啟動了應用程序的可執行文件的路徑，包括可執行文件的名稱。
	



//C#根據原圖生成縮略圖

/// <summary>
    /// 生成縮略圖
    /// </summary>
    /// <param name="imgBuffer">原圖byte[]</param>
    /// <param name="width">生成的縮略圖寬度</param>
    /// <param name="height">生成的縮略圖高度</param>
    /// <returns></returns>
    private byte[] GenerateThumbImg(byte[] imgBuffer,int width,int height)
    {
        MemoryStream imgStream = null;
        MemoryStream thumbStream = new MemoryStream();;
        System.Drawing.Image img = null;
        System.Drawing.Image thumbImg = null;
        System.Drawing.Graphics g = null;
        try
        {
            imgStream = new MemoryStream(imgBuffer);
            img = System.Drawing.Image.FromStream(imgStream);
            thumbImg = new System.Drawing.Bitmap(img, width, height);
            g = System.Drawing.Graphics.FromImage(thumbImg);
            // 設置畫布的描繪質量
            g.CompositingQuality = System.Drawing.Drawing2D.CompositingQuality.HighQuality;
            g.SmoothingMode = System.Drawing.Drawing2D.SmoothingMode.HighQuality;

            g.InterpolationMode = System.Drawing.Drawing2D.InterpolationMode.HighQualityBicubic;
            g.DrawImage(thumbImg, 0, 0, width, height);
            /*g.DrawImage(img, new System.Drawing.Rectangle(0, 0, width, height),
                0, 0, width, height, System.Drawing.GraphicsUnit.Pixel);*/
            thumbImg.Save(thumbStream, System.Drawing.Imaging.ImageFormat.Jpeg);
            return thumbStream.ToArray();
        }
        catch(Exception ex)
        {
            return null;
        }
        finally
        {
            if (g != null)
                g.Dispose();
            if (thumbImg != null)
                thumbImg.Dispose();
            if (img != null)
                img.Dispose();
            if (thumbStream != null)
                thumbStream.Close();
            if (imgStream != null)
                imgStream.Close();
        }
    }
    






Directory类

用来操作文件夹的

Directory.CreateDirectory("d:/ccc/cc"); //创建文件夹

Directory.Delete("d:/ccc",true); //true删除非空文件夹

Directory.Move(@"d:/ccc", @"d:/cccc"); //剪切操作 源目录没了 必须同一卷轴d盘

string[] s = Directory.GetFiles(@"D:\项目\Web\Images\shiji"); //获得文件夹目录下所有文件全路径

string[] s = Directory.GetFiles(@"D:\项目\Web\Images\shiji","*.jpg"); //获得文件夹目录下指定后缀名文件全路径

string[] s = Directory.GetDirectories(@"D:\项目\Web\Images"); //获得文件夹目录下的文件夹的全路径

Directory.Exists(@"D:\项目\Web\Images") //是否存在某文件夹


进程

我们可以把计算机中每一个运行的应用程序当作是一个进程
	
///获得当前程序中正在运行的进程
Process[] pros = Process.GetProcesses();
foreach (var item in pros)
{　　　　//item.Kill(); //关闭所有进程.　　　　//item.ProcessName; //进程名
    Console.Write(item.ToString());
}
//通过进程打开一些程序
Process.Start("calc"); //打开计算器
Process.Start("notepad"); //打开记事本
//打开指定文件
ProcessStartInfo pro = new ProcessStartInfo(@"d:\11.txt");
Process pr = new Process();
pr.StartInfo = pro;
pr.Start();

线程

每一个进程是由多个线程组成的。

单线程：让程序做多件事时，会引发卡死 假死状态。

多线程：让一个程序同时处理多个事情，后台运行程序，提高程序的运行效率。

前台线程：只有所有的前台线程都关闭才能完成程序关闭。(winform多窗口时)

后台线程：只要所有的前台线程结束，后台线程自动结束。
	
	
//实例化Thread类，并传入一个指向线程所要运行的方法。（这时线程已经产生，但还没有运行）
//调用Thread类的Start方法，标记线程可以被CPU执行了，但具体执行事件由CPU决定。
Thread th = new Thread(Test); //创建一个线程去执行这个方法。
th.IsBackground = true; //将线程设置为后台线程，前台关闭后 线程结束。
th.Start(); //标记准备就绪，可以随意被执行，具体什么时候执行由CPU决定。
//在.net下是不允许跨线程访问的。
//有时候需要手动释放线程 关闭时 判断线程是否关闭
if (th != null)
{
    th.Abort(); //结束这个线程 不能再Start()
}
Thread.Sleep(3000); //睡眠3秒后执行
//线程执行带参数方法
Thread.Start("123")； object类型参数 在start后括号写参数




画验证码



/// <summary>
/// 字符
/// </summary>
/// <param name="len">几位</param>
/// <returns></returns>
public static string validation(int cd)
{
    var ran = new Random();
    int num, tem;
    string rtuStr = "";
    for (int i = 0; i < cd; i++)
    {
        num = ran.Next();
        if (i % 2 == 1)
            tem = num % 10 + '0'; //数字
        else
            tem = num % 26 + 'A'; //字母
        rtuStr += Convert.ToChar(tem).ToString();
    }
    //写入cookie
    HttpCookie cookie = new HttpCookie("check");
    cookie.Value = rtuStr.ToLower();
    HttpContext.Current.Response.Cookies.Add(cookie);
    return rtuStr;
}

/// <summary>
/// 生成图像
/// </summary>
/// <param name="check">字符</param>
public static byte[] drawImg(string check)
{
    Bitmap img = new Bitmap(90, 34);
    var ht = Graphics.FromImage(img);
    ht.Clear(Color.White);
    ht.DrawLine(new Pen(Color.SpringGreen), 1, 1, 90, 34);
    Font font = new Font("微软雅黑", 20, FontStyle.Bold);
    var jianbian = new LinearGradientBrush(new Rectangle(0, 0, img.Width, img.Height), Color.Teal, Color.Snow, 2f, true);
    ht.DrawString(check, font, jianbian, 0, 0);
    ht.DrawRectangle(new Pen(Color.Aqua), 0, 0, img.Width - 1, img.Height - 1);
    MemoryStream ms = new MemoryStream();
    img.Save(ms, ImageFormat.Jpeg);
    ht.Dispose();
    img.Dispose();
    return ms.ToArray();
}    






XML文件

可扩展标记性语言，用来保存轻量级数据。

XML的标签是成对出现的、并且是区分大小写的。

XML文档必须包含根节点，且只有一个。

创建XML文件

//创建XML对象
XmlDocument doc = new XmlDocument();
//创建文档描述信息
XmlDeclaration dec = doc.CreateXmlDeclaration("1.0", "utf-8", null);
doc.AppendChild(dec);

//创建根节点
XmlElement books = doc.CreateElement("Books");
doc.AppendChild(books);

//创建子节点
XmlElement book1 = doc.CreateElement("Book");
books.AppendChild(book1); //将子节点添加到books

//给book1子节点追加子节点
XmlElement name1 = doc.CreateElement("Name");
name1.InnerText = "c#"; //赋值 文本值
book1.AppendChild(name1);

XmlElement price1 = doc.CreateElement("Price");
price1.InnerXml = "<b>10.0</b>"; //赋值 html标签
book1.AppendChild(price1);

XmlElement items = doc.CreateElement("Items");
//给节点增加属性
items.SetAttribute("Name", "c#");
items.SetAttribute("Price", "10.0");
book1.AppendChild(items);

doc.Save("Books.xml"); //保存

//创建后
<?xml version="1.0" encoding="utf-8"?>
<Books>
  <Book>
    <Name>c#</Name>
    <Price>
      <b>10.0</b>
    </Price>
    <Items Name="c#" Price="10.0" />
  </Book>
</Books>


向已有XML文件中追加
XmlDocument doc = new XmlDocument();
if (File.Exists("Books.xml"))
{
    doc.Load("Books.xml"); //加载 xml
    XmlElement books = doc.DocumentElement; //得到根节点
    //再建立元素进行追加
}

获取XML文件

XmlDocument doc = new XmlDocument();
doc.Load("Books.xml");

XmlElement books = doc.DocumentElement;
XmlNodeList xnl = books.ChildNodes; //得到所有节点

foreach (XmlNode v in xnl) //遍历得到所有节点值
{
    Console.WriteLine(v.InnerText);
}

XmlNodeList xnl1 = doc.SelectNodes("Books/Book/Items"); //查找节点列表
foreach (XmlNode node in xnl1)
{
    Console.WriteLine(node.Attributes["Name"].Value); //得到name属性的值
    Console.WriteLine(node.Attributes["Price"].Value); //得到price属性的值
}

删除XML文件

XmlDocument doc = new XmlDocument();
doc.Load("Books.xml");

XmlNode xnl = doc.SelectSingleNode("Books/Book"); //查找单一节点
xnl.RemoveAll(); //删除全部
doc.Save("Books.xml");
Console.ReadKey();


LinqToXml

//兼容传统方法创建
XDocument xDoc = new XDocument();
//xDoc.Declaration = new XDeclaration() 默认UTF-8 第一行不需要单独建
XElement xRoot = new XElement("root", "值"); //定义元素

XElement xRoot1 = new XElement("root1");  //定义元素２
xRoot1.Value = "值1";

XAttribute xattr = new XAttribute("Id", "1"); //定义属性

xDoc.Add(xRoot); //统一使用add添加
xRoot.Add(xattr);

xDoc.Save(@"d:\linqtoxml.xml");

//真正的linq语法
//F#  函数式编程语言
new XDocument(
    new XElement("root",
        new XAttribute("id", "001"),
        "值")
    ).Save(@"d:\2.xml");
//链式编程，流水线生产 f1().f2().f3()...

//查找xml
XDocument xdoc = new XDocument(new XElement("root"));//根节点
xdoc.Root.Add(new XElement("person",
    new XAttribute("id", "1"),
    new XAttribute("name", "zhangsan"),
    new XAttribute("sex", "1")
    )); //添加子节点
xdoc.Root.Add(new XElement("person",
   new XAttribute("id", "2"),
   new XAttribute("name", "lisi"),
   new XAttribute("sex", "2")
   ));
xdoc.Save(@"d:\2.xml");

<?xml version="1.0" encoding="utf-8"?>
<root>
  <person id="1" name="zhangsan" sex="1" />
  <person id="2" name="lisi" sex="2" />
</root>

//开始查找、修改、删除

XDocument xdoc = XDocument.Load(@"d:\2.xml"); //加载xml
foreach (XElement xlt in xdoc.Root.Elements()) //Root根节点 Elements 元素集合
{
    if (xlt.Name.LocalName == "person") //Name节点名 LocalName不带命名空间的节点名
    {
        if (xlt.Attribute("id").Value == "1") //判断属性值为1时
        {
            Response.Write(xlt.Attribute("name").Value); //输出name
            xlt.Attribute("name").Value = "newname"; //修改name
            xlt.Remove(); //删除此节点
            xdoc.Save(@"d:2.xml");
        }
    }
}

//Linq查询语法
//Descendants()所有子节点 可加某节点下所有节点
var query = from s in xdoc.Descendants() //从集合里找
            where s.Name.LocalName == "person"
            select s;
foreach (XElement xlt in query)
{
    Response.Write(xlt.Value);
}

//Linq方法语法(lambda表达式)
foreach (XElement xlt in xdoc.Descendants().Where(s =>
{
    if (s.Name.LocalName == "name")
    {
        return true;
    }
    return false;
}))
{
    Response.Write(xlt.Value);
}



























	
	
	


DataTable中使用Order By排序與Where過濾

/// <summary>
/// DataTable中使用Order By排序與Where過濾
/// </summary>
private void Bind()
{
    //這裡構造一個數據源
    DataTable dt = new DataTable();
    dt.Columns.Add("ID", typeof(System.String));
    dt.Columns.Add("uName", typeof(System.String));
    dt.Columns.Add("uDate", typeof(System.DateTime));
    for (int i = 0; i < 10; i++)
    {
        DataRow dr = dt.NewRow();
        dr["ID"] = i.ToString();
        dr["uName"] = "name" + i;
        dt.Rows.Add(dr);
    }
    dt.DefaultView.Sort = "ID asc";//相當於Order By
    dt.DefaultView.RowFilter = "ID>5";//相當於Where
    GridView1.DataSource = dt;
    GridView1.DataBind();
}
    




            string Year = DateTime.Now.Year.ToString();
            string Month = DateTime.Now.Month.ToString().PadLeft(2, '0');
            string Day = DateTime.Now.Day.ToString().PadLeft(2, '0');

            //年月日文件夾是否存在，不存在則建立
            if (!Directory.Exists(myPath + "\\LogFiles\\" + Year + "_" + Month + "\\" + Year + "_" + Month + "_" + Day))
            {
                Directory.CreateDirectory(myPath + "\\LogFiles\\" + Year + "_" + Month + "\\" + Year + "_" + Month + "_" + Day);
            }




        public Bitmap bmpobj; 
 
        public VerifyCode(Bitmap pic) 
        { 
            bmpobj = new Bitmap(pic);    //轉換為Format32bppRgb 
        } 
 
        /// <summary> 
        /// 根據RGB，計算灰度值 
        /// </summary> 
        /// <param name="posClr">Color值</param> 
        /// <returns>灰度值，整型</returns> 
        private int GetGrayNumColor(System.Drawing.Color posClr) 
        { 
            return (posClr.R * 19595 + posClr.G * 38469 + posClr.B * 7472) >> 16; 
        } 
 
        /// <summary> 
        /// 灰度轉換,逐點方式 
        /// </summary> 
        public void GrayByPixels() 
        { 
            for (int i = 0; i < bmpobj.Height; i++) 
            { 
                for (int j = 0; j < bmpobj.Width; j++) 
                { 
                    int tmpValue = GetGrayNumColor(bmpobj.GetPixel(j, i)); 
                    bmpobj.SetPixel(j, i, Color.FromArgb(tmpValue, tmpValue, tmpValue)); 
                } 
            } 
        } 
 





c# Process類使用小例

               
                Process myProcess = new Process();
                try
                {
                    myProcess.StartInfo.UseShellExecute = false;
                    myProcess.StartInfo.FileName = exe_filename;
                    myProcess.StartInfo.CreateNoWindow = true;
                    myProcess.Start();
                }
                catch (Exception ex)
                {
                    Console.WriteLine(ex.Message);
                }








作為一個小型的數據存儲傳遞的工具——XML

try by sugar
C#如何獲取遠程磁盤上的剩余空間
http://www.aspphp.online/bianchen/dnet/cxiapu/cxprm/201701/191690.html


1.對於那種明知道跨線程調用不會帶來錯誤的，可以設置Form控件不檢查跨線程調用錯誤，這樣就不報錯了。
在Form1構造方法中：
C#代碼 
CheckForIllegalCrossThreadCalls = false; 


//發送資料到剪貼簿
Clipboard.SetText(textBox1.Text);
MessageBox.Show("已成功將文本框內容復制到剪貼板!");


//從剪貼簿取得資料

            try
            {
                IDataObject iData = Clipboard.GetDataObject();
                if (iData.GetDataPresent(DataFormats.Text))
                {
                    //MessageBox.Show((string)iData.GetData(DataFormats.Text));
                    textBox2.Text = (string)iData.GetData(DataFormats.UnicodeText);
                }
                else
                {
                    MessageBox.Show("目前剪貼板中數據不可轉換為文本", "錯誤");
                }
            }
            


            
            

//-------------------------------------------------------------

//C#--遍歷文件夾實例


                //實例化DirectoryInfo對象
                DirectoryInfo dinfo = new DirectoryInfo(textBox1.Text);
                //獲取指定目錄下的所有子目錄及文件類型
                FileSystemInfo[] fsinfos = dinfo.GetFileSystemInfos();
                foreach (FileSystemInfo fsinfo in fsinfos)
                {
                    if (fsinfo is DirectoryInfo)    //判斷是否文件夾
                    {
                        //使用獲取的文件夾名稱實例化DirectoryInfo對象
                        DirectoryInfo dirinfo = new DirectoryInfo(fsinfo.FullName);
                        //為ListView控件添加文件夾信息
                        listView1.Items.Add(dirinfo.Name);
                        listView1.Items[listView1.Items.Count - 1].SubItems.Add(dirinfo.FullName);
                        listView1.Items[listView1.Items.Count - 1].SubItems.Add("");
                        listView1.Items[listView1.Items.Count - 1].SubItems.Add(dirinfo.CreationTime.ToShortDateString());
                    }
                    else
                    {
                        //使用獲取的文件名稱實例化FileInfo對象
                        FileInfo finfo = new FileInfo(fsinfo.FullName);
                        //為ListView控件添加文件信息
                        listView1.Items.Add(finfo.Name);
                        listView1.Items[listView1.Items.Count - 1].SubItems.Add(finfo.FullName);
                        listView1.Items[listView1.Items.Count - 1].SubItems.Add(finfo.Length.ToString());
                        listView1.Items[listView1.Items.Count - 1].SubItems.Add(finfo.CreationTime.ToShortDateString());
                    }
                }



  
        
    }

emule
http://www.ed2k.online/tushu/jsjwl/16725.html


ed2k://|file|[www.ed2k.online][C#%E5%85%A8%E8%83%BD%E9%80%9F%E6%9F%A5%E5%AE%9D%E5%85%B8].%E6%98%8E%E6%97%A5%E7%A7%91%E6%8A%80%E7%AD%89.%E6%89%AB%E6%8F%8F%E7%89%88.pdf|255157709|83403adcb05aaf95a0a0ef19846a00aa|h=pk25dcx3grk63emqyukmuh2eb6zuhpg5|/







用C#實現全屏幕截圖


今天一位同事想寫一個全屏幕截圖的代碼。當然要實現的第一步是能夠獲取整個屏幕的位圖，記得Win32 API的CreateDC, BitBlt等函數可以使用。於是上網查了下，果然屏幕截圖用這些函數。但winform已經可以把API都忘記了，所以得尋找一個無Win32 API的實現方式。綜合了網上的實現，以及自己的一些設計，實現思路如下：

1. 開始截圖時，創建一個與屏幕大小一樣的位圖，然後用Graphics.CopyFromScreen()把屏幕位圖拷貝到該位圖上。這是很關鍵的一步，這樣所有的操作就都可以在該位圖上進行了，而無實際屏幕無關了。
    int width = Screen.PrimaryScreen.Bounds.Width;

    int height = Screen.PrimaryScreen.Bounds.Height;

    Bitmap bmp = new Bitmap(width, height);

    using (Graphics g = Graphics.FromImage(bmp))
    {
    g.CopyFromScreen(0, 0, 0, 0, new Size(width, height));
    }






    2. 接下來為了方便在這之上進行截圖，有一個很重要的設計實現方式：用全屏幕窗體代替現有真實屏幕，這樣就可以把截圖過程的所有操作都在那個窗體上實現（該窗體設置成無邊框，高寬等於屏幕大小即可），另外為了顯示掩蔽效果（只能正常顯示選擇的部分屏幕內容，而其實部分用一個如半透明層覆蓋），就添加一層半透明位置位圖。具體代碼如下：

    public partial class FullScreenForm : Form
    {
	    private Rectangle rectSelected = Rectangle.Empty;
	
	    private bool isClipping = false;
	
	    private Bitmap screen;
	
	    private Bitmap coverLayer = null;
	
	    private Color coverColor;
	
	    private Brush rectBrush = null;
	
	    private Bitmap resultBmp = null;
	
	    public FullScreenForm(Bitmap screen)
	    {
		    InitializeComponent();
		
		    int width = Screen.PrimaryScreen.Bounds.Width;
		
		    int height = Screen.PrimaryScreen.Bounds.Height;
		
		    coverLayer = new Bitmap(width, height);
		
		    coverColor = Color.FromArgb(50, 200, 0, 0);
		
		    rectBrush = new SolidBrush(coverColor);
		
		    using (Graphics g = Graphics.FromImage(coverLayer)) {
		
		    g.Clear(coverColor);
	    }
	
	    this.Bounds = new Rectangle(0, 0, width, height);
	
	    this.screen = screen;
	
	    this.DoubleBuffered = true;
    }

    protected override void OnMouseDown(MouseEventArgs e)
    {
	    if (e.Button == MouseButtons.Left)
	    {
		    isClipping = true;
		    rectSelected.Location = e.Location;
	    }
	    else if (e.Button == MouseButtons.Right)
	    {
	    	this.DialogResult = DialogResult.OK;
	    }
    }

    protected override void OnMouseMove(MouseEventArgs e)
    {
	    if (e.Button == MouseButtons.Left & & isClipping)
	    {
		    rectSelected.Width = e.X - rectSelected.X;
		    rectSelected.Height = e.Y - rectSelected.Y;
		    this.Invalidate();
	    }
    }

    protected override void OnMouseUp(MouseEventArgs e)
    {
	    if (e.Button == MouseButtons.Left && isClipping)
	    {
		    rectSelected.Width = e.X - rectSelected.X;
		    rectSelected.Height = e.Y - rectSelected.Y;
		    this.Invalidate();
		    resultBmp = new Bitmap(rectSelected.Width, rectSelected.Height);
		    using (Graphics g = Graphics.FromImage(resultBmp))
		    {
		    	g.DrawImage(screen,new Rectangle(0, 0, rectSelected.Width, rectSelected.Height), rectSelected, GraphicsUnit.Pixel);
		    }
		    this.DialogResult = DialogResult.OK;
	    }
    }

    protected override void OnPaint(PaintEventArgs e)
    {
	    Graphics g = e.Graphics;
	    g.DrawImage(screen, 0, 0);
	    g.DrawImage(coverLayer, 0, 0);
	    PaintRectangle();
    }

    protected override void OnPaintBackground(PaintEventArgs e)
    {
    }

    protected override void OnKeyDown(KeyEventArgs e)
    {
	    if (e.KeyCode == Keys.Escape)
	    {
	    	this.DialogResult = DialogResult.Cancel;
	    }
    }

    private void PaintRectangle()
    {
	    using (Graphics g = Graphics.FromImage(coverLayer))
	    {
		    g.Clear(coverColor);
		    GraphicsPath path = new GraphicsPath();
		    path.AddRectangle(this.Bounds);
		    path.AddRectangle(rectSelected);
		    g.FillPath(rectBrush, path);
		    g.DrawRectangle(Pens.Blue, rectSelected);
	    }
    }

    public Bitmap ResultBitmap
    {
    	get { return resultBmp; }
    }
    
    

}

    
    


/*
XmlDocument 用來存放XML文件的類別

XmlElement 存取節點屬性的類別

XmlNode 選取節點的類別


使用XmlDocument.CreateElement 方法建立節點
*/
			
       


byte[]與Image Image與 byte[] 之間的轉換

/// <summary>
/// 將byte[]轉換為Image
/// </summary>
/// <param name="bytes">字節數組</param>
/// <returns>Image</returns>
public Image ReadImage(byte[] bytes)
{
     MemoryStream ms=new MemoryStream(bytes,0,bytes.Length);
     BinaryFormatter bf = new BinaryFormatter();
     object obj=bf.Deserialize(ms);  
　　ms.Close();
　　return (Image)obj;
}
/// <summary>
/// 將Image轉換為byte[]
/// </summary>
/// <param name="image">Image</param>
/// <returns>byte[]</returns>
public byte[] ConvertImage(Image image)
{
     MemoryStream ms=new MemoryStream();
     BinaryFormatter bf = new BinaryFormatter();
     bf.Serialize(ms,(object)image);
     ms.Close();
     return ms.ToArray();
}




C# GUID介紹和的使用，

GUID（全局統一標識符）是指在一台機器上生成的數字，它保證對在同一時空中的所有機器都是唯一的。通常平台會提供生成GUID的API。生成算法很有意思，用到了以太網卡地址、納秒級時間、芯片ID碼和許多可能的數字。GUID的唯一缺陷在於生成的結果串會比較大。

GUID永遠是方便的; 對於程序開發的各個方面，.NET Framework簡化了建立和處理GUID數值的過程。在.NET程序需要的地方，這一功能很容易地生成唯一的數值。

 

1. 一個GUID為一個128位的整數(16字節)，在使用唯一標識符的情況下，你可以在所有計算機和網絡之間使用這一整數。

2. GUID 的格式為“xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx”，其中每個 x 是 0-9 或 a-f 范圍內的一個十六進制的數字。例如：337c7f2b-7a34-4f50-9141-bab9e6478cc8 即為有效的 GUID 值。

3. 世界上（Koffer注：應該是地球上）的任何兩台計算機都不會生成重復的 GUID 值。GUID 主要用於在擁有多個節點、多台計算機的網絡或系統中，分配必須具有唯一性的標識符。

4. 在 Windows 平台上，GUID 應用非常廣泛：注冊表、類及接口標識、數據庫、甚至自動生成的機器名、目錄名等。





GUID（全局統一標識符）是指在一台機器上生成的數字，它保證對在同一時空中的所有機器都是唯一的。GUID的唯一缺陷在於生成的結果串會比較大。

      對於程序開發的各個方面，.NET Framework簡化了建立和處理GUID數值的過程。在.NET程序需要的地方，這一功能很容易地生成唯一的數值。

1、Guid.NewGuid().ToString("N") 結果為：
         38bddf48f43c48588e0d78761eaa1ce6
2、Guid.NewGuid().ToString("D") 結果為：
            57d99d89-caab-482a-a0e9-a0a803eed3ba
3、Guid.NewGuid().ToString("B") 結果為：
            {09f140d5-af72-44ba-a763-c861304b46f8}
4、Guid.NewGuid().ToString("P") 結果為：
            (778406c2-efff-4262-ab03-70a77d09c2b5)
            
可見默認的為第2種效果

        其中：N、D、B、P分別代表一種輸出格式

小注：在個人使用中，主要是在數據中某列在沒有輸入值的情況下，用於生成內碼（NOT NULL PRIMARY KEY）。
EG:       string str = "insert into 表名(NM,BH,MC) values('" + Guid.NewGuid().ToString("N") + "','" + textBox_bh.Text + "','" + textBox_mc.Text + "')";
            
            




//拜列轉字串(16進制)

	static int buffersize = 18;   //十六進制數的大小（假設為6Byte）
	byte[] buffer = new Byte[buffersize];   //創建緩沖區
	
	private void button1_Click(object sender, EventArgs e)
	{
	    serialPort1.Read(buffer, 0, buffersize);
	    string ss;
	    ss = byteToHexStr(buffer); //用到函數byteToHexStr
	    textBox2.Text = ss;
	    serialPort1.Close();
	    MessageBox.Show("數據接收成功！", "系統提示");
	}
	
	//字節數組轉16進制字符串
	public static string byteToHexStr(byte[] bytes)
	{
	    string returnStr = "";
	    if (bytes != null)
	    {
	        for (int i = 0; i < bytes.Length; i++)
	        {
	            returnStr += bytes[i].ToString("X2");
	        }
	    }
	    return returnStr;
	}
	
	
	 
	



其實在ASP.Net編程中，不用調用md5.ASP來加密數據。在DotNet中有自帶的類：System.Web.Security.HashPassWordForStoringInConfigFile()

public string md5(string str,int code)
{
if(code==16) //16位MD5加密（取32位加密的9~25字符）
{
return System.Web.Security.FormsAuthentication.HashPassWordForStoringInConfigFile(str,"MD5").ToLower().Substring(8,16) ;
}

if(code==32) //32位加密
{
return System.Web.Security.FormsAuthentication.HashPassWordForStoringInConfigFile(str,"MD5").ToLower();
}

return "00000000000000000000000000000000";
}


c#畫三角形、並填充顏色
目前知道有兩種方法：畫多邊形、GraphicsPath。但是用畫多邊形的方式畫三角形不太好。老畫不正的，截圖放大就明顯了。

	Point point1 = new Point(0, 0);
	Point point2 = new Point(11, 0);
	Point point3 = new Point(5, 8);
	Point[] pntArr = {point1, point2, point3};
	
	e.Graphics.FillPolygon(Brushes.Red, pntArr);


C# 條形碼操作【源碼下載】

http://www.aspphp.online/bianchen/dnet/cxiapu/cxprm/201701/185924.html



this.toolStripStatusLabel3.Text = DateTime.Now.DayOfWeek.ToString();
this.textBox1.SelectedText = DateTime.Now.ToString();
this.textBox1.Text += DateTime.Now;


//c#記事本實現代碼




目前大部分數碼相機都將所拍照的圖像保存成JPG格式，
而像拍照日期這樣的 信息統稱為EXIF信息。
EXIF是英文ExchangeableImageFile(可交換圖像文件)的 縮寫




            //獲取本代碼所在的文件作為臨時文件，用於獲取屬性列表
            string tempFile = System.Reflection.Assembly.GetExecutingAssembly().FullName;


new vcs data

不寫注釋是流氓，名字瞎起是扯淡


C#讀取exe版本號

	using System.Reflection;
	using System.IO;
	...
	
	Assembly currentAssembly = Assembly.LoadFile(currentAssemblyPath);
	Assembly updatedAssembly = Assembly.LoadFile(updatedAssemblyPath);
	
	AssemblyName currentAssemblyName = currentAssembly.GetName();
	AssemblyName updatedAssemblyName = updatedAssembly.GetName();
	
	// 比較版本號
	if (updatedAssemblyName.Version.CompareTo(currentAssemblyName.Version) <= 0)
	{
	    // 不需要更新
	    return;
	}
	
	using System.Reflection;
	using System.IO;
	...
	
	AssemblyName currentAssemblyName = AssemblyName.GetAssemblyName(currentAssemblyPath);
	AssemblyName updatedAssemblyName = AssemblyName.GetAssemblyName(updatedAssemblyPath);
	
	// 比較版本
	if (updatedAssemblyName.Version.CompareTo(currentAssemblyName.Version) <= 0)
	{
	    // 不需要更新
	    return;
	}
	
	// 更新
	File.Copy(updatedAssemblyPath, currentAssemblyPath, true);
	


C#對注冊表的操作

C#中提供的與注冊表相關的最主要的是兩個類：

Registry 和 RegistryKey，這兩個類屬於Microsoft.Win32命名空間

 

Registry類包含5個公共的靜態域，分別代表5個基本主鍵分別是：

Registry.ClassesRoot

Registry.CurrentUser

Registry.LocalMachine

Registry.Users

Registry.Current Config

這5個類分別對應注冊表的第二級目錄的五個預定義主鍵

 

RegistryKey類中提供了對注冊表操作的方法

CreateSubKey //建立一個子鍵

OpenSubKey //打開一個子鍵

DeleteKey //刪除一個子鍵

DeleteKeyTree//刪除一個鍵及其下的全部鍵

GetValue //獲取鍵值

SetValue //設置鍵值



//獲取某文件夾所有文件
public static string[] GetFiles(string Path)
{
	return Directory.GetFiles(Path);
}

//讀取文件內容到字符串 www.2cto.com
public static string OpenFile(string Path)
{
	return File.ReadAllText(Path);
}


檢測 USB 設備撥插的 C# 類庫：USBClassLibrary

private void USBPort_USBDeviceAttached(objectsender, USBClass.USBDeviceEventArgs e)
{
	if (!MyUSBDeviceConnected)
	{
		if(USBClass.GetUSBDevice(MyDeviceVID, MyDevicePID, ref USBDeviceProperties, false))
		{
			//My Device is connected
			MyUSBDeviceConnected = true;
		}
	}
}

private void USBPort_USBDeviceRemoved(objectsender, USBClass.USBDeviceEventArgs e)
{
	if(!USBClass.GetUSBDevice(MyDeviceVID, MyDevicePID, ref USBDeviceProperties, false))
	{
		//My Device is removed 
		MyUSBDeviceConnected = false;
	}
}



C# TabControl標簽的隱藏
	當你想要隱藏的時候
	
	if (this.tabMain.TabPages[ "tabpageThePage "] != null)
	
	{
	
	this.tabMain.TabPages.Remove(tabpageThePage);
	
	}
	
	當你想要顯示的時候
	
	if (this.tabMain.TabPages[ "tabpageThePage "] == null)
	
	{
	
	this.tabMain.TabPages.Add(tabpageThePage);
	
	}


c#畫三角形、並填充顏色

代碼 1     Point point1 = new Point(0, 0);
2     Point point2 = new Point(11, 0);
3     Point point3 = new Point(5, 8);
4     Point[] pntArr = {point1, point2, point3};
5 
6     e.Graphics.FillPolygon(Brushes.Red, pntArr);


代碼  1                 int len = 10;                       
 2                 int x = 0;
 3                 int y = 0;
 4                 Point[] pntArr = new Point[3];
 5                 pntArr[0] = new Point(x, y);
 6                 pntArr[1] = new Point(x - len, y);
 7                 pntArr[2] = new Point(x - len / 2, (int)(len * Math.Sqrt(3) / 2 + y));
 8               &nbs 




C# 控制台如何播放音頻文件，
using System.Reflection;
using System.Media;
 
 10             string namespaceName = Assembly.GetExecutingAssembly().GetName().Name.ToString();  
11             Assembly assembly = Assembly.GetExecutingAssembly();
12             SoundPlayer sp = new SoundPlayer(assembly.GetManifestResourceStream(namespaceName + ".Resources" + ".STEAMBLO.WAV"));
13             Console.Write("快看，輪船到了~！");
14             sp.Play();
string namespaceName = Assembly.GetExecutingAssembly().GetName().Name.ToString();   這段代碼是獲取前文檔命名空間的名稱的，也就是對應的“ThePlay”。

Assembly assembly = Assembly.GetExecutingAssembly();   獲取包含當前執行的代碼的程序集。
SoundPlayer sp = new SoundPlayer(assembly.GetManifestResourceStream(namespaceName + ".Resources" + ".STEAMBLO.WAV"));   
namespaceName 是上面獲取的空間名稱，Resource是音頻文件夾的名稱，STEAMBLO.WAV 是對應的音頻文件！ 區分大小寫！ 不然會導致獲取為空！ 遺憾的是，只支持.wav格式的音頻文件！

什麼？還是播放不了？





        protected override void OnPaintBackground(PaintEventArgs e)
        {
            //不進行背景的繪制
        }


                //創建一個進程
                Process pc = new Process();
                pc.StartInfo.FileName = command;
                pc.StartInfo.UseShellExecute = false;
                pc.StartInfo.RedirectStandardOutput = true;
                pc.StartInfo.RedirectStandardError = true;
                pc.StartInfo.CreateNoWindow = true;

                //啟動進程
                pc.Start();

                //准備讀出輸出流和錯誤流
                string outputData = string.Empty;
                string errorData = string.Empty;
                pc.BeginOutputReadLine();
                pc.BeginErrorReadLine();

                pc.OutputDataReceived += (ss, ee) =>
                {
                    outputData += ee.Data;
                };

                pc.ErrorDataReceived += (ss, ee) =>
                {
                    errorData += ee.Data;
                };

                //等待退出
                pc.WaitForExit();

                //關閉進程
                pc.Close();


//字符串轉數組
string mystring="this is a string"
char[] mychars=mystring.ToCharArray();

//foreach循環處理char數組
foreach(char mychar in mystring)
{
Console.WriteLine(mychar);
}
mystring.Length //獲取元素的個數 


        
        

c# 控件閃爍處理方法
如果你在Form中繪圖的話，不論是不是采用的雙緩存，都會看到圖片在更新的時候都會不斷地閃爍，解決方法就是在這個窗體的構造函數中增加以下三行代碼：

請在構造函數裡面底下加上如下幾行：
SetStyle(ControlStyles.UserPaint, true);
SetStyle(ControlStyles.AllPaintingInWmPaint, true); // 禁止擦除背景.
SetStyle(ControlStyles.DoubleBuffer, true); // 雙緩沖
參數說明：

UserPaint
如果為 true，控件將自行繪制，而不是通過操作系統來繪制。此樣式僅適用於派生自 Control 的類。

AllPaintingInWmPaint
如果為 true，控件將忽略 WM_ERASEBKGND 窗口消息以減少閃爍。僅當 UserPaint 位設置為 true 時，才應當應用該樣式。

DoubleBuffer
如果為 true，則繪制在緩沖區中進行，完成後將結果輸出到屏幕上。雙重緩沖區可防止由控件重繪引起的閃爍。要完全啟用雙重緩沖，還必須將 UserPaint 和 AllPaintingInWmPaint 樣式位設置為 true。


/// <summary>
/// 根據url獲取遠程html源碼
/// </summary>
/// <param name="url">搜索url</param>
/// <returns>返回DownloadData</returns>
public static string GetSearchHtml(string url)
{
    WebClient MyWebClient = new WebClient();
    MyWebClient.Credentials = CredentialCache.DefaultCredentials;   //獲取或設置用於對向Internet資源的請求進行身份驗證的網絡憑據。
    Byte[] pageData = MyWebClient.DownloadData(url);                //從指定url下載數據
    return Encoding.UTF8.GetString(pageData);                       //獲取網站頁面采用的是UTF-8
}




C# 關閉窗體立即停止進程
C#在關閉窗體的時候，有時線程還在後台執行，沒有及時退出。
處理方案：
　　為Form添加FormClosing事件，加入以下語句，在退出時，殺死本進程。
System.Diagnostics.Process.GetCurrentProcess().Kill();  



C#的WebBrowser控件浏覽網頁
        private void toolStripButton1_Click(object sender, EventArgs e)
        {
            string add = "";
            if (!(txtUrl.Text.Trim().StartsWith("http://")))
            {
                add = "http://" + txtUrl.Text.Trim();
                txtUrl.Text = add;
            }
            webBrowser1.Url = new Uri(add);
        }


//初始化加載皮膚 
            skinEngine1.SkinFile = "MacOS.ssk"; 

 skinEngine1.SkinFile = "PageColor.ssk"; 


objStreamWriter = new StreamWriter(objFileStream, System.Text.Encoding.Unicode); 



   private DataSet ReadExcel(string strFileName, string sheetName)//使用OLE操作數據庫的方法讀取excel數據，導入到系統 
        { 
            if (strFileName == string.Empty) 
            { 
                return null; 
            } 
            else 
            { 
                string strConnection = "Provider=Microsoft.Jet.OLEDB.4.0;Data Source = " + strFileName + ";Extended Properties = Excel 8.0"; 
                OleDbConnection oleConnection = new OleDbConnection(strConnection); 
                oleConnection.Open(); 
                DataSet dsRead = new DataSet(); 
                OleDbDataAdapter oleAdper = new OleDbDataAdapter(" SELECT *  FROM [" + sheetName + "$]", oleConnection); 
                oleAdper.Fill(dsRead, "result"); 
                oleConnection.Close(); 
                return dsRead;  
            }                                      
        } 
        
        
        
        
        
        
        
        

C#:判斷當前程序是否通過管理員運行，

public bool IsAdministrator()
{
WindowsIdentity current = WindowsIdentity.GetCurrent();
WindowsPrincipal windowsPrincipal = new WindowsPrincipal(current);
return windowsPrincipal.IsInRole(WindowsBuiltInRole.Administrator);
}


C# 文件創建時間，修改時間，

System.IO.FileInfo fi = new System.IO.FileInfo(@"D:\site\EKECMS\skin\Grey\default#.html");
Response.Write("修改時間：" + fi.LastWriteTime.ToString() + "<br>");
Response.Write("創建時間：" + fi.CreationTime.ToString() + "<br>");

//在代碼中設置控件的padding 設置Label的字體
如果要在代碼中設置margin，可以使用如下代碼：
this.label1.Padding = new Padding(20,8,20,8);
或者=new Padding(20);

設置Label的字體代碼：
this.label1.Font = new Font(label1.Font.FontFamily,10f);

設置Label的背景色代碼：
this.label1.BackColor = Color.FromArgb(((int)(((byte)(226)))), ((int)(((byte)(238)))), ((int)(((byte)(255)))));



在不設置Cookie、PostData的情況下要獲得一個頁面 的HTML的方法很簡單：

public static string GetHtml(string URL)
　 　　　{
　　　　　　WebRequest wrt;
　　　　　　wrt = WebRequest.Create(URL);
　　　　　　wrt.Credentials = CredentialCache.DefaultCredentials;
　　　　　　WebResponse wrp;
　　　 　　　wrp = wrt.GetResponse();
　　　　　　return new StreamReader (wrp.GetResponseStream(), Encoding.Default).ReadToEnd();
　　　　} 



地支時間與現在時間的對應關系：

【子時】夜半，又名子夜、中夜：十二時辰的第一個時辰。（23時至次日01時）。

【丑時】雞鳴，又名荒雞：十二時辰的第二個時辰。（01時至03時）。

【寅時】平旦，又稱黎明、早晨、日旦等：時是夜與日的交替之際。（03時至05時）。

【卯時】日出，又名日始、破曉、旭日等：指太陽剛剛露臉，冉冉初升的那段時間。（05 時至07時）。

【辰時】食時，又名早食等：古人“朝食”之時也就是吃早飯時間，（07時至 09時）。

【巳時】隅中，又名日禺等：臨近中午的時候稱為隅中。（09時至11時）。

【午時】日中，又名日正、中午等：（11時至13時）。

【未時】日昳，又名日跌、日央等：太陽偏西為日跌。（13時至15時）。

【申時】哺時，又名日鋪、夕食等：（15時至17時）。

【酉時】日入，又名日落、日沉、傍晚：意為太陽落山的時候。（17時至19時）。　

【戌時】黃昏，又名日夕、日暮、日晚等：此時太陽已經落山，天將黑未黑。天地昏黃，萬物朦胧 ，故稱黃昏。（19時至21時）。

【亥時】人定，又名定昏等：此時夜色已深，人們也已經停止活動，安歇睡眠了。人定也就是人靜 。（21時至23時）。




開關檔案 使用指定的編碼
StreamWriter outStream = new StreamWriter( filepath,false,System.Text.Encoding.GetEncoding( 950 ) );
using ( StreamReader sr = new StreamReader( filepath,System.Text.Encoding.GetEncoding( 936 ) ) )




//Winform中如何讀取局域網路由的IP地址代碼
System.Net.WebClient client = new System.Net.WebClient();
client.Encoding = System.Text.Encoding.Default;
string lip = client.DownloadString("http://www.ip138.com/ip2city.asp");
string sip = reply.Substring(reply.IndexOf("您的IP地址是"), reply.IndexOf("</center>") - reply.IndexOf("您的IP地址是"));
MessageBox.Show(sip);


C#之讀取web上的xml
string　sURL　=　"http://localhost:9058/GameServerInfo/XMLFile.xml";
XDocument　oXDoc　=　XDocument.Load(sURL);

用C＃實現在客戶區拖動窗體



C# WindowsMediaPlayer 的一些用法

播放單首歌曲

                player.URL = 

添加多首歌曲到播放列表

            IWMPPlaylist playList = player.playlistCollection.newPlaylist(); 
 (DataRow drItem = player.newMedia(drItem[].ToString()); 
=

 或者直接在當前列表上添加

 (DataRow drItem = player.newMedia(drItem[].ToString()); 


設置播放器音量

 player.settings.volume=;


 設置循環播放

player.settings.setMode(, );

 

設置隨機播放


  player.settings.setMode(, );




C#調用默認浏覽器打開網頁的幾種方法




方法一：從注冊表中讀取默認浏覽器可執行文件路徑

 

        private void button1_Click(object sender, EventArgs e)
        {
            //從注冊表中讀取默認浏覽器可執行文件路徑
            RegistryKey key = Registry.ClassesRoot.OpenSubKey(@httpshellopencommand);
            string s = key.GetValue().ToString();

            //s就是你的默認浏覽器，不過後面帶了參數，把它截去，不過需要注意的是：不同的浏覽器後面的參數不一樣！
            //D:Program Files (x86)GoogleChromeApplicationchrome.exe -- %1
            System.Diagnostics.Process.Start(s.Substring(0, s.Length - 8), http://blog.csdn.net/testcs_dn);
        }
方法二：
        private void button2_Click(object sender, EventArgs e)
        {
            //調用系統默認的浏覽器 
            System.Diagnostics.Process.Start(explorer.exe, http://blog.csdn.net/testcs_dn);
        }
方法三：
        private void button3_Click(object sender, EventArgs e)
        {
            //調用系統默認的浏覽器 
            System.Diagnostics.Process.Start(http://blog.csdn.net/testcs_dn);
        }

方法四：調用IE浏覽器


從原理上來講，方法二和方法三應該是一樣的，不過方法三的代碼更短一點。 




命令行msinfo32


三、添加office相關引用
Microsoft.Office.Interop.Word 12.0.0.0





using System.Data.OleDb;
using System.Data.SqlClient;
using System.IO;
using Microsoft.Office.Core;
using Word=Microsoft.Office.Interop.Word;
using System.Reflection;

如果其路徑包含後綴名的話，要取得後綴名，只需要一行代碼即可：
1 var ext = System.IO.Path.GetExtension("C:\\soar.jpg");






用C#獲取硬盤ID編號
在軟件產品中常常需要制作軟件注冊碼，而根據硬件產品編號制作注冊碼是一個不錯得選擇。可以使用讀取注冊表的方式獲得第一塊硬盤的編號。 主要程序代碼。

private void button1_Click(object sender, EventArgs e)
{
    textBox1.Text = Registry.GetValue("HKEY_Local_Machine\\HardWare\\Devicemap\\Scsi\\Scsi port 0\\Scsi Bus 0\\Target Id 1\\Logical Unit Id 0","Identifier","cuowu").ToString();
}



            richTextBox1.Text += "string.PadLeft 字串統一長度或補字元\n";
            int a = 15;
            string s1 = a.ToString().PadLeft(10, '-');
            richTextBox1.Text += s1 + "\n";

            string s2 = string.Format("{0:00000}", Convert.ToInt16(a));
            richTextBox1.Text += s2 + "\n";





            //System.Text.StringBuilder("")
            //字元串相加，（+號是不是也一樣？）
            System.Text.StringBuilder sb = new System.Text.StringBuilder("");
            sb.Append("AB");
            sb.Append("CD");
            sb.Append("EFG");

            richTextBox1.Text += sb + "\n";



設定資料到剪貼簿
                Clipboard.SetText(textBox1.Text);
                MessageBox.Show("已成功將文本框內容復制到剪貼板!");
                
從剪貼簿取得資料
            string txt2 = textBox2.Text;
            try
            {
                IDataObject iData = Clipboard.GetDataObject();
                if (iData.GetDataPresent(DataFormats.Text))
                {
                    //MessageBox.Show((string)iData.GetData(DataFormats.Text));
                    textBox2.Text = (string)iData.GetData(DataFormats.UnicodeText);
                }
                else
                {
                    MessageBox.Show("目前剪貼板中數據不可轉換為文本", "錯誤");
                }
            }
            
                            

String.Format是將指定的 String類型的數據中的每個格式項替換為相應對象的值的文本等效項。 
如:

（1）
string p1 = "Jackie";
string p2 = "Aillo";
Response.Write(String.Format("Hello {0}, I'm {1}", p1, p2));
（2）
Response.Write(String.Format("Hello {0}, I'm {1}", "Jackie", "Aillo"));


求取字母的ASCII值

            Console.Write("輸入一個字符："); 
            char c = Console.ReadKey().KeyChar; 
            Console.WriteLine("\r\n字符{0}的ASCII值是：{1}", c, (int)c); 
            Console.ReadKey(false); 



DataGridView 指定欄位排序

// 根據 資料行1 (Name) 做 大到小 排序
dataGridView1.Sort(dataGridView1.Columns[1], System.ComponentModel.ListSortDirection.Descending); 

// 根據 資料行1 (Name) 做 小到大 排序 
dataGridView1.Sort(dataGridView1.Columns[1], System.ComponentModel.ListSortDirection.Ascending); 



    
    
            //                    來源位置             目的位置      要傳輸的區域大小  判斷在像素複製作業中來源色彩如何與目的色彩結合以產生最後的色彩
            //g.CopyFromScreen(new Point(x_st, y_st), new Point(0, 0), new Size(w, h), CopyPixelOperation.SourceInvert);
            //g.CopyFromScreen(new Point(x_st, y_st), new Point(0, 0), new Size(w, h));
            g.CopyFromScreen(new Point(pt.X - w / 2, pt.Y - h / 2), new Point(0, 0), new Size(w, h));


//隨機生成四位驗證碼（0~9，a~Z）
            int LEN = 4;
            Random r = new Random();
            string code = "0123456789abcdefghjklmnopqistuvwxyzABCDEFGHIJKLMNOPQISTUVWXYZ";
            string captcha = "";
            for (int i = 0; i < LEN; i++)
            {
                int ra = r.Next(code.Length);
                captcha = code.Substring(ra, 1) + captcha;
            }
            richTextBox1.Text += captcha + "\n";
            
            
using System.Reflection;
            //取得 namespaceName
            string namespaceName = Assembly.GetExecutingAssembly().GetName().Name.ToString();

            richTextBox1.Text += namespaceName + "\n";

            richTextBox1.Text += Assembly.GetExecutingAssembly().Location + "\n";


//播放音樂
using System.Media;
            string filename = @"C:\______test_files\_wav\start.wav";
            SoundPlayer sp = new SoundPlayer(filename);
            sp.Play();
        
        
      //挪用體系默許的閱讀器 
      System.Diagnostics.Process.Start( "http://www.谷歌.cn");  


            string foldername = @"C:\______test_files\_pic";
            DirectoryInfo TheFolder = new DirectoryInfo(foldername);

            richTextBox1.Text += "遍歷文件夾\n";
            //遍歷文件夾
            foreach (DirectoryInfo NextFolder in TheFolder.GetDirectories())
            {
                this.listBox1.Items.Add(NextFolder.Name);
                richTextBox1.Text += NextFolder.Name+"\n";
            }
            richTextBox1.Text += "\n";

            richTextBox1.Text += "遍歷文件\n";
            foreach (FileInfo NextFile in TheFolder.GetFiles())
            {
                this.listBox2.Items.Add(NextFile.Name);
                richTextBox1.Text += NextFile.Name + "\n";
            }
            richTextBox1.Text += "\n";



16進制與字符串、字節數組之間的轉換。，

1.將十進制數的字符串轉化成十六進制數的字符串

//十進制轉二進制
Console.WriteLine("十進制166的二進制表示: "+Convert.ToString(166, 2));
//十進制轉八進制
Console.WriteLine("十進制166的八進制表示: "+Convert.ToString(166, 8));
//十進制轉十六進制
Console.WriteLine("十進制166的十六進制表示: "+Convert.ToString(166, 16));
    
//二進制轉十進制
Console.WriteLine("二進制 111101 的十進制表示: "+Convert.ToInt32("111101", 2));
//八進制轉十進制
Console.WriteLine("八進制 44 的十進制表示: "+Convert.ToInt32("44", 8));
//十六進制轉十進制
Console.WriteLine("十六進制 CC的十進制表示: "+Convert.ToInt32("CC", 16));

2.16進制與字符串、字節數組之間的轉換

            richTextBox1.Text += "取得網頁資料\n";
            string strUrl = "https://www.google.com.tw/"; //獲得IP的網址了

            Uri uri = new Uri(strUrl);
            System.Net.WebRequest wr = System.Net.WebRequest.Create(uri);
            System.IO.Stream s = wr.GetResponse().GetResponseStream();
            System.IO.StreamReader sr = new System.IO.StreamReader(s, Encoding.Default);
            string all = sr.ReadToEnd(); //讀取網站的數據
            richTextBox1.Text += all + "\n";



 C# 修改啟始Form [複製鏈接]
打開program.cs，修改Application.Run(new Form1());，將Form1改為要啟始的頁面即可!


網際網路時間伺服器，
從原來的 time.windows.com 改為 time.nist.gov，


C# 播放 wav 或音樂檔方式

在 C# 內播放 wav或音樂檔案方式，可使用下面範例實現
Sample Code

System.Media.SoundPlayer sp = new System.Media.SoundPlayer();
sp.SoundLocation = @"C:\Wave音效檔\DoReMe.wav";
sp.Play(); // 撥放
..
..
..
sp.Stop(); // 停止

 
 
 



//如何取得網路上的圖片並顯示 
            string url = @"https://upload.wikimedia.org/wikipedia/commons/0/0f/Ic-photo-intel-D4004.png";
            this.pictureBox1.Image = ReadImageFromUrl(url);

        private Image ReadImageFromUrl(string urlImagePath)
        {
            Uri uri = new Uri(urlImagePath);
            WebRequest webRequest = WebRequest.Create(uri);
            Stream stream = webRequest.GetResponse().GetResponseStream();
            Image res = Image.FromStream(stream);
            return res;

        }



3. 如何为一个窗体设置一个默认按钮？（How to set the default button for a form?）

form1.AcceptButton = button1;

4. 如何为一个窗体设置一个取消按钮？（How to set the Cancel button for a form?）

form1.CancelButton = button1;

5. 如何阻止一个窗体标题显示在任务栏上？（How to prevent a form from being shown in the taskbar?）

设置窗体的ShowIntaskbar属性为False

9. 如何获取应用程序当前执行的路径？（How to get the path to my running EXE?）

string appPath = Application.ExecutablePath; 

23. 如何使Windows Form上的Panel或者Label控件半透明？（How to make a Panel or Label semi-transparent on a Windows Form? ）

通过设置控件背景色的alpha值
panel1.BackColor = Color.FromA#41ccd4;
注意：在设计时手动输入这些值，不要用颜色选取


設定倒數計時
        DateTime dtTarget;
        private void Form1_Load(object sender, EventArgs e)
        {
            //dtTarget = DateTime.Now.AddHours(2);  //設定兩小時後
            dtTarget = new DateTime(2021, 9, 30, 12, 0, 0);   //設定特定時間

            timer1.Start();
        }

        private void timer1_Tick(object sender, EventArgs e)
        {
            TimeSpan diffTime = dtTarget.Subtract(DateTime.Now);

            string diffHour = Convert.ToString(diffTime.Hours);
            string diffMin = Convert.ToString(diffTime.Minutes);
            string diffSec = Convert.ToString(diffTime.Seconds);
            label1.Text = "距離 " + dtTarget.ToString() + " 還有 " + diffHour + " 時 " + diffMin + " 分 " + diffSec + " 秒";

        }


        //執行時期 顯示 屬性編輯視窗
        private void Form1_Load(object sender, EventArgs e)
        {
            PropertyGrid PG = new PropertyGrid();
            Form PGForm = new Form();
            PGForm.Owner = this;
            PGForm.StartPosition = FormStartPosition.Manual;
            PGForm.Left = this.Left + this.Width;
            PGForm.Top = this.Top;
            PGForm.ShowInTaskbar = false;
            PGForm.Controls.Add(PG);
            PG.Dock = DockStyle.Fill;
            PG.SelectedObject = this.label1;  //選擇要顯示的控件名稱
            PGForm.Text = "Label 屬性編輯視窗";
            PGForm.Show();
        }



驗證台灣手機號碼
            bool match;
            match = System.Text.RegularExpressions.Regex.IsMatch(textBox1.Text, @"^09[0-9]{8}$");
            if (match == true)
            {
                richTextBox1.Text += "OK\n";
                     
            }
            else
            {
                richTextBox1.Text += "NG\n";
            }



陣列
一群資料型態相同的變數集合在一起

反向運算子



要顯示 & 以 ＆amp;取代
要顯示 < 以 ＆lt;取代
要顯示 > 以 ＆gt;取代
要顯示 " 以 ＆quot;取代
要顯示 ' 以 ＆apos;取代

Unicode中文字碼（CJK Unified Ideographs；中日韓統一表意文字）的範圍落在0x4E00至0x9FFF（UTF-32），但迄今（Unicode v11.0）最末的0x9FF0～0x9FFF這16個字仍是空白。


#define abs(a, b)	(((a) > (b)) ? (a - b) : (b - a))

printf("function: %s:%s(%d) debug message\r\n",__FILE__,__func__,__LINE__);
       

內建函式

if(isprint(ch))
系統時間

函式 abs dec2hex hex2dec print9X9_Table

VC#
資料型態	string(字串) bool(布耳)
各種控件	button richtextbox picturebox timer

ENUM的用法
        // 定義WeekDays列舉內容7個成員
        // 用來表示一星期的星期日到星期六的列舉常數值
        enum WeekDays : int
        {
            Monday = 1,      	// 星期一
            Tuesday = 2,         // 星期二
            Wednesday = 3,       // 星期三
            Thursday = 4,        // 星期四
            Friday = 5,          // 星期五
            Saturday = 6,        // 星期六
            Sunday = 7           // 星期日
        };

        static void Main(string[] args)
        {
            // 取出WeekDays.Wednesday列舉常數值之後再轉成整數
            Console.WriteLine("星期三列舉常數值：{0}", (int)WeekDays.Wednesday);
            Console.WriteLine("星期五列舉常數值：{0}", (int)WeekDays.Friday);
            Console.Read();
        }
        

colsole mode的scanf        
        
            // 宣告字串資料型別ProductName變數，用來存放品名
            string ProductName;
            // 宣告整數資料型別Price變數，用來存放單價
            int Price;
            Console.Write("請輸入品名：");        // 印出 "請輸入品名："
            // 由鍵盤輸入品名資料並按 [Enter]鍵，即將品名存放至ProductName變數
            ProductName = Console.ReadLine();
            Console.Write("請輸入單價：");         // 印出 "請輸入單價："
            // 由鍵盤輸入單價並按 [Enter]鍵，將單價轉成整數之後
            // 再將單價放至Price變數
            Price = int.Parse(Console.ReadLine());
            Console.WriteLine("品名：{0}　單價：{1}　這筆記錄儲存成功",ProductName, Price);
            Console.Read();

console mode讀取double數字
            double netIncome;
            int taxRate;

            Console.Write("請輸入全年綜合所得淨額(單位:萬元) : ");
            netIncome = double.Parse(Console.ReadLine());

console mode讀取字串
            // 宣告Ans字串變數用來存放使用者由鍵盤輸入的答案
            string Ans = Console.ReadLine();
                        
struct用法

        // 定義Product產品結構資料型別
        struct Product
        {
            // Product產品結構內含No編號欄位、Name品名欄位、Price單價欄位
            public string No, Name;
            public int Price;
       }

       static void Main(string[] args)
        {
            // 宣告game結構變數為Product結構型別
             Product game;
            // 設定game.No編號欄位的值為 "G01"
            game.No = "G01";
            // 設定game.Name品名欄位的值為"XBox One"
            game.Name = "XBox One";
            // 設定game.Price單價欄位的值為10000
            game.Price = 10000;
            Product cookie;        // 宣告cookie結構變數為Product結構型別
            Console.Write(" 請輸入產品編號：");
            // 由鍵盤輸入編號再指定給cookie.No編號欄位
            cookie.No = Console.ReadLine();
            Console.Write(" 請輸入產品名稱：");
            // 由鍵盤輸入品名再指定給cookie.Name品名欄位
            cookie.Name = Console.ReadLine();
            Console.Write(" 請輸入產品單價：");
            // 由鍵盤輸入單價並轉成整數再指定給cookie.Price單價欄位
            cookie.Price = int.Parse(Console.ReadLine());
            Console.WriteLine();
            Console.WriteLine(" ====== 產品單價清單 ====== ");
            Console.WriteLine();
            // 印出game及cookie結構的編號、品名及單價
            Console.WriteLine(" 產品編號：{0} ", game.No);
            Console.WriteLine(" 產品名稱：{0} ", game.Name);
            Console.WriteLine(" 產品單價：{0} ", game.Price);
            Console.WriteLine(" 產品編號：{0} ", cookie.No);
            Console.WriteLine(" 產品名稱：{0} ", cookie.Name);
            Console.WriteLine(" 產品單價：{0} ", cookie.Price);
            Console.Read();
        }



        
        
        
#include <stdio.h>
int main(int argc,char* argv[])
{



    /*
	int i;

	time_t time_ptr;

	printf("david: This is a c template.\n");

	printf("function: %s:%s(%d) debug message\r\n",__FILE__,__func__,__LINE__);


	time(&time_ptr);

	printf("現在時間 : %s\n", asctime(localtime(&time_ptr)));
*/


    time_t t1 = time(NULL);
    struct tm *nPtr = localtime(&t1);
    char *now = asctime(nPtr);

    printf("現在時間 : %s\n", now);
    printf("len = %d\n",sizeof(now));

    int i;

    for(i=0;i<sizeof(now);i++)
    {
        printf("%c\n", now[i]);


    }



    //srand(123);
    srand(now[0]);

    for(i=0;i<10;i++)
    {
        printf("%c\n", 'A' + rand() % 26);

    }

	return 0;
}
        
        
        
        



Display_Cam1

            //pictureBox1.Image = (Bitmap)eventArgs.Frame.Clone();
            bm = (Bitmap)eventArgs.Frame.Clone();
            //bm.RotateFlip(RotateFlipType.RotateNoneFlipY);    //反轉
            pictureBox1.Image = bm;

            GC.Collect();       //回收資源

//--------------------------

            //录像
            //pictureBox1.Image = (Bitmap)eventArgs.Frame.Clone();
            bm = (Bitmap)eventArgs.Frame.Clone();
            //bm.RotateFlip(RotateFlipType.RotateNoneFlipY);    //反轉
			
            Graphics g = Graphics.FromImage(image);
			
			
										SolidBrush drawBrush = new SolidBrush(Color.Yellow);

										Font drawFont = new Font("Arial", 6, System.Drawing.FontStyle.Bold, GraphicsUnit.Millimeter);
										int xPos = image.Width - (image.Width - 15);
										int yPos = 10;
										//写到屏幕上的时间
										string drawDate = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss");

										g.DrawString(drawDate, drawFont, drawBrush, xPos, yPos);

            ////创建文件路径
            string fileFullPath = videoPath + "V1" + DateTime.Now.ToString("yyyy-MM-dd-HH-mm-ss");

            if (stopREC)
            {
                stopREC = true;
                createNewFile = true;  //这里要设置为true表示要创建新文件
                if (videoWriter != null)
                    videoWriter.Close();
            }
            else
            {
										//开始录像
										if (createNewFile)
										{

											createNewFile = false;
											if (videoWriter != null)
											{
												videoWriter.Close();
												videoWriter.Dispose();
											}
											richTextBox1.Text += "開啟檔案 : " + fileFullPath + "\n";

											videoWriter = new VideoFileWriter();
											//这里必须是全路径，否则会默认保存到程序运行根据录下了
											videoWriter.Open(fileFullPath, image.Width, image.Height, 30, VideoCodec.MPEG4);
											videoWriter.WriteVideoFrame(image);
										}
										else
										{
											videoWriter.WriteVideoFrame(image);
										}
            }



fileFullPath : C:\_git\vcs\_2.vcs\my_vcs_lesson_c_example\_video\OperateCamera\bin\Debug\V12021-08-20-15-39-07





關掉AForge的VSP
        // Close currently open camera if any
        private void CloseCamera()
        {
            if (videoSource != null)
            {
                videoSourcePlayer.VideoSource = null;

                videoSource.SignalToStop();
                videoSource.WaitForStop();
                videoSource = null;
            }
        }		




			

                string appDir = Path.GetDirectoryName(Assembly.GetCallingAssembly().GetName().CodeBase);
                path = Path.Combine(appDir, path);

        private static string FFMPEG_EXE_PATH = CheckRelativePath(@"ffmpeg\ffmpeg.exe");
        private static string FFPROBE_EXE_PATH = CheckRelativePath(@"ffmpeg\ffprobe.exe");

            string cmdParams = String.Format("-hide_banner -ss {0} -i {1} -r 1 -t 1 -f image2 {2}", atPositioin, filename, tmpFileName);

                // Execute command to let FFMPEG extract the frame
                Execute(FFMPEG_EXE_PATH, cmdParams);

        private static string Execute(string exePath, string parameters)
        {
            string result = String.Empty;

            using (Process p = new Process())
            {
                p.StartInfo.UseShellExecute = false;
                p.StartInfo.CreateNoWindow = true;
                p.StartInfo.RedirectStandardOutput = true;
                p.StartInfo.FileName = exePath;
                p.StartInfo.Arguments = parameters;
                p.Start();
                p.WaitForExit();

                result = p.StandardOutput.ReadToEnd();
            }

            return result;
        }



在 C# 中使用 File.ReadAllText() 方法將檔案讀取為字串
string text = File.ReadAllText(@"C:\File\file.txt");
Console.WriteLine(text);

在 C# 中使用 StreamReader.ReadToEnd() 方法將檔案讀取為字串
StreamReader fileReader = new StreamReader(@"C:\File\file.txt");
string text = fileReader.ReadToEnd();
Console.WriteLine(text);			

使用 C# 中的 FileInfo.Length 屬性獲取檔案大小



            FileInfo fileinfo = new FileInfo("dark.jpg");
            Console.WriteLine(fileinfo.Length);
FileInfo 類提供了用於在 C# 中建立，開啟，複製，刪除和移動檔案的方法。


在 C# 中使用 BitConverter.ToString() 方法將字串轉換為十六進位制

            string decString = "0123456789";
            byte[] bytes = Encoding.Default.GetBytes(decString);
            string hexString = BitConverter.ToString(bytes);
            hexString = hexString.Replace("-", "");
            Console.WriteLine(hexString);



在 C# 中使用 String.Format() 方法將字串轉換為十六進位制
            string decString = "0123456789";
            var hexString = string.Join("",
                decString.Select(c => String.Format("{0:X2}", Convert.ToInt32(c))));
            Console.WriteLine(hexString);


Process.Start("http://www.mrbccd.com");

//打开注册表
string regeditstr = Environment.GetEnvironmentVariable("WinDir");//WinDir系统环境变量的名称
Process.Start(regeditstr + "\\regedit.exe");//打开注册表


//開啟檔案總管到指定的目錄
string Path = @"C:\dddddddddd";
Process.Start("explorer.exe", Path);

Process.Start(textBox1.Text);//打开文件夹进行查看

richTextBox1.Text += "在任務欄中顯示\n";
this.ShowInTaskbar = true;

richTextBox1.Text += "不在任務欄中顯示\n";
this.ShowInTaskbar = false;


this.StartPosition = FormStartPosition.CenterScreen;//視窗居中顯示


MainMenu選了之後會有打勾記號

        // On Size menu item popup
        private void sizeItem_Popup(object sender, System.EventArgs e)
        {
            normalSizeItem.Checked = (pictureBox.SizeMode == PictureBoxSizeMode.Normal);
            stretchedSizeItem.Checked = (pictureBox.SizeMode == PictureBoxSizeMode.StretchImage);
            centeredSizeItem.Checked = (pictureBox.SizeMode == PictureBoxSizeMode.CenterImage);
        }



richTextBox1.Text += "測試使用WindowsMediaPlayerClass\n";
WindowsMediaPlayerClass c;
IWMPMedia m;

c = new WindowsMediaPlayerClass();
m = c.newMedia(mp3_filename);
richTextBox1.Text += "歌手名:\t" + m.getItemInfo("Author") + "\n" + "歌  名:\t" + m.getItemInfo("Title") + "\n";


getItemInfo Author Title

// Store the current media object.
var cm = Player.currentMedia;

// Get the number of attributes for the current media. 
var atCount = cm.attributeCount;

// Loop through the attribute list.
for(var i=0; i < atCount; i++){

   // Print each attribute index and name.   
   myText.value += "Attribute " + i +": ";
   myText.value += cm.getAttributeName(i);
   myText.value += "\n";
}




//添加列表
WC = new WMPLib.WindowsMediaPlayerClass();
MC = WC.newMedia(str);
this.axWindowsMediaPlayer1.currentPlaylist.appendItem(MC);
richTextBox1.Text += "add " + str + "\n";




            /*  無法依子目錄排序 廢棄
            if (path == String.Empty)
                path = search_path;

            //C# 取得資料夾下的所有檔案(包括子目錄)
            string[] files = Directory.GetFiles(path, filetype2, System.IO.SearchOption.AllDirectories);
            foreach (string filename in files)
            {
                //richTextBox1.Text += filename + "\n";
                FileInfo fi = new FileInfo(filename);
                richTextBox1.Text += fi.Name + "\n";
            }
            */



string newID = id.Insert(6, "19");


        private void button1_Click(object sender, EventArgs e)
        {
            richTextBox1.Text += "檢查IP合法性\n";
            string[] lines = new string[4];
            string s = ".";
            string ip = "192.168.0.123";

            lines = ip.Split(s.ToCharArray(), 4);

            for (int i = 0; i < 4; i++)
            {
                if (Convert.ToInt32(lines[i]) >= 255)
                {
                    richTextBox1.Text += "不合法\n";
                    return;
                }
            }
            richTextBox1.Text += "合法\n";
			

        }




如何清除播放清單

顯示播放清單的內容

播放清單移除特定檔案






        public override string show()
        {
            return base.show() +
                   ": 寬 = " + width +
                   ", 高 = " + height;
        }
		
        public string listing()
        {
            string res = "";

            for (int i = 0; i < count; i++)
            {   // polymorphism
                Shape s = shapeArray[i];
                res += s.show() + ", 面積 = " + s.area() +
                       "\r\n-----------------------\r\n";
            }

            return res;
        }




計算程式執行的時間

int URms = System.Environment.TickCount;

XXXXXXXXX

Console.WriteLine("花費 {0} ms 完成!!!", Environment.TickCount - URms);






//紀錄開始的時間
Stopwatch sw = new Stopwatch();//引用stopwatch物件

sw.Reset();//時間歸零
sw.Start();
sw.Stop();

            label1.Text = "經過時間: " 
                + sw.Elapsed.Hours.ToString().PadLeft(2,'0') + ":"
                + sw.Elapsed.Minutes.ToString().PadLeft(2, '0') + ":"
                + sw.Elapsed.Seconds.ToString().PadLeft(2, '0');
				
				

做一個我的 Transform範例

角度-180~+180
正弦值 -1~+1

xmin = -180;
xmax = 180;
ymin = -1;
ymax = 1;
xmargin = 10;
ymargin = 0.2;

顯示區域寬度W  if 720
顯示區域高度H  if 360

xratio = W/(xmax-xmin+xmargin*2);     //2 倍
yratio = H/(ymax-ymin+ymargin*2);     //180 倍

x=xmin:1:xmax;
y=sind(x);

先不考慮margin  把圖畫在中間

畫x時 每點相距 2 pixel

畫y時 要放大180倍

for(i=0; i<360;i++)
{
 x_new = x_old*2;
 y_new = y_old*180;
}


            e.Graphics.Clear(picGraph.BackColor);
            if (Balance.Count < 2) return;

            e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;

            // Scale to make the data fit.
            float xmin = -1;
            float xmax = Contributions.Count + 1;
            float ymax = Balance.Max(pt => pt.Y);
            float ymin = -ymax * 0.05f;
            RectangleF rect = new RectangleF(xmin, ymin, xmax - xmin, ymax - ymin);
            PointF[] pts =
            {
                new PointF(0, picGraph.ClientSize.Height),
                new PointF(picGraph.ClientSize.Width, picGraph.ClientSize.Height),
                new PointF(0, 0),
            };
            Transform = new Matrix(rect, pts);
            e.Graphics.Transform = Transform;




        string drap_setup_filename = "drap_setup.ini";

        void update_setup_file()
        {
            richTextBox2.Text += "update_setup_file ST\n";
            richTextBox2.Text += "length of old_search_path = " + old_search_path.Count.ToString() + "\n";

            {
                StreamWriter sw = File.CreateText(drap_setup_filename);
                string content = "";
                //定義系統版本
                Version ver = Environment.OSVersion.Version;
                //Major主版本號,Minor副版本號
                if (ver.Major == 6 && ver.Minor == 1)
                {
                    //Windows7
                    content += "\"C:\\Program Files\\DAUM\\PotPlayer\\PotPlayerMini.exe\"\n";
                }
                else
                {
                    //Windows10
                    content += "\"C:\\Program Files (x86)\\DAUM\\PotPlayer\\PotPlayerMini.exe\"\n";
                }
                content += "\"C:\\Program Files (x86)\\AIMP\\AIMP.exe\"\n";
                content += "\"C:\\Program Files (x86)\\ACDSee32\\ACDSee32.exe\"\n";
                content += "\"C:\\Program Files (x86)\\IDM Computer Solutions\\UltraEdit-32\\uedit32.exe\"\n";
                content += SelectedLanguage.ToString() + "\n";
                content += comboBox1.SelectedIndex.ToString() + "\n";
                if (cb_video_only.Checked == true)
                    content += "1\n";
                else
                    content += "0\n";
                if (cb_video_l.Checked == true)
                    content += "1\n";
                else
                    content += "0\n";
                if (cb_video_m.Checked == true)
                    content += "1\n";
                else
                    content += "0\n";
                if (cb_video_s.Checked == true)
                    content += "1\n";
                else
                    content += "0\n";
                if (cb_file_size.Checked == true)
                    content += "1\n";
                else
                    content += "0\n";
                if (cb_file_l.Checked == true)
                    content += "1\n";
                else
                    content += "0\n";
                if (cb_file_m.Checked == true)
                    content += "1\n";
                else
                    content += "0\n";
                if (cb_file_s.Checked == true)
                    content += "1\n";
                else
                    content += "0\n";
                if (cb_generate_text.Checked == true)
                    content += "1\n";
                else
                    content += "0\n";

                /*
                //Major主版本號,Minor副版本號
                if (ver.Major == 6 && ver.Minor == 1)
                {
                    //Windows7
                    video_player_path = @"C:\Program Files\DAUM\PotPlayer\PotPlayerMini.exe";
                }
                else
                {
                    //Windows10
                    video_player_path = @"C:\Program Files (x86)\DAUM\PotPlayer\PotPlayerMini.exe";
                }
                audio_player_path = @"C:\Program Files (x86)\AIMP\AIMP.exe";
                picture_viewer_path = @"C:\Program Files (x86)\ACDSee32\ACDSee32.exe";
                text_editor_path = @"C:\Program Files (x86)\IDM Computer Solutions\UltraEdit-32\uedit32.exe";
                */

                richTextBox2.Text += "目前共有 " + listBox1.Items.Count.ToString() + " 條搜尋路徑\n";

                if (listBox1.Items.Count == 0)
                {
                    content += "C:\\______test_files\n";
                    old_search_path.Add("C:\\______test_files");
                }
                else
                {
                    for (int i = 0; i < listBox1.Items.Count; i++)
                    {
                        richTextBox2.Text += listBox1.Items[i] + "\n";
                        content += listBox1.Items[i] + "\n";
                    }
                }
                content += "\n";

                sw.WriteLine(content, Encoding.UTF8);
                sw.Close();
            }
        }

        void Read_Setup_File()
        {
            int i;
            int tmp;
            if (File.Exists(drap_setup_filename) == false)
            {
                richTextBox2.Text += "檔案 " + drap_setup_filename + " 不存在，製作一個。\n";
                update_setup_file();
            }
            else
            {
                richTextBox2.Text += "檔案 " + drap_setup_filename + " 存在, 開啟，並讀入設定\n";
                string line;
                StreamReader sr = new StreamReader(drap_setup_filename, Encoding.UTF8);
                i = 0;
                while (!sr.EndOfStream)
                {               // 每次讀取一行，直到檔尾
                    line = sr.ReadLine().Trim();            // 讀取文字到 line 變數
                    richTextBox2.Text += "第 " + i.ToString() + " 行資料 : " + line + "\n";
                    switch (i)
                    {
                        case 0:
                            video_player_path = line;
                            break;
                        case 1:
                            audio_player_path = line;
                            break;
                        case 2:
                            picture_viewer_path = line;
                            break;
                        case 3:
                            text_editor_path = line;
                            break;
                        case 4:
                            SelectedLanguage = int.Parse(line);
                            break;
                        case 5:
                            tmp = int.Parse(line);
                            comboBox1.SelectedIndex = tmp;
                            break;
                        case 6:
                            tmp = int.Parse(line);
                            if (tmp == 1)
                                cb_video_only.Checked = true;
                            else
                                cb_video_only.Checked = false;
                            break;
                        case 7:
                            tmp = int.Parse(line);
                            if (tmp == 1)
                                cb_video_l.Checked = true;
                            else
                                cb_video_l.Checked = false;
                            break;
                        case 8:
                            tmp = int.Parse(line);
                            if (tmp == 1)
                                cb_video_m.Checked = true;
                            else
                                cb_video_m.Checked = false;
                            break;
                        case 9:
                            tmp = int.Parse(line);
                            if (tmp == 1)
                                cb_video_s.Checked = true;
                            else
                                cb_video_s.Checked = false;
                            break;
                        case 10:
                            tmp = int.Parse(line);
                            if (tmp == 1)
                                cb_file_size.Checked = true;
                            else
                                cb_file_size.Checked = false;
                            break;
                        case 11:
                            tmp = int.Parse(line);
                            if (tmp == 1)
                                cb_file_l.Checked = true;
                            else
                                cb_file_l.Checked = false;
                            break;
                        case 12:
                            tmp = int.Parse(line);
                            if (tmp == 1)
                                cb_file_m.Checked = true;
                            else
                                cb_file_m.Checked = false;
                            break;
                        case 13:
                            tmp = int.Parse(line);
                            if (tmp == 1)
                                cb_file_s.Checked = true;
                            else
                                cb_file_s.Checked = false;
                            break;
                        case 14:
                            tmp = int.Parse(line);
                            if (tmp == 1)
                                cb_generate_text.Checked = true;
                            else
                                cb_generate_text.Checked = false;
                            break;
                        case 15:
                            search_path = line;
                            break;
                        default:
                            break;
                    }
                    if (i >= 15)
                    {
                        if (line.Length > 0)
                        {
                            richTextBox2.Text += "加入路徑 : " + line + "\n";
                            old_search_path.Add(line);
                        }
                        else
                        {
                            richTextBox2.Text += "空行\n";
                        }
                    }
                    i++;
                }
                sr.Close();
            }
        }





從顏色的名稱 取得顏色的分量
				
				
    Color slateBlue = Color.FromName("SlateBlue");
    byte g = slateBlue.G;
    byte b = slateBlue.B;
    byte r = slateBlue.R;
    byte a = slateBlue.A;
    string text = String.Format("Slate Blue has these ARGB values: Alpha:{0}, " +
        "red:{1}, green: {2}, blue {3}", new object[]{a, r, g, b});
    e.Graphics.DrawString(text, 
        new Font(this.Font, FontStyle.Italic), 
        new SolidBrush(slateBlue), 
        new RectangleF(new PointF(0.0F, 0.0F), this.Size));
        				