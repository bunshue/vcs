 日月 光华   - -   Programming 精华区 文章 阅读 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -   发信人 :   freshbird   ( 真 菜鸟 ~ 快乐 的 愚人 ) ,   信 区 :   Programming 标     题 :   学习 Linux 网络 编程 ( 1 )   发信站 :   日月 光华 站   ( Mon   Apr     2   16 : 53 : 34   2001 )   ,   站 内 信件 学习 Linux 网络 编程 ( 1 ) Linux 系统 的 一个 主要 特点 是 他 的 网络 功能 非常 强大 。 随着 网络 的 日益 普及 ， 基于 网络 的 应用 也 将 越来越 多 。   在 这个 网络时代 ， 掌握 了 Linux 的 网络 编程技术 ， 将令 每 一个 人 处于 不败之地 ， 学习 Linux 的 网络 编程 ， 可以 让 我们 真正 的 体会 到 网络 的 魅力 。   想 成为 一位 真正 的 hacker ， 必须 掌握 网络 编程技术 。 现在 书店 里面 已经 有 了 许多 关于 Linux 网络 编程 方面 的 书籍 ， 网络 上 也 有 了 许多 关于 网络 编程 方面 的 教材 ， 大家 都 可以   去 看一看 的 。 在 这里 我会 和 大家 一 起来 领会 Linux 网络 编程 的 奥妙 ， 由于 我 学习 Linux 的 网络 编程 也 开始 不久 ， 所以 我 下面 所说 的 肯定 会 有 错误 的 ，   还 请 大家 指点 出来 ， 在 这里 我先 谢谢 大家 了 。 在 这 一个 章节 里面 ， 我会 和 以前 的 几个 章节 不同 ， 在 前面 我 都 是 概括 的 说 了 一下 ，   从 现在 开始 我会 尽可能 的 详细 的 说明 每 一个 函数 及其 用法 。 好 了 让 我们 去 领会 Linux 的 伟大 的 魅力 吧 ！ 1 .   Linux 网络 知识 介绍 1.1   客户端程序 和 服务端 程序 网络 程序 和 普通 的 程序 有 一个 最大 的 区别 是 网络 程序 是 由 两个 部分 组成 的 - - 客户端 和 服务器端 . 网络 程序 是 先 有 服务器程序 启动 , 等待 客户端 的 程序运行 并 建立 连接 . 一般 的 来说 是 服务端 的 程序   在 一个 端口 上 监听 , 直到 有 一个 客户端 的 程序 发来 了 请求 . 1.2   常用 的 命令 由于 网络 程序 是 有 两个 部分 组成 , 所以 在 调试 的 时候 比较 麻烦 , 为此 我们 有 必要 知道 一些 常用 的 网络 命令 netstat 命令 netstat 是 用来 显示 网络 的 连接 , 路由表 和 接口 统计 等 网络 的 信息 . netstat 有 许多 的 选项   我们 常用 的 选项 是   - an   用来 显示 详细 的 网络 状态 . 至于 其它 的 选项 我们 可以 使用 帮助 手册 获得 详细 的 情况 . telnettelnet 是 一个 用来 远程 控制 的 程序 , 但是 我们 完全 可以 用 这个 程序 来 调试 我们 的 服务端 程序 的 .   比如 我们 的 服务器程序 在 监听 8888 端口 , 我们 可以 用 telnet   localhost   8888 来 查看 服务端 的 状况 . 1.3   TCP / UDP 介绍 TCP ( Transfer   Control   Protocol ) 传输控制协议 是 一种 面向 连接 的 协议 , 当 我们 的 网络 程序 使用   这个 协议 的 时候 , 网络 可以 保证 我们 的 客户端 和 服务端 的 连接 是 可靠 的 , 安全 的 . UDP ( User   Datagram   Protocol ) 用户 数据 报 协议 是 一种 非 面向 连接 的 协议 , 这种 协议 并 不能 保证 我们   的 网络 程序 的 连接 是 可靠 的 , 所以 我们 现在 编写 的 程序 一般 是 采用 TCP 协议 的 . 2 .   初等 网络函数 介绍 （ TCP ） Linux 系统 是 通过 提供 套 接字 ( socket ) 来 进行 网络 编程 的 . 网络 程序 通过 socket 和 其它 几个 函数 的 调用 , 会 返回 一个   通讯 的 文件 描述符 , 我们 可以 将 这个 描述符 看成 普通 的 文件 的 描述符 来 操作 , 这 就是 linux 的 设备 无关 性 的   好处 . 我们 可以 通过 向 描述符 读写操作 实现 网络 之间 的 数据 交流 . 2.1   socketint   socket ( int   domain ,   int   type , int   protocol ) domain : 说明 我们 网络 程序 所在 的 主机 采用 的 通讯 协族 ( AF _ UNIX 和 AF _ INET 等 ) .   AF _ UNIX 只 能够 用于 单一 的 Unix 系统 进程 间通信 , 而 AF _ INET 是 针对 Internet 的 , 因而 可以 允许 在 远程   主机 之间 通信 ( 当 我们   man   socket 时 发现   domain 可选项 是   PF _ * 而 不是 AF _ * , 因为 glibc 是 posix 的 实现   所以 用 PF 代替 了 AF , 不过 我们 都 可以 使用 的 ) . type : 我们 网络 程序 所 采用 的 通讯 协议 ( SOCK _ STREAM , SOCK _ DGRAM 等 )   SOCK _ STREAM 表明 我们 用 的 是 TCP 协议 , 这样 会 提供 按 顺序 的 , 可靠 , 双向 , 面向 连接 的 比特流 .   SOCK _ DGRAM   表明 我们 用 的 是 UDP 协议 , 这样 只会 提供 定长 的 , 不 可靠 , 无 连接 的 通信 . protocol : 由于 我们 指定 了 type , 所以 这个 地方 我们 一般 只要 用 0 来 代替 就 可以 了   socket 为 网络通讯 做 基本 的 准备 . 成功 时 返回 文件 描述符 , 失败 时 返回 - 1 , 看 errno 可 知道 出错 的 详细情况 . 2.2   bindint   bind ( int   sockfd ,   struct   sockaddr   * my _ addr ,   int   addrlen ) sockfd : 是 由 socket 调用 返回 的 文件 描述符 . addrlen : 是 sockaddr 结构 的 长度 . my _ addr : 是 一个 指向 sockaddr 的 指针 .   在 中 有   sockaddr 的 定义 struct   sockaddr { unisgned   short   as _ family ; char   sa _ data [ 14 ] ; } ; 不过 由于 系统 的 兼容性 , 我们 一般 不用 这个 头文件 , 而 使用 另外 一个 结构 ( struct   sockaddr _ in )   来 代替 . 在 中 有 sockaddr _ in 的 定义 struct   sockaddr _ in { unsigned   short   sin _ family ; unsigned   short   int   sin _ port ; struct   in _ addr   sin _ addr ; unsigned   char   sin _ zero [ 8 ] ; 我们 主要 使用 Internet 所以 sin _ family 一般 为 AF _ INET , sin _ addr 设置 为 INADDR _ ANY 表示 可以   和 任何 的 主机 通信 , sin _ port 是 我们 要 监听 的 端口号 . sin _ zero [ 8 ] 是 用来 填充 的 . bind 将 本地 的 端口 同 socket 返回 的 文件 描述符 捆绑 在 一起 . 成功 是 返回 0 , 失败 的 情况 和 socket 一样 2.3   listenint   listen ( int   sockfd , int   backlog ) sockfd : 是 bind 后 的 文件 描述符 . backlog : 设置 请求 排队 的 最大 长度 . 当有 多个 客户端程序 和 服务端 相连 时 ,   使用 这个 表示 可以 介绍 的 排队 长度 .   listen 函数 将 bind 的 文件 描述符 变为 监听 套 接字 . 返回 的 情况 和 bind 一样 . 2.4   acceptint   accept ( int   sockfd ,   struct   sockaddr   * addr , int   * addrlen ) sockfd : 是 listen 后 的 文件 描述符 . addr , addrlen 是 用来 给 客户端 的 程序 填写 的 , 服务器端 只要 传递 指针 就 可以 了 .   bind , listen 和 accept 是 服务器端 用 的 函数 , accept 调用 时 , 服务器端 的 程序 会 一直 阻塞 到 有 一个   客户程序 发出 了 连接 .   accept 成功 时 返回 最后 的 服务器端 的 文件 描述符 , 这个 时候 服务器端 可以 向 该 描述符 写 信息 了 .   失败 时 返回 - 12.5   connectint   connect ( int   sockfd ,   struct   sockaddr   *   serv _ addr , int   addrlen ) sockfd : socket 返回 的 文件 描述符 . serv _ addr : 储存 了 服务器端 的 连接 信息 . 其中 sin _ add 是 服务端 的 地址 addrlen : serv _ addr 的 长度 connect 函数 是 客户端 用来 同 服务端 连接 的 . 成功 时 返回 0 , sockfd 是 同 服务端 通讯 的 文件 描述符   失败 时 返回 - 1.2 . 6   实例 服务器端 程序 / * * * * * * *   服务器程序   ( server . c )   * * * * * * * * * * * * / # include # include # include # include # include # include # include # includeint   main ( int   argc ,   char   * argv [ ] ) { int   sockfd , new _ fd ; struct   sockaddr _ in   server _ addr ; struct   sockaddr _ in   client _ addr ; int   sin _ size , portnumber ; char   hello [ ] = " Hello !   Are   You   Fine ? \ n " ; if ( argc ! = 2 ) { fprintf ( stderr , " Usage : % s   portnumber \ a \ n " , argv [ 0 ] ) ; exit ( 1 ) ; } if ( ( portnumber = atoi ( argv [ 1 ] ) ) < 0 ) { fprintf ( stderr , " Usage : % s   portnumber \ a \ n " , argv [ 0 ] ) ; exit ( 1 ) ; } / *   服务器端 开始 建立 socket 描述符   * / if ( ( sockfd = socket ( AF _ INET , SOCK _ STREAM , 0 ) ) = = - 1 ) { fprintf ( stderr , " Socket   error : % s \ n \ a " , strerror ( errno ) ) ; exit ( 1 ) ; } / *   服务器端 填充   sockaddr 结构   * / bzero ( & server _ addr , sizeof ( struct   sockaddr _ in ) ) ; server _ addr . sin _ family = AF _ INET ; server _ addr . sin _ addr . s _ addr = htonl ( INADDR _ ANY ) ; server _ addr . sin _ port = htons ( portnumber ) ; / *   捆绑 sockfd 描述符   * / if ( bind ( sockfd , ( struct   sockaddr   * ) ( & server _ addr ) , sizeof ( struct   sockaddr ) ) = = - 1 ) { fprintf ( stderr , " Bind   error : % s \ n \ a " , strerror ( errno ) ) ; exit ( 1 ) ; } / *   监听 sockfd 描述符   * / if ( listen ( sockfd , 5 ) = = - 1 ) { fprintf ( stderr , " Listen   error : % s \ n \ a " , strerror ( errno ) ) ; exit ( 1 ) ; } while ( 1 ) { / *   服务器 阻塞 , 直到 客户程序 建立 连接   * / sin _ size = sizeof ( struct   sockaddr _ in ) ; if ( ( new _ fd = accept ( sockfd , ( struct   sockaddr   * ) ( & client _ addr ) , & sin _ size ) ) = = - 1 ) { fprintf ( stderr , " Accept   error : % s \ n \ a " , strerror ( errno ) ) ; exit ( 1 ) ; } fprintf ( stderr , " Server   get   connection   from   % s \ n " , inet _ ntoa ( client _ addr . sin _ addr ) ) ; if ( write ( new _ fd , hello , strlen ( hello ) ) = = - 1 ) { fprintf ( stderr , " Write   Error : % s \ n " , strerror ( errno ) ) ; exit ( 1 ) ; } / *   这个 通讯 已经 结束   * / close ( new _ fd ) ; / *   循环 下 一个   * / } close ( sockfd ) ; exit ( 0 ) ; } 客户端程序 / * * * * * * *   客户端程序   client . c   * * * * * * * * * * * * / # include # include # include # include # include # include # include # includeint   main ( int   argc ,   char   * argv [ ] ) { int   sockfd ; char   buffer [ 1024 ] ; struct   sockaddr _ in   server _ addr ; struct   hostent   * host ; int   portnumber , nbytes ; if ( argc ! = 3 ) { fprintf ( stderr , " Usage : % s   hostname   portnumber \ a \ n " , argv [ 0 ] ) ; exit ( 1 ) ; } if ( ( host = gethostbyname ( argv [ 1 ] ) ) = = NULL ) { fprintf ( stderr , " Gethostname   error \ n " ) ; exit ( 1 ) ; } if ( ( portnumber = atoi ( argv [ 2 ] ) ) < 0 ) { fprintf ( stderr , " Usage : % s   hostname   portnumber \ a \ n " , argv [ 0 ] ) ; exit ( 1 ) ; } / *   客户程序 开始 建立   sockfd 描述符   * / if ( ( sockfd = socket ( AF _ INET , SOCK _ STREAM , 0 ) ) = = - 1 ) { fprintf ( stderr , " Socket   Error : % s \ a \ n " , strerror ( errno ) ) ; exit ( 1 ) ; } / *   客户程序 填充 服务端 的 资料   * / bzero ( & server _ addr , sizeof ( server _ addr ) ) ; server _ addr . sin _ family = AF _ INET ; server _ addr . sin _ port = htons ( portnumber ) ; server _ addr . sin _ addr = * ( ( struct   in _ addr   * ) host - > h _ addr ) ; / *   客户程序 发起 连接 请求   * / if ( connect ( sockfd , ( struct   sockaddr   * ) ( & server _ addr ) , sizeof ( struct   sockaddr ) ) = = - 1 ) { fprintf ( stderr , " Connect   Error : % s \ a \ n " , strerror ( errno ) ) ; exit ( 1 ) ; } / *   连接 成功 了   * / if ( ( nbytes = read ( sockfd , buffer , 1024 ) ) = = - 1 ) { fprintf ( stderr , " Read   Error : % s \ n " , strerror ( errno ) ) ; exit ( 1 ) ; } buffer [ nbytes ] = \ ; printf ( " I   have   received : % s \ n " , buffer ) ; / *   结束 通讯   * / close ( sockfd ) ; exit ( 0 ) ; } MakeFile 这里 我们 使用 GNU   的 make 实用程序 来 编译 .   关于 make 的 详细 说明 见   Make   使用 介绍 #########   Makefile   ########### all : server   clientserver : server . cgcc   $ ^   - o   $ @ client : client . cgcc   $ ^   - o   $ @ 运行 make 后会 产生 两个 程序 server ( 服务器端 ) 和 client ( 客户端 )   先 运行 . / server   portnumber &   ( portnumber 随便 取 一个 大于 1204 且 不 在 / etc / services 中 出现 的 号码   就 用 8888 好 了 ) , 然后 运行   . / client   localhost   8888   看看 有 什么 结果 .   ( 你 也 可以 用 telnet 和 netstat 试一试 . )   上面 是 一个 最 简单 的 网络 程序 , 不过 是不是 也 有点烦 . 上面 有 许多 函数 我们 还 没有 解释 .   我会 在 下 一章 进行 的 详细 的 说明 . 2.7   总结 总的来说 网络 程序 是 由 两个 部分 组成 的 - - 客户端 和 服务器端 . 它们 的 建立 步骤 一般 是 : 服务器端 socket - - > bind - - > listen - - > accept 客户端 socket - - > connect   - - ※   来源 : · 日月 光华 站   bbs . fudan . edu . cn · [ FROM :   202.119 . 32.102 ]   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - [ 返回 上 一页 ]   [ 本 讨论区 ]