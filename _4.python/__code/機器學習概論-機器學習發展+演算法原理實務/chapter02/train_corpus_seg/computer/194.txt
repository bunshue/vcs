 日月 光华   - -   SE 精华区 文章 阅读 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -   发信人 :   jiachong   ( 甲虫 ) ,   信 区 :   SE 标     题 :   [ 转载 ] 编程 规范 和 范例 发信站 :   日月 光华   ( 2003 年 04 月 20 日 22 : 39 : 43   星期天 ) ,   站 内 信件 【   以下 文字 转载自   FDU _ C . S .   讨论区   】 【   原文 由   violinist   所 发表   】 编程 规范 和 范例 目     录 1   排版     62   注释     113   标识符 命名         184   可读性         205   变量 、 结构         226   函数 、 过程         287   可测性         368   程序 效率     409   质量保证     4410   代码 编辑 、 编译 、 审查   5011   代码 测试 、 维护       5212   宏       53   1   排版 & sup1 ;     1 - 1 ： 程序 块 要 采用 缩进 风格 编写 ， 缩进 的 空格 数为 4 个 。 说明 ： 对于 由 开发工具 自动 生成 的 代码 可以 有 不 一致 。 & sup1 ;     1 - 2 ： 相对 独立 的 程序 块 之间 、 变量 说明 之后 必须 加 空行 。 示例 ： 如下 例子 不 符合规范 。 if   ( ! valid _ ni ( ni ) ) {         ...   / /   program   code } repssn _ ind   =   ssn _ data [ index ] . repssn _ index ; repssn _ ni     =   ssn _ data [ index ] . ni ; 应 如下 书写 if   ( ! valid _ ni ( ni ) ) {         ...   / /   program   code } repssn _ ind   =   ssn _ data [ index ] . repssn _ index ; repssn _ ni     =   ssn _ data [ index ] . ni ; & sup1 ;     1 - 3 ： 较长 的 语句 （ > 80 字符 ） 要 分成 多行 书写 ， 长 表达式 要 在 低优先级 操作符 处 划分 新 行 ， 操作符 放在 新行 之首 ， 划分 出 的 新行 要 进行 适当 的 缩进 ， 使 排版 整齐 ， 语句 可 读 。 示例 ： perm _ count _ msg . head . len   =   NO7 _ TO _ STAT _ PERM _ COUNT _ LEN                                                     +   STAT _ SIZE _ PER _ FRAM   *   sizeof (   _ UL   ) ; act _ task _ table [ frame _ id   *   STAT _ TASK _ CHECK _ NUMBER   +   index ] . occupied                             =   stat _ poi [ index ] . occupied ; act _ task _ table [ taskno ] . duration _ true _ or _ false                             =   SYS _ get _ sccp _ statistic _ state (   stat _ item   ) ; report _ or _ not _ flag   =   ( ( taskno   <   MAX _ ACT _ TASK _ NUMBER )                                             &&   ( n7stat _ stat _ item _ valid   ( stat _ item ) )                                             &&   ( act _ task _ table [ taskno ] . result _ data   ! =   0 ) ) ;   & sup1 ;     1 - 4 ： 循环 、 判断 等 语句 中若有 较长 的 表达式 或 语句 ， 则 要 进行 适应 的 划分 ， 长 表达式 要 在 低优先级 操作符 处 划分 新 行 ， 操作符 放在 新行 之首 。 示例 ： if   ( ( taskno   <   max _ act _ task _ number )         &&   ( n7stat _ stat _ item _ valid   ( stat _ item ) ) ) {         ...   / /   program   code } for   ( i   =   0 ,   j   =   0 ;   ( i   <   BufferKeyword [ word _ index ] . word _ length )                                         &&   ( j   <   NewKeyword . word _ length ) ;   i ++ ,   j ++ ) {         ...   / /   program   code } for   ( i   =   0 ,   j   =   0 ;               ( i   <   first _ word _ length )   &&   ( j   <   second _ word _ length ) ;               i ++ ,   j ++ ) {         ...   / /   program   code   } & sup1 ;     1 - 5 ： 若 函数 或 过程 中 的 参数 较长 ， 则 要 进行 适当 的 划分 。 示例 ： n7stat _ str _ compare ( ( BYTE   * )   &   stat _ object ,                                       ( BYTE   * )   &   ( act _ task _ table [ taskno ] . stat _ object ) ,                                       sizeof   ( _ STAT _ OBJECT ) ) ; n7stat _ flash _ act _ duration (   stat _ item ,   frame _ id   * STAT _ TASK _ CHECK _ NUMBER                                                                             +   index ,   stat _ object   ) ; & sup1 ;     1 - 6 ： 不 允许 把 多个 短 语句 写 在 一行 中 ， 即 一行 只 写 一条 语句 。 示例 ： 如下 例子 不 符合规范 。 rect . length   =   0 ;     rect . width   =   0 ; 应 如下 书写 rect . length   =   0 ; rect . width     =   0 ; & sup1 ;     1 - 7 ： if 、 for 、 do 、 while 、 case 、 switch 、 default 等 语句 自占 一行 ， 且 if 、 for 、 do 、 while 等 语句 的 执行 语句 部分 无论 多少 都 要加 括号 { } 。   示例 ： 如下 例子 不 符合规范 。 if   ( pUserCR   = =   NULL )   return ; 应 如下 书写 ： if   ( pUserCR   = =   NULL ) {         return ; } & sup1 ;     1 - 8 ： 对齐 只 使用 空格键 ， 不 使用 TAB 键 。 说明 ： 以免 用 不同 的 编辑器 阅读程序 时 ， 因 TAB 键 所 设置 的 空格 数目 不同 而 造成 程序 布局 不 整齐 ， 不要 使用 BC 作为 编辑器 合 版本 ， 因为 BC 会 自动 将 8 个 空格 变为 一个 TAB 键 ， 因此 使用 BC 合入 的 版本 大多 会 将 缩进 变乱 。 & sup1 ;     1 - 9 ： 函数 或 过程 的 开始 、 结构 的 定义 及 循环 、 判断 等 语句 中 的 代码 都 要 采用 缩进 风格 ， case 语句 下 的 情况 处理 语句 也 要 遵从 语句 缩进 要求 。 & sup1 ;     1 - 10 ： 程序 块 的 分界 符 （ 如 C / C++ 语言 的 大括号 ‘ { ’ 和 ‘ } ’ ） 应 各 独占 一行 并且 位于 同一 列 ， 同时 与 引用 它们 的 语句 左 对齐 。 在 函数 体 的 开始 、 类 的 定义 、 结构 的 定义 、 枚举 的 定义 以及 if 、 for 、 do 、 while 、 switch 、 case 语句 中 的 程序 都 要 采用 如上 的 缩进 方式 。 示例 ： 如下 例子 不 符合规范 。 for   ( ... )   {         ...   / /   program   code } if   ( ... )           {         ...   / /   program   code         } void   example _ fun (   void   )         {         ...   / /   program   code         } 应 如下 书写 。 for   ( ... )   {         ...   / /   program   code } if   ( ... )   {         ...   / /   program   code } void   example _ fun (   void   ) {         ...   / /   program   code } & sup1 ;     1 - 11 ： 在 两个 以上 的 关键字 、 变量 、 常量 进行 对 等 操作 时 ， 它们 之间 的 操作符 之前 、 之后 或者 前后 要加 空格 ； 进行 非 对 等 操作 时 ， 如果 是 关系密切 的 立即 操作符 （ 如 － > ） ， 后 不 应加 空格 。 说明 ： 采用 这种 松散 方式 编写 代码 的 目的 是 使 代码 更加 清晰 。 由于 留 空格 所 产生 的 清晰性 是 相对 的 ， 所以 ， 在 已经 非常 清晰 的 语句 中 没有 必要 再留 空格 ， 如果 语句 已 足够 清晰 则 括号 内侧 ( 即 左 括号 后面 和 右 括号 前面 ) 不 需要 加 空格 ， 多重 括号 间 不必 加 空格 ， 因为 在 C / C++ 语言 中括号 已经 是 最 清晰 的 标志 了 。 在 长 语句 中 ， 如果 需要 加 的 空格 非常 多 ， 那么 应该 保持 整体 清晰 ， 而 在 局部 不 加 空格 。 给 操作符 留 空格 时 不要 连续 留 两个 以上 空格 。 示例 ： ( 1 )   逗号 、 分号 只 在 后面 加 空格 。 int   a ,   b ,   c ;   ( 2 ) 比较 操作符 ,   赋值 操作符 " = " 、   " + = " ， 算术操作符 " + " 、 " % " ， 逻辑 操作符 " && " 、 " & " ， 位域 操作符 " < < " 、 " ^ " 等 双目 操作符 的 前后 加 空格 。 if   ( current _ time   > =   MAX _ TIME _ VALUE )   a   =   b   +   c ; a   * =   2 ; a   =   b   ^   2 ; ( 3 ) " ! " 、 " ~ " 、 " ++ " 、 " - - " 、 " & " （ 地址 运算符 ） 等 单目 操作符 前后 不 加 空格 。 * p   =   ' a ' ;                 / /   内容 操作 " * " 与 内容 之间 flag   =   ! isEmpty ;   / /   非 操作 " ! " 与 内容 之间 p   =   & mem ;                 / /   地址 操作 " & "   与 内容 之间 i ++ ;                           / /   " ++ " , " - - " 与 内容 之间 ( 4 ) " - > " 、 " . " 前后 不 加 空格 。 p - > id   =   pid ;           / /   " - > " 指针 前后 不 加 空格 ( 5 )   if 、 for 、 while 、 switch 等 与 后面 的 括号 间 应加 空格 ， 使 if 等 关键字 更为 突出 、 明显 。 if   ( a   > =   b   &&   c   >   d ) & frac12 ;         1 - 1 ： 一行 程序 以 小于 80 字符 为宜 ， 不要 写得 过长 。           2   注释 & sup1 ;     2 - 1 ： 一般 情况 下 ， 源程序 有效 注释 量 必须 在 20 ％ 以上 。 说明 ： 注释 的 原则 是 有助于 对 程序 的 阅读 理解 ， 在 该加 的 地方 都 加 了 ， 注释 不宜 太多 也 不能 太 少 ， 注释 语言 必须 准确 、 易懂 、 简洁 。 & sup1 ;     2 - 2 ： 说明性 文件 （ 如 头文件 . h 文件 、 . inc 文件 、 . def 文件 、 编译 说明 文件 . cfg 等 ） 头部 应 进行 注释 ， 注释 必须 列出 ： 版权 说明 、 版本号 、 生成 日期 、 作者 、 内容 、 功能 、 与 其它 文件 的 关系 、 修改 日志 等 ， 头文件 的 注释 中 还 应有 函数 功能 简要 说明 。 示例 ： 下面 这 段 头文件 的 头 注释 比较 标准 ， 当然 ， 并 不 局限于 此 格式 ， 但 上述 信息 建议 要 包含 在内 。 / * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *     Copyright   ( C ) ,   1988 - 1999 ,   Huawei   Tech .   Co . ,   Ltd .     File   name :             / /   文件名     Author :               Version :                 Date :   / /   作者 、 版本 及 完成 日期     Description :         / /   用于 详细 说明 此 程序 文件 完成 的 主要 功能 ， 与 其他 模块                                     / /   或 函数 的 接口 ， 输出 值 、 取值 范围 、 含义 及 参数 间 的 控                                     / /   制 、 顺序 、 独立 或 依赖 等 关系     Others :                   / /   其它 内容 的 说明     Function   List :     / /   主要 函数 列表 ， 每条 记录 应 包括 函数 名及 功能 简要 说明         1 .   ....     History :                 / /   修改 历史记录 列表 ， 每条 修改 记录 应 包括 修改 日期 、 修改                                     / /   者 及 修改 内容 简述             1 .   Date :               Author :               Modification :         2 .   ... * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * / & sup1 ;     2 - 3 ： 源文件 头部 应 进行 注释 ， 列出 ： 版权 说明 、 版本号 、 生成 日期 、 作者 、 模块 目的 / 功能 、 主要 函数 及其 功能 、 修改 日志 等 。 示例 ： 下面 这 段 源文件 的 头 注释 比较 标准 ， 当然 ， 并 不 局限于 此 格式 ， 但 上述 信息 建议 要 包含 在内 。 / * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *     Copyright   ( C ) ,   1988 - 1999 ,   Huawei   Tech .   Co . ,   Ltd .     FileName :   test . cpp     Author :                 Version   :                     Date :     Description :           / /   模块 描述                 Version :                   / /   版本信息     Function   List :       / /   主要 函数 及其 功能         1 .   - - - - - - -     History :                   / /   历史 修改 记录             < author >     < time >       < version   >       < desc >             David         96 / 10 / 12           1.0           build   this   moudle     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * / 说明 ： Description 一项 描述 本 文件 的 内容 、 功能 、 内部 各 部分 之间 的 关系 及本 文件 与 其它 文件 关系 等 。 History 是 修改 历史记录 列表 ， 每条 修改 记录 应 包括 修改 日期 、 修改 者 及 修改 内容 简述 。 & sup1 ;     2 - 4 ： 函数 头部 应 进行 注释 ， 列出 ： 函数 的 目的 / 功能 、 输入 参数 、 输出 参数 、 返回值 、 调用 关系 （ 函数 、 表 ） 等 。 示例 ： 下面 这 段 函数 的 注释 比较 标准 ， 当然 ， 并 不 局限于 此 格式 ， 但 上述 信息 建议 要 包含 在内 。 / * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *     Function :               / /   函数 名称     Description :         / /   函数 功能 、 性能 等 的 描述     Calls :                     / /   被 本 函数调用 的 函数 清单     Called   By :             / /   调用 本 函数 的 函数 清单     Table   Accessed :   / /   被 访问 的 表 （ 此项 仅 对于 牵扯 到 数据库 操作 的 程序 ）     Table   Updated :     / /   被 修改 的 表 （ 此项 仅 对于 牵扯 到 数据库 操作 的 程序 ）     Input :                     / /   输入 参数 说明 ， 包括 每个 参数 的 作                                     / /   用 、 取值 说明 及 参数 间 关系 。     Output :                   / /   对 输出 参数 的 说明 。     Return :                   / /   函数 返回值 的 说明     Others :                   / /   其它 说明 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * / & sup1 ;     2 - 5 ： 边写 代码 边 注释 ， 修改 代码 同时 修改 相应 的 注释 ， 以 保证 注释 与 代码 的 一致性 。 不再 有用 的 注释 要 删除 。 & sup1 ;     2 - 6 ： 注释 的 内容 要 清楚 、 明 了 ， 含义 准确 ， 防止 注释 二义性 。 说明 ： 错误 的 注释 不但 无益 反而 有害 。 规则 2 - 7 ： 避免 在 注释 中 使用 缩写 ， 特别 是 非常 用 缩写 。 说明 ： 在 使用 缩写 时 或 之前 ， 应对 缩写 进行 必要 的 说明 。 & sup1 ;     2 - 8 ： 注释 应 与其 描述 的 代码 相近 ， 对 代码 的 注释 应 放在 其 上方 或 右方 （ 对 单条 语句 的 注释 ） 相邻 位置 ， 不可 放在 下面 ， 如放于 上方 则 需 与其 上面 的 代码 用 空行 隔开 。 示例 ： 如下 例子 不 符合规范 。 例 1 ： / *   get   replicate   sub   system   index   and   net   indicator   * / repssn _ ind   =   ssn _ data [ index ] . repssn _ index ; repssn _ ni   =   ssn _ data [ index ] . ni ; 例 2 ： repssn _ ind   =   ssn _ data [ index ] . repssn _ index ; repssn _ ni   =   ssn _ data [ index ] . ni ; / *   get   replicate   sub   system   index   and   net   indicator   * / 应 如下 书写 / *   get   replicate   sub   system   index   and   net   indicator   * / repssn _ ind   =   ssn _ data [ index ] . repssn _ index ; repssn _ ni   =   ssn _ data [ index ] . ni ; & sup1 ;     2 - 9 ： 对于 所有 有 物理 含义 的 变量 、 常量 ， 如果 其 命名 不是 充分 自 注释 的 ， 在 声明 时 都 必须 加以 注释 ， 说明 其 物理 含义 。 变量 、 常量 、 宏 的 注释 应 放在 其 上方 相邻 位置 或 右方 。 示例 ： / *   active   statistic   task   number   * / # define   MAX _ ACT _ TASK _ NUMBER   1000 # define   MAX _ ACT _ TASK _ NUMBER   1000   / *   active   statistic   task   number   * / & sup1 ;     2 - 10 ： 数据结构 声明 ( 包括 数组 、 结构 、 类 、 枚举 等 ) ， 如果 其 命名 不是 充分 自 注释 的 ， 必须 加以 注释 。 对 数据结构 的 注释 应 放在 其 上方 相邻 位置 ， 不可 放在 下面 ； 对 结构 中 的 每个 域 的 注释 放在 此域 的 右方 。 示例 ： 可 按 如下 形式 说明 枚举 / 数据 / 联合结构 。 / *   sccp   interface   with   sccp   user   primitive   message   name   * / enum     SCCP _ USER _ PRIMITIVE {         N _ UNITDATA _ IND ,   / *   sccp   notify   sccp   user   unit   data   come   * /         N _ NOTICE _ IND ,       / *   sccp   notify   user   the   No . 7   network   can   not   * /                                         / *   transmission   this   message   * /         N _ UNITDATA _ REQ ,   / *   sccp   user ' s   unit   data   transmission   request * / } ; & sup1 ;     2 - 11 ： 全局变量 要 有 较 详细 的 注释 ， 包括 对 其 功能 、 取值 范围 、 哪些 函数 或 过程 存取 它 以及 存取 时 注意事项 等 的 说明 。 示例 ： / *   The   ErrorCode   when   SCCP   translate   * / / *   Global   Title   failure ,   as   follows   * /             / /   变量 作用 、 含义 / *   0   －   SUCCESS       1   －   GT   Table   error   * / / *   2   －   GT   error     Others   －   no   use     * /               / /   变量 取值 范围 / *   only     function     SCCPTranslate ( )   in   * / / *   this   modual   can   modify   it ,     and     other   * / / *   module   can   visit   it   through   call   * / / *   the     function   GetGTTransErrorCode ( )   * /         / /   使用 方法 BYTE   g _ GTTranErrorCode ;     & sup1 ;     2 - 12 ： 注释 与 所 描述 内容 进行 同样 的 缩排 。 说明 ： 可 使 程序 排版 整齐 ， 并 方便 注释 的 阅读 与 理解 。 示例 ： 如下 例子 ， 排版 不 整齐 ， 阅读 稍感 不 方便 。 void   example _ fun (   void   ) { / *   code   one   comments   * /         CodeBlock   One                 / *   code   two   comments   * /         CodeBlock   Two } 应 改为 如下 布局 。 void   example _ fun (   void   ) {         / *   code   one   comments   * /         CodeBlock   One         / *   code   two   comments   * /         CodeBlock   Two } & sup1 ;     2 - 13 ： 将 注释 与其 上面 的 代码 用 空行 隔开 。 示例 ： 如下 例子 ， 显得 代码 过于 紧凑 。 / *   code   one   comments   * / program   code   one / *   code   two   comments   * / program   code   two 应 如下 书写 / *   code   one   comments   * / program   code   one / *   code   two   comments   * / program   code   two & sup1 ;     2 - 14 ： 对 变量 的 定义 和 分支 语句 （ 条件 分支 、 循环 语句 等 ） 必须 编写 注释 。 说明 ： 这些 语句 往往 是 程序实现 某一 特定 功能 的 关键 ， 对于 维护 人员 来说 ， 良好 的 注释 帮助 更好 的 理解 程序 ， 有时 甚至 优于 看 设计 文档 。 & sup1 ;     2 - 15 ： 对于 switch 语句 下 的 case 语句 ， 如果 因为 特殊 情况 需要 处理 完 一个 case 后 进入 下 一个 case 处理 ， 必须 在 该 case 语句 处理 完 、 下 一个 case 语句 前 加上 明确 的 注释 。 说明 ： 这样 比较清楚 程序 编写者 的 意图 ， 有效 防止 无故 遗漏 break 语句 。 示例 （ 注意 斜体 加粗 部分 ） ： case   CMD _ UP :               ProcessUp ( ) ;           break ; case   CMD _ DOWN :           ProcessDown ( ) ;           break ; case   CMD _ FWD :             ProcessFwd ( ) ;           if   ( ... ) {         ...         break ; } else {         ProcessCFW _ B ( ) ;       / /   now   jump   into   case   CMD _ A } case   CMD _ A :                 ProcessA ( ) ;                 break ; case   CMD _ B :                 ProcessB ( ) ;                 break ; case   CMD _ C :                 ProcessC ( ) ;                     break ; case   CMD _ D :                 ProcessD ( ) ;                 break ; ...& frac12 ;         2 - 1 ： 避免 在 一行 代码 或 表达式 的 中间 插入 注释 。 说明 ： 除非 必要 ， 不应 在 代码 或 表达 中间 插入 注释 ， 否则 容易 使 代码 可 理解 性 变差 。 & frac12 ;         2 - 2 ： 通过 对 函数 或 过程 、 变量 、 结构 等 正确 的 命名 以及 合理 地 组织 代码 的 结构 ， 使 代码 成为 自 注释 的 。 说明 ： 清晰 准确 的 函数 、 变量 等 的 命名 ， 可 增加 代码 可读性 ， 并 减少 不必要 的 注释 。 & frac12 ;         2 - 3 ： 在 代码 的 功能 、 意图 层次 上 进行 注释 ， 提供 有用 、 额外 的 信息 。 说明 ： 注释 的 目的 是 解释 代码 的 目的 、 功能 和 采用 的 方法 ， 提供 代码 以外 的 信息 ， 帮助 读者 理解 代码 ， 防止 没 必要 的 重复 注释 信息 。 示例 ： 如下 注释 意义 不 大 。 / *   if   receive _ flag   is   TRUE   * / if   ( receive _ flag ) 而 如下 的 注释 则 给出 了 额外 有用 的 信息 。   / *   if   mtp   receive   a   message   from   links   * / if   ( receive _ flag ) & frac12 ;         2 - 4 ： 在 程序 块 的 结束 行 右方 加 注释 标记 ， 以 表明 某 程序 块 的 结束 。 说明 ： 当 代码段 较长 ， 特别 是 多重 嵌套 时 ， 这样 做 可以 使 代码 更 清晰 ， 更 便于 阅读 。 示例 ： 参见 如下 例子 。 if   ( ... ) {         / /   program   code         while   ( index   <   MAX _ INDEX )         {                 / /   program   code         }   / *   end   of   while   ( index   <   MAX _ INDEX )   * /   / /   指明 该条 while 语句 结束 }   / *   end   of     if   ( ... ) * /   / /   指明 是 哪条 if 语句 结束 & frac12 ;         2 - 5 ： 注释 格式 尽量 统一 ， 建议 使用 “ / *   … …   * / ” 。 & frac12 ;         2 - 6 ： 注释 应 考虑 程序 易读 及 外观 排版 的 因素 ， 使用 的 语言 若 是 中 、 英 兼有 的 ， 建议 多 使用 中文 ， 除非 能 用 非常 流利 准确 的 英文 表达 。 说明 ： 注释 语言 不 统一 ， 影响 程序 易读性 和 外观 排版 ， 出于 对 维护 人员 的 考虑 ， 建议 使用 中文 。   3   标识符 命名 & sup1 ;     3 - 1 ： 标识符 的 命名 要 清晰 、 明 了 ， 有 明确 含义 ， 同时 使用 完整 的 单词 或 大家 基本 可以 理解 的 缩写 ， 避免 使人 产生误解 。 说明 ： 较 短 的 单词 可 通过 去掉 “ 元音 ” 形成 缩写 ； 较长 的 单词 可取 单词 的 头 几个 字母 形成 缩写 ； 一些 单词 有 大家 公认 的 缩写 。 示例 ： 如下 单词 的 缩写 能够 被 大家 基本 认可 。 temp   可 缩写 为     tmp     ; flag   可 缩写 为     flg     ; statistic   可 缩写 为     stat   ; increment   可 缩写 为     inc     ; message   可 缩写 为     msg     ; & sup1 ;     3 - 2 ： 命名 中若 使用 特殊 约定 或 缩写 ， 则 要 有 注释 说明 。 说明 ： 应该 在 源文件 的 开始 之 处 ， 对 文件 中 所 使用 的 缩写 或 约定 ， 特别 是 特殊 的 缩写 ， 进行 必要 的 注释 说明 。 & sup1 ;     3 - 3 ： 自己 特有 的 命名 风格 ， 要 自始至终 保持一致 ， 不可 来回 变化 。 说明 ： 个人 的 命名 风格 ， 在 符合 所在 项目组 或 产品组 的 命名 规则 的 前提 下 ， 才 可 使用 。 （ 即 命名 规则 中 没有 规定 到 的 地方 才 可 有 个人 命名 风格 ） 。 & sup1 ;     3 - 4 ： 对于 变量 命名 ， 禁止 取 单个 字符 （ 如 i 、 j 、 k ... ） ， 建议 除了 要 有 具体 含义 外 ， 还 能 表明 其 变量 类型 、 数据类型 等 ， 但 i 、 j 、 k 作 局部 循环 变量 是 允许 的 。 说明 ： 变量 ， 尤其 是 局部变量 ， 如果 用 单个 字符 表示 ， 很 容易 敲错 （ 如 i 写成 j ） ， 而 编译 时 又 检查 不 出来 ， 有 可能 为了 这个 小小的 错误 而 花费 大量 的 查错 时间 。 示例 ： 下面 所示 的 局部变量 名 的 定义方法 可以 借鉴 。 int   liv _ Width 其 变量名 解释 如下 ：                 l             局部变量 （ Local ）     （ 其它 ： g         全局变量 （ Global ） ... ）                 i             数据类型 （ Interger ）                 v             变量 （ Variable ）       （ 其它 ： c         常量 （ Const ） ... ）                 Width     变量 含义 这样 可以 防止 局部变量 与 全局变量 重名 。 & sup1 ;     3 - 5 ： 命名 规范 必须 与 所 使用 的 系统 风格 保持一致 ， 并 在 同一 项目 中 统一 ， 比如 采用 UNIX 的 全 小写 加 下划线 的 风格 或 大小写 混排 的 方式 ， 不要 使用 大小写 与 下划线 混排 的 方式 ， 用作 特殊 标识 如 标识 成员 变量 或 全局变量 的 m _ 和 g _ ， 其后 加上 大小写 混排 的 方式 是 允许 的 。 示例 ：   Add _ User 不 允许 ， add _ user 、 AddUser 、 m _ AddUser 允许 。   & frac12 ;         3 - 1 ： 除非 必要 ， 不要 用 数字 或 较 奇怪 的 字符 来 定义 标识符 。 示例 ： 如下 命名 ， 使人 产生 疑惑 。 # define   _ EXAMPLE _ 0 _ TEST _# define   _ EXAMPLE _ 1 _ TEST _ void   set _ sls00 (   BYTE   sls   ) ; 应 改为 有 意义 的 单词 命名 # define   _ EXAMPLE _ UNIT _ TEST _# define   _ EXAMPLE _ ASSERT _ TEST _ void   set _ udt _ msg _ sls (   BYTE   sls   ) ; & frac12 ;         3 - 2 ： 在 同一 软件产品 内 ， 应 规划 好 接口 部分 标识符 （ 变量 、 结构 、 函数 及 常量 ） 的 命名 ， 防止 编译 、 链接 时 产生 冲突 。 说明 ： 对接口 部分 的 标识符 应该 有 更 严格 限制 ， 防止 冲突 。 如可 规定 接口 部分 的 变量 与 常量 之前 加上 “ 模块 ” 标识 等 。 & frac12 ;         3 - 3 ： 用 正确 的 反义词 组 命名 具有 互斥 意义 的 变量 或 相反 动作 的 函数 等 。 说明 ： 下面 是 一些 在 软件 中 常用 的 反义词 组 。 add   /   remove               begin   /   end                 create   /   destroy   insert   /   delete         first   /   last               get   /   releaseincrement   /   decrement                                   put   /   getadd   /   delete               lock   /   unlock             open   /   closemin   /   max                     old   /   new                     start   /   stopnext   /   previous         source   /   target         show   /   hidesend   /   receive           source   /   destinationcut   /   paste                 up   /   down 示例 ： int     min _ sum ; int     max _ sum ; int     add _ user (   BYTE   * user _ name   ) ; int     delete _ user (   BYTE   * user _ name   ) ; & frac12 ;         3 - 4 ： 除了 编译 开关 / 头文件 等 特殊 应用 ， 应 避免 使用 _ EXAMPLE _ TEST _ 之类 以 下划线 开始 和 结尾 的 定义 。             4   可读性 & sup1 ;     4 - 1 ： 注意 运算符 的 优先级 ， 并用 括号 明确 表达式 的 操作 顺序 ， 避免 使用 默认 优先级 。 说明 ： 防止 阅读程序 时 产生误解 ， 防止 因 默认 的 优先级 与 设计 思想 不符 而 导致 程序 出错 。 示例 ： 下列 语句 中 的 表达式 word   =   ( high   < <   8 )   |   low           ( 1 ) if   ( ( a   |   b )   &&   ( a   &   c ) )             ( 2 ) if   ( ( a   |   b )   <   ( c   &   d ) )               ( 3 ) 如果 书写 为 high   < <   8   |   lowa   |   b   &&   a   &   ca   |   b   <   c   &   d 由于 high   < <   8   |   low   =   (   high   < <   8 )   |   low , a   |   b   &&   a   &   c   =   ( a   |   b )   &&   ( a   &   c ) ， ( 1 ) ( 2 ) 不会 出错 ， 但 语句 不易 理解 ； a   |   b   <   c   &   d   =   a   |   （ b   <   c ）   &   d ， ( 3 ) 造成 了 判断 条件 出错 。 & sup1 ;     4 - 2 ： 避免 使用 不易 理解 的 数字 ， 用 有 意义 的 标识 来 替代 。 涉及 物理 状态 或者 含有 物理 意义 的 常量 ， 不 应 直接 使用 数字 ， 必须 用 有 意义 的 枚举 或宏来 代替 。 示例 ： 如下 的 程序 可读性 差 。 if   ( Trunk [ index ] . trunk _ state   = =   0 ) {         Trunk [ index ] . trunk _ state   =   1 ;         ...     / /   program   code } 应 改为 如下 形式 。 # define   TRUNK _ IDLE   0 # define   TRUNK _ BUSY   1if   ( Trunk [ index ] . trunk _ state   = =   TRUNK _ IDLE ) {         Trunk [ index ] . trunk _ state   =   TRUNK _ BUSY ;         ...     / /   program   code } & frac12 ;         4 - 1 ： 源程序 中 关系 较为 紧密 的 代码 应 尽可能 相邻 。 说明 ： 便于 程序 阅读 和 查找 。 示例 ： 以下 代码 布局 不太 合理 。 rect . length   =   10 ; char _ poi   =   str ; rect . width   =   5 ; 若 按 如下 形式 书写 ， 可能 更 清晰 一些 。 rect . length   =   10 ; rect . width   =   5 ;   / /   矩形 的 长 与 宽 关系 较 密切 ， 放在 一起 。 char _ poi   =   str ; & frac12 ;         4 - 2 ： 不要 使用 难懂 的 技巧性 很 高 的 语句 ， 除非 很 有 必要 时 。 说明 ： 高 技巧 语句 不 等于 高效率 的 程序 ， 实际上 程序 的 效率 关键在于 算法 。 示例 ： 如下 表达式 ， 考虑不周 就 可能 出 问题 ， 也 较 难 理解 。 *   stat _ poi   ++   + =   1 ; *   ++   stat _ poi   + =   1 ; 应 分别 改为 如下 。 * stat _ poi   + =   1 ; stat _ poi ++ ;           / /   此二 语句 功能 相当于 “   *   stat _ poi   ++   + =   1 ;   ” ++   stat _ poi ; * stat _ poi   + =   1 ;   / /   此二 语句 功能 相当于 “   *   ++   stat _ poi   + =   1 ;   ”   5   变量 、 结构 & sup1 ;     5 - 1 ： 去掉 没 必要 的 公共 变量 。 说明 ： 公共 变量 是 增大 模块 间 耦合 的 原因 之一 ， 故应 减少 没 必要 的 公共 变量 以 降低 模块 间 的 耦合度 。 & sup1 ;     5 - 2 ： 仔细 定义 并 明确 公共 变量 的 含义 、 作用 、 取值 范围 及 公共 变量 间 的 关系 。 说明 ： 在 对 变量 声明 的 同时 ， 应对 其 含义 、 作用 及 取值 范围 进行 注释 说明 ， 同时 若有 必要 还应 说明 与 其它 变量 的 关系 。 & sup1 ;     5 - 3 ： 明确 公共 变量 与 操作 此 公共 变量 的 函数 或 过程 的 关系 ， 如 访问 、 修改 及 创建 等 。 说明 ： 明确 过程 操作 变量 的 关系 后 ， 将 有利于 程序 的 进一步 优化 、 单元测试 、 系统 联调 以及 代码 维护 等 。 这种 关系 的 说明 可 在 注释 或 文档 中 描述 。 示例 ： 在 源文件 中 ， 可 按 如下 注释 形式 说明 。 RELATION         System _ Init         Input _ Rec         Print _ Rec       Stat _ ScoreStudent           Create                   Modify               Access             AccessScore               Create                   Modify               Access             Access ,   Modify 注 ： RELATION 为 操作 关系 ； System _ Init 、 Input _ Rec 、 Print _ Rec 、 Stat _ Score 为 四个 不同 的 函数 ； Student 、 Score 为 两个 全局变量 ； Create 表示 创建 ， Modify 表示 修改 ， Access 表示 访问 。 其中 ， 函数 Input _ Rec 、 Stat _ Score 都 可 修改 变量 Score ， 故此 变量 将 引起 函数 间 较大 的 耦合 ， 并 可能 增加 代码 测试 、 维护 的 难度 。 & sup1 ;     5 - 4 ： 当向 公共 变量 传递数据 时 ， 要 十分 小心 ， 防止 赋 与 不合理 的 值 或 越界 等 现象 发生 。 说明 ： 对 公共 变量 赋值 时 ， 若有 必要 应 进行 合法性检查 ， 以 提高 代码 的 可靠性 、 稳定性 。 & sup1 ;     5 - 5 ： 防止 局部变量 与 公共 变量 同名 。 说明 ： 若 使用 了 较 好 的 命名 规则 ， 那么 此 问题 可 自动 消除 。 & sup1 ;     5 - 6 ： 严禁 使用 未经 初始化 的 变量 作为 右值 。 说明 ： 特别 是 在 C / C++ 中 引用 未经 赋值 的 指针 ， 经常 会 引起 系统 崩溃 。 & frac12 ;         5 - 1 ： 构造 仅 有 一个 模块 或 函数 可以 修改 、 创建 ， 而 其余 有关 模块 或 函数 只 访问 的 公共 变量 ， 防止 多个 不同 模块 或 函数 都 可以 修改 、 创建 同一 公共 变量 的 现象 。 说明 ： 降低 公共 变量 耦合度 。 & frac12 ;         5 - 2 ： 使用 严格 形式 定义 的 、 可移植 的 数据类型 ， 尽量 不要 使用 与 具体 硬件 或 软件 环境 关系密切 的 变量 。 说明 ： 使用 标准 的 数据类型 ， 有利于 程序 的 移植 。 示例 ： 如下 例子 （ 在 DOS 下 BC3 . 1 环境 中 ） ， 在 移植 时 可能 产生 问题 。 void   main ( ) {         register   int   index ;   / /   寄存器 变量         _ AX   =   0x4000 ;   / /   _ AX 是 BC3 . 1 提供 的 寄存器 “ 伪 变量 ”         ...   / /   program   code } & frac12 ;         5 - 3 ： 结构 的 功能 要 单一 ， 是 针对 一种 事务 的 抽象 。 说明 ： 设计 结构 时应 力争 使 结构 代表 一种 现实 事务 的 抽象 ， 而 不是 同时 代表 多种 。 结构 中 的 各 元素 应 代表 同一 事务 的 不同 侧面 ， 而 不应 把 描述 没有 关系 或 关系 很弱 的 不同 事务 的 元素 放到 同一 结构 中 。 示例 ： 如下 结构 不太 清晰 、 合理 。 typedef   struct   STUDENT _ STRU {         unsigned   char   name [ 8 ] ;   / *   student ' s   name   * /         unsigned   char   age ;           / *   student ' s   age   * /         unsigned   char   sex ;           / *   student ' s   sex ,   as   follows   * /                                                       / *   0   -   FEMALE ;   1   -   MALE   * /         unsigned   char                         teacher _ name [ 8 ] ;   / *   the   student   teacher ' s   name   * /         unisgned   char                         teacher _ sex ;           / *   his   teacher   sex   * / }   STUDENT ; 若 改为 如下 ， 可能 更 合理 些 。 typedef   struct   TEACHER _ STRU {         unsigned   char   name [ 8 ] ;   / *   teacher   name   * /         unisgned   char   sex ;           / *   teacher   sex ,   as   follows   * /                                                       / *   0   -   FEMALE ;   1   -   MALE   * / }   TEACHER ; typedef   struct   STUDENT _ STRU {         unsigned   char   name [ 8 ] ;           / *   student ' s   name   * /         unsigned   char   age ;                   / *   student ' s   age   * /         unsigned   char   sex ;                   / *   student ' s   sex ,   as   follows   * /                                                               / *   0   -   FEMALE ;   1   -   MALE   * /         unsigned   int     teacher _ ind ;   / *   his   teacher   index   * / }   STUDENT ; & frac12 ;         5 - 4 ： 不要 设计 面面俱到 、 非常灵活 的 数据结构 。 说明 ： 面面俱到 、 灵活 的 数据结构 反而 容易 引起 误解 和 操作 困难 。 & frac12 ;         5 - 5 ： 不同 结构 间 的 关系 不要 过于 复杂 。 说明 ： 若 两个 结构 间 关系 较 复杂 、 密切 ， 那么 应 合为 一个 结构 。 示例 ： 如下 两个 结构 的 构造 不合理 。 typedef   struct   PERSON _ ONE _ STRU {         unsigned   char   name [ 8 ] ;         unsigned   char   addr [ 40 ] ;         unsigned   char   sex ;         unsigned   char   city [ 15 ] ; }   PERSON _ ONE ; typedef   struct   PERSON _ TWO _ STRU {         unsigned   char   name [ 8 ] ;         unsigned   char   age ;         unsigned   char   tel ; }   PERSON _ TWO ; 由于 两个 结构 都 是 描述 同一 事物 的 ， 那么 不如 合成 一个 结构 。 typedef   struct   PERSON _ STRU {         unsigned   char   name [ 8 ] ;         unsigned   char   age ;         unsigned   char   sex ;         unsigned   char   addr [ 40 ] ;         unsigned   char   city [ 15 ] ;         unsigned   char   tel ; }   PERSON ; & frac12 ;         5 - 6 ： 结构 中 元素 的 个数 应 适中 。 若 结构 中 元素 个数 过多 可 考虑 依据 某种 原则 把 元素 组成 不同 的 子结构 ， 以 减少 原 结构 中 元素 的 个数 。 说明 ： 增加 结构 的 可 理解 性 、 可操作性 和 可维护性 。 示例 ： 假如 认为 如上 的 _ PERSON 结构 元素 过多 ， 那么 可 如下 对 之 划分 。 typedef   struct   PERSON _ BASE _ INFO _ STRU {         unsigned   char   name [ 8 ] ;         unsigned   char   age ;         unsigned   char   sex ; }   PERSON _ BASE _ INFO ; typedef   struct   PERSON _ ADDRESS _ STRU {         unsigned   char   addr [ 40 ] ;         unsigned   char   city [ 15 ] ;         unsigned   char   tel ; }   PERSON _ ADDRESS ; typedef   struct   PERSON _ STRU {         PERSON _ BASE _ INFO   person _ base ;         PERSON _ ADDRESS   person _ addr ; }   PERSON ; & frac12 ;         5 - 7 ： 仔细 设计 结构 中 元素 的 布局 与 排列 顺序 ， 使 结构 容易 理解 、 节省 占用 空间 ， 并 减少 引起 误用 现象 。 说明 ： 合理 排列 结构 中 元素 顺序 ， 可 节省 空间 并 增加 可 理解 性 。 示例 ： 如下 结构 中 的 位域 排列 ， 将 占 较大 空间 ， 可读性 也 稍差 。 typedef   struct   EXAMPLE _ STRU {         unsigned   int   valid :   1 ;         PERSON   person ;         unsigned   int   set _ flg :   1 ; }   EXAMPLE ; 若 改成 如下 形式 ， 不仅 可 节省 1 字节 空间 ， 可读性 也 变好 了 。 typedef   struct   EXAMPLE _ STRU {         unsigned   int   valid :   1 ;         unsigned   int   set _ flg :   1 ;         PERSON   person   ; }   EXAMPLE ; & frac12 ;         5 - 8 ： 结构 的 设计 要 尽量 考虑 向前 兼容 和 以后 的 版本升级 ， 并 为 某些 未来 可能 的 应用 保留余地 （ 如 预留 一些 空间 等 ） 。 说明 ： 软件 向前 兼容 的 特性 ， 是 软件产品 是否 成功 的 重要 标志 之一 。 如果 要 想 使 产品 具有 较 好 的 前 向 兼容 ， 那么 在 产品设计 之初 就 应为 以后 版本升级 保留 一定 余地 ， 并且 在 产品升级 时 必须 考虑 前 一 版本 的 各种 特性 。 & frac12 ;         5 - 9 ： 留心 具体 语言 及 编译器 处理 不同 数据类型 的 原则 及 有关 细节 。 说明 ： 如 在 C语言 中 ， static 局部变量 将 在 内存 “ 数据 区 ” 中 生成 ， 而 非 static 局部变量 将 在 “ 堆栈 ” 中 生成 。 这些 细节 对 程序 质量 的 保证 非常 重要 。 & frac12 ;         5 - 10 ： 编程 时 ， 要 注意 数据类型 的 强制 转换 。 说明 ： 当 进行 数据类型 强制 转换 时 ， 其 数据 的 意义 、 转换 后 的 取值 等 都 有 可能 发生变化 ， 而 这些 细节 若 考虑不周 ， 就 很 有 可能 留下 隐患 。 & frac12 ;         5 - 11 ： 对 编译系统 默认 的 数据 类型转换 ， 也 要 有 充分 的 认识 。 示例 ： 如下 赋值 ， 多数 编译器 不 产生 告警 ， 但值 的 含义 还是 稍 有 变化 。 char   chr ; unsigned   short   int   exam ; chr   =   - 1 ; exam   =   chr ;   / /   编译器 不 产生 告警 ， 此时 exam 为 0xFFFF 。 & frac12 ;         5 - 12 ： 尽量减少 没有 必要 的 数据类型 默认 转换 与 强制 转换 。 & frac12 ;         5 - 13 ： 合理 地 设计 数据 并 使用 自定义 数据类型 ， 避免 数据 间 进行 不必要 的 类型转换 。 & frac12 ;         5 - 14 ： 对 自定义 数据类型 进行 恰当 命名 ， 使 它 成为 自 描述性 的 ， 以 提高 代码 可读性 。 注意 其 命名 方式 在 同一 产品 中 的 统一 。 说明 ： 使用 自定义 类型 ， 可以 弥补 编程语言 提供 类型 少 、 信息量 不足 的 缺点 ， 并 能 使 程序 清晰 、 简洁 。 示例 ： 可 参考 如下 方式 声明 自定义 数据类型 。 下面 的 声明 可 使 数据类型 的 使用 简洁 、 明 了 。 typedef   unsigned   char     BYTE ; typedef   unsigned   short   WORD ; typedef   unsigned   int       DWORD ; 下面 的 声明 可 使 数据类型 具有 更 丰富 的 含义 。 typedef   float   DISTANCE ; typedef   float   SCORE ; & frac12 ;         5 - 15 ： 当 声明 用于 分布式 环境 或 不同 CPU 间通信 环境 的 数据结构 时 ， 必须 考虑 机器 的 字节 顺序 、 使用 的 位域 及 字节 对齐 等 问题   。 说明 ： 比如 Intel   CPU 与 68360   CPU ， 在 处理 位域 及 整数 时 ， 其 在 内存 存放 的 “ 顺序 ” 正好 相反 。 示例 ： 假如 有 如下 短 整数 及 结构 。 unsigned   short   int   exam ; typedef   struct   EXAM _ BIT _ STRU {                                               / *   Intel   68360   * /         unsigned   int   A1 :   1 ;   / *   bit     0             7       * /         unsigned   int   A2 :   1 ;   / *   bit     1             6       * /         unsigned   int   A3 :   1 ;   / *   bit     2             5       * / }   EXAM _ BIT ; 如下 是 Intel   CPU 生成 短 整数 及 位域 的 方式 。 内存 ：   0                     1                   2         ...     （ 从 低 到 高 ， 以 字节 为 单位 ） exam     exam 低字节     exam 高字节 内存 ：                 0   bit           1   bit             2   bit         ...     （ 字节 的 各 “ 位 ” ） EXAM _ BIT           A1                 A2                   A3 如下 是 68360   CPU 生成 短 整数 及 位域 的 方式 。 内存 ：   0                     1                   2         ...     （ 从 低 到 高 ， 以 字节 为 单位 ） exam     exam 高字节     exam 低字节 内存 ：                 7   bit           6   bit             5   bit         ...     （ 字节 的 各 “ 位 ” ） EXAM _ BIT           A1                 A2                   A3 说明 ： 在 对齐 方式 下 ， CPU 的 运行 效率 要 快得多 。 示例 ： 如下 图 ， 当 一个 long 型数 （ 如图 中 long1 ） 在 内存 中 的 位置 正好 与 内存 的 字 边界 对齐 时 ， CPU 存取 这个 数只 需 访问 一次 内存 ， 而 当 一个 long 型数 （ 如图 中 的 long2 ） 在 内存 中 的 位置 跨越 了 字 边界 时 ， CPU 存取 这个 数 就 需要 多次 访问 内存 ， 如 i960cx 访问 这样 的 数 需读 内存 三次 （ 一个 BYTE 、 一个 SHORT 、 一个 BYTE ， 由 CPU 的 微 代码执行 ， 对 软件 透明 ） ， 所有 对齐 方式 下 CPU 的 运行 效率 明显 快 多 了 。         1               8               16             24             32         - - - - - - -   - - - - - - -   - - - - - - -   - - - - - - -         |   long1   |   long1   |   long1   |   long1   |         - - - - - - -   - - - - - - -   - - - - - - -   - - - - - - -         |               |               |               |   long2   |         - - - - - - -   - - - - - - -   - - - - - - -   - - - - - - - -         |   long2   |   long2   |   long2   |               |         - - - - - - -   - - - - - - -   - - - - - - -   - - - - - - - -         |   ....   6   函数 、 过程 & sup1 ;     6 - 1 ： 对 所 调用函数 的 错误 返回 码要 仔细 、 全面 地 处理 。 & sup1 ;     6 - 2 ： 明确 函数 功能 ， 精确 （ 而 不是 近似 ） 地 实现 函数 设计 。 & sup1 ;     6 - 3 ： 编写 可 重入 函数 时 ， 应 注意 局部变量 的 使用 （ 如 编写 C / C++ 语言 的 可 重入 函数 时 ， 应 使用 auto 即 缺省 态 局部变量 或 寄存器 变量 ） 。 说明 ： 编写 C / C++ 语言 的 可 重入 函数 时 ， 不 应 使用 static 局部变量 ， 否则 必须 经过 特殊 处理 ， 才能 使 函数 具有 可重 入性 。 & sup1 ;     6 - 4 ： 编写 可 重入 函数 时 ， 若 使用 全局变量 ， 则 应 通过 关 中断 、 信号量 （ 即 P 、 V 操作 ） 等 手段 对 其 加以 保护 。 说明 ： 若 对 所 使用 的 全局变量 不 加以 保护 ， 则 此 函数 就 不 具有 可重 入性 ， 即当 多个 进程 调用 此 函数 时 ， 很 有 可能 使 有关 全局变量 变为 不 可知 状态 。 示例 ： 假设 Exam 是 int 型 全局变量 ， 函数 Squre _ Exam 返回 Exam 平方 值 。 那么 如下 函数 不 具有 可重 入性 。 unsigned   int   example (   int   para   ) {         unsigned   int   temp ;         Exam   =   para ;   / /   （ * * ）         temp   =   Square _ Exam (   ) ;         return   temp ; } 此 函数 若 被 多个 进程 调用 的话 ， 其 结果 可能 是 未知 的 ， 因为 当 （ * * ） 语句 刚 执行 完后 ， 另外 一个 使用 本 函数 的 进程 可能 正好 被 激活 ， 那么 当新 激活 的 进程 执行 到 此 函数 时 ， 将 使 Exam 赋 与 另 一个 不同 的 para 值 ， 所以 当 控制 重新 回到 “ temp   =   Square _ Exam (   ) ” 后 ， 计算 出 的 temp 很 可能 不是 预想 中 的 结果 。 此 函数 应 如下 改进 。 unsigned   int   example (   int   para   ) {         unsigned   int   temp ;         [ 申请 信号量 操作 ]                     / /   若 申请 不到 “ 信号量 ” ， 说明 另外 的 进程 正 处于         Exam   =   para ;                         / /   给 Exam 赋值 并 计算 其 平方 过程 中 （ 即 正在 使用 此         temp   =   Square _ Exam (   ) ;     / /   信号 ） ， 本 进程 必须 等待 其 释放 信号 后 ， 才 可继         [ 释放 信号量 操作 ]                     / /   续 执行 。 若 申请 到 信号 ， 则 可 继续执行 ， 但 其                                                         / /   它 进程 必须 等待 本 进程 释放 信号量 后 ， 才能 再 使                                                         / /   用本 信号 。         return   temp ; } & sup1 ;     6 - 5 ： 在 同一 项目组 应 明确规定 对 接口函数 参数 的 合法性检查 应由 函数 的 调用者 负责 还是 由 接口函数 本身 负责 ， 缺省 是 由 函数调用 者 负责 。 说明 ： 对于 模块 间 接口函数 的 参数 的 合法性检查 这一 问题 ， 往往 有 两个 极端 现象 ， 即 ： 要么 是 调用者 和 被 调用者 对 参数均 不 作 合法性检查 ， 结果 就 遗漏 了 合法性检查 这一 必要 的 处理过程 ， 造成 问题 隐患 ； 要么 就是 调用者 和 被 调用者 均 对 参数 进行 合法性检查 ， 这种 情况 虽 不会 造成 问题 ， 但 产生 了 冗余 代码 ， 降低 了 效率 。 & frac12 ;         6 - 1 ： 防止 将 函数 的 参数 作为 工作 变量 。 说明 ： 将 函数 的 参数 作为 工作 变量 ， 有 可能 错误 地 改变 参数 内容 ， 所以 很 危险 。 对 必须 改变 的 参数 ， 最好 先 用 局部变量 代之 ， 最后 再 将 该 局部变量 的 内容 赋给 该 参数 。 示例 ： 下 函数 的 实现 不太好 。 void   sum _ data (   unsigned   int   num ,   int   * data ,   int   * sum   ) {         unsigned   int   count ;                 * sum   =   0 ;         for   ( count   =   0 ;   count   <   num ;   count ++ )         {                 * sum     + =   data [ count ] ;   / /   sum 成 了 工作 变量 ， 不太好 。         } } 若 改为 如下 ， 则 更好 些 。 void   sum _ data (   unsigned   int   num ,   int   * data ,   int   * sum   ) {         unsigned   int   count   ;         int   sum _ temp ;                 sum _ temp   =   0 ;         for   ( count   =   0 ;   count   <   num ;   count   ++ )         {                 sum _ temp     + =   data [ count ] ;           }                 * sum   =   sum _ temp ; } & frac12 ;         6 - 2 ： 函数 的 规模 尽量 限制 在 200 行 以内 。 说明 ： 不 包括 注释 和 空格 行 。 & frac12 ;         6 - 3 ： 一个 函数 仅 完成 一件 功能 。 & frac12 ;         6 - 4 ： 为 简单 功能 编写 函数 。 说明 ： 虽然 为 仅 用 一 两行 就 可 完成 的 功能 去 编 函数 好象 没有 必要 ， 但用 函数 可 使 功能 明确化 ， 增加 程序 可读性 ， 亦可 方便 维护 、 测试 。 示例 ： 如下 语句 的 功能 不 很 明显 。 value   =   (   a   >   b   )   ?   a   :   b   ; 改为 如下 就 很 清晰 了 。 int   max   ( int   a ,   int   b ) {         return   ( ( a   >   b )   ?   a   :   b ) ; } value   =   max   ( a ,   b ) ; 或 改为 如下 。 # define   MAX   ( a ,   b )   ( ( ( a )   >   ( b ) )   ?   ( a )   :   ( b ) ) value   =   MAX   ( a ,   b ) ; & frac12 ;         6 - 5 ： 不要 设计 多用途 面面俱到 的 函数 。 说明 ： 多功能 集于一身 的 函数 ， 很 可能 使 函数 的 理解 、 测试 、 维护 等 变得 困难 。 & frac12 ;         6 - 6 ： 函数 的 功能 应该 是 可以 预测 的 ， 也 就是 只要 输入 数据 相同 就 应 产生 同样 的 输出 。 说明 ： 带有 内部 “ 存储器 ” 的 函数 的 功能 可能 是 不可 预测 的 ， 因为 它 的 输出 可能 取决于 内部 存储器 （ 如某 标记 ） 的 状态 。 这样 的 函数 既 不 易于 理解 又 不利于 测试 和 维护 。 在 C / C++ 语言 中 ， 函数 的 static 局部变量 是 函数 的 内部 存储器 ， 有 可能 使 函数 的 功能 不可 预测 ， 然而 ， 当某 函数 的 返回值 为 指针 类型 时 ， 则 必须 是 STATIC 的 局部变量 的 地址 作为 返回值 ， 若为 AUTO 类 ， 则 返回 为 错针 。 示例 ： 如下 函数 ， 其 返回值 （ 即 功能 ） 是 不可 预测 的 。 unsigned   int   integer _ sum (   unsigned   int   base   ) {         unsigned   int   index ;         static   unsigned   int   sum   =   0 ;   / /   注意 ， 是 static 类型 的 。                                                                   / /   若 改为 auto 类型 ， 则 函数 即 变为 可 预测 。         for   ( index   =   1 ;   index   < =   base ;   index ++ )         {                 sum   + =   index ;         }         return   sum ; } & frac12 ;         6 - 7 ： 尽量 不要 编写 依赖于 其他 函数 内部 实现 的 函数 。 说明 ： 此条 为 函数 独立性 的 基本 要求 。 由于 目前 大部分 高级 语言 都 是 结构化 的 ， 所以 通过 具体 语言 的 语法 要求 与 编译器 功能 ， 基本 就 可以 防止 这种 情况 发生 。 但 在 汇编语言 中 ， 由于 其 灵活性 ， 很 可能 使 函数 出现 这种 情况 。 示例 ： 如下 是 在 DOS 下 TASM 的 汇编程序 例子 。 过程 Print _ Msg 的 实现 依赖于 Input _ Msg 的 具体 实现 ， 这种 程序 是非 结构化 的 ， 难以 维护 、 修改 。 ...     / /   程序代码 proc   Print _ Msg   / /   过程 （ 函数 ） Print _ Msg         ...     / /   程序代码         jmp     LABEL         ...     / /   程序代码 endpproc   Input _ Msg   / /   过程 （ 函数 ） Input _ Msg         ...     / /   程序代码 LABEL :         ...     / /   程序代码 endp & frac12 ;         6 - 8 ： 避免 设计 多 参数 函数 ， 不 使用 的 参数 从 接口 中 去掉 。 说明 ： 目的 减少 函数 间接口 的 复杂度 。 & frac12 ;         6 - 9 ： 非 调度 函数 应 减少 或 防止 控制参数 ， 尽量 只 使用 数据 参数 。 说明 ： 本 建议 目的 是 防止 函数 间 的 控制 耦合 。 调度 函数 是 指 根据 输入 的 消息 类型 或 控制 命令 ， 来 启动 相应 的 功能 实体 （ 即 函数 或 过程 ） ， 而 本身 并 不 完成 具体 功能 。 控制参数 是 指 改变 函数 功能 行为 的 参数 ， 即 函数 要 根据 此参数 来 决定 具体 怎样 工作 。 非 调度 函数 的 控制参数 增加 了 函数 间 的 控制 耦合 ， 很 可能 使 函数 间 的 耦合度 增大 ， 并 使 函数 的 功能 不 唯一 。 示例 ： 如下 函数 构造 不太 合理 。 int   add _ sub (   int   a ,   int   b ,   unsigned   char   add _ sub _ flg   ) {         if   ( add _ sub _ flg   = =   INTEGER _ ADD )         {                 return   ( a   +   b ) ;         }         else         {                 return   ( a       b ) ;         } } 不如 分为 如下 两个 函数 清晰 。 int   add (   int   a ,   int   b   ) {         return   ( a   +   b ) ; } int   sub (   int   a ,   int   b   )   {         return   ( a       b ) ; } & frac12 ;         6 - 10 ： 检查 函数 所有 参数 输入 的 有效性 。 & frac12 ;         6 - 11 ： 检查 函数 所有 非 参数 输入 的 有效性 ， 如 数据文件 、 公共 变量 等 。 说明 ： 函数 的 输入 主要 有 两种 ： 一种 是 参数 输入 ； 另 一种 是 全局变量 、 数据文件 的 输入 ， 即非 参数 输入 。 函数 在 使用 输入 之前 ， 应 进行 必要 的 检查 。 & frac12 ;         6 - 12 ： 函数 名应 准确 描述 函数 的 功能 。 & frac12 ;         6 - 13 ： 使用 动宾 词组 为 执行 某 操作 的 函数 命名 。 如果 是 OOP 方法 ， 可以 只有 动词 （ 名词 是 对象 本身 ） 。 示例 ： 参照 如下 方式 命名 函数 。 void   print _ record (   unsigned   int   rec _ ind   )   ; int     input _ record (   void   )   ; unsigned   char   get _ current _ color (   void   )   ; 建议 6 - 14 ： 避免 使用 无 意义 或 含义 不清 的 动词 为 函数 命名 。 说明 ： 避免 用 含义 不清 的 动词 如 process 、 handle 等 为 函数 命名 ， 因为 这些 动词 并 没有 说明 要 具体 做 什么 。 建议 6 - 15 ： 函数 的 返回值 要 清楚 、 明 了 ， 让 使用者 不 容易 忽视 错误 情况 。 说明 ： 函数 的 每种 出错 返回值 的 意义 要 清晰 、 明 了 、 准确 ， 防止 使用者 误用 、 理解 错误 或 忽视 错误 返回 码 。 & frac12 ;         6 - 16 ： 除非 必要 ， 最好 不要 把 与 函数 返回值 类型 不同 的 变量 ， 以 编译系统 默认 的 转换 方式 或 强制 的 转换 方式 作为 返回值 返回 。 & frac12 ;         6 - 17 ： 让 函数 在 调用 点 显得 易懂 、 容易 理解 。 & frac12 ;         6 - 18 ： 在 调用函数 填写 参数 时 ， 应 尽量减少 没有 必要 的 默认 数据 类型转换 或 强制 数据 类型转换 。 说明 ： 因为 数据 类型转换 或多或少 存在 危险 。 & frac12 ;         6 - 19 ： 避免 函数 中 不必要 语句 ， 防止 程序 中 的 垃圾 代码 。 说明 ： 程序 中 的 垃圾 代码 不仅 占用 额外 的 空间 ， 而且 还 常常 影响 程序 的 功能 与 性能 ， 很 可能 给 程序 的 测试 、 维护 等 造成 不必要 的 麻烦 。 & frac12 ;         6 - 20 ： 防止 把 没有 关联 的 语句 放到 一个 函数 中 。 说明 ： 防止 函数 或 过程 内 出现 随机 内聚 。 随机 内聚 是 指 将 没有 关联 或 关联 很弱 的 语句 放到 同一个 函数 或 过程 中 。 随机 内聚 给 函数 或 过程 的 维护 、 测试 及 以后 的 升级 等 造成 了 不便 ， 同时 也 使 函数 或 过程 的 功能 不 明确 。 使用 随机 内聚 函数 ， 常常 容易 出现 在 一种 应用 场合 需要 改进 此 函数 ， 而 另 一种 应用 场合 又 不 允许 这种 改进 ， 从而 陷入困境 。 在 编程 时 ， 经常 遇到 在 不同 函数 中 使用 相同 的 代码 ， 许多 开发人员 都 愿 把 这些 代码 提出 来 ， 并 构成 一个 新 函数 。 若 这些 代码 关联 较大 并且 是 完成 一个 功能 的 ， 那么 这种 构造 是 合理 的 ， 否则 这种 构造 将 产生 随机 内聚 的 函数 。 示例 ： 如下 函数 就是 一种 随机 内聚 。 void   Init _ Var (   void   ) {         Rect . length   =   0 ;         Rect . width   =   0 ;   / *   初始化 矩形 的 长 与 宽   * /                 Point . x   =   10 ;         Point . y   =   10 ;       / *   初始化 “ 点 ” 的 坐标   * / } 矩形 的 长 、 宽 与 点 的 坐标 基本 没有 任何 关系 ， 故 以上 函数 是 随机 内聚 。 应 如下 分为 两个 函数 ： void   Init _ Rect (   void   ) {         Rect . length   =   0 ;         Rect . width   =   0 ;   / *   初始化 矩形 的 长 与 宽   * / } void   Init _ Point (   void   ) {         Point . x   =   10 ;         Point . y   =   10 ;       / *   初始化 “ 点 ” 的 坐标   * / } & frac12 ;         6 - 21 ： 如果 多 段 代码 重复 做同 一件 事情 ， 那么 在 函数 的 划分 上 可能 存在 问题 。 说明 ： 若此 段 代码 各 语句 之间 有 实质性 关联 并且 是 完成 同 一件 功能 的 ， 那么 可 考虑 把 此段 代码 构造 成 一个 新 的 函数 。 & frac12 ;         6 - 22 ： 功能 不 明确 较 小 的 函数 ， 特别 是 仅 有 一个 上级 函数调用 它 时 ， 应 考虑 把 它 合并 到 上级 函数 中 ， 而 不必 单独 存在 。 说明 ： 模块 中 函数 划分 的 过 多 ， 一般 会 使 函数 间 的 接口 变得复杂 。 所以 过 小 的 函数 ， 特别 是 扇入 很 低 的 或 功能 不 明确 的 函数 ， 不 值得 单独 存在 。 & frac12 ;         6 - 23 ： 设计 高 扇入 、 合理 扇出 （ 小于 7 ） 的 函数 。 说明 ： 扇出 是 指 一个 函数 直接 调用 （ 控制 ） 其它 函数 的 数目 ， 而 扇入 是 指有 多少 上级 函数调用 它 。 扇 出过 大 ， 表明 函数 过分 复杂 ， 需要 控制 和 协调 过多 的 下级 函数 ； 而 扇 出过 小 ， 如 总是 1 ， 表明 函数 的 调用 层次 可能 过多 ， 这样 不利 程序 阅读 和 函数 结构 的 分析 ， 并且 程序运行 时会 对 系统资源 如 堆栈 空间 等 造成 压力 。 函数 较 合理 的 扇 出 （ 调度 函数 除外 ） 通常 是 3 - 5 。 扇 出太大 ， 一般 是 由于 缺乏 中间 层次 ， 可 适当 增加 中间 层次 的 函数 。 扇出 太小 ， 可 把 下级 函数 进一步 分解 多个 函数 ， 或 合并 到 上级 函数 中 。 当然 分解 或 合并 函数 时 ， 不能 改变 要 实现 的 功能 ， 也 不能 违背 函数 间 的 独立性 。 扇入 越大 ， 表明 使用 此 函数 的 上级 函数 越 多 ， 这样 的 函数 使用 效率高 ， 但 不能 违背 函数 间 的 独立性 而 单纯 地 追求 高 扇入 。 公共 模块 中 的 函数 及 底层 函数 应该 有 较 高 的 扇入 。 较 良好 的 软件结构 通常 是 顶层 函数 的 扇 出 较 高 ， 中层 函数 的 扇 出 较 少 ， 而 底层 函数 则 扇入 到 公共 模块 中 。 & frac12 ;         6 - 24 ： 减少 函数 本身 或 函数 间 的 递归 调用 。 说明 ： 递归 调用 特别 是 函数 间 的 递归 调用 （ 如 A - > B - > C - > A ） ， 影响 程序 的 可 理解 性 ； 递归 调用 一般 都 占用 较 多 的 系统资源 （ 如栈 空间 ） ； 递归 调用 对 程序 的 测试 有 一定 影响 。 故 除非 为 某些 算法 或 功能 的 实现 方便 ， 应 减少 没 必要 的 递归 调用 。 & frac12 ;         6 - 25 ： 仔细分析 模块 的 功能 及 性能需求 ， 并 进一步 细分 ， 同时 若有 必要 画出 有关 数据流 图 ， 据此 来 进行 模块 的 函数 划分 与 组织 。 说明 ： 函数 的 划分 与 组织 是 模块 的 实现 过程 中 很 关键 的 步骤 ， 如何 划分 出 合理 的 函数 结构 ， 关系 到 模块 的 最终 效率 和 可维护性 、 可测性 等 。 根据 模块 的 功能 图 或 / 及 数据流 图 映射 出 函数 结构 是 常用 方法 之一 。 & frac12 ;         6 - 26 ： 改进 模块 中 函数 的 结构 ， 降低 函数 间 的 耦合度 ， 并 提高 函数 的 独立性 以及 代码 可读性 、 效率 和 可维护性 。 优化 函数 结构 时 ， 要 遵守 以下 原则 ： （ 1 ） 不能 影响 模块 功能 的 实现 。 （ 2 ） 仔细 考查 模块 或 函数 出错 处理 及 模块 的 性能 要求 并 进行 完善 。 （ 3 ） 通过 分解 或 合并 函数 来 改进 软件结构 。 （ 4 ） 考查 函数 的 规模 ， 过大 的 要 进行 分解 。 （ 5 ） 降低 函数 间接口 的 复杂度 。 （ 6 ） 不同 层次 的 函数调用 要 有 较 合理 的 扇入 、 扇出 。 （ 7 ） 函数 功能 应可 预测 。 （ 8 ） 提高 函数 内聚 。 （ 单一 功能 的 函数 内聚 最高 ） 说明 ： 对 初步 划分 后 的 函数 结构 应 进行 改进 、 优化 ， 使 之 更为 合理 。 & frac12 ;         6 - 27 ： 在 多任务 操作系统 的 环境 下 编程 ， 要 注意 函数 可重 入性 的 构造 。 说明 ： 可重 入性 是 指 函数 可以 被 多个 任务 进程 调用 。 在 多任务 操作系统 中 ， 函数 是否 具有 可重 入性 是 非常 重要 的 ， 因为 这是 多个 进程 可以 共用 此 函数 的 必要条件 。 另外 ， 编译器 是否 提供 可 重入 函数库 ， 与 它 所 服务 的 操作系统 有关 ， 只有 操作系统 是 多任务 时 ， 编译器 才 有 可能 提供 可 重入 函数库 。 如 DOS 下 BC 和 MSC 等 就 不 具备 可 重入 函数库 ， 因为 DOS 是 单用户 单任务 操作系统 。 & frac12 ;         6 - 28 ： 避免 使用 BOOL 参数 。 说明 ： 原因 有 二 ， 其一 是 BOOL 参数值 无 意义 ， TURE / FALSE 的 含义 是 非常 模糊 的 ， 在 调用 时 很 难 知道 该 参数 到底 传达 的 是 什么 意思 ； 其二 是 BOOL 参数值 不利于 扩充 。 还有 NULL 也 是 一个 无 意义 的 单词 。 & frac12 ;         6 - 29 ：   对于 提供 了 返回值 的 函数 ， 在 引用 时 最好 使用 其 返回值 。 & frac12 ;         6 - 30 ： 当 一个 过程 （ 函数 ） 中 对 较长 变量 （ 一般 是 结构 的 成员 ） 有 较 多 引用 时 ， 可以 用 一个 意义 相当 的 宏 代替 。   说明 ： 这样 可以 增加 编程 效率 和 程序 的 可读性 。 示例 ： 在 某 过程 中较 多 引用 TheReceiveBuffer [ FirstSocket ] . byDataPtr ， 则 可以 通过 以下 宏 定义 来 代替 ： #   define   pSOCKDATA   TheReceiveBuffer [ FirstScoket ] . byDataPtr   7   可测性 & sup1 ;     7 - 1 ： 在 同一 项目组 或 产品组 内 ， 要 有 一套 统一 的 为 集成 测试 与 系统 联调 准备 的 调测 开关 及 相应 打印函数 ， 并且 要 有 详细 的 说明 。 说明 ： 本 规则 是 针对 项目组 或 产品组 的 。 & sup1 ;     7 - 2 ： 在 同一 项目组 或 产品组 内 ， 调测 打印 出 的 信息 串 的 格式 要 有 统一 的 形式 。 信息 串中 至少 要 有所 在 模块 名 （ 或源 文件名 ） 及 行号 。 说明 ： 统一 的 调测 信息格式 便于 集成 测试 。 & sup1 ;     7 - 3 ： 编程 的 同时 要 为 单元测试 选择 恰当 的 测试点 ， 并 仔细 构造 测试代码 、 测试用例 ， 同时 给出 明确 的 注释 说明 。 测试代码 部分 应 作为 （ 模块 中 的 ） 一个 子 模块 ， 以 方便 测试代码 在 模块 中 的 安装 与 拆卸 （ 通过 调测 开关 ） 。 说明 ： 为 单元测试 而 准备 。 & sup1 ;     7 - 4 ： 在 进行 集成 测试 / 系统 联调 之前 ， 要 构造 好 测试环境 、 测试项目 及 测试用例 ， 同时 仔细分析 并 优化 测试用例 ， 以 提高 测试 效率 。 说明 ： 好 的 测试用例 应 尽可能 模拟出 程序 所 遇到 的 边界值 、 各种 复杂 环境 及 一些 极端 情况 等 。 & sup1 ;     7 - 5 ： 使用 断言 来 发现 软件 问题 ， 提高 代码 可测性 。 说明 ： 断言 是 对 某种 假设 条件 进行 检查 （ 可 理解 为 若 条件 成立 则 无 动作 ， 否则 应 报告 ） ， 它 可以 快速 发现 并 定位 软件 问题 ， 同时 对系统 错误 进行 自动 报警 。 断言 可以 对 在 系统 中 隐藏 很深 ， 用 其它 手段 极难 发现 的 问题 进行 定位 ， 从而 缩短 软件 问题 定位 时间 ， 提高 系统 的 可测性 。 实际 应用 时 ， 可 根据 具体情况 灵活 地 设计 断言 。 示例 ： 下面 是 C语言 中 的 一个 断言 ， 用宏来 设计 的 。 （ 其中 NULL 为 0L ） # ifdef   _ EXAM _ ASSERT _ TEST _     / /   若 使用 断言 测试 void   exam _ assert (   char   *   file _ name ,   unsigned   int   line _ no   ) {         printf (   " \ n [ EXAM ] Assert   failed :   % s ,   line   % u \ n " ,                           file _ name ,   line _ no   ) ;         abort (   ) ; } # define     EXAM _ ASSERT (   condition   )         if   ( condition )   / /   若 条件 成立 ， 则 无 动作                 NULL ;         else     / /   否则 报告                 exam _ assert (   __ FILE __ ,   __ LINE __   )   # else     / /   若 不 使用 断言 测试 # define   EXAM _ ASSERT ( condition )     NULL   # endif     / *   end   of   ASSERT   * / & sup1 ;     7 - 6 ： 用 断言 来 检查程序 正常 运行 时不应 发生 但 在 调测 时有 可能 发生 的 非法 情况 。 & sup1 ;     7 - 7 ： 不能 用 断言 来 检查 最终 产品 肯定 会 出现 且 必须 处理 的 错误 情况 。 说明 ： 断言 是 用来 处理 不 应该 发生 的 错误 情况 的 ， 对于 可能 会 发生 的 且 必须 处理 的 情况 要 写 防错 程序 ， 而 不是 断言 。 如某 模块 收到 其它 模块 或 链路 上 的 消息 后 ， 要 对 消息 的 合理性 进行 检查 ， 此 过程 为 正常 的 错误 检查 ， 不能 用 断言 来 实现 。 & sup1 ;     7 - 8 ： 对 较 复杂 的 断言 加上 明确 的 注释 。 说明 ： 为 复杂 的 断言 加 注释 ， 可 澄清 断言 含义 并 减少 不必要 的 误用 。 & sup1 ;     7 - 9 ： 用 断言 确认 函数 的 参数 。 示例 ： 假设 某 函数参数 中有 一个 指针 ， 那么 使用 指针 前 可 对 它 检查 ， 如下 。 int   exam _ fun (   unsigned   char   * str   ) {         EXAM _ ASSERT (   str   ! =   NULL   ) ;     / /   用 断言 检查 “ 假设 指针 不为 空 ” 这个 条件                 ...   / / other   program   code } & sup1 ;     7 - 10 ： 用 断言 保证 没有 定义 的 特性 或 功能 不 被 使用 。 示例 ： 假设 某 通信 模块 在 设计 时 ， 准备 提供 “ 无 连接 ” 和 “ 连接 ”   这 两种 业务 。 但 当前 的 版本 中仅 实现 了 “ 无 连接 ” 业务 ， 且 在 此 版本 的 正式 发行版 中 ， 用户 （ 上层 模块 ） 不 应 产生 “ 连接 ” 业务 的 请求 ， 那么 在 测试 时 可用 断言 检查用户 是否 使用 “ 连接 ” 业务 。 如下 。 # define   EXAM _ CONNECTIONLESS   0   / /   无 连接 业务 # define   EXAM _ CONNECTION           1   / /   连接 业务 int   msg _ process (   EXAM _ MESSAGE   * msg   ) {         unsigned   char   service ;   / *   message   service   class   * /         EXAM _ ASSERT (   msg   ! =   NULL   ) ; service   =   get _ msg _ service _ class (   msg   ) ;         EXAM _ ASSERT (   service   ! =   EXAM _ CONNECTION   ) ;   / /   假设 不 使用 连接 业务         ...     / / other   program   code } & sup1 ;     7 - 11 ： 用 断言 对 程序开发 环境 （ OS / Compiler / Hardware ） 的 假设 进行 检查 。 说明 ： 程序运行 时 所 需 的 软硬件 环境 及 配置 要求 ， 不能 用 断言 来 检查 ， 而 必须 由 一段 专门 代码 处理 。 用 断言 仅 可 对 程序开发 环境 中 的 假设 及 所 配置 的 某 版本 软硬件 是否 具有 某种 功能 的 假设 进行 检查 。 如某 网卡 是否 在 系统 运行 环境 中 配置 了 ， 应由 程序 中 正式 代码 来 检查 ； 而此 网卡 是否 具有 某 设想 的 功能 ， 则 可 由 断言 来 检查 。 对 编译器 提供 的 功能 及 特性 假设 可用 断言 检查 ， 原因 是 软件 最终 产品 （ 即 运行 代码 或 机器码 ） 与 编译器 已 没有 任何 直接 关系 ， 即 软件 运行 过程 中 （ 注意 不是 编译 过程 中 ） 不会 也 不 应该 对 编译器 的 功能 提出 任何 需求 。 示例 ： 用 断言 检查 编译器 的 int 型 数据 占用 的 内存空间 是否 为 2 ， 如下 。 EXAM _ ASSERT (   sizeof (   int   )   = =   2   ) ; & sup1 ;     7 - 12 ： 正式 软件产品 中应 把 断言 及其 它 调测 代码 去掉 （ 即 把 有关 的 调测 开关 关掉 ） 。 说明 ： 加快 软件 运行 速度 。 & sup1 ;     7 - 13 ： 在 软件系统 中 设置 与 取消 有关 测试 手段 ， 不能 对 软件 实现 的 功能 等 产生 影响 。 说明 ： 即 有 测试代码 的 软件 和 关掉 测试代码 的 软件 ， 在 功能 行为 上应 一致 。 & sup1 ;     7 - 14 ： 用 调测 开关 来 切换 软件 的 DEBUG 版 和 正式版 ， 而 不要 同时 存在 正式 版本 和 DEBUG 版本 的 不同 源文件 ， 以 减少 维护 的 难度 。 & sup1 ;     7 - 15 ： 软件 的 DEBUG 版本 和 发行 版本 应该 统一 维护 ， 不 允许 分家 ， 并且 要 时刻 注意 保证 两个 版本 在 实现 功能 上 的 一致性 。 & frac12 ;         7 - 1 ： 在 编写 代码 之前 ， 应 预先 设计 好 程序调试 与 测试 的 方法 和 手段 ， 并 设计 好 各种 调测 开关 及 相应 测试代码 如 打印函数 等 。 说明 ： 程序 的 调试 与 测试 是 软件 生存 周期 中 很 重要 的 一个 阶段 ， 如何 对 软件 进行 较 全面 、 高率 的 测试 并 尽可能 地 找出 软件 中 的 错误 就 成为 很 关键 的 问题 。 因此 在 编写 源代码 之前 ， 除了 要 有 一套 比较完善 的 测试 计划外 ， 还应 设计 出 一系列 代码 测试 手段 ， 为 单元测试 、 集成 测试 及 系统 联调 提供方便 。 & frac12 ;         7 - 2 ： 调测 开关 应 分为 不同 级别 和 类型 。 说明 ： 调测 开关 的 设置 及 分类 应从 以下 几 方面 考虑 ： 针对 模块 或 系统 某 部分 代码 的 调测 ； 针对 模块 或 系统 某 功能 的 调测 ； 出于 某种 其它 目的 ， 如对 性能 、 容量 等 的 测试 。 这样 做 便于 软件 功能 的 调测 ， 并且 便于 模块 的 单元测试 、 系统 联调 等 。 & frac12 ;         7 - 3 ： 编写 防错 程序 ， 然后 在 处理错误 之后 可用 断言 宣布 发生 错误 。 示例 ： 假如 某 模块 收到 通信 链路 上 的 消息 ， 则 应对 消息 的 合法性 进行 检查 ， 若 消息 类别 不是 通信协议 中 规定 的 ， 则 应 进行 出错 处理 ， 之后 可用 断言 报告 ， 如下 例 。 # ifdef   _ EXAM _ ASSERT _ TEST _   / /   若 使用 断言 测试 / *   Notice :   this   function   does   not   call   ' abort '   to   exit   program   * / void   assert _ report (   char   *   file _ name ,   unsigned   int   line _ no   ) {         printf (   " \ n [ EXAM ] Error   Report :   % s ,   line   % u \ n " ,                           file _ name ,   line _ no   ) ; } # define     ASSERT _ REPORT (   condition   )           if   (   condition   )   / /   若 条件 成立 ， 则 无 动作                 NULL ;         else   / /   否则 报告                 assert _ report   (   __ FILE __ ,   __ LINE __   )   # else   / /   若 不 使用 断言 测试 # define   ASSERT _ REPORT (   condition   )     NULL   # endif   / *   end   of   ASSERT   * / int   msg _ handle (   unsigned   char   msg _ name ,   unsigned   char   *   msg   ) {         switch (   msg _ name   )         {                 case   MSG _ ONE :                         ...   / /   消息 MSG _ ONE 处理                         return   MSG _ HANDLE _ SUCCESS ;                                 ...   / /   其它 合法 消息 处理                         default :                         ...   / /   消息 出错 处理                         ASSERT _ REPORT (   FALSE   ) ;     / /   “ 合法 ” 消息 不 成立 ， 报告                         return   MSG _ HANDLE _ ERROR ;         } }   8   程序 效率 & sup1 ;     8 - 1 ： 编程 时要 经常 注意 代码 的 效率 。 说明 ： 代码 效率 分为 全局 效率 、 局部 效率 、 时间 效率 及 空间 效率 。 全局 效率 是 站 在 整个 系统 的 角度 上 的 系统 效率 ； 局部 效率 是 站 在 模块 或 函数 角度 上 的 效率 ； 时间 效率 是 程序处理 输入 任务 所 需 的 时间 长短 ； 空间 效率 是 程序 所 需 内存空间 ， 如 机器 代码 空间 大小 、 数据 空间 大小 、 栈 空间 大小 等 。 & sup1 ;     8 - 2 ： 在 保证 软件系统 的 正确性 、 稳定性 、 可读性 及 可测性 的 前提 下 ， 提高 代码 效率 。 说明 ： 不能 一味 地 追求 代码 效率 ， 而 对 软件 的 正确性 、 稳定性 、 可读性 及 可测性 造成 影响 。 & sup1 ;     8 - 3 ： 局部 效率 应为 全局 效率 服务 ， 不能 因为 提高 局部 效率 而 对 全局 效率 造成 影响 。 & sup1 ;     8 - 4 ： 通过 对系统 数据结构 的 划分 与 组织 的 改进 ， 以及 对 程序 算法 的 优化 来 提高 空间 效率 。 说明 ： 这种 方式 是 解决 软件 空间 效率 的 根本 办法 。 示例 ： 如下 记录 学生 学习成绩 的 结构 不合理 。 typedef   unsigned   char     BYTE ; typedef   unsigned   short   WORD ; typedef   struct   STUDENT _ SCORE _ STRU         BYTE   name [ 8 ] ;         BYTE   age ;         BYTE   sex ;         BYTE   class ;         BYTE   subject ;         float   score ; }   STUDENT _ SCORE ; 因为 每位 学生 都 有 多科 学习成绩 ， 故如上 结构 将 占用 较大 空间 。 应 如下 改进 （ 分为 两个 结构 ） ， 总 的 存贮空间 将 变小 ， 操作 也 变得 更 方便 。 typedef   struct   STUDENT _ STRU {         BYTE   name [ 8 ] ;         BYTE   age ;         BYTE   sex ;         BYTE   class ; }   STUDENT ; typedef   struct   STUDENT _ SCORE _ STRU {         WORD   student _ index ;         BYTE   subject ;         float   score ; }   STUDENT _ SCORE ; & sup1 ;     8 - 5 ： 循环 体内 工作量 最小化 。 说明 ： 应 仔细 考虑 循环 体内 的 语句 是否 可以 放在 循环体 之外 ， 使 循环 体内 工作量 最小 ， 从而 提高 程序 的 时间 效率 。 示例 ： 如下 代码 效率 不高 。 for   ( ind   =   0 ;   ind   <   MAX _ ADD _ NUMBER ;   ind ++ ) {         sum   + =   ind ;         back _ sum   =   sum ;   / *   backup   sum   * / } 语句 “ back _ sum   =   sum ; ” 完全 可以 放在 for 语句 之后 ， 如下 。 for   ( ind   =   0 ;   ind   <   MAX _ ADD _ NUMBER ;   ind ++ ) {         sum   + =   ind ; } back _ sum     =   sum ;   / *   backup   sum   * / & frac12 ;         8 - 1 ： 仔细分析 有关 算法 ， 并 进行 优化 。 & frac12 ;         8 - 2 ： 仔细 考查 、 分析 系统 及 模块 处理 输入 （ 如 事务 、 消息 等 ） 的 方式 ， 并 加以改进 。 & frac12 ;         8 - 3 ： 对 模块 中 函数 的 划分 及 组织 方式 进行 分析 、 优化 ， 改进 模块 中 函数 的 组织 结构 ， 提高 程序 效率 。 说明 ： 软件系统 的 效率 主要 与 算法 、 处理 任务 方式 、 系统 功能 及 函数 结构 有 很大 关系 ， 仅 在 代码 上 下功夫 一般 不能 解决 根本 问题 。 & frac12 ;         8 - 4 ： 编程 时 ， 要 随时 留心 代码 效率 ； 优化 代码 时 ， 要 考虑 周全 。 & frac12 ;         8 - 5 ： 不应 花过 多 的 时间 拼命 地 提高 调用 不 很 频繁 的 函数 代码 效率 。 说明 ： 对 代码优化 可 提高效率 ， 但 若 考虑不周 很 有 可能 引起 严重后果 。 & frac12 ;         8 - 6 ： 要 仔细 地 构造 或 直接 用 汇编 编写 调用 频繁 或 性能 要求 极高 的 函数 。 说明 ： 只有 对 编译系统 产生 机器码 的 方式 以及 硬件 系统 较为 熟悉 时 ， 才 可 使用 汇编 嵌入 方式 。 嵌入 汇编 可 提高 时间 及 空间 效率 ， 但 也 存在 一定 风险 。 & frac12 ;         8 - 7 ： 在 保证 程序 质量 的 前提 下 ， 通过 压缩 代码 量 、 去掉 不必要 代码 以及 减少 不必要 的 局部 和 全局变量 ， 来 提高 空间 效率 。 说明 ： 这种 方式 对 提高 空间 效率 可 起到 一定 作用 ， 但 往往 不能 解决 根本 问题 。 & frac12 ;         8 - 8 ： 在 多重 循环 中 ， 应 将 最忙 的 循环 放在 最 内层 。 说明 ： 减少 CPU 切入 循环 层 的 次数 。 示例 ： 如下 代码 效率 不高 。 for   ( row   =   0 ;   row   <   100 ;   row ++ ) {         for   ( col   =   0 ;   col   <   5 ;   col ++ )         {                 sum   + =   a [ row ] [ col ] ;         } } 可以 改为 如下 方式 ， 以 提高效率 。 for   ( col   =   0 ;   col   <   5 ;   col ++ ) {         for   ( row   =   0 ;   row   <   100 ;   row ++ )         {                 sum   + =   a [ row ] [ col ] ;         } } & frac12 ;         8 - 9 ： 尽量减少 循环 嵌套 层次 。 & frac12 ;         8 - 10 ： 避免 循环体 内含 判断 语句 ， 应 将 循环 语句 置于 判断 语句 的 代码 块 之中 。 说明 ： 目的 是 减少 判断 次数 。 循环体 中 的 判断 语句 是否 可以 移 到 循环 体外 ， 要视 程序 的 具体情况 而言 ， 一般 情况 ， 与 循环 变量 无关 的 判断 语句 可以 移 到 循环 体外 ， 而 有关 的 则 不 可以 。 示例 ： 如下 代码 效率 稍低 。 for   ( ind   =   0 ;   ind   <   MAX _ RECT _ NUMBER ;   ind ++ ) {         if   ( data _ type   = =   RECT _ AREA )         {                 area _ sum   + =   rect _ area [ ind ] ;         }         else         {                 rect _ length _ sum   + =   rect [ ind ] . length ;                 rect _ width _ sum   + =   rect [ ind ] . width ;         } } 因为 判断 语句 与 循环 变量 无关 ， 故可 如下 改进 ， 以 减少 判断 次数 。 if   ( data _ type   = =   RECT _ AREA ) {         for   ( ind   =   0 ;   ind   <   MAX _ RECT _ NUMBER ;   ind ++ )         {                 area _ sum   + =   rect _ area [ ind ] ;         } } else {         for   ( ind   =   0 ;   ind   <   MAX _ RECT _ NUMBER ;   ind ++ )         {                 rect _ length _ sum   + =   rect [ ind ] . length ;                 rect _ width _ sum     + =   rect [ ind ] . width ;         } } & frac12 ;         8 - 11 ： 尽量 用 乘法 或 其它 方法 代替 除法 ， 特别 是 浮点运算 中 的 除法 。 说明 ： 浮点运算 除法 要 占用 较 多 CPU 资源 。 示例 ： 如下 表达式 运算 可能 要 占 较 多 CPU 资源 。 # define   PAI   3.1416 radius   =   circle _ length   /   ( 2   *   PAI ) ; 应 如下 把 浮点 除法 改为 浮点 乘法 。 # define   PAI _ RECIPROCAL   ( 1   /   3.1416   )   / /   编译器 编译 时 ， 将 生成 具体 浮点数 radius   =   circle _ length   *   PAI _ RECIPROCAL   /   2 ;   & frac12 ;         8 - 12 ： 不要 一味 追求 紧凑 的 代码 。 说明 ： 因为 紧凑 的 代码 并 不 代表 高效 的 机器码 。   9   质量保证 & sup1 ;     9 - 1 ： 在 软件设计 过程 中 构筑 软件 质量 。 & sup1 ;     9 - 2 ： 代码 质量保证 优先 原则           （ 1 ） 正确性 ， 指 程序 要 实现 设计 要求 的 功能 。           （ 2 ） 稳定性 、 安全性 ， 指 程序 稳定 、 可靠 、 安全 。           （ 3 ） 可 测试 性 ， 指 程序 要 具有 良好 的 可 测试 性 。           （ 4 ） 规范 / 可读性 ， 指 程序 书写 风格 、 命名 规则 等 要 符合规范 。           （ 5 ） 全局 效率 ， 指 软件系统 的 整体 效率 。           （ 6 ） 局部 效率 ， 指 某个 模块 / 子 模块 / 函数 的 本身 效率 。           （ 7 ） 个人 表达方式 / 个人 方便性 ， 指 个人 编程 习惯 。 & sup1 ;     9 - 3 ： 只 引用 属于 自己 的 存贮空间 。 说明 ： 若 模块 封装 的 较 好 ， 那么 一般 不会 发生 非法 引用 他人 的 空间 。 & sup1 ;     9 - 4 ： 防止 引用 已经 释放 的 内存空间 。 说明 ： 在 实际 编程 过程 中 ， 稍 不留心 就 会 出现 在 一个 模块 中 释放 了 某个 内存 块 （ 如 C语言 指针 ） ， 而 另 一 模块 在 随后 的 某个 时刻 又 使用 了 它 。 要 防止 这种 情况 发生 。 & sup1 ;     9 - 5 ： 过程 / 函数 中 分配 的 内存 ， 在 过程 / 函数 退出 之前 要 释放 。 & sup1 ;     9 - 6 ： 过程 / 函数 中 申请 的 （ 为 打开 文件 而 使用 的 ） 文件 句柄 ， 在 过程 / 函数 退出 之前 要 关闭 。 说明 ： 分配 的 内存 不 释放 以及 文件 句柄 不 关闭 ， 是 较 常见 的 错误 ， 而且 稍 不 注意 就 有 可能 发生 。 这 类 错误 往往 会 引起 很 严重后果 ， 且 难以 定位 。 示例 ： 下 函数 在 退出 之前 ， 没有 把 分配 的 内存 释放 。 typedef   unsigned   char   BYTE ; int   example _ fun (   BYTE   gt _ len ,   BYTE   * gt _ code   ) {         BYTE   * gt _ buf ;         gt _ buf   =   ( BYTE   * )   malloc   ( MAX _ GT _ LENGTH ) ;         ...     / / program   code ,   include   check   gt _ buf   if   or   not   NULL .                 / *   global   title   length   error   * /         if   ( gt _ len   >   MAX _ GT _ LENGTH )         {                 return   GT _ LENGTH _ ERROR ;   / /   忘 了 释放 gt _ buf         }                 ...     / /   other   program   code } 应 改为 如下 。 int   example _ fun (   BYTE   gt _ len ,   BYTE   * gt _ code   ) {         BYTE   * gt _ buf ;         gt _ buf   =   ( BYTE   *   )   malloc   (   MAX _ GT _ LENGTH   ) ;         ...     / /   program   code ,   include   check   gt _ buf   if   or   not   NULL .                 / *   global   title   length   error   * /         if   ( gt _ len   >   MAX _ GT _ LENGTH )         {                 free (   gt _ buf     ) ;   / /   退出 之前 释放 gt _ buf                 return   GT _ LENGTH _ ERROR ;             }                 ...     / /   other   program   code } & sup1 ;     9 - 7 ： 防止 内存 操作 越界 。 说明 ： 内存 操作 主要 是 指 对 数组 、 指针 、 内存地址 等 的 操作 。 内存 操作 越界 是 软件系统 主要 错误 之一 ， 后果 往往 非常 严重 ， 所以 当 我们 进行 这些 操作 时 一定 要 仔细 小心 。 示例 ： 假设 某 软件系统 最多 可 由 10 个 用户 同时 使用 ， 用户 号 为 1 - 10 ， 那么 如下 程序 存在 问题 。 # define   MAX _ USR _ NUM   10unsigned   char   usr _ login _ flg [ MAX _ USR _ NUM ] =   " " ; void   set _ usr _ login _ flg (   unsigned   char   usr _ no   ) {         if   ( ! usr _ login _ flg [ usr _ no ] )         {                 usr _ login _ flg [ usr _ no ] =   TRUE ;         } } 当 usr _ no 为 10 时 ， 将 使用 usr _ login _ flg 越界 。 可 采用 如下 方式 解决 。 void   set _ usr _ login _ flg (   unsigned   char   usr _ no   ) {         if   ( ! usr _ login _ flg [ usr _ no   -   1 ] )         {                 usr _ login _ flg [ usr _ no   -   1 ] =   TRUE ;         } } & sup1 ;     9 - 8 ： 认真 处理程序 所 能 遇到 的 各种 出错 情况 。 & sup1 ;     9 - 9 ： 系统 运行 之初 ， 要 初始化 有关 变量 及 运行 环境 ， 防止 未经 初始化 的 变量 被 引用 。 & sup1 ;     9 - 10 ： 系统 运行 之初 ， 要 对 加载 到 系统 中 的 数据 进行 一致性 检查 。 说明 ： 使用 不 一致 的 数据 ， 容易 使 系统 进入 混乱状态 和 不 可知 状态 。 & sup1 ;     9 - 11 ： 严禁 随意 更改 其它 模块 或 系统 的 有关 设置 和 配置 。 说明 ： 编程 时 ， 不能 随心所欲 地 更改 不 属于 自己 模块 的 有关 设置 如 常量 、 数组 的 大小 等 。 & sup1 ;     9 - 12 ： 不能 随意 改变 与 其它 模块 的 接口 。 & sup1 ;     9 - 13 ： 充分 了解 系统 的 接口 之后 ， 再 使用 系统 提供 的 功能 。 示例 ： 在 B型 机 的 各 模块 与 操作系统 的 接口函数 中 ， 有 一个 要 由 各 模块 负责 编写 的 初始化 过程 ， 此 过程 在 软件系统 加载 完成 后 ， 由 操作系统 发送 的 初始化 消息 来 调度 。 因此 就 涉及 到 初始化 消息 的 类型 与 消息 发送 的 顺序 问题 ， 特别 是 消息 顺序 ， 若 没 搞清楚 就 开始 编程 ， 很 容易 引起 严重后果 。 以下 示例 引 自 B型 曾 出现 过 的 实际 代码 ， 其中 使用 了 FID _ FETCH _ DATA 与 FID _ INITIAL 初始化 消息 类型 ， 注意 B型 机 的 系统 是 在 FID _ FETCH _ DATA 之前 发送 FID _ INITIAL 的 。 MID   alarm _ module _ list [ MAX _ ALARM _ MID ] ; int   FAR   SYS _ ALARM _ proc (   FID   function _ id ,   int   handle   ) {         _ UI   i ,   j ;         switch   (   function _ id   )         {                 ...   / /   program   code                         case   FID _ INITAIL :                         for   ( i   =   0 ;   i   <   MAX _ ALARM _ MID ;   i ++ )                         {                                 if   ( alarm _ module _ list [ i ] = =   BAM _ MODULE   / /   * * ）                                       | |   ( alarm _ module _ list [ i ] = =   LOCAL _ MODULE )                                 {                                         for   ( j   =   0 ;   j   <   ALARM _ CLASS _ SUM ;   j ++ )                                         {                                                 FAR _ MALLOC (   ...   ) ;                                         }                                 }                         }                         ...   / /   program   code                         break ;                         case   FID _ FETCH _ DATA :                         ...   / /   program   code                         Get _ Alarm _ Module (   ) ;     / /   初始化 alarm _ module _ list                         break ;                         ...   / /   program   code         } } 由于 FID _ INITIAL 是 在 FID _ FETCH _ DATA 之前 执行 的 ， 而 初始化 alarm _ module _ list 是 在 FID _ FETCH _ DATA 中 进行 的 ， 故 在 FID _ INITIAL 中 （ * * ） 处 引用 alarm _ module _ list 变量 时 ， 它 还 没有 被 初始化 。 这 是 个 严重错误 。 应 如下 改正 ： 要么 把 Get _ Alarm _ Module 函数 放在 FID _ INITIAL 中 （ * * ） 之前 ； 要么 就 必须 考虑 （ * * ） 处 的 判断 语句 是否 可以 用 （ 不 使用 alarm _ module _ list 变量 的 ） 其它 方式 替代 ， 或者 是否 可以 取消 此 判断 语句 。 & sup1 ;     9 - 14 ： 编程 时 ， 要 防止 差 1 错误 。 说明 ： 此类 错误 一般 是 由于 把 “ < = ” 误 写成 “ < ” 或 “ > = ” 误 写成 “ > ” 等 造成 的 ， 由此 引起 的 后果 ， 很多 情况 下 是 很 严重 的 ， 所以 编程 时 ， 一定 要 在 这些 地方 小心 。 当编 完 程序 后 ， 应对 这些 操作符 进行 彻底 检查 。 & sup1 ;     9 - 15 ： 要 时刻 注意 易 混淆 的 操作符 。 当编 完 程序 后 ， 应 从头至尾 检查 一遍 这些 操作符 ， 以 防止 拼写错误 。 说明 ： 形式 相近 的 操作符 最 容易 引起 误用 ， 如 C / C++ 中 的 “ = ” 与 “ = = ” 、 “ | ” 与 “ | | ” 、 “ & ” 与 “ && ” 等 ， 若 拼写 错 了 ， 编译器 不 一定 能够 检查 出来 。 示例 ： 如 把 “ & ” 写成 “ && ” ， 或 反之 。 ret _ flg   =   ( pmsg - > ret _ flg   &   RETURN _ MASK ) ;     被 写 为 ： ret _ flg   =   ( pmsg - > ret _ flg   &&   RETURN _ MASK ) ; rpt _ flg   =   ( VALID _ TASK _ NO (   taskno   )   &&   DATA _ NOT _ ZERO (   stat _ data   ) ) ; 被 写 为 ： rpt _ flg   =   ( VALID _ TASK _ NO (   taskno   )   &   DATA _ NOT _ ZERO (   stat _ data   ) ) ; & sup1 ;     9 - 16 ： 有 可能 的话 ， if 语句 尽量 加上 else 分支 ， 对 没有 else 分支 的 语句 要 小心 对待 ； switch 语句 必须 有 default 分支 。 & sup1 ;     9 - 17 ： Unix 下 ， 多线程 的 中 的 子 线程 退出 必需 采用 主动 退出 方式 ， 即子 线程 应 return 出口 。 & sup1 ;     9 - 18 ： 不要 滥用 goto 语句 。 说明 ： goto 语句 会 破坏 程序 的 结构性 ， 所以 除非 确实 需要 ， 最好 不 使用 goto 语句 。 & frac12 ;         9 - 1 ： 不 使用 与 硬件 或 操作系统 关系 很大 的 语句 ， 而 使用 建议 的 标准 语句 ， 以 提高 软件 的 可移植性 和 可 重用 性 。 & frac12 ;         9 - 2 ： 除非 为了 满足 特殊 需求 ， 避免 使用 嵌入式 汇编 。 说明 ： 程序 中 嵌入式 汇编 ， 一般 都 对 可移植性 有 较大 的 影响 。 & frac12 ;         9 - 3 ： 精心 地 构造 、 划分 子 模块 ， 并 按 “ 接口 ” 部分 及 “ 内核 ” 部分 合理 地 组织 子 模块 ， 以 提高 “ 内核 ” 部分 的 可移植性 和 可 重用 性 。 说明 ： 对 不同 产品 中 的 某个 功能 相同 的 模块 ， 若能 做到 其 内核 部分 完全 或 基本一致 ， 那么 无论 对 产品 的 测试 、 维护 ， 还是 对 以后 产品 的 升级 都 会 有 很大 帮助 。 & frac12 ;         9 - 4 ： 精心 构造 算法 ， 并 对 其 性能 、 效率 进行 测试 。 & frac12 ;         9 - 5 ： 对 较 关键 的 算法 最好 使用 其它 算法 来 确认 。 & frac12 ;         9 - 6 ： 时刻 注意 表达式 是否 会上 溢 、 下溢 。 示例 ： 如下 程序 将 造成 变量 下溢 。 unsigned   char   size   ; while   ( size - -   > =   0 )   / /   将 出现 下溢 {         ...   / /   program   code } 当 size 等于 0 时 ， 再减 1 不会 小于 0 ， 而是 0xFF ， 故 程序 是 一个 死循环 。 应 如下 修改 。 char   size ;   / /   从 unsigned   char   改为 charwhile   ( size - -   > =   0 ) {         ...   / /   program   code } & frac12 ;         9 - 7 ： 使用 变量 时要 注意 其 边界值 的 情况 。 示例 ： 如 C语言 中 字符 型 变量 ， 有效值 范围 为 - 128 到 127 。 故 以下 表达式 的 计算 存在 一定 风险 。 char   chr   =   127 ; int   sum   =   200 ; chr   + =   1 ;   / /   127 为 chr 的 边界值 ， 再加 1 将 使 chr 上溢 到 - 128 ， 而 不是 128 。 sum   + =   chr ;   / /   故 sum 的 结果 不是 328 ， 而是 72 。 若 chr 与 sum 为同 一种 类型 ， 或 表达式 按 如下 方式 书写 ， 可能 会 好些 。 sum   =   sum   +   chr   +   1 ;   & frac12 ;         9 - 8 ： 留心 程序 机器码 大小 （ 如 指令 空间 大小 、 数据 空间 大小 、 堆栈 空间 大小 等 ） 是否 超出 系统 有关 限制 。 & frac12 ;         9 - 9 ： 为 用户 提供 良好 的 接口界面 ， 使 用户 能 较 充分 地 了解 系统 内部 运行 状态 及 有关 系统 出错 情况 。 & frac12 ;         9 - 10 ： 系统 应 具有 一定 的 容错 能力 ， 对 一些 错误 事件 （ 如 用户 误操作 等 ） 能 进行 自动 补救 。 & frac12 ;         9 - 11 ： 对 一些 具有 危险性 的 操作 代码 （ 如写 硬盘 、 删 数据 等 ） 要 仔细 考虑 ， 防止 对 数据 、 硬件 等 的 安全 构成 危害 ， 以 提高 系统 的 安全性 。 & frac12 ;         9 - 12 ： 使用 第三方 提供 的 软件开发 工具包 或 控件 时 ， 要 注意 以下几点 ： （ 1 ） 充分 了解 应用 接口 、 使用 环境 及 使用 时 注意事项 。 （ 2 ） 不能 过分 相信 其 正确性 。 （ 3 ） 除非 必要 ， 不要 使用 不 熟悉 的 第三方 工具包 与 控件 。 说明 ： 使用 工具包 与 控件 ， 可 加快 程序开发 速度 ， 节省时间 ， 但 使用 之前 一定 对 它 有 较 充分 的 了解 ， 同时 第三方 工具包 与 控件 也 有 可能 存在 问题 。 & frac12 ;         9 - 13 ： 资源 文件 （ 多 语言 版本 支持 ） ， 如果 资源 是 对 语言 敏感 的 ， 应 让 该 资源 与 源代码 文件 脱离 ， 具体方法 有 下面 几种 ： 使用 单独 的 资源 文件 、 DLL 文件 或 其它 单独 的 描述 文件 （ 如 数据库 格式 ）   10   代码 编辑 、 编译 、 审查 & sup1 ;     10 - 1 ： 打开 编译器 的 所有 告警 开关 对 程序 进行 编译 。 & sup1 ;     10 - 2 ： 在 产品软件 （ 项目组 ） 中 ， 要 统一 编译 开关 选项 。 & sup1 ;     10 - 3 ： 通过 代码 走读 及 审查 方式 对 代码 进行 检查 。 说明 ： 代码 走读 主要 是 对 程序 的 编程 风格 如 注释 、 命名 等 以及 编程 时易 出错 的 内容 进行 检查 ， 可 由 开发人员 自己 或 开发人员 交叉 的 方式 进行 ； 代码 审查 主要 是 对 程序实现 的 功能 及 程序 的 稳定性 、 安全性 、 可靠性 等 进行 检查 及 评审 ， 可 通过 自审 、 交叉 审核 或 指定 部门 抽查 等 方式 进行 。 & sup1 ;     10 - 4 ： 测试 部 测试 产品 之前 ， 应对 代码 进行 抽查 及 评审 。 & frac12 ;         10 - 1 ： 编写 代码 时要 注意 随时 保存 ， 并 定期 备份 ， 防止 由于 断电 、 硬盘 损坏 等 原因 造成 代码 丢失 。 & frac12 ;         10 - 2 ： 同 产品软件 （ 项目组 ） 内 ， 最好 使用 相同 的 编辑器 ， 并 使用 相同 的 设置 选项 。 说明 ： 同一 项目组 最好 采用 相同 的 智能 语言 编辑器 ， 如 Muiti   Editor ， Visual   Editor 等 ， 并 设计 、 使用 一套 缩进 宏及 注释 宏等 ， 将 缩进 等 问题 交由 编辑器 处理 。 & frac12 ;         10 - 3 ： 要 小心 地 使用 编辑器 提供 的 块拷贝 功能 编程 。 说明 ： 当 某段 代码 与 另 一段 代码 的 处理 功能 相似 时 ， 许多 开发人员 都 用 编辑器 提供 的 块拷贝 功能 来 完成 这 段 代码 的 编写 。 由于 程序 功能 相近 ， 故所 使用 的 变量 、 采用 的 表达式 等 在 功能 及 命名 上 可能 都 很 相近 ， 所以 使用 块拷贝 时要 注意 ， 除了 修改 相应 的 程序 外 ， 一定 要 把 使用 的 每个 变量 仔细 查看 一遍 ， 以 改成 正确 的 。 不 应 指望 编译器 能 查出 所有 这种 错误 ， 比如 当 使用 的 是 全局变量 时 ， 就 有 可能 使 某种 错误 隐藏 下来 。 & frac12 ;         10 - 4 ： 合理 地 设计 软件系统 目录 ， 方便 开发人员 使用 。 说明 ： 方便 、 合理 的 软件系统 目录 ， 可 提高 工作效率 。 目录 构造 的 原则 是 方便 有关 源程序 的 存储 、 查询 、 编译 、 链接 等 工作 ， 同时 目录 中 还 应 具有 工作 目录 - - - - 所有 的 编译 、 链接 等 工作 应 在 此 目录 中 进行 ， 工具 目录 - - - - 有关 文件 编辑器 、 文件 查找 等 工具 可 存放 在 此 目录 中 。 & frac12 ;         10 - 5 ： 某些 语句 经 编译 后 产生 告警 ， 但 如果 你 认为 它 是 正确 的 ， 那么 应 通过 某种 手段 去掉 告警信息 。 说明 ： 在 Borland   C / C++ 中 ， 可用 “ # pragma     warn ” 来 关掉 或 打开 某些 告警 。 示例 ： # pragma   warn   - rvl   / /   关闭 告警 int   examples _ fun (   void   ) {             / /   程序 ， 但 无 return 语句 。 } # pragma   warn   + rvl   / /   打开 告警 编译 函数 examples _ fun 时本应 产生 “ 函数 应有 返回值 ” 告警 ， 但 由于 关掉 了 此 告警信息 显示 ， 所以 编译 时 将 不会 产生 此 告警 提示 。 & frac12 ;         10 - 6 ： 使用 代码 检查 工具 （ 如 C语言 用 PC - Lint ） 对 源程序 检查 。 & frac12 ;         10 - 7 ： 使用 软件工具 （ 如   LogiSCOPE ） 进行 代码 审查 。   11   代码 测试 、 维护 & sup1 ;     11 - 1 ： 单元测试 要求 至少 达到 语句 覆盖 。 & sup1 ;     11 - 2 ： 单元测试 开始 要 跟踪 每 一条 语句 ， 并 观察 数据流 及 变量 的 变化 。 & sup1 ;     11 - 3 ： 清理 、 整理 或 优化 后 的 代码 要 经过 审查 及 测试 。 & sup1 ;     11 - 4 ： 代码 版本升级 要 经过 严格 测试 。 & sup1 ;     11 - 5 ： 使用 工具软件 对 代码 版本 进行 维护 。 & sup1 ;     11 - 6 ： 正式 版本 上 软件 的 任何 修改 都 应有 详细 的 文档 记录 。 & frac12 ;         11 - 1 ： 发现错误 立即 修改 ， 并且 要 记录下来 。 & frac12 ;         11 - 2 ： 关键 的 代码 在 汇编 级 跟踪 。 & frac12 ;         11 - 3 ： 仔细 设计 并 分析 测试用例 ， 使 测试用例 覆盖 尽可能 多 的 情况 ， 以 提高 测试用例 的 效率 。 & frac12 ;         11 - 4 ： 尽可能 模拟出 程序 的 各种 出错 情况 ， 对 出错 处理 代码 进行 充分 的 测试 。 & frac12 ;         11 - 5 ： 仔细 测试代码 处理 数据 、 变量 的 边界 情况 。 & frac12 ;         11 - 6 ： 保留 测试 信息 ， 以便 分析 、 总结经验 及 进行 更 充分 的 测试 。 & frac12 ;         11 - 7 ： 不 应 通过 “ 试 ” 来 解决问题 ， 应 寻找 问题 的 根本原因 。 & frac12 ;         11 - 8 ： 对 自动 消失 的 错误 进行 分析 ， 搞清楚 错误 是 如何 消失 的 。 & frac12 ;         11 - 9 ： 修改 错误 不仅 要治表 ， 更要 治本 。 & frac12 ;         11 - 10 ： 测试 时应 设法 使 很少 发生 的 事件 经常 发生 。 & frac12 ;         11 - 11 ： 明确 模块 或 函数 处理 哪些 事件 ， 并 使 它们 经常 发生 。 & frac12 ;         11 - 12 ：   坚持 在 编码 阶段 就 对 代码 进行 彻底 的 单元测试 ， 不要 等 以后 的 测试 工作 来 发现 问题 。 & frac12 ;         11 - 13 ： 去除 代码运行 的 随机性 （ 如 去掉 无用 的 数据 、 代码 及 尽可能 防止 并 注意 函数 中 的 “ 内部 寄存器 ” 等 ） ， 让 函数 运行 的 结果 可 预测 ， 并 使 出现 的 错误 可 再现 。   12   宏 & sup1 ;     12 - 1 ： 用宏 定义 表达式 时 ， 要 使用 完备 的 括号 。 示例 ： 如下 定义 的 宏 都 存在 一定 的 风险 。 # define   RECTANGLE _ AREA (   a ,   b   )   a   *   b # define   RECTANGLE _ AREA (   a ,   b   )   ( a   *   b ) # define   RECTANGLE _ AREA (   a ,   b   )   ( a )   *   ( b ) 正确 的 定义 应为 ： # define   RECTANGLE _ AREA (   a ,   b   )   ( ( a )   *   ( b ) ) & sup1 ;     12 - 2 : 将宏所 定义 的 多条 表达式 放在 大括号 中 。 示例 ： 下面 的 语句 只有 宏 的 第一条 表达式 被 执行 。 为了 说明 问题 ， for 语句 的 书写 稍 不符 规范 。 # define   INTI _ RECT _ VALUE (   a ,   b   ) \         a   =   0 ; \         b   =   0 ; for   ( index   =   0 ;   index   <   RECT _ TOTAL _ NUM ;   index ++ )         INTI _ RECT _ VALUE (   rect . a ,   rect . b   ) ; 正确 的 用法 应为 ： # define   INTI _ RECT _ VALUE (   a ,   b   ) \ { \         a   =   0 ; \         b   =   0 ; \ } for   ( index   =   0 ;   index   <   RECT _ TOTAL _ NUM ;   index ++ ) {         INTI _ RECT _ VALUE (   rect [ index ] . a ,   rect [ index ] . b   ) ; } & sup1 ;     12 - 3 : 使用 宏时 ， 不 允许 参数 发生变化 。 示例 ： 如下 用法 可能 导致 错误 。 # define   SQUARE (   a   )   ( ( a )   *   ( a ) ) int   a   =   5 ; int   b ; b   =   SQUARE (   a ++   ) ;   / /   结果 ： a   =   7 ， 即 执行 了 两次 增 1 。 正确 的 用法 是 ： b   =   SQUARE (   a   ) ; a ++ ;   / /   结果 ： a   =   6 ， 即 只 执行 了 一次 增 1 。 _ - - ※   来源 : · 日月 光华   bbs . fudan . edu . cn · HTTP   [ FROM :   10.11 . 12.192 ] - - ※   来源 : · 日月 光华   bbs . fudan . edu . cn · HTTP   [ FROM :   10.11 . 12.192 ] ※   修改 : · huahero   於   03 月 11 日 10 : 59 : 37   修改 本文 · [ FROM :   10.85 . 7.77 ] - - ※   转载 : · 日月 光华   bbs . fudan . edu . cn · [ FROM :   10.100 . 131.108 ]   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - [ 返回 上 一页 ]   [ 本 讨论区 ]