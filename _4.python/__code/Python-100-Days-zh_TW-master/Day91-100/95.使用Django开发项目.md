## 使用Django開發項目

> 說明：本文的部分插圖來自於《Python項目開發實戰》和《精通Django》，這兩本書中都包含了對Django框架精彩的講解，有興趣的讀者可以自行購買閱讀。

### Web應用

問題1：描述一個Web應用的工作流程。

![](./res/web-application.png)

問題2：描述項目的物理架構。（上圖中補充負載均衡（反向代理）服務器、數據庫服務器、文件服務器、郵件服務器、緩存服務器、防火牆等，而且每個節點都有可能是多節點構成的集群，如下圖所示，架構並不是一開始就是這樣，而是逐步演進的）

![](./res/05.django_massive_cluster.png)

問題3：描述Django項目的工作流程。（如下圖所示）

![](./res/django_request_response_cycle.png)

### MVC架構模式

問題1：為什麼要使用MVC架構模式？（模型和視圖解耦合）

問題2：MVC架構中每個部分的作用？（如下圖所示）

![](./res/mvc.png)

### HTTP請求和響應

#### HTTP請求 = 請求行+請求頭+空行+[消息體]

![](./res/http-request.png)

#### HTTP響應 = 響應行+響應頭+空行+消息體

![](./res/http-response.png)

1. `HTTPRequest`對象的屬性和方法：

   - `method` - 獲取請求方法
   - `path` / `get_full_path()` - 獲取請求路徑/帶查詢字符串的路徑
   - `scheme` / `is_secure()` / `get_host()` / `get_port()` - 獲取請求的協議/主機/端口
   - `META` / `COOKIES` - 獲取請求頭/Cookie信息
   - `GET` / `POST` / `FILES` - 獲取GET或POST請求參數/上傳的文件
   - `get_signed_cookie()` - 獲取帶簽名的Cookie
   - `is_ajax()` - 是不是Ajax異步請求
   - `body` / `content_type` / `encoding` - 獲取請求的消息體（bytes流）/MIME類型/編碼
2. 中間件添加的屬性：

   - `session` / `user` / `site`
3. `HttpResponse`對象的屬性和方法：

   - `set_cookie()` / `set_signed_cookie()` / `delete_cookie()` - 添加/刪除Cookie
   - `__setitem__` / `__getitem__` / `__delitem__` - 添加/獲取/刪除響應頭
   - `charset` / `content` / `status_code` - 響應的字符集/消息體（bytes流）/狀態碼
     - 1xx：請求已經收到，繼續處理
     - 2xx（成功）：請求已經成功收到、理解和接收。
     - 3xx（重定向）：為完成請求要繼續執行後續的操作。
     - 4xx（客戶端錯誤）：請求不正確或不能夠被受理。
     - 5xx（服務器錯誤）：服務器處理請求失敗。
4. `JsonResponse`（`HttpResponse`的子類型）對象

    ```Python
    >>> from django.http import HttpResponse, JsonResponse
    >>>
    >>> response = JsonResponse({'foo': 'bar'})
    >>> response.content
    >>>
    >>> response = JsonResponse([1, 2, 3], safe=False)
    >>> response.content
    >>>
    >>> response = HttpResponse(b'...')
    >>> response['cotent-type'] = 'application/pdf';
    >>> response['content-disposition'] = 'inline; filename="xyz.pdf"'
    >>> response['content-disposition'] = 'attachment; filename="xyz.pdf"'
    >>>
    >>> response.set_signed_cookie('foo', 'bar', salt='')
    >>> response.status_code = 200
    ```

### 數據模型(Model)

問題1：關係型數據庫表的設計應該注意哪些問題（範式理論和逆範式）？如何通過表來創建模型類（反向工程）？如何通過模型類來創建表（正向工程）？

```Shell
python manage.py makemigrations <appname>
python manage.py migrate

python manage.py inspectdb > <appname>/models.py
```

問題2：關係型數據庫中數據完整性指的是什麼？什麼時候需要犧牲數據完整性？（實體完整性/參照完整性/域完整性）

問題3：ORM是什麼以及解決了什麼問題？（對象模型-關係模型雙向轉換）

1. `Field`及其子類的屬性：

   - 通用選項：
     - `db_column` / `db_tablespace`
     - `null` / `blank` / `default`
     - `primary_key`
     - `db_index` / `unqiue`
     - `choices` / `help_text` / `error_message` / `editable` / `hidden`
   - 其他選項：
     - `CharField`: `max_length`
     - `DateField`: `auto_now` / `auto_now_add`
     - `DecimalField`: `max_digits` / `decimal_places`
     - `FileField`: `storage` / `upload_to`
     - `ImageField`: `height_field` / `width_field`

2. `ForeignKey`的屬性：

   - 重要屬性：
     - `db_constraint`（提升性能或者數據分片的情況可能需要設置為`False`）

     - `on_delete`

       * `CASCADE`：級聯刪除。

       - `PROTECT`：拋出`ProtectedError`異常，阻止刪除引用的對象。
       - `SET_NULL`：把外鍵設置為`null`，當`null`屬性被設置為`True`時才能這麼做。
       - `SET_DEFAULT`：把外鍵設置為默認值，提供了默認值才能這麼做。

     - `related_name`

       ```Python
       class Dept(models.Model):
           pass
       
       
       class Emp(models.Model):
           dept = models.ForeignKey(related_name='+', ...)
           
        
       Dept.objects.get(no=10).emp_set.all()
       Emp.objects.filter(dept__no=10)
       ```

       > 說明：`related_name`設置為`'+'`，可以防止一對多外鍵關聯從“一”的一方查詢“多”的一方。

   - 其他屬性：

     - `to_field` / `limit_choices_to` / `swappable`

3. `Model`的屬性和方法

   - `objects` / `pk`

   - `save()` / `delete()` 

   - `clean()` / `validate_unique()` / `full_clean()`

4. `QuerySet`的方法

   - `get()` / `all()` / `values()`

     > 說明：`values()`返回的`QuerySet`中不是模型對象而是字典

   - `count()` / `order_by()` / `exists()` / `reverse()`

   - `filter()` / `exclude()`

     - `exact` / `iexact`：精確匹配/忽略大小寫的精確匹配查詢

     - `contains` / `icontains` / `startswith / istartswith / endswith / iendswith`：基於`like`的模糊查詢

     - `in`：集合運算

     - `gt` / `gte` / `lt` / `lte`：大於/大於等於/小於/小於等於關係運算

     - `range`：指定範圍查詢（SQL中的`between…and…`）

     - `year` / `month` / `day` / `week_day` / `hour` / `minute` / `second`：查詢時間日期

     - `isnull`：查詢空值（`True`）或非空值（`False`）

     - `search`：基於全文索引的全文檢索

     - `regex` / `iregex`：基於正則表達式的模糊匹配查詢

     - `aggregate()` / `annotate()`

     - `Avg` / `Count` / `Sum` / `Max` / `Min`

       ```Python
       >>> from django.db.models import Avg
       >>> Emp.objects.aggregate(avg_sal=Avg('sal'))
       (0.001) SELECT AVG(`TbEmp`.`sal`) AS `avg_sal` FROM `TbEmp`; args=()
       {'avg_sal': 3521.4286}
       ```

       ```Python
       >>> Emp.objects.values('dept').annotate(total=Count('dept'))
       (0.001) SELECT `TbEmp`.`dno`, COUNT(`TbEmp`.`dno`) AS `total` FROM `TbEmp` GROUP BY `TbEmp`.`dno` ORDER BY NULL LIMIT 21; args=()
       <QuerySet [{'dept': 10, 'total': 4}, {'dept': 20, 'total': 7}, {'dept': 30, 'total': 3}]
       ```

   - `first()` / `last()`

     > 說明：調用`first()`方法相當於用`[0]`對`QuerySet`進行切片。

   - `only()` / `defer()`

     ```Python
     >>> Emp.objects.filter(pk=7800).only('name', 'sal')
     (0.001) SELECT `TbEmp`.`empno`, `TbEmp`.`ename`, `TbEmp`.`sal` FROM `TbEmp` WHERE `TbEmp`.`empno` = 7800 LIMIT 21; args=(7800,)
     <QuerySet [<Emp: Emp object (7800)>]>
     >>> Emp.objects.filter(pk=7800).defer('name', 'sal')
     (0.001) SELECT `TbEmp`.`empno`, `TbEmp`.`job`, `TbEmp`.`mgr`, `TbEmp`.`comm`, `TbEmp`.`dno` FROM `TbEmp` WHERE `TbEmp`.`empno` = 7800 LIMIT 21; args=(7800,)
     <QuerySet [<Emp: Emp object (7800)>]>
     ```

   - `create()` / `update()` / `raw()` 

     ```Python
     >>> Emp.objects.filter(dept__no=20).update(sal=F('sal') + 100)
     (0.011) UPDATE `TbEmp` SET `sal` = (`TbEmp`.`sal` + 100) WHERE `TbEmp`.`dno` = 20; args=(100, 20)
     >>>
     >>> Emp.objects.raw('select empno, ename, job from TbEmp where dno=10')
     <RawQuerySet: select empno, ename, job from TbEmp where dno=10>
     ```

5. `Q`對象和`F`對象

   > 說明：Q對象主要用來解決多條件組合的複雜查詢；F對象主要用於更新數據。

   ```Python
   >>> from django.db.models import Q
   >>> Emp.objects.filter(
   ...     Q(name__startswith='張'),
   ...     Q(sal__lte=5000) | Q(comm__gte=1000)
   ... ) # 查詢名字以“張”開頭且工資小於等於5000或補貼大於等於1000的員工
   <QuerySet [<Emp: 張三丰>]>
   ```

   ```Python
   >>> from backend.models import Emp, Dept
   >>> emps = Emp.objects.filter(dept__no=20)
   >>> from django.db.models import F
   >>> emps.update(sal=F('sal') + 100)
   ```

6. 原生SQL查詢

   ```Python
   from django.db import connections
   
   
   with connections['...'].cursor() as cursor:
       cursor.execute("UPDATE TbEmp SET sal=sal+10 WHERE dno=30")
       cursor.execute("SELECT ename, job FROM TbEmp WHERE dno=10")
       row = cursor.fetchall()
   ```

7. 模型管理器

   ```Python
   class BookManager(models.Manager):
       
       def title_count(self, keyword):
           return self.filter(title__icontains=keyword).count()
   
   class Book(models.Model):
       
       objects = BookManager()
   ```

### 視圖函數(Controller)

#### 如何設計視圖函數

1. 用戶的每個操作（用戶故事）對應一個視圖函數。

2. [每個視圖函數可以構成一個事務邊界](https://docs.djangoproject.com/en/2.1/ref/settings/)。

   - 事務的ACID特性。

     - 原子性（Atomicity）：事務中各項的操作要麼全做要麼全不做；
     - 一致性（Consistentcy）：事務前後系統的狀態是一致的；
     - 隔離性（Isolation）：併發執行的事務無法看到彼此的中間狀態；
     - 持久性（Duration）：事務完成後所做的改動都會被持久化。

   - 事務隔離級別 - 設置事務隔離級別是為了數據庫底層依據事務隔離級別為數據加上適當的鎖。如果需要保證數據的強一致性，那麼關係型數據庫仍然是唯一的也是最好的選擇，因為關係型數據庫可以通過鎖機制來保護數據。事務隔離級別從低到高依次是：Read Uncommitted（讀未提交）、Read Committed（讀提交）、Repeatable Read（可重複讀）、Serializable（串行化）。事務隔離級別越高，數據併發訪問的問題越少，但是性能越差；事務隔離級別越低，數據併發訪問的問題越多，但是性能越好。

   - 數據併發訪問會產生5種問題（請參考我的[《Java面試題全集（上）》](https://blog.csdn.net/jackfrued/article/details/44921941)第80題對該問題的講解）：

     - 第1類丟失更新（A事務撤銷覆蓋B事務更新的數據）和第2類丟失更新（A事務提交覆蓋B事務更新的數據）。
     - 髒讀（讀髒數據）：一個事務讀取到其他尚未提交的事務的數據。
     - 不可重複讀： 一個事務在讀取它的查詢結果時，被另一個事務更新了它的查詢記錄導致無法讀到數據。
     - 幻讀：一個事務在讀取它的查詢結果時，發現讀到了被另一個事務提交的新數據。

     ```SQL
     -- 設置全局默認的事務隔離級別
     set global transaction isolation level repeatable read;
     -- 設置當前會話的事務隔離級別
     set session transaction isolation level read committed;
     -- 查詢當前會話的事務隔離級別
     select @@tx_isolation;
     ```

   - Django中的事務控制。

     - 給每個請求綁定事務環境（反模式）。

       ```Python
       ATOMIC_REQUESTS = True
       ```

     - 使用事務裝飾器（簡單易用） - 粗粒度（控制不夠精細）。

       ```Python
       @transaction.non_atomic_requests
       @transaction.atomic
       ```

     - 使用上下文語法（細粒度 - 事務控制的範圍更加精準）。

       ```Python
       with transaction.atomic():
           pass
       ```

     - 關閉自動提交使用手動提交。

       ```Python
       AUTOCOMMIT = False
       ```

       ```Python
       transaction.commit()
       transaction.rollback()
       ```

#### URL配置

1. 可以讓部分URL只在調試模式下生效。

   ```Python
   from django.conf import settings
   
   urlpatterns = [
       ...
   ]
   
   if settings.DEBUG:
       urlpatterns += [ ... ]
   ```

2. 可以使用命名捕獲組捕獲路徑參數。

   ```Python
   url(r'api/code/(?P<mobile>1[3-9]\d{9})'),
   path('api/code/<str:mobile>'),
   ```

3. URL配置不關心請求使用的方法（一個視圖函數可以處理不同的請求方式）。

4. 如果使用`url`函數捕獲的路徑參數都是字符串，`path`函數可以指定路徑參數類型。

5. 可以使用`include`函數引入其他URL配置，捕獲的參數會向下傳遞。

6. 在`url`和`path`函數甚至是`include`函數中都可以用字典向視圖傳入額外的參數，如果參數與捕獲的參數同名，則使用字典中的參數。

7. 可以用`reverse`函數實現URL的逆向解析（從名字解析出URL），在模板中也可以用`{% url %}`實現同樣的操作。

   ```Python
   path('', views.index, name='index')
   
   return redirect(reverse('index'))
   return redirect('index')
   ```


### 模板(View)

#### 後端渲染

1. 模板的配置和渲染函數。

   ```Python
   TEMPLATES = [
       {
           'BACKEND': 'django.template.backends.django.DjangoTemplates',
           'DIRS': [os.path.join(BASE_DIR, 'templates'), ],
           'APP_DIRS': True,
           'OPTIONS': {
               'context_processors': [
                   'django.template.context_processors.debug',
                   'django.template.context_processors.request',
                   'django.contrib.auth.context_processors.auth',
                   'django.contrib.messages.context_processors.messages',
               ],
           },
       },
   ]
   ```

   ```Python
   resp = render(request, 'index.html', {'foo': ...})
   ```

2. 模板遇到變量名的查找順序。

   - 字典查找（如：`foo['bar']`）
   - 屬性查找（如：`foo.bar`）
   - 方法調用（如：`foo.bar()`）
     - 方法不能有必須傳值的參數
     - 在模板中不能夠給方法傳參
     - 如果方法的`alters_data`被設置為`True`則不能調用該方法（避免誤操作的風險），模型對象動態生成的`delete()`和`save()`方法都設定了`alters_data = True`。
   - 列表索引查找（如：`foo[0]`）

3. 模板標籤的使用。

   - `{% if %}` / `{% else %}` / `{% endif %}`
   - `{% for %}` / `{% endfor %}`
   - `{% ifequal %}` / `{% endifequal %}` / `{% ifnotequal %}` / `{% endifnotequal %}`
   - `{# comment #}` / `{% comment %}` / `{% endcomment %}`

4. 過濾器的使用。

   - `lower` / `upper` / `first` / `last` / `truncatewords` / `date `/ `time` / `length` / `pluralize` / `center` / `ljust` / `rjust` / `cut` / `urlencode` / `default_if_none` / `filesizeformat` / `join` / `slice` / `slugify`

5. 模板的包含和繼承。

   - `{% include %}` / `{% block %}`
   - `{% extends %}`

6. 模板加載器（後面優化部分會講到）。

   - 文件系統加載器

     ```Python
     TEMPLATES = [{
         'BACKEND': 'django.template.backends.django.DjangoTemplates',
         'DIRS': [os.path.join(BASE_DIR, 'templates')],
     }]
     ```

   - 應用目錄加載器

     ```Python
     TEMPLATES = [{
         'BACKEND': 'django.template.backends.django.DjangoTemplates',
         'APP_DIRS': True,
     }]
     ```


#### 前端渲染

1. 前端模板引擎：Handlebars / Mustache。
2. 前端MV\*框架。
   - MVC - AngularJS
   - MVVM(Model-View-ViewModel) - Vue.js

#### 其他視圖

1. MIME（多用途Internet郵件擴展）類型 - 告知瀏覽器傳輸的數據類型。

   | Content-Type     | 說明                                                         |
   | ---------------- | ------------------------------------------------------------ |
   | application/json | [JSON](https://zh.wikipedia.org/wiki/JSON)（JavaScript Object Notation） |
   | application/pdf  | [PDF](https://zh.wikipedia.org/wiki/PDF)（Portable Document Format） |
   | audio/mpeg       | [MP3](https://zh.wikipedia.org/wiki/MP3)或其他[MPEG](https://zh.wikipedia.org/wiki/MPEG)音頻文件 |
   | audio/vnd.wave   | [WAV](https://zh.wikipedia.org/wiki/WAV)音頻文件             |
   | image/gif        | [GIF](https://zh.wikipedia.org/wiki/GIF)圖像文件             |
   | image/jpeg       | [JPEG](https://zh.wikipedia.org/wiki/JPEG)圖像文件           |
   | image/png        | [PNG](https://zh.wikipedia.org/wiki/PNG)圖像文件             |
   | text/html        | [HTML](https://zh.wikipedia.org/wiki/HTML)文件               |
   | text/xml         | [XML](https://zh.wikipedia.org/wiki/XML)                     |
   | video/mp4        | [MP4](https://zh.wikipedia.org/wiki/MP4)視頻文件             |
   | video/quicktime  | [QuickTime](https://zh.wikipedia.org/wiki/QuickTime)視頻文件 |

2. 如何處置生成的內容（inline / attachment）。

   ```Python
   >>> from urllib.parse import quote
   >>>
   >>> response['content-type'] = 'application/pdf'
   >>> filename = quote('Python語言規範.pdf')
   >>> filename
   'Python%E8%AF%AD%E8%A8%80%E8%A7%84%E8%8C%83.pdf'
   >>> response['content-disposition'] = f'attachment; filename="{filename}"'
   ```
   > 提醒：URL以及請求和響應頭中的中文都應該處理成[百分號編碼](https://zh.wikipedia.org/zh-hans/%E7%99%BE%E5%88%86%E5%8F%B7%E7%BC%96%E7%A0%81)。

3. 生成CSV / Excel / PDF / 統計報表。

   - 向瀏覽器傳輸二進制數據。

     ```Python
     buffer = ByteIO()
     
     resp = HttpResponse(content_type='...')
     resp['Content-Disposition'] = 'attachment; filename="..."'
     resp.write(buffer.getvalue())
     ```

     ```Python
     def get_style(name, color=0, bold=False, italic=False):
         style = xlwt.XFStyle()
         font = xlwt.Font()
         font.name = name
         font.colour_index = color
         font.bold = bold
         font.italic = italic
         style.font = font
         return style
     
     
     def export_emp_excel(request):
         # 創建Excel工作簿(使用三方庫xlwt)
         workbook = xlwt.Workbook()
         # 向工作簿中添加工作表
         sheet = workbook.add_sheet('員工詳細信息')
         # 設置表頭
         titles = ['編號', '姓名', '主管', '職位', '工資', '部門名稱']
         for col, title in enumerate(titles):
             sheet.write(0, col, title, get_style('HanziPenSC-W3', 2, True))
         # 使用Django的ORM框架查詢員工數據
         emps = Emp.objects.all().select_related('dept').select_related('mgr')
         cols = ['no', 'name', 'mgr', 'job', 'sal', 'dept']
         # 通過嵌套的循環將員工表的數據寫入Excel工作表的單元格
         for row, emp in enumerate(emps):
             for col, prop in enumerate(cols):
                 val = getattr(emp, prop, '')
                 if isinstance(val, (Dept, Emp)):
                     val = val.name
                 sheet.write(row + 1, col, val)
         # 將Excel文件的二進制數據寫入內存
         buffer = BytesIO()
         workbook.save(buffer)
         # 通過HttpResponse對象向瀏覽器輸出Excel文件
         resp = HttpResponse(buffer.getvalue())
         resp['content-type'] = 'application/msexcel'
         # 如果文件名有中文需要處理成百分號編碼
         resp['content-disposition'] = 'attachment; filename="detail.xls"'
         return resp
     
     ```

   - 大文件的流式處理：`StreamingHttpResponse`。

     ```Python
     def download_file(request):
         file_stream = open('...', 'rb')
         # 如果文件的二進制數據較大則最好用迭代器進行處理避免過多的佔用服務器內存
         file_iter = iter(lambda: file_stream.read(4096), b'')
         resp = StreamingHttpResponse(file_iter)
         # 中文文件名要處理成百分號編碼
         filename = quote('...', 'utf-8')
         resp['Content-Type'] = '...'
         resp['Content-Disposition'] = f'attachment; filename="{filename}"'
         return resp
     ```

     > 說明：如果需要生成PDF文件，可以需要安裝`reportlab`。另外，使用StreamingHttpResponse只能減少內存的開銷，但是如果下載一個大文件會導致一個請求長時間佔用服務器資源，比較好的做法還是把報表提前生成好（可以考慮使用定時任務），放在靜態資源服務器或者是雲存儲服務器上以訪問靜態資源的方式訪問。

   - [ECharts](http://echarts.baidu.com/)或[Chart.js](https://www.chartjs.org/)。

     - 思路：後端只提供JSON格式的數據，前端JavaScript渲染生成圖表。

     ```Python
     def get_charts_data(request):
         """獲取統計圖表JSON數據"""
         names = []
         totals = []
         # 通過connections獲取指定數據庫連接並創建遊標對象
         with connections['backend'].cursor() as cursor:
             # 在使用ORM框架時可以使用對象管理器的aggregate()和annotate()方法實現分組和聚合函數查詢
             # 執行原生SQL查詢(如果ORM框架不能滿足業務或性能需求)
             cursor.execute('select dname, total from vw_dept_emp')
             for row in cursor.fetchall():
                 names.append(row[0])
                 totals.append(row[1])
         return JsonResponse({'names': names, 'totals': totals})
     ```

     ```HTML
     <!DOCTYPE html>
     <html lang="en">
     <head>
         <meta charset="UTF-8">
         <title>統計圖表</title>
         <style>
             #main {
                 width: 600px;
                 height: 400px;
             }
         </style>
     </head>
     <body>
         <div id="main"></div>
         <script src="https://cdn.bootcss.com/echarts/4.2.0-rc.2/echarts.min.js"></script>
         <script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
         <script>
             var myChart = echarts.init($('#main')[0]);
             $.ajax({
                 'url': 'charts_data',
                 'type': 'get',
                 'data': {},
                 'dataType': 'json',
                 'success': function(json) {
                     var option = {
                         title: {
                             text: '員工分佈統計圖'
                         },
                         tooltip: {},
                         legend: {
                             data:['人數']
                         },
                         xAxis: {
                             data: json.names
                         },
                         yAxis: {},
                         series: [{
                             name: '人數',
                             type: 'bar',
                             data: json.totals
                         }]
                     };
                     myChart.setOption(option);
                 },
                 'error': function() {}
             });
         </script>
     </body>
     </html>
     ```


### 中間件

問題1：中間件背後的設計理念是什麼？（分離橫切關注功能/攔截過濾器模式）

問題2：中間件有哪些不同的實現方式？（參考下面的代碼）

問題3：描述Django內置的中間件及其執行順序。（推薦閱讀：[Django官方文檔 - 中間件 - 中間件順序](https://docs.djangoproject.com/zh-hans/2.0/ref/middleware/#middleware-ordering)）

#### 激活中間件

```Python
MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
    'common.middlewares.block_sms_middleware',
]
```

#### 自定義中間件


```Python
def simple_middleware(get_response):
    
    def middleware(request, *args, **kwargs):
        
		response = get_response(request, *args, **kwargs)
        
		return response
    
    return middleware
```

```Python
class MyMiddleware(object):
        
    def __init__(self, get_response):
        self.get_response = get_response
        
    def __call__(self, request):
        
        response = self.get_response(request)
       
        return response
```

```Python
class MyMiddleware(object):
    
    def __init__(self):
        pass
    
    def process_request(request):
        pass
    
    def process_view(request, view_func, view_args, view_kwargs):
        pass
    
    def process_template_response(request, response):
        pass
    
    def process_response(request, response):
        pass
    
    def process_exception(request, exception):
        pass
```


#### 內置中間件

1. CommonMiddleware - 基礎設置中間件
   - DISALLOWED_USER_AGENTS - 不被允許的用戶代理（瀏覽器）
   - APPEND_SLASH - 是否追加`/`
   - USE_ETAG - 瀏覽器緩存相關

2. SecurityMiddleware - 安全相關中間件
   - SECURE_HSTS_SECONDS - 強制使用HTTPS的時間
   - SECURE_HSTS_INCLUDE_SUBDOMAINS - HTTPS是否覆蓋子域名
   - SECURE_CONTENT_TYPE_NOSNIFF - 是否允許瀏覽器推斷內容類型
   - SECURE_BROWSER_XSS_FILTER - 是否啟用跨站腳本攻擊過濾器
   - SECURE_SSL_REDIRECT - 是否重定向到HTTPS連接
   - SECURE_REDIRECT_EXEMPT - 免除重定向到HTTPS

3. SessionMiddleware - 會話中間件

4. CsrfViewMiddleware - 防範跨站身份偽造中間件

5. XFrameOptionsMiddleware - 防範點擊劫持攻擊中間件

   ![](./res/click-jacking.png)

![](./res/builtin-middlewares.png)

### 表單

1. 用法：通常不要用來生成頁面上的表單控件（耦合度太高不容易定製），主要用來驗證數據。
2. Form的屬性和方法：
   - `is_valid()` / `is_multipart()`
   - `errors` / `fields` / `is_bound` / `changed_data` / `cleaned_data`
   - `add_error()` / `has_errors()` / `non_field_errors()`
   - `clean()`
3. Form.errors的方法：
   - `as_data()` / `as_json()` / `get_json_data()`

問題1：Django中的`Form`和`ModelForm`有什麼作用？（通常不用來生成表單主要用來驗證數據）

問題2：表單上傳文件時應該注意哪些問題？（表單的設置、多文件上傳、圖片預覽（FileReader）、Ajax上傳文件、上傳後的文件如何存儲、調用雲存儲（如[阿里雲OSS](https://www.aliyun.com/product/oss)、[七牛雲](https://www.qiniu.com/)、[LeanCloud](https://leancloud.cn/storage/)等））

```HTML
<form action="" method="post" enctype="multipart/form-data">
    <input type="file" name="..." multiple>
    <input type="file" name="foo">
    <input type="file" name="foo">
    <input type="file" name="foo">
</form>
```

> 說明：上傳圖片文件的預覽效果可以通過HTML5的FileReader來實現。

> 說明：使用雲存儲通常是比自己配置分佈式文件系統這種方式更靠譜的做法，而且雲存儲通常成本並不太高，不僅如此大多數雲存儲還提供瞭如圖片剪裁、生成水印、視頻轉碼、CDN等服務。如果要自己做上傳的視頻文件轉碼，需要安裝三方庫ffmpeg，在程序中調用該三方庫可以實現轉碼。

### Cookie和Session

問題1：使用Cookie能解決什麼問題？（用戶跟蹤，解決HTTP協議無狀態問題）

1. URL重寫

   ```
   http://www.abc.com/path/resource?foo=bar
   ```

2. 隱藏域（隱式表單域）- 埋點

   ```HTML
   <form action="" method="post">
   
       <input type="hidden" name="foo" value="bar">
       
   </form>
   ```

3. Cookie - 瀏覽器中的臨時文件（文本文件）- BASE64

問題2：Cookie和Session之間關係是什麼？（Session的標識通過Cookie保存和傳輸）

#### Session的配置

1. Session對應的中間件：`django.contrib.sessions.middleware.SessionMiddleware`。

2. Session引擎。

   - 基於數據庫（默認方式）

     ```Python
     INSTALLED_APPS = [
         'django.contrib.sessions',
     ]
     ```

   - 基於緩存（推薦使用）

     ```Python
     SESSION_ENGINE = 'django.contrib.sessions.backends.cache'
     SESSION_CACHE_ALIAS = 'session'
     ```

   - 基於文件（基本不考慮）

   - 基於Cookie（不靠譜）

     ```Python
     SESSION_ENGINE = 'django.contrib.sessions.backends.signed_cookies'
     ```

3. Cookie相關的配置。

   ```Python
   SESSION_COOKIE_NAME = 'djang_session_id'
   SESSION_COOKIE_AGE = 1209600
   # 如果設置為True，Cookie就是基於瀏覽器窗口的Cookie，不會持久化
   SESSION_EXPIRE_AT_BROWSER_CLOSE = False 
   SESSION_SAVE_EVERY_REQUEST = False
   SESSION_COOKIE_HTTPONLY = True
   ```

4. session的屬性和方法。

   - `session_key` / `session_data` / `expire_date`
   - `__getitem__` / `__setitem__` / `__delitem__` / `__contains__`
   - `set_expiry()` / `get_expiry_age()` / `get_expiry_date()` - 設置/獲取會話超期時間
   - `flush()` - 銷燬會話
   - `set_test_cookie()` / `test_cookie_worked()` / `delete_test_cookie()` - 測試瀏覽器是否支持Cookie（提示用戶如果瀏覽器禁用Cookie可能會影響網站的使用）

5. session的序列化。

   ```Python
   SESSION_SERIALIZER = 'django.contrib.sessions.serializers.JSONSerializer'
   ```

   - JSONSerializer（1.6及以後默認）- 如果想將自定義的對象放到session中，會遇到“Object of type 'XXX' is not JSON serializable”的問題（如果配置使用Redis保存Session，django-redis使用了Pickle序列化，這個問題就不存在了）。
   - PickleSerializer（1.6以前的默認）- 因為安全問題不推薦使用，但是隻要不去反序列化用戶構造的惡意的Payload其實也沒有什麼風險。關於這種方式的安全漏洞，可以參考《[Python Pickle的任意代碼執行漏洞實踐和Payload構造》](http://www.polaris-lab.com/index.php/archives/178/)一文或《軟件架構-Python語言實現》上關於這個問題的講解。

     > 說明：如果使用了django_redis整合Redis作為session的存儲引擎，那麼由於django_redis又封裝了一個PickleSerializer來提供序列化，所以不會存在上述的問題，且Redis中保存的value是pickle序列化之後的結果。


### 緩存

#### 配置緩存


```Python
CACHES = {
    # 默認緩存
    'default': {
        'BACKEND': 'django_redis.cache.RedisCache',
        'LOCATION': [
            'redis://1.2.3.4:6379/0',
        ],
        'KEY_PREFIX': 'teamproject',
        'OPTIONS': {
            'CLIENT_CLASS': 'django_redis.client.DefaultClient',
            'CONNECTION_POOL_KWARGS': {
                'max_connections': 1000,
            },
            'PASSWORD': '1qaz2wsx',
        }
    },
    # 頁面緩存
    'page': {
        'BACKEND': 'django_redis.cache.RedisCache',
        'LOCATION': [
            'redis://1.2.3.4:6379/1',
        ],
        'KEY_PREFIX': 'teamproject:page',
        'OPTIONS': {
            'CLIENT_CLASS': 'django_redis.client.DefaultClient',
            'CONNECTION_POOL_KWARGS': {
                'max_connections': 500,
            },
            'PASSWORD': '1qaz2wsx',
        }
    },
    # 會話緩存
    'session': {
        'BACKEND': 'django_redis.cache.RedisCache',
        'LOCATION': [
            'redis://1.2.3.4:6379/2',
        ],
        'KEY_PREFIX': 'teamproject:session',
        'TIMEOUT': 1209600,
        'OPTIONS': {
            'CLIENT_CLASS': 'django_redis.client.DefaultClient',
            'CONNECTION_POOL_KWARGS': {
                'max_connections': 2000,
            },
            'PASSWORD': '1qaz2wsx',
        }
    },
    # 接口數據緩存
    'api': {
        'BACKEND': 'django_redis.cache.RedisCache',
        'LOCATION': [
            'redis://1.2.3.4:6379/3',
        ],
        'KEY_PREFIX': 'teamproject:api',
        'OPTIONS': {
            'CLIENT_CLASS': 'django_redis.client.DefaultClient',
            'CONNECTION_POOL_KWARGS': {
                'max_connections': 500,
            },
            'PASSWORD': '1qaz2wsx',
        }
    },
}
```
> 說明：通過Redis底層提供的多個數據庫來隔離緩存數據有助於緩存數據的管理。如果配置了Redis的主從複製（讀寫分離），LOCATION列表中可以配置多個Redis連接，第一個被視為master用來進行寫操作，後面的被視為slave用來進行讀操作。

#### 全站緩存

```Python
MIDDLEWARE_CLASSES = [
    'django.middleware.cache.UpdateCacheMiddleware',
    ...
    'django.middleware.common.CommonMiddleware',
    ...
    'django.middleware.cache.FetchFromCacheMiddleware',
]

CACHE_MIDDLEWARE_ALIAS = 'default'
CACHE_MIDDLEWARE_SECONDS = 300
CACHE_MIDDLEWARE_KEY_PREFIX = 'djang:cache'
```
#### 視圖層緩存

```Python
from django.views.decorators.cache import cache_page
from django.views.decorators.vary import vary_on_cookie


@cache_page(timeout=60 * 15, cache='page')
@vary_on_cookie
def my_view(request):
    pass
```

```Python
from django.views.decorators.cache import cache_page

urlpatterns = [
    url(r'^foo/([0-9]{1,2})/$', cache_page(60 * 15)(my_view)),
]
```
#### 其他內容

1. 模板片段緩存。

   - `{% load cache %}`
   - `{% cache %}` / `{% endcache %}`

2. 使用底層API訪問緩存。

   ```Python
   >>> from django.core.cache import cache
   >>>
   >>> cache.set('my_key', 'hello, world!', 30)
   >>> cache.get('my_key')
   >>> cache.clear()
   ```

   ```Python
   >>> from django.core.cache import caches
   >>> cache1 = caches['page']
   >>> cache2 = caches['page']
   >>> cache1 is cache2
   True
   >>> cache3 = caches['session']
   >>> cache2 is cache3
   False
   ```

   ```Python
   >>> from django_redis import get_redis_connection
   >>>
   >>> redis_client = get_redis_connection()
   >>> redis_client.hgetall()
   ```


### 日誌

#### 日誌級別

NOTSET < DEBUG < INFO < WARNING < ERROR < FATAL

#### 日誌配置

```Python
LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    # 配置日誌格式化器
    'formatters': {
        'simple': {
            'format': '%(asctime)s %(module)s.%(funcName)s: %(message)s',
            'datefmt': '%Y-%m-%d %H:%M:%S',
        },
        'verbose': {
            'format': '%(asctime)s %(levelname)s [%(process)d-%(threadName)s] '
                      '%(module)s.%(funcName)s line %(lineno)d: %(message)s',
            'datefmt': '%Y-%m-%d %H:%M:%S',
        }
    },
    # 配置日誌過濾器
    'filters': {
        'require_debug_true': {
            '()': 'django.utils.log.RequireDebugTrue',
        },
    },
    # 配置日誌處理器
    'handlers': {
        'console': {
            'class': 'logging.StreamHandler',
            'level': 'DEBUG',
            'filters': ['require_debug_true'],
            'formatter': 'simple',
        },
        'file1': {
            'class': 'logging.handlers.TimedRotatingFileHandler',
            'filename': 'access.log',
            'when': 'W0',
            'backupCount': 12,
            'formatter': 'simple',
            'level': 'INFO',
        },
        'file2': {
            'class': 'logging.handlers.TimedRotatingFileHandler',
            'filename': 'error.log',
            'when': 'D',
            'backupCount': 31,
            'formatter': 'verbose',
            'level': 'WARNING',
        },
    },
    # 配置日誌器
    'loggers': {
        'django': {
            'handlers': ['console', 'file1', 'file2'],
            'propagate': True,
            'level': 'DEBUG',
        },
    }
}
```

[日誌配置官方示例](https://docs.djangoproject.com/zh-hans/2.0/topics/logging/#s-examples)。

#### 日誌分析

1. Linux相關命令：head、tail、grep、awk、uniq、sort

   ```Shell
   tail -10000 access.log | awk '{print $1}' | uniq -c | sort -r
   ```

2. 實時日誌文件分析：Python + 正則表達式 + Crontab

3. [《Python日誌分析工具》](https://github.com/jkklee/web_log_analyse)。

4. [《集中式日誌系統ELK》](https://www.ibm.com/developerworks/cn/opensource/os-cn-elk/index.html)。

   - ElasticSearch：搜索引擎，實現全文檢索。
   - Logstash：負責從指定節點收集日誌。
   - Kibana：日誌可視化工具。

5. 大數據日誌處理：Flume+Kafka日誌採集、Storm / Spark實時數據處理、Impala實時查詢。

### RESTful

問題1：RESTful架構到底解決了什麼問題？（URL具有自描述性、資源表述與視圖的解耦和、互操作性利用構建微服務以及集成第三方系統、無狀態性提高水平擴展能力）

問題2：項目在使用RESTful架構時有沒有遇到一些問題或隱患？（對資源訪問的限制、資源從屬關係檢查、避免洩露業務信息、防範可能的攻擊）

> 補充：下面的幾個和安全性相關的響應頭在前面講中間件的時候提到過的。
>
> - X-Frame-Options: DENY
> - X-Content-Type-Options: nosniff
> - X-XSS-Protection: 1; mode=block;
> - Strict­-Transport-­Security: max-age=31536000;

問題3：如何保護API中的敏感信息以及防範重放攻擊？（摘要和令牌）

推薦閱讀：[《如何有效防止API的重放攻擊》](https://help.aliyun.com/knowledge_detail/50041.html)。

#### 使用djangorestframework

安裝djangorestfrmework（為了描述方便，以下統一簡稱為drf）。

```Shell
pip install djangorestframework
```

配置drf。

```Python
INSTALLED_APPS = [
    
    'rest_framework',
    
]

REST_FRAMEWORK = {
    # 配置默認頁面大小
    'PAGE_SIZE': 10,
    # 配置默認的分頁類
    'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.PageNumberPagination',
    # 配置異常處理器
    # 'EXCEPTION_HANDLER': 'api.exceptions.exception_handler',
    # 配置默認解析器
    # 'DEFAULT_PARSER_CLASSES': (
    #     'rest_framework.parsers.JSONParser',
    #     'rest_framework.parsers.FormParser',
    #     'rest_framework.parsers.MultiPartParser',
    # ),
    # 配置默認限流類
    # 'DEFAULT_THROTTLE_CLASSES': (),
    # 配置默認授權類
    # 'DEFAULT_PERMISSION_CLASSES': (
    #     'rest_framework.permissions.IsAuthenticated',
    # ),
    # 配置默認認證類
    # 'DEFAULT_AUTHENTICATION_CLASSES': (
    #     'rest_framework_jwt.authentication.JSONWebTokenAuthentication',
    # ),
}
```

#### 編寫序列化器

```Python
from rest_framework import serializers
from rest_framework.serializers import ModelSerializer

from common.models import District, HouseType, Estate, Agent


class DistrictSerializer(ModelSerializer):

    class Meta:
        model = District
        fields = ('distid', 'name')


class HouseTypeSerializer(ModelSerializer):

    class Meta:
        model = HouseType
        fields = '__all__'


class AgentSerializer(ModelSerializer):

    class Meta:
        model = Agent
        fields = ('agentid', 'name', 'tel', 'servstar', 'certificated')


class EstateSerializer(ModelSerializer):
    district = serializers.SerializerMethodField()
    agents = serializers.SerializerMethodField()

    @staticmethod
    def get_agents(estate):
        return AgentSerializer(estate.agents, many=True).data

    @staticmethod
    def get_district(estate):
        return DistrictSerializer(estate.district).data

    class Meta:
        model = Estate
        fields = '__all__'
```

#### 方法1：使用裝飾器

```Python
@api_view(['GET'])
@cache_page(timeout=None, cache='api')
def provinces(request):
    queryset = District.objects.filter(parent__isnull=True)
    serializer = DistrictSerializer(queryset, many=True)
    return Response(serializer.data)


@api_view(['GET'])
@cache_page(timeout=300, cache='api')
def cities(request, provid):
    queryset = District.objects.filter(parent__distid=provid)
    serializer = DistrictSerializer(queryset, many=True)
    return Response(serializer.data)
```

```Python
urlpatterns = [
    path('districts/', views.provinces, name='districts'),
    path('districts/<int:provid>/', views.cities, name='cities'),
]
```

> 說明：上面使用了Django自帶的視圖裝飾器（@cache_page）來實現對API接口返回數據的緩存。

#### 方法2：使用APIView及其子類

更好的複用代碼，不要重“復發明輪子”。

```Python
class HouseTypeApiView(CacheResponseMixin, ListAPIView):
    queryset = HouseType.objects.all()
    serializer_class = HouseTypeSerializer
```

```Python
urlpatterns = [
    path('housetypes/', views.HouseTypeApiView.as_view(), name='housetypes'),
]
```

> 說明：上面使用了drf_extensions提供的CacheResponseMixin混入類實現了對接口數據的緩存。如果重寫了獲取數據的方法，可以使用drf_extensions提供的@cache_response來實現對接口數據的緩存，也可以用自定義的函數來生成緩存中的key。當然還有一個選擇就是通過Django提供的@method_decorator裝飾器，將@cache_page裝飾器處理為裝飾方法的裝飾器，這樣也能提供使用緩存服務。

`drf-extensions`配置如下所示。

```Python
# 配置DRF擴展來支持緩存API接口調用結果
REST_FRAMEWORK_EXTENSIONS = {
    'DEFAULT_CACHE_RESPONSE_TIMEOUT': 300,
    'DEFAULT_USE_CACHE': 'default',
    # 配置默認緩存單個對象的key函數
    'DEFAULT_OBJECT_CACHE_KEY_FUNC': 'rest_framework_extensions.utils.default_object_cache_key_func',
    # 配置默認緩存對象列表的key函數
    'DEFAULT_LIST_CACHE_KEY_FUNC': 'rest_framework_extensions.utils.default_list_cache_key_func',
}
```

#### 方法3：使用ViewSet及其子類

```Python
class HouseTypeViewSet(CacheResponseMixin, viewsets.ModelViewSet):
    queryset = HouseType.objects.all()
    serializer_class = HouseTypeSerializer
    pagination_class = None
```

```Python
router = DefaultRouter()
router.register('housetypes', views.HouseTypeViewSet)

urlpatterns += router.urls
```

djangorestframework提供了基於Bootstrap定製的頁面來顯示接口返回的JSON數據，當然也可以使用[POSTMAN](https://www.getpostman.com/)這樣的工具對API接口進行測試。

#### 補充說明

在這裡順便提一下跟前端相關的幾個問題。

問題1：如何讓瀏覽器能夠發起DELETE/PUT/PATCH？

```HTML
<form method="post">
    
    <input type="hidden" name="_method" value="delete">
    
</form>
```

```Python
if request.method == 'POST' and '_method' in request.POST:
    request.method = request.POST['_method'].upper()
```

```HTML
<script>
    $.ajax({
        'url': '/api/provinces',
        'type': 'put',
        'data': {},
        'dataType': 'json',
        'success': function(json) {
            // Web = 標籤(內容) + CSS(顯示) + JS(行為)
            // JavaScript = ES + BOM + DOM
            // DOM操作實現頁面的局部刷新
        },
        'error': function() {}
    });
    $.getJSON('/api/provinces', function(json) {
        // DOM操作實現頁面的局部刷新
    });
</script>
```

問題2：如何解決多個JavaScript庫之間某個定義（如$函數）衝突的問題？

```HTML
<script src="js/jquery.min.js"></script>
<script src="js/abc.min.js"></script>
<script>
    // $已經被後加載的JavaScript庫佔用了
    // 但是可以直接用綁定在window對象上的jQuery去代替$
    jQuery(function() {
        jQuery('#okBtn').on('click', function() {});
    });
</script>
```

```HTML
<script src="js/abc.min.js"></script>
<script src="js/jquery.min.js"></script>
<script>
    // 將$讓出給其他的JavaScript庫使用
	jQuery.noConflict();
	jQuery(function() {
        jQuery('#okBtn').on('click', function() {});
    });
</script>
```

問題3：jQuery對象與原生DOM對象之間如何轉換？

```HTML
<button id="okBtn">點我</button>
<script src="js/jquery.min.js"></script>
<script>
    var btn = document.getElementById('okBtn');	// 原生JavaScript對象(使用相對麻煩)
    var $btn = $('#okBtn');	// jQuery對象(擁有更多的屬性和方法而且沒有瀏覽器兼容性問題)
    $btn.on('click', function() {});
    // $(btn)可以將原生JavaScript對象轉成jQuery對象
    // $btn.get(0)或$btn[0]可以獲得原生的JavaScript對象
</script>
```

#### 過濾數據

如果需要過濾數據（對數據接口設置篩選條件、排序條件等），可以使用`django-filter`三方庫來實現。

```Shell
pip install django-filter
```

```Python
INSTALLED_APPS = [
    
    'django_filters',

]
REST_FRAMEWORK = {
  	
    'DEFAULT_FILTER_BACKENDS': (
        'django_filters.rest_framework.DjangoFilterBackend',
        'rest_framework.filters.OrderingFilter',
    ),
    
}
```

```Python
from django.utils.decorators import method_decorator
from django.views.decorators.cache import cache_page
from django_filters.rest_framework import DjangoFilterBackend
from rest_framework.filters import OrderingFilter
from rest_framework.generics import RetrieveAPIView, ListCreateAPIView

from api.serializers import EstateSerializer
from common.models import Estate


@method_decorator(decorator=cache_page(timeout=120, cache='api', key_prefix='estates'), name='get')
class EstateView(RetrieveAPIView, ListCreateAPIView):
    queryset = Estate.objects.all().select_related('district').prefetch_related('agents')
    serializer_class = EstateSerializer
    filter_backends = (DjangoFilterBackend, OrderingFilter)
    filter_fields = ('name', 'district')
    ordering = ('-hot', )
    ordering_fields = ('hot', 'estateid')
```

```Python
from django_filters import rest_framework as drf
from common.models import HouseInfo


class HouseInfoFilter(drf.FilterSet):
    """自定義房源數據過濾器"""

    title = drf.CharFilter(lookup_expr='starts')
    dist = drf.NumberFilter(field_name='district')
    min_price = drf.NumberFilter(field_name='price', lookup_expr='gte')
    max_price = drf.NumberFilter(field_name='price', lookup_expr='lte')
    type = drf.NumberFilter()

    class Meta:
        model = HouseInfo
        fields = ('title', 'district', 'min_price', 'max_price', 'type')
```

```Python
class HouseInfoViewSet(CacheResponseMixin, ReadOnlyModelViewSet):
    queryset = HouseInfo.objects.all() \
        .select_related('type', 'district', 'estate', 'agent') \
        .prefetch_related('tags').order_by('-pubdate')
    serializer_class = HouseInfoSerializer
    filter_backends = (DjangoFilterBackend, OrderingFilter)
    filterset_class = HouseInfoFilter
    ordering = ('price',)
    ordering_fields = ('price', 'area')
```

#### 身份認證

查看drf中APIView類的代碼可以看出，drf默認的認證方案是 `DEFAULT_AUTHENTICATION_CLASSES`，如果修改authentication_classes就可以自行定製身份認證的方案。

```Python
class APIView(View):

    # The following policies may be set at either globally, or per-view.
    renderer_classes = api_settings.DEFAULT_RENDERER_CLASSES
    parser_classes = api_settings.DEFAULT_PARSER_CLASSES
    authentication_classes = api_settings.DEFAULT_AUTHENTICATION_CLASSES
    throttle_classes = api_settings.DEFAULT_THROTTLE_CLASSES
    permission_classes = api_settings.DEFAULT_PERMISSION_CLASSES
    content_negotiation_class = api_settings.DEFAULT_CONTENT_NEGOTIATION_CLASS
    metadata_class = api_settings.DEFAULT_METADATA_CLASS
    versioning_class = api_settings.DEFAULT_VERSIONING_CLASS

   	# 此處省略下面的代碼
```

```Python
DEFAULTS = {
    # Base API policies
    'DEFAULT_RENDERER_CLASSES': (
        'rest_framework.renderers.JSONRenderer',
        'rest_framework.renderers.BrowsableAPIRenderer',
    ),
    'DEFAULT_PARSER_CLASSES': (
        'rest_framework.parsers.JSONParser',
        'rest_framework.parsers.FormParser',
        'rest_framework.parsers.MultiPartParser'
    ),
    'DEFAULT_AUTHENTICATION_CLASSES': (
        'rest_framework.authentication.SessionAuthentication',
        'rest_framework.authentication.BasicAuthentication'
    ),
    'DEFAULT_PERMISSION_CLASSES': (
        'rest_framework.permissions.AllowAny',
    ),
    'DEFAULT_THROTTLE_CLASSES': (),
    'DEFAULT_CONTENT_NEGOTIATION_CLASS': 'rest_framework.negotiation.DefaultContentNegotiation',
    'DEFAULT_METADATA_CLASS': 'rest_framework.metadata.SimpleMetadata',
    'DEFAULT_VERSIONING_CLASS': None,

    # 此處省略下面的代碼
}
```

自定義認證類，繼承`BaseAuthentication`並重寫`authenticate(self, request)`方法，通過請求中的userid和token來確定用戶身份。如果認證成功，該方法應返回一個二元組（用戶和令牌的信息），否則產生異常。也可以重寫 `authenticate_header(self, request)`方法來返回一個字符串，該字符串將用於`HTTP 401 Unauthorized`響應中的WWW-Authenticate響應頭的值。如果未重寫該方法，那麼當未經身份驗證的請求被拒絕訪問時，身份驗證方案將返回`HTTP 403 Forbidden`響應。

```Python
class MyAuthentication(BaseAuthentication):
    """自定義用戶身份認證類"""

    def authenticate(self, request):
        try:
            token = request.GET['token'] or request.POST['token']
            user_token = UserToken.objects.filter(token=token).first()
            if user_token:
                return user_token.user, user_token
            else:
                raise AuthenticationFailed('請提供有效的用戶身份標識')
        except KeyError:
            raise AuthenticationFailed('請提供有效的用戶身份標識')

    def authenticate_header(self, request):
        pass
```

使用自定義的認證類。

```Python
class EstateViewSet(CacheResponseMixin, ModelViewSet):
    # 通過queryset指定如何獲取數據（資源）
    queryset = Estate.objects.all().select_related('district').prefetch_related('agents')
    # 通過serializer_class指定如何序列化數據
    serializer_class = EstateSerializer
    # 指定根據哪些字段進行數據篩選
    filter_fields = ('district', 'name')
    # 指定根據哪些字段對數據進行排序
    ordering_fields = ('hot', )
    # 指定用於進行用戶身份驗證的類
    authentication_classes = (MyAuthentication, )
```

> 說明：也可以在Django配置文件中將自定義的認證類設置為默認認證方式。

#### 授予權限

權限檢查總是在視圖的最開始處運行，在任何其他代碼被允許進行之前。最簡單的權限是允許通過身份驗證的用戶訪問，並拒絕未經身份驗證的用戶訪問，這對應於dfr中的`IsAuthenticated`類，可以用它來取代默認的`AllowAny`類。權限策略可以在Django的drf配置中用`DEFAULT_PERMISSION_CLASSES`全局設置。

```Python
REST_FRAMEWORK = {
    'DEFAULT_PERMISSION_CLASSES': (
        'rest_framework.permissions.IsAuthenticated',
    )
}
```

也可以在基於`APIView`類的視圖上設置身份驗證策略。

```Python
from rest_framework.permissions import IsAuthenticated
from rest_framework.views import APIView

class ExampleView(APIView):
    permission_classes = (IsAuthenticated, )
    # 此處省略其他代碼
```

或者在基於`@api_view`裝飾器的視圖函數上設置。

```Python
from rest_framework.decorators import api_view, permission_classes
from rest_framework.permissions import IsAuthenticated

@api_view(['GET'])
@permission_classes((IsAuthenticated, ))
def example_view(request, format=None):
    # 此處省略其他代碼
```

自定義權限需要繼承`BasePermission`並實現以下方法中的一個或兩個，下面是BasePermission的代碼。

```Python
@six.add_metaclass(BasePermissionMetaclass)
class BasePermission(object):
    """
    A base class from which all permission classes should inherit.
    """

    def has_permission(self, request, view):
        """
        Return `True` if permission is granted, `False` otherwise.
        """
        return True

    def has_object_permission(self, request, view, obj):
        """
        Return `True` if permission is granted, `False` otherwise.
        """
        return True
```

如果請求被授予訪問權限，則方法應該返回True，否則返False。下面的例子演示了阻止黑名單中的IP地址訪問接口數據（這個在反爬蟲的時候很有用喲）。

```Python
from rest_framework import permissions


class BlacklistPermission(permissions.BasePermission):
    """
    Global permission check for blacklisted IPs.
    """

    def has_permission(self, request, view):
        ip_addr = request.META['REMOTE_ADDR']
        blacklisted = Blacklist.objects.filter(ip_addr=ip_addr).exists()
        return not blacklisted
```

如果要實現更為完整的權限驗證，可以考慮RBAC或ACL。

1. RBAC - 基於角色的訪問控制，如下圖所示。

   ![](./res/rbac-basic.png)

   ![](./res/rbac-full.png)

2. ACL - 訪問控制列表（每個用戶綁定自己的訪問白名單）。

#### 訪問限流

可以修改dfr配置的`DEFAULT_THROTTLE_CLASSES` 和 `DEFAULT_THROTTLE_RATES`兩個值來設置全局默認限流策略。例如：

```Python
REST_FRAMEWORK = {
    'DEFAULT_THROTTLE_CLASSES': (
        'rest_framework.throttling.AnonRateThrottle',
        'rest_framework.throttling.UserRateThrottle'
    ),
    'DEFAULT_THROTTLE_RATES': {
        'anon': '3/min',
        'user': '10000/day'
    }
}
```

`DEFAULT_THROTTLE_RATES`中使用的頻率描述可能包括`second`、`minute`、`hour`或`day`。

如果要為接口單獨設置限流，可以在每個視圖或視圖集上設置限流策略，如下所示：

```Python
from rest_framework.throttling import UserRateThrottle
from rest_framework.views import APIView


class ExampleView(APIView):
    throttle_classes = (UserRateThrottle, )
    # 此處省略下面的代碼
```

或

```Python
@api_view(['GET'])
@throttle_classes([UserRateThrottle, ])
def example_view(request, format=None):
    # 此處省略下面的代碼
```

當然也可以通過繼承`BaseThrottle`來自定義限流策略，通常需要重寫`allow_request`和`wait`方法。

### 異步任務和計劃任務

#### Celery的應用

Celery 是一個簡單、靈活且可靠的，處理大量消息的分佈式系統，並且提供維護這樣一個系統的必需工具。它是一個專注於實時處理的任務隊列，同時也支持任務調度。

推薦閱讀：[《Celery官方文檔中文版》](http://docs.jinkan.org/docs/celery/)，上面有極為詳細的配置和使用指南。

![](./res/celery_architecture.png)

Celery是一個本身不提供隊列服務，官方推薦使用RabbitMQ或Redis來實現消息隊列服務，前者是更好的選擇，它對AMQP（高級消息隊列協議）做出了非常好的實現。

1. 安裝RabbitMQ。

   ```Shell
   docker pull rabbitmq
   docker run -d -p 5672:5672 --name myrabbit rabbitmq
   docker container exec -it myrabbit /bin/bash
   ```

2. 創建用戶、資源以及分配操作權限。

   ```Shell
   rabbitmqctl add_user luohao 123456
   rabbitmqctl set_user_tags luohao administrator
   rabbitmqctl add_vhost vhost1
   rabbitmqctl set_permissions -p vhost1 luohao ".*" ".*" ".*"
   ```

3. 創建Celery實例。

   ```Python
   # 註冊環境變量
   os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'fangtx.settings')
   
   # 創建Celery實例
   app = celery.Celery(
       'fangtx',
       broker='amqp://luohao:123456@120.77.222.217:5672/vhost1'
   )
   
   # 從項目的配置文件讀取Celery配置信息
   app.config_from_object('django.conf:settings')
   # 從指定的文件(例如celery_config.py)中讀取Celery配置信息
   # app.config_from_object('celery_config')
   
   # 讓Celery自動從參數指定的應用中發現異步任務/定時任務
   app.autodiscover_tasks(['common', ])
   # 讓Celery自動從所有註冊的應用中發現異步任務/定時任務
   # app.autodiscover_tasks(lambda: settings.INSTALLED_APPS)
   ```

4. 啟動Celery創建woker（消息的消費者）。

   ```Shell
   celery -A <name> worker -l debug &
   ```

5. 執行異步任務。

   ```Python
   @app.task
   def send_email(from, to, cc, subject, content):
       pass
   
   
   send_email.delay('', [], [], '', '')
   ```

6. 創建定時任務。

   ```Python
   # 配置定時任務（計劃任務）
   app.conf.update(
       timezone=settings.TIME_ZONE,
       enable_utc=True,
       # 定時任務（計劃任務）相當於是消息的生產者
       # 如果只有生產者沒有消費者那麼消息就會在消息隊列中積壓
       # 將來實際部署項目的時候生產者、消費者、消息隊列可能都是不同節點
       beat_schedule={
           'task1': {
               'task': 'common.tasks.show_msg',
               'schedule': crontab(),
               'args': ('劉強東，奶茶妹妹喊你回家喝奶啦', )
           },
       },
   )
   ```

   ```Python
   @app.task
   def show_msg(content):
       print(content)
   ```

7. 啟動Celery創建執行定時任務的beat（消息的生產者）。

   ```Shell
   celery -A <name> beat -l info
   ```

8. 檢查消息隊列狀況。

   ```Shell
   rabbitmqctl list_queues -p vhost1
   ```

9. 監控Celery - 可以通過flower來對Celery進行監控。

   ```Shell
   pip install flower
   celery flower --broker=amqp://luohao:123456@120.77.222.217:5672/vhost1
   ```

### 其他問題

問題1：如何解決JavaScript跨域獲取數據的問題？（django-cors-headers）

```Python
INSTALLED_APPS = [
    'corsheaders',
]

MIDDLEWARE = [
    'corsheaders.middleware.CorsMiddleware',
]

CORS_ORIGIN_ALLOW_ALL = True
# 配置跨域白名單
# CORS_ORIGIN_WHITELIST = ('www.abc.com', 'www.baidu.com')
# CORS_ORIGIN_REGEX_WHITELIST = ('...', )
# CORS_ALLOW_CREDENTIALS = True
# CORS_ALLOW_METHODS = ('GET', 'POST', 'PUT', 'DELETE')
```

問題2：網站圖片（水印、剪裁）和視頻（截圖、水印、轉碼）是如何處理的？（雲存儲、FFmpeg）

問題3：網站如何架設（靜態資源）文件系統？（FastDFS、雲存儲、CDN）

### 安全保護

問題1：什麼是跨站腳本攻擊，如何防範？（對提交的內容進行消毒）

問題2：什麼是跨站身份偽造，如何防範？（使用隨機令牌）

問題3：什麼是SQL注射攻擊，如何防範？（不拼接SQL語句，避免使用單引號）

問題4：什麼是點擊劫持攻擊，如何防範？（不允許`<iframe>`加載非同源站點內容）

#### Django提供的安全措施

簽名數據的API

   ```Python
>>> from django.core.signing import Signer
>>> signer = Signer()
>>> value = signer.sign('hello, world!')
>>> value
'hello, world!:BYMlgvWMTSPLxC-DqxByleiMVXU'
>>> signer.unsign(value)
'hello, world!'
>>>
>>> signer = Signer(salt='1qaz2wsx')
>>> signer.sign('hello, world!')
'hello, world!:9vEvG6EA05hjMDB5MtUr33nRA_M'
>>>
>>> from django.core.signing import TimestampSigner
>>> signer = TimestampSigner()
>>> value = signer.sign('hello, world!')
>>> value
'hello, world!:1fpmcQ:STwj464IFE6eUB-_-hyUVF3d2So'
>>> signer.unsign(value, max_age=5)
Traceback (most recent call last):
    File "<console>", line 1, in <module>
    File "/Users/Hao/Desktop/fang.com/venv/lib/python3.6/site-packages/django/core/signing.py", line 198, in unsign
    'Signature age %s > %s seconds' % (age, max_age))
    django.core.signing.SignatureExpired: Signature age 21.020604848861694 > 5 seconds
>>> signer.unsign(value, max_age=120)
'hello, world!'
   ```

CSRF令牌和小工具

```HTML
{% csrf_token %}
```

- @csrf_exempt：免除令牌 
- @csrf_protect：提供令牌保護
- @require_csrf_token：提供令牌保護
- @ensure_csrf_cookie：強制視圖發送帶令牌的cookie

> 說明：可以在Chrome瀏覽器中安裝EditThisCookie插件來方便的查看Cookie。


#### 用戶敏感信息的保護

1. 哈希摘要（簽名）

   ```Python
   >>> import hashlib
   >>> 
   >>> md5_hasher = hashlib.md5()
   >>> md5_hasher.update('hello, world!'.encode())
   >>> md5_hasher.hexdigest()
   '3adbbad1791fbae3ec908894c4963870'
   >>>
   >>> sha1_hasher = hashlib.sha1()
   >>> sha1_hasher.update('hello, world!'.encode())
   >>> sha1_hasher.update('goodbye, world!'.encode())
   >>> sha1_hasher.hexdigest()
   '1f09d30c707d53f3d16c530dd73d70a6ce7596a9'
   ```

2. 加密和解密（對稱加密和非對稱加密）

   ```Shell
   pip install rsa
   ```

   ```Python
   >>> pub_key, pri_key = rsa.newkeys(1024)
   >>> message = 'hello, world!'
   >>> crypto = rsa.encrypt(message.encode(), pub_key)
   >>> crypto
   b'Ou{gH\xa9\xa8}O\xe3\x1d\x052|M\x9d9?\xdc\xd8\xecF\xd3v\x9b\xde\x8e\x12\xe6M\xebvx\x08\x08\x8b\xe8\x86~\xe4^)w\xf2\xef\x9e\x9fOg\x15Q\xb7\x7f\x1d\xcfV\xf1\r\xbe^+\x8a\xbf }\x10\x01\xa4U9b\x97\xf5\xe0\x90T\'\xd4(\x9b\x00\xa5\x92\x17\xad4\xb0\xb0"\xd4\x16\x94*s\xe1r\xb7L\xe2\x98\xb7\x7f\x03\xd9\xf2\t\xee*\xe6\x93\xe6\xe1o\xfd\x18\x83L\x0cfL\xff\xe4\xdd%\xf2\xc0/\xfb'
   >>> origin = rsa.decrypt(crypto, pri_key).decode()
   >>> origin
   'hello, world!'
   ```

   ```Shell
   pip install pycrypto
   ```

   AES對稱加密：

   ```Python
   >>> from hashlib import md5
   >>>
   >>> from Crypto.Cipher import AES
   >>> from Crypto import Random
   >>>
   >>> key = md5(b'mysecret').hexdigest()
   >>> iv = Random.new().read(AES.block_size)
   >>> str1 = '我愛你們！'
   >>> str2 = AES.new(key, AES.MODE_CFB, iv).encrypt(str1)
   b'p\x96o\x85\x0bq\xc4-Y\xc4\xbcp\n)&'
   >>> str3 = AES.new(key, AES.MODE_CFB, iv).decrypt(str2).decode()
   '我愛你們！'
   ```

   RSA非對稱加密：

   ```Python
   >>> from Crypto.PublicKey import RSA
   >>> # 生成密鑰對
   >>> key_pair = RSA.generate(2048)
   >>> # 導入公鑰
   >>> pub_key = RSA.importKey(key_pair.publickey().exportKey())
   >>> # 導入私鑰
   >>> pri_key = RSA.importKey(key_pair.exportKey())
   >>> # 明文
   >>> message1 = 'hello, world!'.encode()
   >>> # 加密數據
   >>> message2 = pub_key.encrypt(message1, None)
   (b'\x03\x86t\xa0\x00\xc4\xea\xd2\x80\xed\xa7YN7\x07\xff\x88\xaa\x1eW\x0cmH0\x06\xa7\'\xbc<w@q\x8b\xaf\xf7:g\x92{=\xe2E\xa5@\x1as2\xdd\xcb\x8e[\x98\x85\xdf,X\xecj.U\xd6\xa7W&u\'Uz"\x0f\x0e\\<\xa4\xfavC\x93\xa7\xbcO"\xb9a\x06]<.\xc1\r1}*\xdf\xccdqXML\x93\x1b\xe9\xda\xdf\xab|\xf8\x18\xe4\x99\xbb\x7f\x18}\xd9\x9a\x1e*J\\\xca\x1a\xd1\x85\xf7t\x81\xd95{\x19\xc9\x81\xb6^}\x9c5\xca\xfe\xcf\xc8\xd8M\x9a\x8c-\xf1t\xee\xf9\x12\x90\x01\xca\x92~\x00c5qg5g\x95&\x10\xb1\x0b\x1fo\x95\xf2\xbc\x8d\xf3f"@\xc5\x188\x0bX\x9cfo\xea\x97\x05@\xe5\xb2\xda\xb8\x97a\xa5w\xa8\x01\x9a\xa5N\xc4\x81\x8d\x0f<\x96iU\xd3\x95\xacJZs\xab_ #\xee\xf9\x0f\xf2\x12\xdb\xfc\xf8g\x18v\x02k+\xda\x16Si\xbf\xbb\xec\xf7w\x90\xde\xae\x97\t\xed{}5\xd0',)
   >>> # 解密數據
   >>> message3 = pri_key.decrypt(message2)
   'hello, world!'
   ```

#### 安全相關建議

1. 雖然 Django 自帶了穩固的安全保護措施，但是依然要採用正確的方式部署應用程序，利用 Web 服務器、操作系統和其他組件提供的安全保護措施。
2. 記得把 Python 代碼放在 Web 服務器的文檔根目錄之外，避免代碼意外洩露。
3. 謹慎處理用戶上傳的文件。 
4. Django本身沒有對請求次數加以限制（包括驗證用戶身份的請求），為了防止暴力攻擊和破解，可以考慮使用具有一次消費性的驗證碼或對這類請求的次數進行限制。  
5. 將緩存系統、數據庫服務器以及重要的資源服務器都放在第二級防火牆之後（不要放在DMZ）。 

### 測試相關

測試是發現和標記缺陷的過程。所謂的缺陷是指實際結果和期望結果之間的任何差別。有的地方，測試也被認為是執行以找出錯誤為目的的程序的過程。 測試是為了讓產品達到以下目標： 

1. 滿足需求用戶滿意
2. 改善產品的市場佔有率
3. 樹立對產品的信任
4. 減少開發和維護的成本

#### 功能測試

如果一個軟件單元的行為方式與它的開發規範完全一樣，那麼該軟件單元就通過了它的功能測試。
 - 白盒測試：開發人員自己實現，最基本的形式是單元測試，還有集成測試和系統測試。
 - 黑盒測試：由開發團隊之外的人執行，對測試代碼沒有可見性，將被測系統視為黑盒子。通常由測試人員或QA工程師來執行，Web應用可以通過Selenium這樣的測試框架自動化實施。

#### 性能測試

軟件在高工作負載下對其響應性和健壯性展開的測試。

- 負載測試：在特定負載下執行的測試。

 - 壓力測試：突發條件或極限條件下的性能測試。

#### 安全性測試

系統的敏感數據都是經過認證和授權之後才能訪問。

#### 其他測試

易用性測試 / 安裝測試 / 可訪問性測試

#### 單元測試

測試函數和對象的方法（程序中最小最基本的單元）。通過對實際輸出和預期輸出的比對以及各種的斷言條件來判定被測單元是否滿足設計需求。

- 測試用例
- 測試固件 - 每次測試時都要使用的東西。
- 測試套件（測試集）- 組合了多個測試用例而構成的集合。

```Python
class UtilTest(TestCase):

    def setUp(self):
        self.pattern = re.compile(r'\d{6}')

    def test_gen_mobile_code(self):
        for _ in range(100):
            self.assertIsNotNone(self.pattern.match(gen_mobile_code()))

    def test_to_md5_hex(self):
        md5_dict = {
            '123456': 'e10adc3949ba59abbe56e057f20f883e',
            '123123123': 'f5bb0c8de146c67b44babbf4e6584cc0',
            '1qaz2wsx': '1c63129ae9db9c60c3e8aa94d3e00495',
        }
        for key, value in md5_dict.items():
            self.assertEqual(value, to_md5_hex(key))
```

`TestCase`的斷言方法：

- assertEqual / assertNotEqual
- assertTrue / assertFalse / assertIsNot
- assertRaise / assertRaiseRegexp
- assertAlmostEqual / assertNotAlmostEqual
- assertGreater / assertGreaterEqual / assertLess / assertLessEqual
- assertRegexpMatches / assertNotRegexpMatches
- assertListEqual / assertSetEqual / assertTupleEqual / assertDictEqual

可以使用nose2或pytest來輔助執行單元測試，同時通過cov-core或pytest-cov可以對測試覆度進行評估。覆蓋率由百分比表示。比如測試代碼執行過了程序的每一行，那麼覆蓋率就是100%。這種時候，幾乎不會出現新程序上線後突然無法運行的尷尬情況。覆蓋率不關心代碼內容究竟是什麼，覆蓋率是用來檢查“測試代碼不足、測試存在疏漏”的一個指標，“測試內容是否妥當”並不歸它管。

```Shell
pip install nose2 pytest cov-core pytest-cov
```

可以使用Selenium來實現Web應用的自動化測試，它還可以用於屏幕抓取與瀏覽器行為模擬，通過爬蟲抓取頁面上的動態數據也可以使用它。Selenium其實包括三個部分：

- Selenium IDE：嵌入到瀏覽器的插件，可以錄製和回放腳本。

  ![](./res/selenium_ide.png)

- Selenium WebDriver：支持多種語言可以操控瀏覽器的API。

- Selenium Standalone Server：Selenium Grid、遠程控制、分佈式部署。

```Shell
pip install selenium
```

```Python
from selenium import webdriver
import pytest
import contextlib


@pytest.fixture(scope='session')
def chrome():
    # 設置使用無頭瀏覽器(不會打開瀏覽器窗口)
    options = webdriver.ChromeOptions()
    options.add_argument('--headless')
    driver = webdriver.Chrome(options=options)
    yield driver
    driver.quit()


def test_baidu_index(chrome):
    chrome.get('https://www.baidu.com')
    assert chrome.title == '百度一下，你就知道'

```

除了Selenium之外，還有一個Web自動化測試工具名叫Robot Framework。

```Shell
nose2 -v -C
pytest --cov
```

```Shell
Ran 7 tests in 0.002s

OK
Name                       Stmts   Miss  Cover
----------------------------------------------
example01.py                  15      0   100%
example02.py                  49     49     0%
example03.py                  22     22     0%
example04.py                  61     61     0%
example05.py                  29     29     0%
example06.py                  39     39     0%
example07.py                  19     19     0%
example08.py                  27     27     0%
example09.py                  18     18     0%
example10.py                  19     19     0%
example11.py                  22     22     0%
example12.py                  28     28     0%
example13.py                  28     28     0%
test_ddt_example.py           18      0   100%
test_pytest_example.py        11      6    45%
test_unittest_example.py      22      0   100%
----------------------------------------------
TOTAL                        427    367    14%
```

在測試過程中需要孤立各種外部依賴（數據庫、外部接口調用、時間依賴），具體又包括兩個方面：

1. 數據源：數據本地化 / 置於內存中 / 測試之後回滾

2. 資源虛擬化：存根/樁（stub）、仿製/模擬（mock）、偽造（fake）

   - stub：測試期間為提供響應的函數生成的替代品
   - mock：代替實際對象（以及該對象的API）的對象
   - fake：沒有達到生產級別的輕量級對象

#### 集成測試

集成多個函數或方法的輸入輸出的測試，測試時需要將多個測試對象組合在一起。

 - 測試組件互操作性 / 需求變更測試 / 外部依賴和API / 調試硬件問題 / 在代碼路徑中發現異常


#### 系統測試

對需求的測試，測試成品是否最終滿足了所有需求，在客戶驗收項目時進行。

#### 數據驅動測試

使用外部數據源實現對輸入值與期望值的參數化，避免在測試中使用硬編碼的數據。

被測函數：

```Python
def add(x, y):
    return x + y
```

data.csv文件：

```
3,1,2
0,1,-1
100,50,50
100,1,99
15,7,8
```

測試代碼：

```Python
import csv

from unittest import TestCase
from ddt import ddt, data, unpack


@ddt
class TestAdd(TestCase):

    def load_data_from_csv(filename):
        data_items = []
        with open(filename, 'r', newline='') as fs:
            reader = csv.reader(fs)
            for row in reader:
                data_items.append(list(map(int, row)))
        return data_items


    @data(*load_data_from_csv('data.csv'))
    @unpack
    def test_add(self, result, param1, param2):
        self.assertEqual(result, add(param1, param2))
```

#### Django中的測試

1. 測試Django視圖 - Django中提供的`TestCase`擴展了`unittest`中的`TestCase`，綁定了一個名為`client`的屬性，可以用來模擬瀏覽器發出的GET、POST、DELETE、PUT等請求。

```Python
class SomeViewTest(TestCase):

    def test_example_view(self):
        resp = self.client.get(reverse('index'))
        self.assertEqual(200, resp.status_code)
        self.assertEqual(5, resp.context['num'])
```

2. 運行測試 - 配置測試數據庫。

```Python
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.mysql',
        'HOST': 'localhost',
        'PORT': 3306,
        'NAME': 'DbName',
        'USER': os.environ['DB_USER'],
        'PASSWORD': os.environ['DB_PASS'],
        'TEST': {
            'NAME': 'DbName_for_testing',
            'CHARSET': 'utf8',
        },
    }
}
```

```Shell
python manage.py test
python manage.py test common
python manage.py test common.tests.UtilsTest
python manage.py test common.tests.UtilsTest.test_to_md5_hex
```

3. 評估測試覆蓋度

```Shell
pip install coverage
coverage run --source=<path1> --omit=<path2> manage.py test common
coverage report

Name                            Stmts   Miss  Cover
---------------------------------------------------
common/__init__.py                  0      0   100%
common/admin.py                     1      0   100%
common/apps.py                      3      3     0%
common/forms.py                    16     16     0%
common/helper.py                   32     32     0%
common/middlewares.py              19     19     0%
common/migrations/__init__.py       0      0   100%
common/models.py                   71      2    97%
common/serializers.py              14     14     0%
common/tests.py                    14      8    43%
common/urls_api.py                  3      3     0%
common/urls_user.py                 3      3     0%
common/utils.py                    22      7    68%
common/views.py                    69     69     0%
---------------------------------------------------
TOTAL                             267    176    34%
```

#### 性能測試

問題1：性能測試的指標有哪些？

1. ab（ Apache Benchmark） / webbench / httpperf

   ```Shell
   yum -y install httpd
   ab -c 10 -n 1000 http://www.baidu.com/
   ...
   Benchmarking www.baidu.com (be patient).....done
   Server Software:        BWS/1.1
   Server Hostname:        www.baidu.com
   Server Port:            80
   Document Path:          /
   Document Length:        118005 bytes
   Concurrency Level:      10
   Time taken for tests:   0.397 seconds
   Complete requests:      100
   Failed requests:        98
      (Connect: 0, Receive: 0, Length: 98, Exceptions: 0)
   Write errors:           0
   Total transferred:      11918306 bytes
   HTML transferred:       11823480 bytes
   Requests per second:    252.05 [#/sec] (mean)
   Time per request:       39.675 [ms] (mean)
   Time per request:       3.967 [ms] (mean, across all concurrent requests)
   Transfer rate:          29335.93 [Kbytes/sec] received
   Connection Times (ms)
                 min  mean[+/-sd] median   max
   Connect:        6    7   0.6      7       9
   Processing:    20   27  22.7     24     250
   Waiting:        8   11  21.7      9     226
   Total:         26   34  22.8     32     258
   Percentage of the requests served within a certain time (ms)
     50%     32
     66%     34
     75%     34
     80%     34
     90%     36
     95%     39
     98%     51
     99%    258
    100%    258 (longest request)
   ```

2. mysqlslap

   ```Shell
   mysqlslap -a -c 100 -h 1.2.3.4 -u root -p
   mysqlslap -a -c 100 --number-of-queries=1000 --auto-generate-sql-load-type=read -h <負載均衡服務器IP地址> -u root -p
   mysqlslap -a --concurrency=50,100 --number-of-queries=1000 --debug-info --auto-generate-sql-load-type=mixed -h 1.2.3.4 -u root -p
   ```

3. sysbench

   ```Shell
   sysbench --test=threads --num-threads=64 --thread-yields=100 --thread-locks=2 run
   sysbench --test=memory --num-threads=512 --memory-block-size=256M --memory-total-size=32G run
   ```

4. jmeter

   請查看[《使用JMeter進行性能測試》](https://www.ibm.com/developerworks/cn/java/l-jmeter/index.html)。

5. LoadRunner / QTP

### 項目調試

可以使用django-debug-toolbar來輔助項目調試。

1. 安裝

   ```Shell
   pip install django-debug-toolbar
   ```

2. 配置 - 修改settings.py。

   ```Python
   INSTALLED_APPS = [
       'debug_toolbar',
   ]
   
   MIDDLEWARE = [
       'debug_toolbar.middleware.DebugToolbarMiddleware',
   ]
   
   DEBUG_TOOLBAR_CONFIG = {
       # 引入jQuery庫
       'JQUERY_URL': 'https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js',
       # 工具欄是否摺疊
       'SHOW_COLLAPSED': True,
       # 是否顯示工具欄
       'SHOW_TOOLBAR_CALLBACK': lambda x: True,
   }
   ```

3. 配置 - 修改urls.py。

   ```Python
   if settings.DEBUG:
   
       import debug_toolbar
   
       urlpatterns.insert(0, path('__debug__/', include(debug_toolbar.urls)))
   ```

4. 使用 - 在頁面右側可以看到一個調試工具欄，上面包括了執行時間、項目設置、請求頭、SQL、靜態資源、模板、緩存、信號等調試信息，查看起來非常的方便。

### 部署相關

請參考《Django項目上線指南》。

### 性能相關

#### 網站優化兩大定律：

1. 儘可能的使用緩存 - 犧牲空間換取時間（普適策略）。

2. 能推遲的都推遲 - 使用消息隊列將並行任務串行來緩解服務器壓力。

   - 服務器CPU利用率出現瞬時峰值 - 削峰（CPU利用率平緩的增長）
   - 上下游節點解耦合（下訂單和受理訂單的系統通常是分離的）


#### Django框架

1. 配置緩存來緩解數據庫的壓力，並有合理的機制應對[緩存穿透和緩存雪崩](https://www.cnblogs.com/zhangweizhong/p/6258797.html)。

2. 開啟[模板緩存](https://docs.djangoproject.com/en/2.0/ref/templates/api/#django.template.loaders.cached.Loader)來加速模板的渲染。

   ```Python
   TEMPLATES = [
       {
           'BACKEND': 'django.template.backends.django.DjangoTemplates',
           'DIRS': [os.path.join(BASE_DIR, 'templates'), ],
           # 'APP_DIRS': True,
           'OPTIONS': {
               'context_processors': [
                   'django.template.context_processors.debug',
                   'django.template.context_processors.request',
                   'django.contrib.auth.context_processors.auth',
                   'django.contrib.messages.context_processors.messages',
               ],
               'loaders': [(
                   'django.template.loaders.cached.Loader', [
                       'django.template.loaders.filesystem.Loader',
                       'django.template.loaders.app_directories.Loader',
                   ], ),
               ],
           },
       },
   ]
   ```

3. 用惰性求值、迭代器、`defer()`、`only()`等緩解內存壓力。

4. 用`select_related()`和`prefetch_related()`執行預加載避免“1+N查詢問題”。

#### 數據庫

1. 用ID生成器代替自增主鍵（性能更好、適用於分佈式環境）。

   - 自定義ID生成器

   - UUID

   ```Python
   >>> my_uuid = uuid.uuid1()
   >>> my_uuid
   UUID('63f859d0-a03a-11e8-b0ad-60f81da8d840')
   >>> my_uuid.hex
   '63f859d0a03a11e8b0ad60f81da8d840'
   ```

2. 避免不必要的外鍵列上的約束（除非必須保證參照完整性），更不要使用觸發器之類的機制。

3. 使用索引來優化查詢性能（索引放在要用於查詢的字段上）。InnoDB用的是BTREE索引，使用>、<、>=、<=、BETWEEN或者LIKE 'pattern'（pattern不以通配符開頭）時都可以用到索引。因為建立索引需要額外的磁盤空間，而主鍵上是有默認的索引，所以主鍵要儘可能選擇較短的數據類型來減少磁盤佔用，提高索引的緩存效果。

   ```SQL
   create index idx_goods_name on tb_goods (gname(10));
   ```

   ```SQL
   -- 無法使用索引
   select * from tb_goods where gname like '%iPhone%';
   -- 可以使用索引
   select * from tb_goods where gname like 'iPhone%';
   ```

   ```Python
   # 無法使用索引
   Goods.objects.filter(name_icontains='iPhone')
   # 可以使用索引
   Goods.objects.filter(name__istartswith='iPhone');
   ```

4. 使用存儲過程（存儲在服務器端編譯過的一組SQL語句）。

   ```SQL
   drop procedure if exists sp_avg_sal_by_dept;
   
   create procedure sp_avg_sal_by_dept(deptno integer, out avg_sal float)
   begin 
       select avg(sal) into avg_sal from TbEmp where dno=deptno;
   end;
   
   call sp_avg_sal_by_dept(10, @a);
   
   select @a;
   ```

   ```Python
   >>> from django.db import connection
   >>> cursor = connection.cursor()
   >>> cursor.callproc('sp_avg_sal_by_dept', (10, 0))
   >>> cursor.execute('select @_sp_avg_sal_by_dept_1')
   >>> cursor.fetchone()
   (2675.0,)
   ```

5. 使用數據分區。通過分區可以存儲更多的數據、優化查詢更大的吞吐量、可以快速刪除過期的數據。關於這個知識點可以看看MySQL的[官方文檔](https://dev.mysql.com/doc/refman/5.7/en/partitioning-overview.html)。

   - RANGE分區：基於連續區間範圍，把數據分配到不同的分區。
   - LIST分區：基於枚舉值的範圍，把數據分配到不同的分區。
   - HASH分區 / KEY分區：基於分區個數，把數據分配到不同的分區。

   ```SQL
   CREATE TABLE tb_emp (
       eno INT NOT NULL,
       ename VARCHAR(20) NOT NULL,
       job VARCHAR(10) NOT NULL,
       hiredate DATE NOT NULL,
       dno INT NOT NULL
   )
   PARTITION BY HASH(dno)
   PARTITIONS 4;
   ```

   ```SQL
   CREATE TABLE tb_emp (
       eno INT NOT NULL,
       ename VARCHAR(20) NOT NULL,
       job VARCHAR(10) NOT NULL,
       hiredate DATE NOT NULL,
       dno INT NOT NULL
   )
   PARTITION BY RANGE( YEAR(hiredate) ) (
       PARTITION p0 VALUES LESS THAN (1960),
       PARTITION p1 VALUES LESS THAN (1970),
       PARTITION p2 VALUES LESS THAN (1980),
       PARTITION p3 VALUES LESS THAN (1990),
       PARTITION p4 VALUES LESS THAN MAXVALUE
   );
   ```

6. 使用`explain`來分析查詢性能 - 執行計劃。

   ```SQL
   explain select * from ...;
   ```

   `explain`結果解析：

   - select_type：表示select操作的類型，常見的值有SIMPLE（簡單查詢，沒有使用子查詢或者表連接查詢）、PRIMARY（主查詢，外層的查詢）、UNION（並集操作中的第二個或者後面的查詢）、SUBQUERY（子查詢中的第一個SELECT）等。
   - table：輸出結果的表。
   - type：MySQL在表中找到所需行的方式，也稱為訪問類型，常見的值有：
     - ALL：全表掃描（遍歷全表找到匹配的行）
     - index：索引全掃描（遍歷整個索引）
     - range：索引範圍掃描
     - ref：非唯一索引掃描或唯一索引的前綴掃描
     - eq_ref：唯一索引掃描
     - const / system：表中最多有一行匹配
     - NULL：不用訪問表或者索引
   - possible_keys：查詢時可能用到的索引。
   - key：實際使用的索引。
   - key_len：使用到索引字段的長度。
   - rows：掃描行的數量。
   - Extra：額外的信息（執行情況的說明或描述）。

   > 說明：關於MySQL更多的知識尤其是性能調優和運維方面的內容，推薦大家閱讀網易出品的《深入淺出MySQL（第2版）》，網易出品必屬精品。

7. 使用慢查詢日誌來發現性能低下的查詢。

   ```SQL
   mysql> show variables like 'slow_query%';
   +---------------------------+----------------------------------+
   | Variable_name             | Value                            |
   +---------------------------+----------------------------------+
   | slow_query_log            | OFF                              |
   | slow_query_log_file       | /mysql/data/localhost-slow.log   |
   +---------------------------+----------------------------------+
   
   mysql> show variables like 'long_query_time';
   +-----------------+-----------+
   | Variable_name   | Value     |
   +-----------------+-----------+
   | long_query_time | 10.000000 |
   +-----------------+-----------+
   ```

   ```SQL
   mysql> set global slow_query_log='ON'; 
   mysql> set global long_query_time=1;
   ```

   ```INI
   [mysqld]
   slow_query_log=ON
   slow_query_log_file=/usr/local/mysql/data/slow.log
   long_query_time=1
   ```

#### 其他

請參考《Python性能調優》。