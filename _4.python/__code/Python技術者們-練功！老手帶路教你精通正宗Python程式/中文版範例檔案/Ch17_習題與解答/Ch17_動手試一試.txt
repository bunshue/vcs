### 17.3 ###

x = []
if isinstance(x, list):
    print("is list")

---

這是LBYL風格。

你可以將動作包裝在try ...except區塊內，並捕獲TypeError異常，這種作法比較接近EAFP風格。

### 17.6 ###

如果你嘗試透過索引取值，將無法正常運作；而且索引值只能遞增無法倒退。

### 17.8 ###

class TypedList:
    def __init__(self, example_element, initial_list=[]):
        self.type = type(example_element)
        if not isinstance(initial_list, list):
            raise TypeError("Second argument of TypedList must " 
                            "be a list.")
        for element in initial_list: 
            self.__check(element)
        self.elements = initial_list[:]

    def __check(self, element):
        if type(element) != self.type:
            raise TypeError("Attempted to add an element of " 
                            "incorrect type to a typed list.")

    def __setitem__(self, i, element):
        self.__check(element)
        self.elements[i] = element

    def __getitem__(self, i):
        return self.elements[i]

    # added methods
    def __delitem__(self, i):
        del self.elements[i]

    def __len__(self):
        return len(self.elements)

    def append(self, element):
        self.__check(element)
        self.elements.append(element)


>>> x = TypedList(1, [1,2,3])
>>> print(len(x))
>>> x.append(1)
>>> del x[2]

### 17.10 ###

你可以使用與TypedList相同的方法，並從UserDict類別繼承。
你也可以直接從dict繼承，或者你可以自己實作所有的dict功能。

自己實作所有內容提供了最大的控制權，但是卻最容易出錯。
如果你只需要作很小的更動（在這種情況下，只需在添加鍵之
前檢查型別），直接從dict繼承可能是最好的方式。另一方面，
從User-Dict繼承可能是最安全的，因為內部dict物件是一個普
通的dict，而dict本身就是一個高度優化和成熟的實作。

