### 9.1 ###

>>> def fact(n): 
...     """回傳參數 n 的階乘"""
...     r = 1
...     while n > 0:
...         r = r * n
...         n = n - 1
...     return r 
...

---

>>> fact(4)    
24              
>>> x = fact(4)
>>> x 
24
>>>

### 9.2 ###

>>> def power(x, y):
...     r = 1
...     while y > 0:
...         r = r * x
...         y = y - 1
...     return r
... 
>>> power(3, 4)
81

---

>>> power(3)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: power() missing 1 required positional argument: 'y'
>>>

---

def func(p1, p2,...):
    p1 = p1 + 1
    x = p1 + p2

func(a1, a2,...)  

---

>>> def power(x, y=2):
...     r = 1
...     while y > 0:
...         r = r * x
...         y = y - 1
...     return r
...

---

>>> power(3, 4)
81
>>> power(3)
9

---

>>> def func(x=2, y):
...     pass
...
  File "<stdin>", line 1
SyntaxError: non-default argument follows default argument

### 9.2.2 ###

>>> power(2, 3)
8
>>> power(3, 2)
9
>>> power(y=2, x=3)   
9

---

>>> power(y=3, 2)
  File "<stdin>", line 1
SyntaxError: positional argument follows keyword argument

---

>>> power(2, x=3)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: power() got multiple values for argument 'x'

---

def list_file_info(size=False, create_date=False, mod_date=False, ...):
    # 取得目前目錄下的檔案名稱...
    if size:
        # 取得檔案大小
    if create_date:
        # 取得檔案建立日期
    if mod_date:
        # 取得檔案修改日期
    
    return fileinfostructure

---

fileinfo = list_file_info(True, mod_date=True)

### 9.2.3 ###

>>> def maximum(*numbers):
...     if len(numbers) == 0:
...         return None
...     else:
...         maxnum = numbers[0]
...         for n in numbers[1:]:
...             if n > maxnum:
...                 maxnum = n
...         return maxnum
...

---

>>> maximum(3, 2, 8)
8
>>> maximum(1, 5, 9, -2, 2)
9
>>> maximum()

---

>>> def example_fun(x, y, **other):
...     print("x: {0}, y: {1}, 字典 'other' 內的鍵: {2}".format(x, 
...           y, list(other.keys())))
...     other_total = 0
...     for k in other.keys():
...         other_total = other_total + other[k]
...     print("字典 'other' 內值的總和為 {0}".format(other_total))

---

>>> example_fun(2, y="1", foo=3, bar=4)  
x: 2, y: 1, 字典 'other' 內的鍵: ['foo', 'bar']  
字典 'other' 內值的總和為 7

### 9.2.4 ###

>>> def func(p1, p2, p3='three', *p4, **p5):
...     print(p1, p2, p3, p4, p5)
...

>>> func(1, 2, 3, 4, 5, x=1, y=2)
1 2 3  (4, 5) {'x': 1, 'y': 2}

>>> func(1, 2, 3, 4, 5)
1 2 3 (4, 5) {}

>>> func(1, 2, 3, 4, x=5)
1 2 3 (4,) {'x': 5}

>>> func(1, 2, 3)
1 2 3 () {}

>>> func(1, 2)
1 2 three () {}

>>> func(1)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: func() missing 1 required positional argument: 'p2' 

>>> func(1, 2, 3, p3=3)    
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: func() got multiple values for 
argument 'p3'

>>> func(1, 2, p4=4)  
1 2 three () {'p4': 4}

### 9.3 ###

>>> def f(n, list1, list2):
...    list1.append(3)
...    list2 = [4, 5, 6]
...    n = n + 1
...
>>> x = 5
>>> y = [1, 2]
>>> z = [4, 5]
>>> f(x, y, z)
>>> x, y, z
(5, [1, 2, 3], [4, 5])

---

>>> def f(lst):
...    lst = lst[:]
...    lst.append(3)
...
>>> x = [1, 2]
>>> f(x)
>>> x
[1, 2]

---

>>> def data_append(v, lst=[]):
...     lst.append(v)
...     return lst
... 
>>> data_append(1)
[1]
>>> data_append(2)
[1, 2]

---

>>> def data_append(v, lst=None):
...     if lst is None:
...         lst = []
...     lst.append(v)
...     return lst
...
>>> data_append(1)
[1]
>>> data_append(2)
[2]

### 9.4 ###

def fact(n):
    """回傳參數指定數字的階乘值"""
    r = 1
    while n > 0:
        r = r * n
        n = n - 1
    return r

---

>>> def func():
...     global a
...     a = 1
...     b = 2
...

---

>>> a = "one"
>>> b = "two"
>>> func()
>>> a
1
>>> b
'two'

---

g_var = 0               
nl_var = 0               
print("top level-> g_var: {0} nl_var: {1}".format(g_var, nl_var))
def test():
    nl_var = 2
    print("in test-> g_var: {0} nl_var: {1}".format(g_var, nl_var))
    def inner_test():
        global g_var   
        nonlocal nl_var
                  
        g_var = 1
        nl_var = 4
    
        print("in inner_test-> g_var: {0} nl_var: {1}".format(g_var,
                                                            nl_var))
    inner_test()
    print("in test-> g_var: {0} nl_var: {1}".format(g_var, nl_var))

test()
print("top level-> g_var: {0} nl_var: {1}".format(g_var, nl_var))

---

top level-> g_var: 0 nl_var: 0
in test-> g_var: 0 nl_var: 2
in inner_test-> g_var: 1 nl_var: 4
in test-> g_var: 1 nl_var: 4
top level-> g_var: 1 nl_var: 0

---

>>> def fun():
…     a = 1
…     global a
    
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
SyntaxError: name 'a' is assigned to before global declaration

---

>>> a = "one"
>>> def func():
...     print(a)
...     a = 1     
...
>>> func()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 2, in func
UnboundLocalError: local variable 'a' referenced before assignment

---

>>> a = "one"
>>> def func(x):
...     if x: 
...         a = 1 
...     print(a)
...
>>> func(True)
1
>>> func(False)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 4, in func
UnboundLocalError: local variable 'a' referenced before assignment

### 9.5 ###

>>> def f_to_kelvin(degrees_f):                 
...     return 273.15 + (degrees_f - 32) * 5 / 9
...
>>> def c_to_kelvin(degrees_c):                 
...     return 273.15 + degrees_c
...
>>> abs_temperature = f_to_kelvin               
>>> abs_temperature(32)
273.15
>>> abs_temperature = c_to_kelvin               
>>> abs_temperature(0)
273.15

---

>>> t = {'FtoK': f_to_kelvin, 'CtoK': c_to_kelvin}
>>> t['FtoK'](32)                                 
273.15
>>> t['CtoK'](0)                                  
273.15

---

>>> w = ['Quick', 'Python', 'Book']
>>> def uppercase(s):
…      return s.upper()
>>> list(map(uppercase, w)) 
['QUICK', 'PYTHON', 'BOOK']     

### 9.6 ###

>>> t2 = {'FtoK': lambda deg_f: 273.15 + (deg_f - 32) * 5 / 9,
...       'CtoK': lambda deg_c: 273.15 + deg_c}               
>>> t2['FtoK'](32)
273.15

---

>>> def compare_num_of_chars(string1):
...     return len(string1)
>>> word_list = ['Python', 'is', 'better', 'than', 'C'] 
>>> word_list.sort(key=compare_num_of_chars)

---

>>> word_list = ['Python', 'is', 'better', 'than', 'C']
>>> word_list.sort(key=lambda s: len(s))

---

>>> word_list = ['Python', 'is', 'better', 'than', 'C']
>>> word_list.sort(key=len)

### 9.7 ###

>>> def four():
...     x = 0                             
...     while x < 4:
...         print("in generator, x =", x)
...         yield x                       
...         x += 1                        
... 
>>> for i in four():
...     print(i)
...
in generator, x = 0
0
in generator, x = 1
1
in generator, x = 2
2
in generator, x = 3
3

---

>>> 2 in four()
in generator, x = 0
in generator, x = 1
in generator, x = 2
True
>>> 5 in four()
in generator, x = 0
in generator, x = 1
in generator, x = 2
in generator, x = 3
False

---

>>> def subgen(x): 
...     for i in range(x):
...         yield i
...
>>> def gen(y):    
...     yield from subgen(y)
...
>>> for q in gen(6):
...     print(q)
... 
0
1
2
3
4
5

---

def gen_allusers():
    for id in get_teacher_id():
        ... 做額外處理 ...
        yield id
    for id in get_student_id():
        ... 做額外處理 ...
        yield id

---

def gen_teacher():
    for id in get_teacher_id():
        ... 做額外處理 ...
        yield id
def gen_student():
    for id in get_student_id():
        ... 做額外處理 ...
        yield id

---

def gen_allusers():
    for id in gen_teacher():
        yield id
    for id in gen_student():
        yield id

---

def gen_allusers():
    yield from gen_teacher() 
    yield from gen_student() 

### 9.8 ###

>>> def decorate(func):  
...     def wrapper_func(*args):
...         print("原函式執行前")
...         func(*args)
...         print("原函式已執行")
...     return wrapper_func
...
>>> def myfunction(parameter):
...     print(parameter)
...
>>> myfunction = decorate(myfunction)  
>>> myfunction("hello")
原函式執行前 
hello      
原函式已執行 

---

>>> myfunction("hello")
原函式執行前             
hello                  
原函式已執行             

---

>>> def decorate(func):
...     def wrapper_func(*args):
...         print("原函式執行前")
...         func(*args)
...         print("原函式已執行")
...     return wrapper_func
...
>>> @decorate   
... def myfunction(parameter):
...     print(parameter)
...
>>> myfunction("hello")
原函式執行前
hello 
原函式已執行

---

from flask import Flask
app = Flask(__name__)

@app.route("/hello") 
def hello():
    return "Hello World!"
