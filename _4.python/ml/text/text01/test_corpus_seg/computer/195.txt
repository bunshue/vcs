 日月 光华   - -   SE 精华区 文章 阅读 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -   发信人 :   jiachong   ( 甲虫 ) ,   信 区 :   SE 标     题 :   [ 转载 ] 软件 编程 规范 培训 实例 与 练习 发信站 :   日月 光华   ( 2003 年 04 月 20 日 22 : 40 : 14   星期天 ) ,   站 内 信件 【   以下 文字 转载自   FDU _ C . S .   讨论区   】 【   原文 由   fdchosen   所 发表   】 软件 编程 规范 培训 实例 与 练习 &# 376 ; 	 问题 分类 1             逻辑 类 问题 （ A 类 ） － 指 设计 、 编码 中 出现 的 计算 正确性 和 一致性 、 程序逻辑 控制 等 方面 出现 的 问题 ， 在 系统 中起 关键作用 ， 将 导致 软件 死机 、 功能 正常 实现 等 严重 问题 ；             接口类 问题 （ B 类 ） － 指 设计 、 编码 中 出现 的 函数 和 环境 、 其他 函数 、 全局 / 局部变量 或 数据 变量 之间 的 数据 / 控制传输 不 匹配 的 问题 ， 在 系统 中起 重要 作用 ， 将 导致 模块 间 配合 失效 等 严重 问题 ；             维护 类 问题 （ C 类 ） － 指 设计 、 编码 中 出现 的 对 软件系统 的 维护 方便 程度 造成 影响 的 问题 ， 在 系统 中不起 关键作用 ， 但 对系统 后期 维护 造成 不便 或 导致 维护费用 上升 ；             可 测试 性 问题 （ D 类 ） － 指 设计 、 编码 中因 考虑不周 而 导致 后期 系统 可 测试 性差 的 问题 。 &# 376 ; 	 处罚 办法 	             问题 发生率 ： 	                                   P = D / S 	                                   D = DA + 0.5 DB + 0.25 DC 	 	             其中 ： 	                             P       － 问题 发生率 	                             D       － 1 个 季度 内 错误 总数 	                             DA   － 1 个 季度 内 A 类 错误 总数 	                             DB   － 1 个 季度 内 B 类 错误 总数 	                             DC   － 1 个 季度 内 C 类 错误 总数 	                             S       － 1 个 季度 内 收到 问题 报告单 总数             1 ） 当 D ≥ 3 时 ， 如果 P ≥ 3 ％ ， 将 进行 警告 处理 ， 并 予以 公告 ；             2 ） 当 D ≥ 5 时 ， 如果 P ≥ 5 ％ ， 将 进行 罚款 处理 ， 并 予以 公告 。   目       录一 、 逻辑 类 代码 问题 	 第 5 页 1 、 变量 / 指针 在 使用 前 就 必须 初始化 	 第 5 页 【 案例 1.1 . 1 】 	 第 5 页 2 、 防止 指针 / 数组 操作 越界 	 第 5 页 【 案例 1.2 . 1 】 	 第 5 页 【 案例 1.2 . 2 】 	 第 6 页 【 案例 1.2 . 3 】 	 第 7 页 【 案例 1.2 . 4 】 	 第 8 页 3 、 避免 指针 的 非法 引用 	 第 9 页 【 案例 1.3 . 1 】 	 第 9 页 4 、 变量 类型定义 错误 	 第 10 页 【 案例 1.4 . 1 】 	 第 10 页 5 、 正确 使用 逻辑 与 && 、 屏蔽 & 操作符 	 第 17 页 【 案例 1.5 . 1 】 	 第 17 页 6 、 注意 数据类型 的 匹配 	 第 18 页 【 案例 1.6 . 1 】 	 第 18 页 【 案例 1.6 . 2 】 	 第 18 页 7 、 用于 控制 条件 转移 的 表达式 及 取值 范围 是否 书写 正确 	 第 20 页 【 案例 1.7 . 1 】 	 第 20 页 【 案例 1.7 . 2 】 	 第 21 页 【 案例 1.7 . 3 】 	 第 22 页 8 、 条件 分支 处理 是否 有 遗漏 	 第 24 页 【 案例 1.8 . 1 】 	 第 24 页 9 、 引用 已 释放 的 资源 	 第 26 页 【 案例 1.9 . 1 】 	 第 26 页 10 、 分配资源 是否 已 正确 释放 	 第 28 页 【 案例 1.10 . 1 】 	 第 28 页 【 案例 1.10 . 2 】 	 第 29 页 【 案例 1.10 . 3 】 	 第 30 页 【 案例 1.10 . 4 】 	 第 32 页 【 案例 1.10 . 5 】 	 第 33 页 【 案例 1.10 . 6 】 	 第 35 页 【 案例 1.10 . 7 】 	 第 38 页 11 、 防止 资源 的 重复 释放 	 第 39 页 【 案例 1.11 . 1 】 	 第 39 页 12 、 公共资源 的 互斥性 和 竞用 性 	 第 40 页 【 案例 1.12 . 1 】 	 第 40 页 【 案例 1.12 . 2 】 	 第 40 页 二 、 接口类 代码 问题 	 第 43 页 1 、 对 函数参数 进行 有效性 检查 	 第 43 页 【 案例 2.1 . 1 】 	 第 43 页 【 案例 2.1 . 2 】 	 第 43 页 【 案例 2.1 . 3 】 	 第 44 页 【 案例 2.1 . 4 】 	 第 46 页 【 案例 2.1 . 5 】 	 第 47 页 【 案例 2.1 . 6 】 	 第 48 页 2 、 注意 多 出口 函数 的 处理 	 第 49 页 【 案例 2.2 . 1 】 	 第 49 页 三 、 维护 类 代码 问题 	 第 51 页 1 、   统一 枚举 类型 的 使用 	 第 51 页 【 案例 3.1 . 1 】 	 第 51 页 2 、   注释 量 至少 占 代码 总量 的 20 ％ 	 第 51 页 【 案例 3.2 . 1 】 对 XXX 产品 BAM 某 版本 部分 代码 注释 量 的 统计 	 第 51 页 四 、 产品 兼容性问题 	 第 52 页 1 、 系统配置 、 命令 方式 	 第 52 页 【 案例 4.1 . 1 】 	 第 52 页 【 案例 4.1 . 2 】 	 第 53 页 2 、 设备 对接 	 第 54 页 【 案例 4.2 . 1 】 	 第 54 页 3 、 其他 	 第 55 页 【 案例 4.3 . 1 】 	 第 55 页 五 、 版本控制 问题 	 第 58 页 1 、 新老 代码 中 同一 全局变量 不 一致 	 第 58 页 【 案例 5.1 . 1 】 	 第 58 页 六 、 可 测试 性 代码 问题 	 第 59 页 1 、 调试信息 / 打印信息 的 正确性 	 第 59 页 【 案例 6.1 . 1 】 	 第 59 页   一 、 逻辑 类 代码 问题 1 、 变量 / 指针 在 使用 前 就 必须 初始化 【 案例 1.1 . 1 】 	 C语言 中 最大 的 特色 就是 指针 。 指针 的 使用 具有 很强 的 技巧性 和 灵活性 ， 但 同时 也 带来 了 很大 的 危险性 。 在 XXX 的 代码 中有 如下 一端 对 指针 的 灵活 使用 ： ...   ...         _ UC   * puc _ card _ config _ tab ;   ...   ...                 Get _ Config _ Table (   AMP _ CPM _ CARD _ CONFIG _ TABLE ,                                                       & ul _ card _ config _ num ,                                                       & puc _ card _ config _ tab ,                                                       use _ which _ data _ area                                                 ) ; ...   ...             b _ middle _ data _ ok   =   generate _ trans _ middle _ data _ from _ original _ data (                                                                 puc _ card _ config _ tab ,                                                                 Ul _ card _ config _ num ) ....   ... 其中 红色 部分 巧妙 的 利用 指向 指针 的 指针 为 指针 puc _ card _ config _ tab 赋值 , 而 在 兰色 部分 使用 该 指针 。 但 在 Get _ Config _ Table 函数 中有 可能 失败 返回 而 不 给 该 指针 赋值 。 因此 ， 以后 使用 的 可能 是 一个 非法 指针 。 指针 的 使用 是 非常灵活 的 ， 同时 也 存在 危险性 ， 必须 小心 使用 。 指针 使用 的 危险性 举世 共知 。 在 新 的 编程 思想 中 ， 指针 基本上 被 禁止 使用 （ JAVA 中 就是 这样 ） ， 至少 也 是 被 限制 使用 。 而 在 我们 交换机 的 程序 中 大量 使用 指针 ， 并且 有增无减 。 2 、 防止 指针 / 数组 操作 越界 【 案例 1.2 . 1 】                 在 香港 项目 测试 中 ， 发现 ISDN 话机 拨新 业务 号码 时 ， 若 一位 一位 的 拨 至 18 位 ， 不会 有 问题 。 但 若 先 拨 完 号码 再 成组 发送 ， 会 导致 MPU 死机 。                   处理过程 ：                 查错 过程 很 简单 ， 按 呼叫 处理 的 过程 检查 代码 ， 发现 某 一处 的 判断 有误 ， 本 应为 小于 18 的 判断 ， 写成 了 小于 等于 18 。                         结     论 ：                   代码 编写 有误 。 思考 与 启示 ： 	 1 、 极限 测试 必须 注意 ， 测试 前 应对 某项 设计 的 极限 做好 充分 测试 规划 。                     2 、 测试 极限 时 还要 注意 多种 业务 接入点 ， 本例 为 ISDN 。 对于 交换机 来说 ， 任何 一种 业务 都 要 分别 在 模拟 话机 、 ISDN 话机 、 V5 话机 、 多种形式 的 话务台 上 做 测试 。 对于 中继 的 业务 ， 则 要 充分考虑 各种 信令 ： TUP 、 ISUP 、 PRA 、 NO1 、 V5 等等 。 【 案例 1.2 . 2 】 	 对 某 交换 类 进行 计费 测试 ， 字冠 011 对应 1 号 路由 、 1 号子 路由 ， 有 4 个 中继 群 11 , 12 , 13 , 14 ( 都 属于 1 # 模块 ) ， 前后 两个 群 分别 构成 自环 。 其中 11 , 13 群向 为 出 中继 , 12 , 14 群向 为 入 中继 ， 对 这 四个 群 分别 进行 计费 设置 ， 对 出入 中继 都 计费 。 电话 60640001 拨打 01160010001 两次 ， 使 四个 群 都 有 机会 被 计费 ， 取 话单 后 浏览 话单 发现 对 11 群 计费 计次 表 话单 出 中继 群号 不 正确 ， 其它 群 的 计次 表中出 中继 群号 正常 。 处理过程 ： 	 与 开发人员 在 测试 组 环境 多次重复 以上 步骤 ， 发现 11 群 的 计次 表 话单 有时 正常 ， 有时 其出 中继 群号 就 为 一个 随机 值 ， 发生 异常 的 频率 比较 高 。 为什么 其它 群 的话 单 正常 ， 唯独 11 群 不 正常 呢 ？ 11 群是 四个 群中 最小 的 群 ， 其中 继 计次 表 位于 缓冲区 的 首位 ， 打 完 电话 后 查询 内存 发现 出 中继 群号 在 内存 中是 正确 的 ， 取完 话单 后 再查 就 不 正确 了 。 结     论 ： 	 话单 池 的 一个 备份 指针 Pool _ head _ 1 和 中继 计次 表 的 头 指针 重合 ， 影响 到 第一个 中继 计次 表 的 计费 。 思考 与 启示 ： 	 随机 值 的 背后 往往 隐藏 着 指针 问题 ， 两块 内存 缓冲区 的 交界处 比较 容易 出现 问题 ， 在 编程 时 是 应该 注意 的 地方 。 【 案例 1.2 . 3 】 【 正                         文 】                     在 接入网 产品 A 测试 中 ， 在 内存 数据库 正常 的 情况 下 的 各种 数据库 方面 的 操作 都 是 正常 的 。 为了 进行 数据库 异常 测试 ， 于是 将 数据库 内容 人为 地 破坏 了 。 发现 在 对 数据库 进行 比较 操作 时 ， 出现 程序 跑 死 了 现象 。 	 经过 跟踪 调试 发现 问题 出现 在 如下 一段 代码 中 :         1 	 for ( i = 0 ;   i < pSysHead - > dbf _ count ;   i ++ ) 2 	 { 3 	                         pDBFat   =   ( _ NM _ DBFAT _ STRUC   * ) ( NVDB _ BASE   +   DBFAT _ OFFSET   +   i * DBFAT _ LEN ) ; 4 	 	 if ( fat _ check ( pDBFat )   ! =   0 )   5 	 	 { 6                               	 	 pSysHead - > system _ flag   =   0 ; 7                                 	 	 head _ sum ( ) ; 8                               	 	 continue ; 9                         	 } 10                         	 if ( strlen ( dbf - > dbf _ name )   ! =   0   &&   strncmp ( dbf - > dbf _ name ,   pDBFat - > dbf _ name ,   strlen ( dbf - > dbf _ name ) )   = =   0 ) 11                         	 { 12                               	 	 dbf _ ptr1   =   ( _ UC   * ) pDBFat - > dbf _ head ; 13                               	 	 filesize   =   pDBFat - > dbf _ fsize ; 14                                 	 	 break ; 15                       	 } 16       	 }                 在 测试 时 发现 程序 死 在 循环 之中 ， 得到 的 错误 记录 是 " Bus   Error " （ 总线 出错 ） ， 由此 可以 说明 出现 了 内存 操作 异常 。 	 经过 跟踪 变量值 发现 循环 变量 i 的 阀值 pSysHead - > dbf _ count 的 数值 为 0xFFFFFFFF ， 该值 是从 被 破坏 的 内存 数据库 中 获取 的 ， 正常 情况 下 该值 小于 127 。 而 pDBFat 是 数据库 的 起始 地址 ， 如果 pSysHead - > dbf _ count 值 异常 过大 ， 将 导致 pDBFat 值 超过 最大 内存地址 值 ， 随后 进行 的 内存 操作 将 导致 内存 操作 越界 错误 ， 因而 在 测试 过程 中 数据库 破坏 后 就 出现 了 主机 死机 的 现象 。 	 上面 的 问题 解决 起来 很 容易 ， 只 需 在 第一行 代码 中 增加 一个 判断 条件 即可 ， 如下 ： 　 for ( i = 0 ;   i < pSysHead - > dbf _ coun   &&   i   <   MAX _ DB _ NUM ;   i ++ )               / /   MAX _ DB _ NUM = 127 	 这样 就 保证 了 循环 变量 i 的 值 在 正常 范围 内 ， 从而 避免 了 对 指针 pDBFat 进行 内存 越界 的 操作 。 　 　 从 上面 的 测试 过程 中 ， 我们 可以 看到 ： 如此 严重 的 问题 ， 仅仅 是 一个 简单 的 错误 引起 的 。 实际上 ， 系统 的 不 稳定 往往 是 由 这些 看似 很 简单 的 小 错误 导致 的 。 这个 问题 给 我们 教训 的 是 ： 在 直接 对 内存地址 进行 操作 时 ， 一定 要 保证 其值 的 合法性 ， 否则 容易 引起 内存 操作 越界 ， 给 系统 的 稳定性 带来 潜在 的 威胁 。 	 【 案例 1.2 . 4 】 	 近日 在 CDB 并行 测试 中 发现 一个 问题 ： 我们 需要 的 小区 负荷 话统 结果 总是 为 零 ， 开始 还 以为 小区 负荷 太小 ， 于是 加大 短消息 下发 数量 ， 但 还 为 零 ， 于是 在 程序 中 加入 测试代码 ， 把 收到 的 数据 在 BAM 上 打印 出来 , 	 结果 打印 出来 的 数据 正常 , 不 可能 为 零 , 仔细 查看 相关 代码 , 问题 只 可能 在 指针 移位 上 有 问题 , 果然 在 函数 中 发现 一处 比较 隐蔽 的 错误 。 / *   功能 : 一个 BM 模块 内 所有 小区 CDB 侧 广播 消息 忙 闲 情况           * / / * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * / void   Cell _ CBCH _ Load _ Static ( struct   MsgCB   FAR   * pMsg )             { 	 。 。 。 	 	 memcpy ( ( _ UC   * ) & tmp _ msg , pMsg , sizeof ( tmp _ msg ) ) ; 	 pMsg = pMsg + sizeof ( tmp _ msg ) ; / / sizeof ( tmp _ msg ) = 10 ; 本意 是 想 移动 10 个 字节 , 可是 实际上 指针 移动 了 10 * sizeof ( struct   MsgCB ) 个 字节 ; 	 CellNum = tmp _ msg . usCellNum ; 	 。 。 。             } 1             所以 结构 指针 传入 函数 后 ， 如 要 进行 指针 移动 操作 ， 最好 先 将 其 转化 为 _ UC 型 再说 。 总之 指针 操作 要 小心 为 上 。 3 、 避免 指针 的 非法 引用 【 案例 1.3 . 1 】 【 正                         文 】 在 一次 测试 中 ， 并 没有 记得 做 了 什么 操作 ， 发现 HONET 系统 的 主机 复位 了 ， 之后 ， 系统 又 工作 正常 了 。 由于 没有 打开 后台 的 跟踪 窗口 ， 当时 查 了 半天 没有 眉目 。 过 了 半天 ， 现象 又 出现 了 ， 而且 这次 是 主机 在 反复 复位 ， 系统 根本无法 正常 工作 了 。 我 凭 记忆 ， 判断 应该 是 与 当时 正在 测试 的 DSL 板 的 端口配置 有关 。 于是 将板 上 所有 端口配置 为 普通 2B + D 端口 ， 重新 加载 在 主机 数据 ， 现象 消失 。 于是 初步 定位 为 主机 在 DSL 端口 处理过程 中有 重大 错误 。 我 在 新 的 数据 上 努力 恢复原 出 问题 的 现象 ， 却 一直 没有 重现 ， 于是 恢复原 数据 ， 加载 后 立即 重现 。 并 注意 到 ， 当 DSL 端口 激活 时 ， 主机 复位 。 仔细 比较 两种 数据 的 差别 ， 发现 出现 主机 复位 问题 的 数据 中 DSL 板 配置 了 MNT / MLT 端口 ， 但是 没有 做 DSL 端口 之间 的 半 永久 数据 。 于是 在 程序 中 不断 加 打印 语句 ， 通过 后台 的 DBWIN 调试程序 跟踪 ， 最后 终于 定位 为 ： 每当 执行 到 portdsl . c 的 DeviceDslMsgProc ( ) 函数 中 处理 U 口透传 的 if   (   SPC _ STATE _ OK   = =   pSpcCB - > bySpcState   ) 语句 时 ， 主机 复位 。 但是 该 语句 似乎 并 无 不妥 。 再 分析 整个 函数 ， pSpcCB 在 函数 前 部分 已经 被 赋值 ， pSpcCB   =   SpcCB   +   ( PortTable + index ) - > spcNo ; 但 由于 得到   index   后 ， 没有 任何 判断 ， 导致 若 MNT / MLT 端口 没有 做半 永久 ， 端口 激活 后 ， 执行 此 部分 函数 ， ( PortTable + index ) - > spcNo   有 可能 为 NULL _ WORD ， 于是 ， 运算 后 ， pSpcCB   可能 为 非法 值 。 此时 主机 在 取 进行 判断 ， 就 不知 会 导致 什么 后果 了 。 其实 ， 改 起来 很 简单 ， 只要 在 这 两句 前 增加 一个 判断 就行了 。 于是 ， 修改 代码 为 ： if   (   ( PortTable + index ) - > spcNo   ! =   NULL _ WORD ) { 	 pSpcCB   =   SpcCB   +   ( PortTable + index ) - > spcNo ; 	 if   (   SPC _ STATE _ OK   = =   pSpcCB - > bySpcState   ) 	 { 。 。 。 } } 	 修改 后 ， 问题 不再 重现 。 经过 分析 可以 发现 ， 编译 环境 是 有 很大 的 容许 空间 的 ， 若 主机 没有 做 充分 的 保护 ， 很 可能 会 有 极 严重 的 随即 故障 出现 。 所以 编程 时 一定 要 考虑 各种 可能 情况 ； 而 测试 中 遇到 此类 死机 问题 ， 则 要 耐心 的 定位 到 具体 是 执行 哪句 代码 时 出现 的 ， 再 进行 分析 。 因为 问题 很 隐蔽 ， 直接 分析 海 一样 的 代码 是 很 难 发现 的 。 4 、 变量 类型定义 错误 【 案例 1.4 . 1 】 【 正                         文 】                 在 FRI 板上 建 几条 FRPVC ， 其 DLCI 类型 分别 为 ： 10Bit / 2bytes 、 10bit / 3bytes 、 16bit / 3bytes 、 17bit / 4bytes 、 23bit / 4bytes 。 相应 的 DLCI 值为 ： 16 、 234 、 991 、 126975 、 1234567 ， 然后 保存 ， 重起 MUX ， 观察 PVC 的 恢复 情况 ， 结果 DLCI 值为 16 、 234 和 991 的 PVC 正确 恢复 ， 而 DLCI = 126975 的 PVC 恢复 的 数据 错误 为 61439 ， 而 DLCI = 1234567 的 PVC 完全 没有 恢复 。                 对于 17 / 4 类型 ， DLCI = 126975 的 PVC 在 恢复 时 变成 61439 ， 根据 这 条 线索 ， 查找 原因 ， 发现 126975 - 61439 = 65535 ， 转化 二进制 就是 10000000000000000 ， 也就是说 在 数据恢复 或 保存 时 把 原 数据 的 第一个 1 给 忽略 了 。 此时 第一个 想法 是 ： 在 程序处理 中 ， 把 无 符号长 整型 变量 当作 短 整型 变量 处理 了 ， 为了 证实 这个 判断 ， 针对 17bit / 4bytes 类型 又 重新 设计 测试用例 ： （ 1 ）   先建 PVC ， DLCI = 65535 ， 然后 保存 ， 重起 MUX ， 观察 PVC 的 恢复 情况 ， 发现 PVC 能够 正确 恢复 ； （ 2 ） 再建 PVC ， DLCI = 65536 ， 然后 保存 ， 重起 MUX ， 观察 PVC 的 恢复 情况 ， 此时 PVC 不能 正确 恢复 。 至此 基本 可以 断定 原因 就是 出 在 这里 。 带 着 这个 目的 查看 原代码 ， 发现 在 以下 代码 中有 问题 ： int 	 _ GetFrDlci (   DWORD *   dwDlci ,   char *   str ,   DWORD   dwDlciType ,   DWORD   dwPortType ,   DWORD   dwSlotID ,   DWORD   dwPortID ) {                     DWORD     tempDlci ; 	 char 	 szArg [ 80 ] ; 1 	 char 	 szLine [ 80 ] ; 	 ID 	 LowPVCEP ;                         DWORD 	 dwDlciVal [ 5 ] [ 2 ]   =       	 	 {   { 16 , 1007 } ,   { 16 , 1007 } ,   { 1024 , 64511 } ,       	 	     { 2048 , 129023 } ,   { 131072 , 4194303 }   }   ;                         ． ． ． } typedef   struct   tagFrPppIntIWF { 	 ． ． ． 	 WORD 	 wHdlcPort ; 	 WORD 	 wHdlcDlci ;             	 WORD 	 wPeerHdlcDlci ;       	 WORD 	 wPeerOldAtmPort ; 	 ． ． ． 	 } 	 SFrPppIntIWFData ; DWORD   	 SaveFrNetIntIWFData   (   DWORD   * pdwWritePoint   ) { 	 BYTE 	 bSlotID ,   bPeerSlotID ; 	 DWORD 	 dwCCID ,   dwPeerCCID ; 	 WORD 	 wHdlcPort ,   wAtmPort ,   wIci ,   wPeerIci ,   wPeerHdlcPort   ; 	 WORD 	 wCount ;                         ． ． ． } DWORD   	 SaveFrNetExtIWFData   (   DWORD   * pdwWritePoint   ) { 	 BYTE 	 bSlotID ; 	 DWORD 	 dwCCID ,   dwPeerCCID ; 	 WORD 	 wHdlcPort ,   wAtmPort ,   wIci   ; 	 WORD 	 wCount ; 	 ． ． ． unSevData . FrNetExtIWF [ wCount ] . bSlotID 	 =   bSlotID ; 	 unSevData . FrNetExtIWF [ wCount ] . wHdlcPort 	 =   wHdlcPort ; 	 unSevData . FrNetExtIWF [ wCount ] . wHdlcDlci 	 =   gFrPVCEP [ bSlotID   ] [   gFrPVCC [ bSlotID ] [ dwCCID ] . dwLoPVCEP   ] . dwDLCI ; 	 unSevData . FrNetExtIWF [ wCount ] . wOldAtmPort 	 =   wAtmPort ; 	 unSevData . FrNetExtIWF [ wCount ] . wAtmDlci 	 =   gFrPVCEP [   bSlotID   ] [   gFrPVCC [ bSlotID ] [ dwCCID ] . dwHiPVCEP   ] . dwDLCI ; 	 unSevData . FrNetExtIWF [ wCount ] . dwMapMode   =   gFrPVCC [ bSlotID ] [ dwCCID ] . dwMapMode ; 　 　 　 　 　 ． ． ．               } DWORD   RestoreFrNetExtIWFData   (   WORD   wSlotID ,   BYTE   * pReadPoint   ) { 	 WORD 	 wCount ,   wTotalNetIWF ; 	 BYTE 	 bSlotID ,   bHdlcDlciType ,   bAtmDlciType ; 	 WORD 	 wOldAtmPort ,   wAtmDlci ,   wHdlcPort ,   wHdlcDlci ;     	 DWORD 	 dwMapMode ,   dwCIR ,   dwBe ; 	 DWORD 	 dwCCID ,   dwResult ,   dwAtmPort ; 	 wTotalNetIWF   =   g _ MuxData . SevDataSize . wFrNetExtIWFNum ; 	 ． ． ． } DWORD   RestoreFrHdlcIntIWFData   (   WORD   wSlotID ,   BYTE   * pReadPoint   ) { 	 WORD 	 wCount ,   wTotalHdlcIWF ; 	 DWORD 	 dwCCID ,   dwPeerCCID ,   dwAtmPort ,   dwPeerAtmPort ; 	 DWORD 	 dwResult ; 	 BYTE 	 bSlotID ,   bPeerSlotID ; 	 WORD 	 wHdlcPort ,   wOldAtmPort ,   wCIR ; 	 WORD 	 wPeerHdlcPort ,   wPeerOldAtmPort ;                         ． ． ． }                 其中 涉及 DLCI 值 的 变量 都 为 WORD （ 即 无 符号 短 整型 ） 类型 ， 在 程序 的 处理 时 ， 出现 WORD 和 DWORD （ 无 符号长 整型 ） 类型 在 一句 中 同时 存在 的 情况 ， 至此 可以 判断 问题 出 在 这里 。 由于 DLCI 值 在 不同 类型 时 的 取值 范围 不同 ， 前 三种 类型 的 取值 范围 为 16 ~ 991 ， 第四种 取值 范围 为 2048 ~ 126975 ， 第五种 取值 范围 为 131072 ~ 4194303 ， 所以 当 采用 前 三种 DLCI 类型 时 ， 采用 WORD 类型 最大值 为 65535 ， 已经 完全 够用 了 ； 而 对于 第四种 类型 时 ， 其 取值 在 超过 65535 时 ， 获取 DLCI 值 的 函数 _ GetFrDlci （ ） 采用 DWORD 类型 ， 而 负责 保存 和 恢复 的 两个 函数 SaveFrNetExtIWFData （ ） 和 RestoreFrNetExtIWFData （ ） ， 都 把 DLCI 的 值 当作 WORD 类型 进行 处理 ， 因此 导致 DLCI 取值 越界 ， 于是 程序 把 原本 为长 整型 的 DLCI 强制 转换成 整型 ， 从而 导致 DLCI 值 在 恢复 时 ， 比原 数据 小 65536 。 而 在 程序运行 过程 中 ， 这些 数据 保存 在 DRAM 中 ， 程序运行 直接 从 DRAM 中 获取数据 ， 程序 不会 出错 ； 当 FRI 板 复位 或 插拔 后 ， 需要 从 FLASH 中 读取数据 ， 此时 恢复 函数 的 错误 就 表现 出来 。               另 一个 问题 是 为什么 23 / 4 类型 的 DLCI 数据 不能 恢复 ？ 这是 由于 对于 23 / 4 类型 的 PVC ， 其 DLCI 的 取值 范围 为 ： 131072 ~ 4194303 ， 而 程序 强制 转换 并 恢复 的 数据 最大 只能 是 65535 ， 所以 这条 PVC 不能 恢复 。                 至此 ， DLCI 数据恢复 出错 的 原因 完全 找到 ， 解决 的 方法 是 将 DLCI 的 类型 改为 DWORD 类型 。 从 这个 案例 可以 看出 ， 在 程序开发 中 一个 很 低级 的 错误 ， 将 在 实际 工作 中 造成 很 严重 的 后果 。 【 案例 1.4 . 2 】 【 正                         文 】                 在 FRI 板上 建 几条 FRPVC ， 其 DLCI 类型 分别 为 ： 10Bit / 2bytes 、 10bit / 3bytes 、 16bit / 3bytes 、 17bit / 4bytes 、 23bit / 4bytes 。 相应 的 DLCI 值为 ： 16 、 234 、 991 、 126975 、 1234567 ， 然后 保存 ， 重起 MUX ， 观察 PVC 的 恢复 情况 ， 结果 DLCI 值为 16 、 234 和 991 的 PVC 正确 恢复 ， 而 DLCI = 126975 的 PVC 恢复 的 数据 错误 为 61439 ， 而 DLCI = 1234567 的 PVC 完全 没有 恢复 。                 对于 17 / 4 类型 ， DLCI = 126975 的 PVC 在 恢复 时 变成 61439 ， 根据 这 条 线索 ， 查找 原因 ， 发现 126975 - 61439 = 65535 ， 转化 二进制 就是 10000000000000000 ， 也就是说 在 数据恢复 或 保存 时 把 原 数据 的 第一个 1 给 忽略 了 。 此时 第一个 想法 是 ： 在 程序处理 中 ， 把 无 符号长 整型 变量 当作 短 整型 变量 处理 了 ， 为了 证实 这个 判断 ， 针对 17bit / 4bytes 类型 又 重新 设计 测试用例 ： （ 1 ）   先建 PVC ， DLCI = 65535 ， 然后 保存 ， 重起 MUX ， 观察 PVC 的 恢复 情况 ， 发现 PVC 能够 正确 恢复 ； （ 2 ） 再建 PVC ， DLCI = 65536 ， 然后 保存 ， 重起 MUX ， 观察 PVC 的 恢复 情况 ， 此时 PVC 不能 正确 恢复 。 至此 基本 可以 断定 原因 就是 出 在 这里 。 带 着 这个 目的 查看 原代码 ， 发现 在 以下 代码 中有 问题 ： int 	 _ GetFrDlci (   DWORD *   dwDlci ,   char *   str ,   DWORD   dwDlciType ,   DWORD   dwPortType ,   DWORD   dwSlotID ,   DWORD   dwPortID ) {                     DWORD     tempDlci ; 	 char 	 szArg [ 80 ] ; 	 char 	 szLine [ 80 ] ; 	 ID 	 LowPVCEP ;                         DWORD 	 dwDlciVal [ 5 ] [ 2 ]   =       	 	 {   { 16 , 1007 } ,   { 16 , 1007 } ,   { 1024 , 64511 } ,       	 	     { 2048 , 129023 } ,   { 131072 , 4194303 }   }   ;                         ． ． ． } typedef   struct   tagFrPppIntIWF { 	 ． ． ． 	 WORD 	 wHdlcPort ; 	 WORD 	 wHdlcDlci ;             	 WORD 	 wPeerHdlcDlci ;       	 WORD 	 wPeerOldAtmPort ; 	 ． ． ． 	 } 	 SFrPppIntIWFData ; DWORD   	 SaveFrNetIntIWFData   (   DWORD   * pdwWritePoint   ) { 	 BYTE 	 bSlotID ,   bPeerSlotID ; 	 DWORD 	 dwCCID ,   dwPeerCCID ; 	 WORD 	 wHdlcPort ,   wAtmPort ,   wIci ,   wPeerIci ,   wPeerHdlcPort   ; 	 WORD 	 wCount ;                         ． ． ． } DWORD   	 SaveFrNetExtIWFData   (   DWORD   * pdwWritePoint   ) { 	 BYTE 	 bSlotID ; 	 DWORD 	 dwCCID ,   dwPeerCCID ; 	 WORD 	 wHdlcPort ,   wAtmPort ,   wIci   ; 	 WORD 	 wCount ; 	 ． ． ． unSevData . FrNetExtIWF [ wCount ] . bSlotID 	 =   bSlotID ; 	 unSevData . FrNetExtIWF [ wCount ] . wHdlcPort 	 =   wHdlcPort ; 	 unSevData . FrNetExtIWF [ wCount ] . wHdlcDlci 	 =   gFrPVCEP [ bSlotID   ] [   gFrPVCC [ bSlotID ] [ dwCCID ] . dwLoPVCEP   ] . dwDLCI ; 	 unSevData . FrNetExtIWF [ wCount ] . wOldAtmPort 	 =   wAtmPort ; 	 unSevData . FrNetExtIWF [ wCount ] . wAtmDlci 	 =   gFrPVCEP [   bSlotID   ] [   gFrPVCC [ bSlotID ] [ dwCCID ] . dwHiPVCEP   ] . dwDLCI ; 	 unSevData . FrNetExtIWF [ wCount ] . dwMapMode   =   gFrPVCC [ bSlotID ] [ dwCCID ] . dwMapMode ; 　 　 　 　 　 ． ． ．               } DWORD   RestoreFrNetExtIWFData   (   WORD   wSlotID ,   BYTE   * pReadPoint   ) { 	 WORD 	 wCount ,   wTotalNetIWF ; 	 BYTE 	 bSlotID ,   bHdlcDlciType ,   bAtmDlciType ; 	 WORD 	 wOldAtmPort ,   wAtmDlci ,   wHdlcPort ,   wHdlcDlci ;     	 DWORD 	 dwMapMode ,   dwCIR ,   dwBe ; 	 DWORD 	 dwCCID ,   dwResult ,   dwAtmPort ; 	 wTotalNetIWF   =   g _ MuxData . SevDataSize . wFrNetExtIWFNum ; 	 ． ． ． } DWORD   RestoreFrHdlcIntIWFData   (   WORD   wSlotID ,   BYTE   * pReadPoint   ) { 	 WORD 	 wCount ,   wTotalHdlcIWF ; 	 DWORD 	 dwCCID ,   dwPeerCCID ,   dwAtmPort ,   dwPeerAtmPort ; 	 DWORD 	 dwResult ; 	 BYTE 	 bSlotID ,   bPeerSlotID ; 	 WORD 	 wHdlcPort ,   wOldAtmPort ,   wCIR ; 	 WORD 	 wPeerHdlcPort ,   wPeerOldAtmPort ;                         ． ． ． }                 其中 涉及 DLCI 值 的 变量 都 为 WORD （ 即 无 符号 短 整型 ） 类型 ， 在 程序 的 处理 时 ， 出现 WORD 和 DWORD （ 无 符号长 整型 ） 类型 在 一句 中 同时 存在 的 情况 ， 至此 可以 判断 问题 出 在 这里 。 由于 DLCI 值 在 不同 类型 时 的 取值 范围 不同 ， 前 三种 类型 的 取值 范围 为 16 ~ 991 ， 第四种 取值 范围 为 2048 ~ 126975 ， 第五种 取值 范围 为 131072 ~ 4194303 ， 所以 当 采用 前 三种 DLCI 类型 时 ， 采用 WORD 类型 最大值 为 65535 ， 已经 完全 够用 了 ； 而 对于 第四种 类型 时 ， 其 取值 在 超过 65535 时 ， 获取 DLCI 值 的 函数 _ GetFrDlci （ ） 采用 DWORD 类型 ， 而 负责 保存 和 恢复 的 两个 函数 SaveFrNetExtIWFData （ ） 和 RestoreFrNetExtIWFData （ ） ， 都 把 DLCI 的 值 当作 WORD 类型 进行 处理 ， 因此 导致 DLCI 取值 越界 ， 于是 程序 把 原本 为长 整型 的 DLCI 强制 转换成 整型 ， 从而 导致 DLCI 值 在 恢复 时 ， 比原 数据 小 65536 。 而 在 程序运行 过程 中 ， 这些 数据 保存 在 DRAM 中 ， 程序运行 直接 从 DRAM 中 获取数据 ， 程序 不会 出错 ； 当 FRI 板 复位 或 插拔 后 ， 需要 从 FLASH 中 读取数据 ， 此时 恢复 函数 的 错误 就 表现 出来 。               另 一个 问题 是 为什么 23 / 4 类型 的 DLCI 数据 不能 恢复 ？ 这是 由于 对于 23 / 4 类型 的 PVC ， 其 DLCI 的 取值 范围 为 ： 131072 ~ 4194303 ， 而 程序 强制 转换 并 恢复 的 数据 最大 只能 是 65535 ， 所以 这条 PVC 不能 恢复 。                 至此 ， DLCI 数据恢复 出错 的 原因 完全 找到 ， 解决 的 方法 是 将 DLCI 的 类型 改为 DWORD 类型 。 从 这个 案例 可以 看出 ， 在 程序开发 中 一个 很 低级 的 错误 ， 将 在 实际 工作 中 造成 很 严重 的 后果 。 5 、 正确 使用 逻辑 与 && 、 屏蔽 & 操作符 【 案例 1.5 . 1 】 【 案例 描述 】 ： 由于 C语言 中位 与 比求模 效率高 ， 因而 系统 设计 时 ， 对于 模 128 的 地方 都 改为 与 127 ， 系统 定义 的 宏为 # define   MOD128     127 和 # define   W _ MOD         127 ( 定义 的 宏 的 名字 易 引起 误解 ) ， 但 实际 程序 中 还是 采取 求模 ， 从而 引起 发送窗口 欲 重发 的 和 实际 重发 的 不 一致 ， 最终 导致 链路 复位 此类 严重 问题 ， 曾 在 定位 此 问题 时花 了 不少 时间 。 【 处理过程 】 ： 处理过程 如下 ： # define           MOD128                     127     / / 队列 长 128 ， 当队 头 到 128 时 ， 上 其 返回 。 # define         W _ MOD                       127   / / 发送窗口 队列 ， 意义 同 上 。 在 函数 L2 _ TO _ L1 ( ) 中 ， 有 如下 语句 ：                 linkstate _ ptr - > SendWin . head   =   ( head   +   1 )   %   W _ MOD   ; 这里 当 head = 126 时 ， SendWin . head   =   0 ， 这 将 造成 发送窗口 指针 和 队列 窗口 指针 错位 ， 造成 链路 复位 ; 另外 ， 在 重发 函数 void   INVOKE _ RETRANSMISSION ( _ US   logic _ link , _ US   n _ r ) 中 ， 有 如下 语句 ：                 retran _ num   =   ( LinkState [ logic _ link ] . Vs   +   MOD128     -   ( _ UC ) n _ r )   %     MOD128   ;                 w _ head   =   ( LinkState [ logic _ link ] . SendWin . head   +   W _ MOD     -   retran _ num )   %   W _ MOD   ; 第一个 语句 求欲 重发 的 消息 包 个数 ， 第二个 语句 求 重发 的 起始 位置 ， 当 Vs 小于 n _ r 时 ， 将 造成 实际 重发数 小于 欲重 发数 ， 同时 造成 实际 起始 重 发 位置 和 欲 重 发起 始 位置 错开 ， 从而 引起 链路 复位 。 上面 三个 语句 应该 做 如下 改动 ：                 linkstate _ ptr - > SendWin . head   =   ( head   +   1 )   &   W _ MOD   ;                 retran _ num   =   ( LinkState [ logic _ link ] . Vs   +   MOD128     +   1   -   ( _ UC ) n _ r )   &     MOD128   ;                 w _ head   =   ( LinkState [ logic _ link ] . SendWin . head   +   W _ MOD   +   1   -   retran _ num )   &   W _ MOD   ; 【 结     论 】 ： 由于 链路 通信 对系统 效率 要求 很 高 ， 算法 采用 效率 最高 的 ， 但位 与 （ & ） 和 求模 （ % ） 这 小小的 区别 ， 造成 的 竟是 链路 复位 这种 严重 的 错误 。 【 思考 与 启示 】 ： 对 这类 问题 ， 大家 在 阅读 代码 或 代码 审查 时 一定 要 注意 ， 仔细 一点 往往 能 发现 问题 ， 但 在 测试 中来 定位 这种 问题 ， 花费 的 时间 往往 更长 。 6 、 注意 数据类型 的 匹配 【 案例 1.6 . 1 】 【 案例 描述 】 	 下面 通过 测试 中 的 一个 例子 来 说明 这个 问题 ： 命令 DSP   N7C 是 用来 显示 NO7 电路状态 的 ， 其 参数 设备 类型 DID 支持 TUP 和 ISUP ， 参数 信道 号 BSN 支持 多值 输入 （ 最 多 支持 32 路 查询 ） ， 正常 情况 下该 命令 没有 问题 。 但试 了 非正常 情况 下 ， 问题 就 出来 了 。 	 1 、 首先 试 BSN 参数 越界 情况 ， 即 参数 BSN 超过 32 路 查询 ， 选 了 几个 数据 段 ， 问题 就 出来 了 。 对于 0 && 300 和 0 && 256 ， 该 命令 返回 结果 不 一致 ， 对 前者 认为 参数 越界 ， 对 后者 返回 执行 成功 。 	 2 、 对于 参数 DID ， 选定 一种 设备 类型 （ TUP 或 ISUP ） ， 让 参数 BSN 所 包含 的 32 路电路 跨越 TUP 和 ISUP ， 两次 结果 是 不 一致 的 。 【 处理过程 】 	 反馈 到 开发人员 那里 ， 第一个 问题 是 BAM 的 问题 ， 第二个 问题 是 SM 的 问题 。 【 结     论 】 	 1 、 为 数据 超出范围 溢出 造成 ， int 值 赋值 给 BYTE ， 造成 数据 丢失 。 	 2 、 问题 的 产生 是因为 查询 的 第一个 信道 是 TUP 电路 ， 但是 却 按 ISUP 电路 查询 。 ISUP 的 维护 处理函数 判断 第一个 信道 不是 ISUP 信道 ， 认为 整个 的 PCM 不是 ISUP 类型 的 PCM ， 返回 全部 的 电路状态 为 未 安装 。 消息 处理 不合理 。 TUP 也 会 产生 如此 错误 。 【 思考 与 启示 】 	 我们 的 MML 命令 并 不是 无懈可击 的 ， 许多 表面 上 的 小 问题 ， 往往 隐藏 着 代码 的 缺陷 和 错误 。 【 案例 1.6 . 2 】 【 正                         文 】 当 我们 使用 PC - LINT 检查 代码 时 ， 会 发现 大量 的 数据类型 不 匹配 的 告警 ， 大部分 情况 下 ， 这种 代码 上 存在 的 问题 并 不会 引起 程序 功能 实现 上 的 错误 ， 但 有些 情况 下 ， 也许 会 产生 严重 的 问题 ：               一 、 不同 数据类型 变量 之间 赋值 引起 的 问题 ， 实际上 ， 该类 问题 也 可以 分为 几种 情况 ： 1 、 直接 赋值 ， 比如 ， 把 一个 WORD 型 变量 赋给 一个 INT 型 变量 ， 如果 WORD 型 变量 大于 32767 ， INT 型 变量 得到 的 就是 一个 负值 了 。   【 例一 】 一次 测试 过程 中 发现 ， SDH 送 的 告警 在 BAM 调试 窗口 打印 出 红色 提示 ： File ( XXX ) , Line ( XXX ) : Invalid   alarm   id   , from :   7 ,   AlarmId :   65463 经过 检查数据 发现 ， 并 没有 ID 为 65463 的 告警 ， 分析 上报 的 数据 帧 ， 发现 上报 的 告警 ID 为 B7 ， 原来 代码 中有 一处 强制 类型转换 ：                         sdhAlmStru . AlarmId   =   ( WORD ) RecvBuffer [ iTmpLen   +   5 ] ; char 型 强制 转换成 WORD 型 。 B7 就 变成 了 FFB7 ， 十进制 就是 65463 。 由于 char 是 有 符号 型 ， B7 的 第 8 位为 1 ， 所以 转换 后 为 FFB7 ， 而 不是 代码 作者 希望 的 00B7 ， 如果 第 8 位是 0 ， 或 该 变量 是 BYTE 型 ， 转换 就 不会 有 问题 了 。 2 、 函数 形参 和 实参 不 一致 ， 实际上 和 第一种 情况 本质 上 是 一样 的 ， 只是 表现 的 形式 不太 一样 ， 这种 情况 也 是 代码 中 经常出现 的 问题 , 下面 例子 是 测试 中 曾经 发现 的 一个 小 问题 ： 【 例二 】 在 file01 中 的 INT   DebugMsgProc ( char   byMsg0 ,   char   byMsg1 ) 函数 ， 两个 形参 都 是 char 型 ， 而 实际 传入 的 参数 都 是 BYTE 型 ， 结果 函数 中 的 如下 语句 ： PrintfE ( PID _ RED , "   % d   ticks   time   out ! " , byMsg1 ) ; 在 byMsg1 大于 127 时 ， 输出 错误 的 结果 。         二 、 不同 数据类型 之间 的 比较 操作 在 循环 终止 条件 的 判断 中 ， 不同 类型 变量 的 比较 操作 是 容易 造成 死循环 错误 的 地方 ， 同时 也 是 开发人员 容易 忽视 的 地方 ， 值得 测试人员 多加 留意 。 下面 两个 例子 是 该类 错误 的 两种 典型 情况 ： 【 例三 】 file02 文件 中 某 函数 中 如下 代码 ， 可能 造成 死循环 ：                   ......                         int   i ; 	 WORD   * pCheck     = ( WORD * ) p ; 	 WORD   wCheckSum = * pCheck ; 	 pCheck ++ ; 	 for ( i = 1 ; i < dwLen / 2 ; i ++ ) 	 { 	 	 wCheckSum ^ = ( * pCheck ) ; 	 	 pCheck ++ ; 	 } 	 / / binlen   had   already   word   alignment 	 return   ( wCheckSum ) ; 	 	 	 ......       该段 代码 是 在 DOS 环境 下用 BC 编译 的 ， 由于 循环 变量 i 是 int 型 （ 2 个 字节 ） ， 而 dwLen 是 DWORD 型 （ 4 个 字节 ） ， 如果 dwLen 大于 65536 ， 那么 该 函数 就是 死循环 了 。 上面 的 例子 是 不同 类型 变量 之间 直接 比较 操作 ， 还有 一种 情况 是 函数 的 返回值 与 另 一 不同 类型 的 变量 比较 ， 见 下面 例子 ： 【 例四 】 file03 . c 文件 中 某 函数 中 如下 代码 ，           	 	 while (   ftell ( fp ) <   Part [ 3 ] ) 	 	 { .....                                                   } 	     ftell 返回 long 型 ， 而 Part 是 DWORD 型 ， 有 符号 变量 和 无 符号 变量 的 比较 ， 可能 造成 死循环 。 类似 的 例子 还有 很多 ， 类型 不 匹配 的 问题 还有 许多种 情况 ， 都 是 代码 中 的 隐患 ， 有时 会 造成 严重 的 后果 ， 需要 引起 足够 的 重视 。 对于 该类 问题 ， 我们 可以 利用 PC - LINT 工具 对 代码 进行 细致 的 检查 。 7 、 用于 控制 条件 转移 的 表达式 及 取值 范围 是否 书写 正确 【 案例 1.7 . 1 】 【 案例 描述 】 ： 	 在 测试主机 MPU 板 倒换 功能 时 ， 如果 MPU 备份 充分 ， 倒换 前后 对 处于 激活状态 的 电路 应 无 影响 ， 即 不 影响 通话 。 但 近期 测试 发现 ， 如果 两局 通过 DT 板 进行 一号 对接 ， MPU 备份 倒换 却 发生 断话 。 具体 现象 为 ： 如果 DT 板 的 第 1 个 PCM 系统 电路 为 故障 ， 则 MPU 倒换 时 复位 该 DT 板 ， 如果 DT 板 的 第 2 个 PCM 系统 电路 为 故障 ， 则 MPU 倒换 时 复位 下 一块 DT 。 【 处理过程 】 ： 	 据查 ， MPU 倒换 时会 自动 复位 处于 “ 故障 ” 态 的 电路 ， 但 由于 计算错误 （ 多加 了 32 ） ， 错 复位 了 下 一个 PCM 系统 32 路电路 。 【 结     论 】 ： 	 如此 严重 问题 为什么 到 今天 才 发现 ？ 因为 我们 在 实验室 中 一般 采用 同一 单板 的 2 个 PCM 系统 自环 进行 测试 ， 则 不会 在 某 单板 上 有 故障 和 空闲 电路 共存 ， 自环 屏蔽 了 错误 。 【 思考 与 启示 】 ： 	 自环 是 在 测试环境 下 常用 的 一种 提高效率 的 手段 ， 但 一旦 条件 允许 ， 我们 的 测试 工作 应 尽量 模拟 网上 的 实际 环境 进行 。 【 案例 1.7 . 2 】 	 平时 对 计费 功能 进行 测试 的 时候 ， 浏览 详细 话单 都 是 比较 注意 话单 本身 的 正确性 ， 并 没有 注意 该 命令 对系统 的 影响 。 所以 当 浏览 少量 话单 的 时候 ， 并 没有 发现 该 命令 的 异常 。 但是 当 时间 的 跨度 较大 时 ， 详细 话单 数量 较 多 ， 问题 就 出现 了 。 执行 如下 命令 ： 	 LST   AMA :   TP = NRM ,   SD = 1999 & 7 & 1 ,   SA = YES ; 	 当 浏览 了 大约 10 万张 详细 话单 后 ， 终端 与 BAM 的 连接 关闭 。 重建 连接 后 ， 发现 话单 台 的 命令 不能 执行 。 观察 BAM 的 性能 ， 发现 话单 台 仍 占有 CPU50 % 以上 的 利用率 ， 说明 原来 的 任务 仍 在 执行 。 需要 关 一下 话单 台 才能 恢复正常 。 	 重复 上述 步骤 ， 当 终端 与 BAM 的 连接 尚未 关闭 时 主动 断开 此次 连接 ， 结果 同 上 。 	 反馈 到 开发人员 那里 ， 发现 该 现象 与 设计 的 初衷 是 相 违背 的 。 本来 话单 台 控制 最 多 输出 200 张 话单 ， 这是 为了 防止 过多 话单 的 输出 显示 会 增加 BAM 的 开销 ， 从而 降低 BAM 的 性能 。 查看 一下 源代码 ， 问题 就 发现 了 。 	 话单 台 控制 最 多 输出 200 张 话单 程序 如下         while ( timeCur   < =   timeEnd )         { 	 timeCur   + =   tsOneDay ; / / 加 一天 	 while ( fileBill . Read ( & rpt ,   sizeof ( CBillReport ) )   = =   	 	 sizeof ( CBillReport ) ) 	 {                                   ..................... 	                                                   / / 只 输出 满足条件 的 前 200 张 话单 	                   if   ( ++ wBillCount   = =   200 ) 	                 { 	 	 break ; 	                 } 	 } / / 一个 文件 查询 结束       } / / 所有 文件 查询 结束 	 在 话单 输出 200 张 之后 ， 程序 只 退出 一层 循环 ， 仍然 会 从 下 一天 话单 继续 输出 ， 导致 向 MML 发帧 过 多 ， 造成 MML 和 话单 台 都 被 堵死 。 	 修改 ProcessQueryBill ( ) 函数           / / 只 输出 满足条件 的 前 200 张 话单           if   ( ++ wBillCount   = =   200 )           {                   	 timeCur   =   timeEnd   +   tsOneDay ; / / 退出 第二层 循环 , 	 	 while ( timeCur   < =   timeEnd ) 	 	 	 break ;           }                 	 作 上述 修改 后 问题 就 不再 出现 了 。 	 一些 MML 命令 从 完成 的 功能 来讲 可能 是 没什么 问题 的 ， 但 其 执行 对系统 性能 的 影响 我们 在 测试 时时 往往 给 忽视 了 。 在 我们 目前 的 BAM 方案 中 ， 存在 着 多个 终端 协同工作 ， 如果 某个 终端 发出 的 命令 在 BAM 中 长时间 独占 着 大部分 系统资源 ， 造成 的 后果 是 严重 的 。 这 是 在 设计 时要 避免 的 ， 在 测试 中要 注意 的 问题 。 【 案例 1.7 . 3 】 【 正                         文 】 	 在 判断 模拟 用户 端口 是否 反 极性 时有 这样 一段 程序 ：                 	 if   (   (   bsn   > =   g _ wASL32StartPSN   )   &&                         (   (   (   bsn   -   g _ wASL32StartPSN   )   %   32   )   = =   15     | |     (   (   bsn   -   g _ wASL32StartPSN   )   %   32   = =   16   )   )   ) 	 	 	 return   TRUE ;   	 if   (   (   bsn   %   16   )   = =   7   | |   (   bsn   %   16   )   = =   8   ) 	 	 	 return   TRUE ;   	   	 return   FALSE ; 	 作者 的 本意 是 如果 是 32 路 用户 板 （ 蓝色 字体 判断 ） ， 就 看 端口号 是否是 第 15 和 16 路 ， 如果 是 ， 就是 反 极性 端口 ， 返回 TRUE ， 否则 就 不是 ， 应该 返回 FALSE 。 但 代码 表达 的 意思 是 ： 如果 是 32 路 用户 板 并且 端口号 是 15 或 16 就 返回 真值 ， 否则 还要 执行 下边 语句 。 	 当 端口 在 32 路 用户 板上 ， 但 端口号 不是 15 或 16 时 ， 不同 的 32 路 端口 的 起始 地址 g _ wASL32StartPSN ， 会 导致 不同 的 非 15 、 16 端口 被 误认为 是 反 极性 端口 。 举个 例子 ， 当 g _ wASL32StartPSN 的 值 为 3000 时 ， 端口号 为 3000 （ 第一块 板上 的 第 0 个 端口 ） 就 被 认为 是 反 极性 端口 ， 这 与 作者 的 意图 完全 相悖 。 	 可以 将 代码 修改 如下 ：             	 if   (   (   bsn   > =   g _ wASL32StartPSN   )   	 	 { 	 	 	 if     (   (   (   bsn   -   g _ wASL32StartPSN   )   %   32   )   = =   15     | |     (   (   bsn   -     g _ wASL32StartPSN   )   %   32   = =   16   )   )   ) 	 	 	 return   TRUE ; 	 	 }   	 	 	   else 	 	 if   (   (   bsn   %   16   )   = =   7   | |   (   bsn   %   16   )   = =   8   ) 	 	 	 return   TRUE ;   	 return   FALSE ; 	 通过 这个 例子 ， 我 觉得 在 代码 审查 时 应该 留意 在 判断 条件 较 多 的 情况 下 ， 每个 输入 是否 都 能 正确 输出 ， 在 单元测试 、 集成 测试 、 系统 测试 时要 针对 边界值 设计 相应 的 测试用例 。 	 判断 条件 较多时 开发人员 也 应该 适当 分开 写 ， 既 使 代码 更 易读 ， 又 不 容易 出错 。 8 、 条件 分支 处理 是否 有 遗漏 【 案例 1.8 . 1 】 【 现     象 】                 在 接入网 主机 程序 的 代码 审查 中 ， 发现 dbquery . c 的 DBQ _ Init _ ANType 函数 中 如下 代码段 缺少 应有 的 条件 分支 ， 在 数据 异常 的 情况 下 ， 会 产生 较 严重 的 问题 。 【 处理过程 】                   该 错误 比较 隐蔽 ， 现在 说明 如下 ：                   Max2B1QStatTime   最大 统计 时间                   Max2B1QStatPortNum 最大 统计 端口数                   MAX _ 2B1Q _ STAT _ PSN               最大 统计 内存 分配 数量                   其中 ： Max2B1QStatTime （ 最大 统计 时间 ） 和 Max2B1QStatPortNum （ 最大 统计   端口数 ） 的 乘积 不能 大于 MAX _ 2B1Q _ STAT _ PSN                   程序 如下 ：                     / / 查询数据库 ， 获得 Max2B1QStatTime 的 值 	 directQueryCond . tupleNo   =   10 ; 	 error _ code   =   DB _ Query (   RID _ OTHERS _ PARA _ INFO ,   1 , 	 	 	 	 	 	       ( LPDBCondition ) & directQueryCond , 	 	 	 	 	 	       ( BYTE   FAR   * ) & tempstruct0   ) ; 	 / / 查询数据库 成功 	 if (   error _ code   = =   DB _ SUCCESS   ) 	 { 	 	 / / tempstruct0 . data 是 数据库 中为 Max2B1QStatTime 配置 的 值 	 	 if   (   tempstruct0 . data   >   MAX _ 2B1Q _ STAT _ PSN   ) 	 	 	 Max2B1QStatTime   =   MAX _ 2B1Q _ STAT _ PSN ; 	 	 else   if   (   tempstruct0 . data   ! =   0   ) 	 	 	 Max2B1QStatTime   =   tempstruct0 . data ; 	 }                     / / 查询数据库 ， 获得 Max2B1QStatPortNum 的 值 	 directQueryCond . tupleNo   =   11 ; 	 error _ code   =   DB _ Query (   RID _ OTHERS _ PARA _ INFO ,   1 , 	 	 	 	 	 	       ( LPDBCondition ) & directQueryCond , 	 	 	 	 	 	       ( BYTE   FAR   * ) & tempstruct0   ) ; 	 / / 查询数据库 成功 	 if (   error _ code   = =   DB _ SUCCESS   ) 	 { 	       / / tempstruct0 . data 为 数据库 中为 Max2B1QStatPortNum 配置 的 值 ， 如果 其 缺省值 和 Max2B1QStatTime 乘积 值 大于 MAX _ 2B1Q _ STAT _ PSN 的话 ： 	       if   (   ( tempstruct0 . data   *   Max2B1QStatTime )   >   MAX _ 2B1Q _ STAT _ PSN   )                                                                 	 Max2B1QStatPortNum   =   MAX _ 2B1Q _ STAT _ PSN   /   Max2B1QStatTime ;                             / / 如果 在 合理 范围 内且 不为 0 的话 ：                             else   if   (   tempstruct0 . data   ! =   0   )     	 	 Max2B1QStatPortNum   =   tempstruct0 . data ; 	 }                 此处 if - else   if   分支 没有 判断   值为 0 的 情况 ， 即 数据库 为 Max2B1QStatPortNum 配置 的 值 为 0 ：   tempstruct0 . data   = =   0 ， 则 Max2B1QStatPortNum 就 为 缺省值 32 。 【 结     论 】                 由于 内存 限制 ， Max2B1QStatTime （ 最大 统计 时间 ） 和 Max2B1QStatPortNum （ 最大 统计 端口数 ） 的 乘积 不能 大于 MAX _ 2B1Q _ STAT _ PSN ，                 如果 从 数据库 中 得到 Max2B1QStatTime 为 MAX _ 2B1Q _ STAT _ PSN ， 而 数据库 中 最大 统计 端口数 恰好 为 0 ， 由于 上述 代码 没有 对 tempstruct0 . data   = =   0 的 情况 进行 判断 ， Max2B1QStatPortNum 为 缺省值 32 ， 这样 Max2B1QStatTime 和 Max2B1QStatPortNum 乘积 已经 是 32 倍 MAX _ 2B1Q _ STAT _ PSN 了 ， 远远 超过 了 设计 内存 的 限制 。                   造成 这种 错误 的 原因 是 判断 语句 对 条件 判断 不 完整 。 【 思考 与 启示 】                 在 代码 审查 时 ， 应该 十分注意 条件 判断 的 的 完备 性 。 好多 问题 就是 因为 条件 判断 不 完全 造成 的 。 9 、 引用 已 释放 的 资源 【 案例 1.9 . 1 】 【 正                         文 】 	 在 计费 测试 的 过程 中 ， 用 呼叫器 进行 大 话务量 呼叫 测试 。 30 路话 路 通过 TUP 自环 呼叫 另外 30 路话 路 ， 计费数据 的 设定 是 这样 的 ： 通过 计费 情况 索引 对 主叫 计费 ， 得到 详细 话单 。 首先 保证 计费数据 设定 的 正确性 ， 打 了 几次 自环 电话 后 ， 查看 话单 正常 ， 则 开始 呼叫 。 呼叫 几万 次后 停止 呼叫 ， 取 话单 进行 观察 。 发现 这 30 路 每次 呼叫 总会 出现 一张 告警 话单 ， 其余 话单 正常 ， 该 告警 话单 相对 于 话 路 来说 是 随机 出现 的 。 	 通知 开发人员 后 ， 首先 我们 再次 对 计费数据 进行 了 确认 。 某个 用户 在 某 次呼叫 产生 了 告警 话单 ， 其上 一次 和 下 一次 呼叫 的 计费 情况 都 正常 ， 两次 呼叫 之间 的 时间 间隔 只有 几秒钟 ， 排除 了 人为 修改 数据 的 可能 。 开发人员 认为 是 CCB 的 问题 ， 后来 一查 果然如此 。 	 当中 继 选线 发生 了 同 抢 需要 重新 选线 时 ， CCB 的 reset _ CCB _ for _ reseatch _ called _ location ( ) 就 会 把 有关 的 呼叫 信息 清掉 ， 造成 计费 情况 分析 失败 ， 产生 计费 费用 为 0 的 告警 话单 。 	 更正 reset _ CCB _ for _ reseatch _ called _ location ( ) 中 清除 被叫 信息 的 代码 ， 重选 中继 时 不 清除 被叫 用户 这部分 属性 。 	 思考 与 启示 ： 	 1 、 在 计费 测试 过程 中 ， 对话 单 的 观察 很 重要 ， 不 应该 放过 任何 一个 细小 的 疑点 ； 	 2 、 计费 测试 仅仅 打 几次 电话 往往 达 不到 效果 ， 越 接近 用户 实际 使用 的 情况 越 可能 发现 问题 。 【 案例 1.9 . 2 】 【 案例 描述 】                 在 进行 128 模块 V5 用户 CENTREX 新 业务 测试 时 ， 偶然 遇到 一个 怪现象 ： 对 群内 一个 V5ST 用户 只 开放 MCT 权限 ， 在 进行 恶意 呼叫 追查 时 ， 有 一次 报 恶意 呼叫 追查 成功 音只 报 了 一半 ， 当 正要 报出 恶意 呼叫 的 号码 时 ， 业务 中断 重新 回到 通话 态 ， 随即 重新 追查 一次 ， 报 “ 已 申请 其它 新 业务 ， 本次 申请 不 成功 ” 。 恶意 呼叫 追查 与 任何 新 业务 都 不会 冲突 ， 而且 此 用户 也 只有 恶意 呼叫 追查 有权 ， 可以 肯定 此时 程序 出 问题 了 。 为了 重现 ， 再次 挂机 ， 重新 呼叫 ， 应用 此新 业务 ， 但 这个 现象 一直 没有 出现 。 大约 反复 操作 20 遍 ， 又 出现 了 一次 这样 的 情况 ， 显然 程序 中 可能 存在 某种 问题 。   【 处理过程 】                 出现 这个 问题 后 ， 及时 与 开发人员 A 取得 了 联系 ， 并 一起 试图 重现 这个 问题 ， 通过 许多次 的 反复 操作 ， 又 出现 了 一次 这种 情况 。 确认 问题 后 ， A 表现 出 高度 的 责任心 ， 马上 驾 调试 环境 ， 反复 调测 ， 终于 在 当天 就 逮住 了 狐狸尾巴 ：                 1 、 当 用户 接听 恶意 呼叫者 的 电话 ,   并 启动 恶意 呼叫 追查 业务 后 ,   在 V5 _ CR _ VOICETONE 状态 下 ,   只要 听 MCT 音 的 用户 用 脉冲 方式 拨 任意 一个 数字 ,   则 立即 停止 送 MCT 音 ,   而 将 用户 切换 回 与 恶意 呼叫者 的 通话 .     但是 程序 中 没有 对 拨号 类型 作 判断 ,   导致用户 若用 音频 拨号 也 会作 同样 的 处理 。                 2 、 除了 取消 此次 MCT 服务 ,   将 用户 切换 回 与 恶意 呼叫者 的 通话 外 ,     如果 不 释放 MCT _ HANDLE ,   由于 每个 模块 只有 一个 这样 的 资源 ,     则 下 一次 使用 MCT 业务 的 用户 不能 成功 ,   因为 会 在 申请 MCT _ HANDLE 时 失败 ,   V5 模块 和 ST 模块 在 这个 地方 处理 都 有 问题 ,   没有 将 MCT _ HANDLE 释放 掉 ,     对于 V5 用户 会 听 新 业务 失败 音 ,   对于 ST 用户 会 听 音乐 。                 当 不停 的 拨测 V5 用户 的 MCT 业务 时 ,   有时 在 听音 时 ,   可能 由于 网板 有 杂音 等 原因 ( 或 用户 碰 了 话机 的 按键 ) ,     导致 DTR 收到 一位 号 ,   则 会 立即 停止 此次 MCT 服务 ,   用户 会 听到 MCT 送音 突然 中断 ,   然后 恢复 了 与 恶意 呼叫者 的 通话 .   而 下次 再用 MCT 时 ,   由于 上面 所述 的 原因 ,   会 听到 新 业务 失败 音 ,   此次 失败 后 ,   无论 MCT _ HANDLE 分配 成功 与否 ,   该 用户 的 MCT 标志 都 被 置 为 1 ,   所以 在 用户 挂机 时 ,   会 将 该 模块 唯一 的 MCT _ HANDLE 资源 释放 掉 .   则 以后 该 功能 又 可以 正常 实现 。                 在 追查 这个 问题 时 ， 开发人员 A 又 发现 了 一个 可能 导致 死机 的 严重 问题 ： 在 用户 启动 MCT 服务 ,   正在 听报 追查 号码 的 MCT 音时 ,   若 恶意 用户 此时 挂机 ,     CCB 的 处理 中 ,   只 针对 ST 用户 送 DISCONNECT ,   而 对 V5ST 用户 送 的 是 RELEASE 消息 ,   这 导致 V5X 收到 此 消息 后 ,   将 该 V5ST 用户 的 cr2 清除 掉 ,   V5 _ USER _ TALBE [     ] .   cr2 变为 0xFFFF ,   这样 在 V5 _ CR _ VOICETONE 超时 后 ,     程序 中 会 检查 cr2 的 状态 是否 为 HOLD ,   当取 cr2 的 内容 时 ,   由于 cr2 已 被 清除 ,   会 发生 指针 越界 的 GP 错误 。   【 结     论 】                 通过 调测 发现 、 定位 并 解决问题 。 【 思考 与 启示 】                 我们 平常 一些 熟视无睹 的 业务 或 按 正常 流程 操作 没有 问题 的 业务 ， 不能 保证 它 就 一定 没有 问题 ， 要 善于 抓住 一丝一毫 的 异常现象 。 对于 很难 重现 的 问题 千万 不要 轻易 放过 ， 我们 网上 设备 所出 的 问题 很多 都 是 一些 在 实验室 难以 出现 或 很 难 重现 的 一些 问题 ， 一些 显而易见 的 问题 一般 都 可 消灭 在 实验室 ， 难 就 难 在 消灭 一些 隐藏 很深 的 问题 。 说老实话 ， 我们 的 产品 还有 许多 问题   ， 需要 我们 扎扎实实 锲而不舍 的 工作 。 10 、 分配资源 是否 已 正确 释放 【 案例 1.10 . 1 】 【 正                         文 】                     在 对 接入网 A 产品 的 网管软件 测试 中 ， 发现 了 一个 WINDSOWS 资源 损耗 的 的 问题 ： 当 网管软件 运行 几天 后 ， WINDOWS 总会 出现 “ 资源 不够 ” 的 告警 提示 。 如果 网管软件 不 关掉 再 重新启动 的话 ， 就 会 出现 WINDOWS 资源 完全 耗尽 的 现象 ， 最终 网管 系统 反应 很 慢 ， 无法 正常 工作 。 	 从 现象 上 可以 判断 出 ， 网管软件 存在 隐蔽 的 内存 泄露 或 资源 不 释放 的 问题 ， 并且 这种 资源 耗尽 是 一个 缓慢 的 过程 。 如何 定位 这个 问题 呢 ？                   	 定位 这种 问题 可以 利用 WINDOWS 中 的 一个 系统资源 监视 工具 。 打开 Windows 的 “ 附件 / 系统 工具 / 资源 状况 ” ， 这是 一个 系统资源 、 用户 资源 、 和 GDI 资源 的 实时 监视 工具 。 	 工具 有 了 ， 那么 如何 发现 导致 不断 消耗 资源 的 特定 操作 呢 ？ 	 首先 和 开发人员 共同 探讨 ， 列出 几个 最 可能 消耗 资源 的 操作 和 一些 操作 组合 ， 这样 就 缩小 了 监视 范围 ， 避免 没有 范围 的 碰运气 ， 否则 如 大海捞针 。 	 监视 前 ， 首先 重新启动 WINDOWS ， 最好 不 运行 其他 的 程序 ， 打开 “ 系统 状况 ” 这个 监视 工具 ， 然后 运行 网管软件 ， 记下 此时 的 资源 状况 数据 。 	 然后 针对 一个 可疑 的 操作 ， 快速 大量 地 重复 进行 。 这种 重复性 的 操作 可以 利用 QArun 测试工具 执行 ， QArun 可以 记录 操作者 的 一次 操作步骤 ， 然后 按照 设定 的 次数 重复 操作 。 操作 后 ， 观察 此时 的 资源 状况 ， 并 记下 此时 的 数据 ， 与 操作前 的 数据 比较 ， 如果 操作 前后 的 数据 数据 没有 变化 或 变化 很小 ， 可 排除 此项 操作 ， 否则 就 可 断定 此项 操作 会 引起 资源 耗尽 。 	 对 其它 可疑 的 操作 和 操作 组合 重复 以上 过程 。 	 通过 以上 的 步骤 ， 终于 找出 引起 资源 耗尽 的 罪魁祸首 。 分析 相应 部分 的 代码 ， 发现 引起 资源 耗尽 原因 有 ： 内存 泄露 ， 画笔 和 画 刷 资源 用 完后 未 释放 等 。 【 案例 1.10 . 2 】 【 正                         文 】             某 产品 后台 软件 版本 ， 是 用 C++ 写 的 ， 程序员 在 写 代码 时 ， 经常 在 构造函数 中 申请 一块 内存 ， 而 不 释放 ， 在 程序 其他 代码 中 也 经常 只管 申请 ， 不管 释放 。 例如 :   void   WarnSvr : : SaveWarnData ( ) {           ...... 	 	     for ( int   m = 0 ; m < RecordsInBuffer [ EVENT _ ALARM ] ; m ++ ) 	 	     { 	 	 	 HISTORY _ FILTER _ INDEX *   item =                                 new   HISTORY _ FILTER _ INDEX ; 	 	 	 item - > Csn = Buffer [ EVENT _ ALARM ] [ m ] . Csn ; 	 	 	                                                               item - > Position = m                                   + ( RecordsInHistoryFile - RecordsInBuffer [ EVENT _ ALARM ] ) ; 	 	 	 / / If   a   warn   with   a   certain   Csn   is   not   in   EventFilterIndex 	 	 	 / / it   is   not   necessary   to   be   added   to     HistoryFilterIndex 	 	 	 int   item _ total = EventFilterIndex . GetItemsInContainer ( ) ; 	 	 	 BOOL   find _ flag = false ; 	 	 	 for ( int   k = 0 ; k < item _ total ; k ++ ) 	 	 	   if ( EventFilterIndex [ k ] - > Csn = = item - > Csn ) 	 	 	 	   { 	 	 	 	   find _ flag = true ; 	 	 	 	   break ; 	 	 	 	   } 	 	 	 if ( find _ flag ) 	 	 	     { 	 	 	 	 HistoryFilterIndex . Add ( item ) ; 	 	 	 	 if ( HistoryFilterIndex . IsFull ( ) ) 	 	 	 	     ClearIndexEntry ( ) ; 	 	 	   } / / 建议 在 此处 加上 :                                 / /                                                           else   / /                                                                             delete   item ; } 。                 有 的 程序员 认为 ， 后台 运行 的 环境 有 大量 内存 ， 几个 字节 的 浪费 不会 造成 死机 等 重大事故 。 然而 ， 长时间 累计 起来 ， 必然 会 造成 资源 紧张 而 出现 故障 。                   实际上 ， 这种 思想 是 造成 我们 产品 不 稳定 的 原因 之一 。 我们 的 主机 在 网上 能 运行 几个 月 几年 ， 大家 对 内存 的 分配 释放 较 敏感 ， 而 我们 的 后台 产品 往往 只能 正常 运行 几天 。 这个 地方 不 注意 也 是 原因 之一 吧 。 【 案例 1.10 . 3 】 【 正                         文 】 	 在 进行 代码 审查 过程 中 ， 造成 内存 泄漏 的 代码 比较 多 。 下面 举 几种 常见 的 内存 泄漏 错误 ， 供 测试人员 在 代码 审查 中 参考 ： 	 1 .   函数 有 多个 出口 时 ， 没有 在 每个 出口处 对 动态 申请 的 内存 进行 释放 。 一般 在 异常 处理 时 容易 出现 这种 错误 。 下面 的 代码段 就是 这样 的 例子 ： .....                 pRecord   =   new   char [ pTable - > GetRecordLength ( ) ] ; 	 assert ( pRecord   ! =   NULL ) ; 	 if   ( pTable - > GoTop ( FALSE )   ! =   DBIERR _ NONE ) 	 	 return ;   / /   如果 从 这里 返回 ， pRecord 将 得不到 释放           .....                 pTable - > Close ( ) ; 	 delete [ ]   pRecord ;             } 	 2 .   给 指针 赋值 时 ， 没有 检查 指针 是否 为空 ， 如果 指针 不为 空 ， 那么 指针 原来 指向 的 内存 将 丢失 。 请 看 如下 代码段 ： .... 	 struct   FileInfo   *   pdbffile   =   new   struct   FileInfo ; 	 pdbffile - > pfileinfo   =   new   struct   ffblk ; 	 pdbffile - > srcname   =   srcRootPath ; 	 pdbffile - > desname   =   desRootPath ; 	 pdbffile - > prev   =   NULL ; 	 pfile   =   pdbffile ; / / 赋值 之前 没有 检查一下 pfile 是否 为空 ， 如果 不为 空 ， 会 造成 pfile 指向 的 内存 丢失 。 	 dbf _ start _ needed   =   FALSE ; 	 dbf _ Finish   =   FALSE ; 	 flag _ begined   =   TRUE ; 	 if ( FALSE   = =   Copy ( TRUE ) ) 	 { 	 	 dbf _ start _ needed   =   TRUE ; 	 	 WarnMsgOut ( " Error   occurs   while   copying   files   in   directory   < dbf > , trying   again . " ) ; 	 }         } 	 3 .   连续 二次 内存 动态分配 ， 在 第二次 分配 失败 时 ， 忘记 释放 第一次 已经 申请 到 的 内存 。 	 .... 	 pMsgDB _ DEV   =   ( PDBDevMsg ) GetBuff (   sizeof (   DBDevMsg   ) ,   __ LINE __ ) ; 	 if (   pMsgDB _ DEV   = =   NULL   ) 	 	 return ; 	 pMsgDBApp _ To _ Logic   =   ( LPDBSelfMsg ) GetBuff (   sizeof ( DBSelfMsg ) ,   __ LINE __   ) ; 	 if (   pMsgDBApp _ To _ Logic   = =   NULL   ) 	 	 return ; / / 此处 返回 造成 pMsgDB _ DEV 指向 的 内存 丢失 	 .... 	 	 4 . 代码 中 缺少 应有 的 条件 分支 处理 ， 导致 程序 未 执行 任何 操作 而 退出 时 ， 也 可能 没有 释放 应 释放 的 内存 ， 这种 情况 一般 是 缺少 应有 的 else 分支 ， 或 switch 语句 的 default 分支 没有 应有 的 处理 。 static   void     OncePowerCmdHandle (   struct   HT _ Appmsg     *   msg   ) { 	 ...   ...         	 pPower _ test _ answer   = ( struct   _ oncepower _ test _ answer   * ) GetBuff ( sizeof ( struct   _ oncepower _ test _ answer ) , __ LINE __ ) ; 	 if (   pPower _ test _ answer   = =   NULL _ PTR   ) 	 	 	 	 	 	   return ; 	 ...   ... 	 if   ( TSS _ State [ testpsn ] . state   = =   TEST _ DEV _ BUSY   | | 	 	 TSS _ State [ testpsn ] . state   = =   TEST _ DEV _ ERROR   ) 	 { ... 	 } 	 else   if   ( TSS _ State [ testpsn ] . state   = =   TEST _ DEV _ IDLE   ) 	 { ...   	 } 	 / /   缺少   else   分支 ， 可能 造成   pPower _ test _ answer   得不到 释放 } 造成 内存 泄漏 的 情况 很多 ， 以上 是 几种 典型 的 情况 。 虽然 内存 泄露 一般 出现 在 异常情况 下 ， 毕竟 给 系统 造成 很大 的 隐患 ， 使 系统 的 健壮性 降低 。 测试人员 在 作 代码 审查 时 ， 对 上述 几种 情况 要 尤其 注意 。 【 案例 1.10 . 4 】 【 正                         文 】 在 进行 SAR 的 PDU 包 发收 的 测试 过程 中要 同时 考虑 几个 边界值 , 即 发送 包 大小 范围 [ 0 - Nmax ] , SAR 的 PDU 包 接收 的 最大值 Kmax , MBUF 块 的 大小 M . 在 实测 中 , 将 SAR 的 PDU 包 接收 的 最大值 设为 2000 ( Kmax = 2000B ) ,   MBUF 的 块长 设为 512 ( M   =   512B ) , 则 发送 包 大小 的 正确 分支 的 取值 为 下限 0 , 上限 Nmax = 2000 , 然后 在 0 与 2000 之间 随机 取 若干 值 , 再 考虑 MBUF 的 块长 , 还 可 增加 M 倍数 的 若干 选值 及其 附近 值 . 以上 是 测试 的 一般 思路 , 但 由于 很 偶然 的 机会 选择 包长 2000 , 及 Kmax = 2000B , 才 发现 问题 . 原因 如下 : MBUF 块长 512 , 但块 中 实际 存放数据 的 只有 500 ( MBUF 头上 有 2 个 长字 , 尾部 有 1 个长 字 共 12B 只 用于 块 控制 ) , 而 发送 的 包长 正好 是 500 的 整数倍 4 , 由于 是 整数倍 , 所以 SAR ( BT8230 ) 从 FREE 链上 摘成 5 个 MBUF ( 原因 从略 ) , 而 SAR 驱动 只 知道 有 4 个 MBUF , 这样 到 上层 用户 时 , 只 释放 4 个 MBUF , 从而 漏掉 1 个 MBUF , 经过 很 短 一段时间 后 , 内存 即 被 耗尽 . ( 此 问题 非常 严重 , 因为 在 实际 运用 中 , 是 500 的 整数倍 的 PDU 包 的 概率 较 小 , 但 一旦 出现 就 会 发生 一次 内存 泄漏 , 这样 经过 若干天 或 若干 月 的 运行 后会 使 系统 崩溃 ) 以前 未 发现 此 问题 的 原因 是因为 原来 使用 的 缓冲 块长 为 2048 , 减去 12B 的 控制 信息 , 实际 存放数据 的 长度 为 2036 . 由于 只 考虑 了 2048 这个 值 , 忽略 了 2036 , 所以 在 选取 上 下限 中 的 若干 值时 , 选取 包 的 长度 是 2036 的 倍数 的 概率 就 非常 小 , 因而 未 发现 该 问题 . 由于 测试 中 一般 很难 将 取值 范围 中 的 所有 值 覆盖 全 , 所以 在 选取 上 下限 中 的 若干 取值 时要 格外 仔细 , 考虑 的 方面 尽可能 全 , 因为 很 有 可能 其中 某些 值 就是 测试 边界值 . 凡是 涉及 的 数字 尽量 选取 , 象该 例中 正确 分支 的 测试 边界 为 0 , 2000 , 512 及其 整数倍 , 500   及其 整数倍 , 12   及其 整数倍 等值 , 它们 是 必测 的 边界值 , 而 非 可测 可 不测 的 随机 选取 的 所谓 若干 选值 . 【 案例 1.10 . 5 】 【 正                         文 】 ABIS . CPP 中 的 函数 rel _ ABIS _ CCB _ conn (   ) 中 ， 在 进行 消息 链表 Msg _ Queue [ ces ] 的 拆链 操作 时 ， 对于 相应 的 CCB 只 进行 了 一次 拆链 操作 ， 即 只 拆除 了 一个 节点 ， 如果 出现 该 CCB 对应 的 消息 节点 不止 一个 的 情况 就 会 出现 大量 节点 不能 释放 的 问题 。 if (   Msg _ Queue [ ces ] . msghead   ! =   NULL _ PTR   ) / / message   buffer   notempty {             / / get   first   message   record             pMsgRecord   =   Msg _ Queue [ ces ] . msghead ;             / / release   buffer - messages   concerning   with   ccb _ no             for (   index   =   0 ;   index   <   MSGBUFFERNUM ;   index ++   )             {                   / / 这里 要 对 pMsgRecord 的 值 进行 判断                     if (   ( pMsgRecord   ! =   NULL _ PTR )   &&   pMsgRecord - > CCB _ no   = =                         ccb _ no   )                                     {                         / / free   the   message   buffer                         if (   pMsgRecord   = =   Msg _ Queue [ ces ] . msghead   ) / / head                         Msg _ Queue [ ces ] . msghead   =   pMsgRecord - > pnext ;                         else   if (   pMsgRecord   = =   Msg _ Queue [ ces ] . msgtail   ) / / tail                         {                                         Msg _ Queue [ ces ] . msgtail   =   pPrevMsgRecord ;                                         Msg _ Queue [ ces ] . msgtail - > pnext   =   NULL _ PTR ;                         }                         else / / not   head   and   tail                         {                                       pPrevMsgRecord - > pnext   =   pMsgRecord - > pnext ;                         }                           / / put   buffer   back   to   buffer   pool                         if (   Msg _ Buffer . empty _ num   = =   0   )                         {                                     Msg _ Buffer . linkhead   =   Msg _ Buffer . linktail   =   pMsgRecord ;                                     pMsgRecord - > pnext   =   NULL _ PTR ; / / 这里 将                                                                                                                                                             pMsgRecord - > pnext 置 为 空                                     Msg _ Buffer . empty _ num ++ ;                         }                         else                         {                                     Msg _ Buffer . linktail - > pnext   =   pMsgRecord ;                                     pMsgRecord - > pnext   =   NULL _ PTR ; / / 这里 将                                                                                                                                                             pMsgRecord - > pnext 置 为 空                                     Msg _ Buffer . linktail   =   pMsgRecord ;                                     Msg _ Buffer . empty _ num ++ ;                         }                   }                                   else   if (   pMsgRecord   = =   NULL _ PTR   )                                           break ; / / end   of   if                   / / get   next   message   record                       pPrevMsgRecord   =   pMsgRecord ;                       pMsgRecord   =   pMsgRecord - > pnext ; / / 这时 pMsgRecord 为                                                                                                                                               NULL _ PTR 将 跳出 for 循环 语句             } / / end   of   for } / / end   of   if 这里 在 拆除 一个 节点 后 导致 pMsgRecord 为 NULL _ PTR ， 再 进行 判断 时 将 会 跳出 循环 ， 这样 将 不能 保证 所有 与 同一个 CCB 有关 的 节点均 被 拆除 ， 这时 如果 与 同一个 CCB 对应 的 消息 节点 不止 一个 则 这些 消息 节点均 无法 释放 ， 造成 可用 的 节点 数 不断 减少 ， 直接 影响 系统 的 建链 过程 ， 给 系统 的 稳定 带来 隐患 。 后 与 开发人员 联系 ， 根据 这 段 算法 编写 小 程序验证 了 该 问题 ， 并 提出 了 相应 的 解决方案 ， 消除 了 该 隐患 。 【 案例 1.10 . 6 】 【 正                         文 】               1 、 建立 一个 呼叫 ， 并 保持 通话 。 在 AM 控存 监控 操作界面 中 观察 通话 建立 在 哪一块 FBI 板上 。               2 、 将 有 通话 的 FBI 板 拔出 ， 观察 通话 情况 ， 此时 话音 中断 ， 但 信令 仍然 保持 。 观察 AM 控存 监控 操作界面 和 E3M 板 2K 网 界面 ， 发现 AM 侧 因为 检测 到 光纤 已断 ， 将 通话 在 CTN 、 E3M 板上 占用 的 时隙 置 为 空闲 ， 即 在 AM 控存 监控 操作界面 和 E3M 板 2K 网 界面 观察 不到 时隙 占用 情况 。             3 、 分别 在 30 秒 、 1 分钟 、 3 分钟 时 将 拔出 的 FBI 板 插回 原槽 位 ， 发现 每次 插回 FBI 板后 话音 立即 恢复 。           4 、 观察 BAM 上 的 打印消息 ， 发现 打印 的 各 模块 占用 CTN 板大 HW 上 DM 时隙 的 空闲 个数 比较 混乱 。 打印消息 如下 图 所示 ：                     其中 ：             1 ）   由于 模块 1 、 2 、 3 、 4 各 占用 CTN 板上 两条 大 HW ， 每个 DM 时隙 个数 为 256 （ 即 由 两条 大 HW 的 两个 DM 组成 ， 由于 与 OPT 相联 的 大 HW 上 有 两个 保留 时隙 ， 因此 此 DM 上 空闲 时隙 个数 为 ： 254 。           2 ）     由于 E3M 板 只 与 一条 大 HW 相联 ， 故 每个 DM 上 空闲 的 时隙 个数 为 ： 128 。           本 现象 对应 2 个 问题 ： idle _ count 打印 混乱 ， BM 释放 故障 光路 的 时隙 和 对应 的 CCB 、 无线 信道 等 资源 。           1 、 idle _ count 打印 混乱 是 由于 函数 restore _ one _ hw 中 的 一些 处理不当 造成 的 ， 以前 被 当作 B型 机 的 历史 遗留问题 没有 重视 ； 2 、 B2 模块 有 2 条光路 ， 如果 断掉 其中 一条 ， 模块 状态 不会 改变 ， 原 B型 机 程序 对此 不 作 任何 处理 ， 但 应该 增加 这个 功能 ， 以免 光 路 故障 导致 资源 吊死 。           解决 方法 ：           问题 一 ：   将 函数 restore _ one _ hw 中原 代码 作 如下 改动 ：                                                           mod _ dm [ mod ] [ i ] . tail . tsn   =   idle _ dm _ head   +   125 ; 	 	                 (   idle _ dm _ head   = =   384   )   ? 	 	                         mod _ dm [ mod ] [ i ] . idle _ count   + =   TS _ PER _ DM   -   1 : 	 	                         mod _ dm [ mod ] [ i ] . idle _ count   + =   TS _ PER _ DM   -   1 ; 	 	 改为 ： 	 	 	 if   (   idle _ dm _ head   ! =   384   ) 	 	 	 { 	 	                                           mod _ dm [ mod ] [ i ] . tail . tsn   =   idle _ dm _ head   +   127 ; 	 	 	                       mod _ dm [ mod ] [ i ] . idle _ count   + =   TS _ PER _ DM ; 	 	 	 }   	 	 	   else 	 	 	 { 	 	 	                       mod _ dm [ mod ] [ i ] . tail . tsn   =   idle _ dm _ head   +   126 ; 	 	 	                       mod _ dm [ mod ] [ i ] . idle _ count   + =   TS _ PER _ DM   -   1 ; 	 	 	 }             问题 二 分析 如下 ：                         目前 的 模块 状态 是 由 IPATH 调用 DBMS 模块 的 边 检查 实现 的 ， 只要 存在 一条 可用 的 光路 ， 即 认为 相邻 模块 为 正常 ， 对于 具体 的 OPT 板上 的 时隙 状态 的 维护 没有 与 呼叫 控制 的 接口 。 具体 的 OPT 板 状态 功能 的 检测 是 由 IPATH 完成 的 ， 在 BM 侧 没有 专门 维护 OPT 和 MC2 板 的 模块 ， 将 转交 OS 组 处理 。               总结 ：                   在 拔出 FBC 板后 ， 通话 话音 被 中断 ， AM / CM 侧 已 将 与 被 拔出 的 FBC     板 相关 的 资源 全部 置 为 不可 用 ， 此时 BM 侧 主机 程序 也 应该 与 AM / CM 侧 一致 ， 释放 掉 所 占用 的 资源 ， 并 将 原 通话 的 信令 连接 断开 。 这 可能 是 由于 不同 模块 的 开发人员 缺少 相互间 了解 而 造成 的 ， 即 AM / CM 侧 与 BM 侧 开发人员 交流 不够 。 作为 测试人员 对 类似 两个 或 多个 模块 相关 的 部分 应该 充分 进行 测试 ， 不要 想当然 ， 往往 是 看起来 不 可能 出 问题 的 地方 也 容易 测出 问题 。 【 案例 1.10 . 7 】 	 在 进行 有关 排队 指示 的 系统 测试 中 ， 先 闭塞 掉 基站 的 所有 业务 信道 TCH ， 进行 呼叫 ， 再 直接 挂机 或 超时 释放 ， 发现 TC 存在 中继 资源 吊死 的 问题 。       	 由于 此 问题 重现 ， 后经 定位 分析 ， 发现 是 ccb 超时 后 收到 AIR 发来 的 clear   cmd ， 进入   rel _ one _ bm _ res (   ) 时 ， 由于 ccb 所 登记 的 CIC 还 放在 pre _ occupied _ res ， 并 没有 放入 occuped _ res ， 而 rel _ one _ bm _ res ( ) 只 对 存入 occuped _ res 的 CIC 进行 判断 ， 并 向 AIE 发 UNBOOKCIC ， 而 没有 对 存入 pre _ occupied _ res 的 CIC 进行 判断 ， 并 UNBOOK 掉 ， 导致 TC 的 中继 资源 吊死 。 应 在 超时 函数 或 释放 函数 中 对 pre _ occupied _ res 的 CIC 进行 处理 。 在 此 过程 中 ， CIC 资源 还 存放 在 老 CCB 的 pre _ occupied _ res 中 ， 在 超时 函数 或 释放 函数 中均 未 对 pre _ occupied _ res 中 的 CIC 进行 处理 （ 即 向 AIE   UNBOOK ） ， 导致 TC 中继 资源 吊死 。 	 在 超时 函数 RR _ time _ out ( ) 中 timer _ name 为 TN _ WAIT _ ASS _ READY 时 ， 和 释放 函数 rel _ one _ bam _ res ( ) 中 增加 对 CCB 的 pre _ occupied _ res 中 的 CIC 的 判断 和 释放 处理 。               	 在 使用 资源 同时 ， 就要 周密 地 考虑 好 资源 的 释放 问题 ， 只有 这样 ， 才能 使 我们 的 系统 不断 地 稳定下来 。   	 资源 的 释放 对于 我们 的 交换机 来说 是 至关重要 的 ， 一点点 的 疏忽 都 可能 最终 使 我们 的 交换机 因为 无 资源 使用 而 死 掉 ， 要 知道 ， “ 千里 长堤 ， 毁于蚁穴 ” 。 11 、 防止 资源 的 重复 释放 【 案例 1.11 . 1 】 【 正                         文 】               当 进行 大 话务量 呼叫 时 ， 在 统计 代码 中 出现 AIE 收到 UNBOOK   CIC 消息 时 ， 发现 自身 电路状态 为 空闲 ， 出现 一个 断言 。 这 说明 AIE 电路 电路 被误 释放 了 。 	 这个 问题 出现 的 原因 有 以下 几种 ： 	 1 .   RR 可能 发错 了 电路 号 ， 导致 AIE 状态 错误 。 	 2 .   AIE 可能 发起 资源 核查 ， 失败 后 将 本 控制 表项 释放 了 。 	 3 .   RR 可能 发起 了 重复 释放 操作 ， 导致 AIE 的 某个 表项 连续 收到 两个 UNBOOK 消息 。 	 分析 完 了 可能 的 情况 ， 就要 一一 分析 定位 。 	 在 可能 原因 一 发生 的 情况 下 ， RR 发来 的 UNBOOK 消息 所带 的 AIR 连接号 和 模块号 会 错误 ， 导致 我们 会 出现 断言 。 而 在 测试数据 结果 文件 中 ， 没有 出现 这个 断言 ， 因此 可能 原因 一 不 成立 。 	 在 可能 原因 二 发生 的 情况 下 ， AIE 收到 资源 核查 失败 消息 的 数目 应该 不是 零 。 但是 实际 情况 下 统计 结果 中 收到 资源 核查 失败 消息 的 个数 为 零 ， 说明 情况 二 也 不 成立 。 	 由 上 分析 ， 这个 问题 只 可能 是 由于 RR 重复 释放 造成 的 。 但是 为何 会 发生 重复 释放 ， 这 需要 进行 进一步 分析 。 	 从 呼叫 的 正常 流程 来看 ， 是 不会 产生 重复 释放 的 ， 因此 我们 怀疑 该 问题 与 异常 流程 有关 。 从 统计 代码 中 查找 异常 流程 ， 发现 该次 统计 中 BSC 内 切换 流程 多次 出现 问题 ， 具体 原因 是 由于 切换 过程 中 在 目标 小区 申请 不到 信道 ， 产生 切换 失败 造成 的 。 因此 集中 研究 这个 流程 ， 发现 存在 问题 如下 ： 	 当原 小区 向 目标 小区 发送 内部 切换 请求 消息 时 ， 带来 了 AIR 和 AIE 的 各项 信息 ， 而 目标 小区 收到 这些 信息 后 就 将 之 保存 在 自身 的 占用 资源 中 。 如果 目标 侧 申请 信道 失败 ， 就会 向源 侧发 内部 切换 拒绝 消息 ， 而后 产生 本地 释放 。 由于 在 释放 前 目标 侧 RR 没有 将 占用 资源 中 的 AIR 和 AIE 信息 清除 ， 因此 导致 重复 释放 时 对 AIR 和 AIE 发起 了 释放 操作 。 由于 AIR 释放 时有 保护 机制 ， 所以 不会 产生 问题 ， 而 AIE 没有 保护 机制 ， 新 CCB 就 将 AIE 电路 释放 掉 了 。 而后 当老 CCB 在 通话 结束 后 发起 释放 时 ， 就 产生 了 重复 释放 。 	 从 上面 分析 可以 看出 ， 这个 问题 是 由于 RR 释放 流程 的 错误 造成 的 ， 因此 ， 我们 要 对此 加以 修改 ， 在 新 CCB 释放 前 将 AIR 和 AIE 信息 从 预占 资源 中 清除 。                 RR 的 释放 是 一个 非常复杂 的 过程 ， 如何 正确 的 整理 资源 ， 确保 资源 的 合理 释放 ， 这是 摆在 我们 面前 的 一个 艰巨 的 问题 ， 我们 要 仔细分析 各种 可能 发生 的 情况 ， 正确 释放 各种 资源 ， 即 不会 吊死 资源 ， 也 不会 产生 重复 释放 。 12 、 公共资源 的 互斥性 和 竞用 性 【 案例 1.12 . 1 】 【 正                         文 】 	 试验 环境 ： CPX8216   CPCI   机架 、 vxWorks 操作系统 、 Tornado1 . 0.1 调试 环境 	 测试用例 ： 测试 板 间通信 性能 。 从 接口板 A 向 接口板 B 循环 发送 消息 ， 通过 超级终端 观察 消息 的 收发 情况 。 	 测试 结果 ： 每 发送 一定 数量 的 消息 帧 后 ， 会 出现 发送 地址 出错 现象 。 	 原因 分析 ： 接收 板 回送 缓冲区 指针 给 发送 板 ， 是 采用 memcpy 单字节 拷贝 的 方式 。 若 发送 速度 快 于 接收 速度 ， 两板 竞用 发送 板 系统总线 访问 缓冲区 指针 所在 的 共享内存 ， 导致 数据 访问 冲突 。 memcpy 过程 被 打断 ， 即 出现 发送 板读 发送 地址 出错 现象 。 	 采用 四 字节 拷贝 函数 bcopyLongs 传送 发送缓冲区 指针 ， 问题 解决 。 	 共享内存 的 访问 设计 ， 除了 考虑 互斥 外 ， 还有 总线 竞用 问题 。 【 案例 1.12 . 2 】 【 正                         文 】 问题 描述 ：                 在 进行 主 BCCH 载频 互助 新 功能 开发 的 并行 联调 测试 的 过程 中 ， 发现 了 以下 的 问题 ： 在 数管 台 设置 “ TRX 倒换 是否 允许 ” 为 “ 是 ” ， 进行 设定 整表后 ， 关闭 基站 其中 配有 4 个 TRX 的 小区 的 主 BCCH 所在 的 TRX 电源 ， 发现 对应 小区 重新 初始化 并 成功 ， 也 就是 载频 互助 成功 。 这个 时候 从 后台 对 该 小区 所在 的 站点 进行 4 级 复位 ， 同时 重新 打开 之前 关闭 的 该 小区 的 原配 主 BCCH 所在 TRX 的 电源 ， 发现 对应 小区 初始化 失败 。 问题 定位 ：                   在 问题 定位 开始 ， 先是 查看 了 载频 互助 相关 代码 在 站点 初始化 流程 中 的 处理 。 BTSM 程序 初始化 过程 中 ， 先是 判断 这 一次 初始化 之前 是否 发生 过 载频 互助 ， 若 发生 过 ， 再 判断 原配 主 BCCH （ 即 数据库 中 实际 配置 的 主 BCCH 所在 的 TRX ） 是否 已经 恢复 （ 即能 正常 建立 TEI ， 能 正常 设置 该 TRX 对应 的 RC 属性 ， 总之 能 正常 开工 ） 。 若 载频 互助 发生 过 ， 且 原配 主 BCCH 所在 的 TRX （ CoTRXGroupForBts [ BtsNo ] . MainTRX ） 已经 恢复 ， 即 把 之前 进行 互助 的 TRX   （ CoTRXGroupForBts [ BtsNo ] . AidTRX ） 的 数据 和 原配 的 主 BCCH 所在 TRX 的 数据交换 回来 ， 并 重新 进行 初始化 。 表面 上 看 原理 应该 没有 什么 逻辑 错误 ， 怎么 会 出现 初始化 不 成功 呢 ？ 我们 对 程序 中 的 每 一个 可能 导致 该 问题 的 变量 加 打印 调试程序 ， 然后 重现 该 问题 ， 终于 在 打印 出来 的 信息 中 发现 在 载频 互助 发生 后 其 互助 的 主 BCCH 所在 的 TRX 与 实际 数据 配置 主 BCCH 所在 的 TRX 为 同一 TRX ， 这有 问题 ， 因为 载频 互助 的 实质 就是 实际 数据 配置 主 BCCH 所在 的 TRX 不能 正常 开工 而 借用 其他 TRX 作为 主 BCCH 。 于是 我们 根据 此 线索 查询 了 所有 BTSM 的 程序 ， 没有 发现 问题 的 根源 。 于是 我们 查 了 最近 合进 版本 的 相关 模块 的 程序 ， 终于 找出 了 问题 的 根源 所在 。 在 载频 互助 程序 中以 全局变量 ptrBTS _ CONFIG _ MAP [ BtsNo ] . TRX _ no _ BCCH _ in 表示 当前 实际 运行 的 主 BCCH 所在 的 TRX 号 ， 是 随时 变化 的 ； 以 CoTRXGroupForBts [ BtsNo ] . MainTRX 表示 原配 的 主 BCCH 所在 的 TRX 号 ， 是 固定 的 。 两者 在 系统 开工 的 系统 开工 的 接口函数 FetchOneSiteConfig （   ） 中赋 了 相同 的 值 ： 该 函数 的 409 行有 赋值 语句 CoTRXGroupForBts [ BTS _ no _ temp ] . MainTRX   =   ptrBTS _ CONFIG _ MAP [ BTS _ no _ temp ] . TRX _ no _ BCCH _ in 。 以前 函数 FetchOneSiteConfig （ ） 只是 在 系统 开工 时才 调用 过 一次 ， 故 CoTRXGroupForBts [ BTS _ no _ temp ] . MainTRX   在 系统 开工 以后 是 不变 的 ， 但是 在 DBMI 同步 开发 的 整改 中 ， 作 了 如下 处理 ： 在 每 一次 数据 动态 设定 后 ， 先 判断 站点 下 有没有 发生 过 载频 互助 ， 若 发生 过则 试图 先 把 目前 进行 互助 的 TRX 的 数据 与 实际 数据 配置 成主 BCCH 的 TRX 的 数据 倒换 回来 ， 然后 进行 站点 初始化 。 问题 就 出现 在 这 ， 在 DBMI 中 认为 DB 中 原配 的 主 BCCH 的 TRX 是 ptrBTS _ CONFIG _ MAP [ BTS _ no _ temp ] . TRX _ no _ BCCH _ in ， 而且 每次 进行 站点 初始化 时 都 调用函数 FetchOneSiteConfig （ ） ， 这样 将 导致 CoTRXGroupForBts [ BTS _ no _ temp ] . MainTRX 的 值 与 DB 中 实际 原配 主 BCCH 所在 TRX 不 一致 ， 从而 导致 主 BCCH 的 相关 数据 倒换 是 出现 错误 ， 最终 导致 相应 小区 初始化 不 成功 。                                                                   收获 及 反思 ： 这个 问题 的 出现 是因为 主机 程序 两个 功能模块 DBMI 与 BTSM 之间 的 开发 缺少 相互 沟通 引起 ， 如果 在 开发 之前 两个 模块 的 的 开发人员 先 约定 好 各个 全局变量 的 用途 ， 如果 DBMI 与 BTSM 两个 功能模块 都 认为 CoTRXGroupForBts [ BTS _ no _ temp ] . MainTRX 是 实际 数据 的 原来 的 主 BCCH 所在 的 TRX 号 ， 那么 就 不会 出现 以上 问题 。 现在 BSC 主机 程序 的 各个 功能模块 都 同时 合进 了 许多 代码 ， 各个 功能模块 之间 的 联系 与 冲突 肯定 会 存在 ， 这 就 需要 开发人员 在 开发 设计方案 时 就 相互 沟通 ， 否则 以上 由于 功能模块 间 的 的 冲突 引起 的 问题 肯定 会 存在 ， 而且 可能 不 那么 明显 的 暴露 了 出来 。 我们 的 产品 埋伏 的 炸弹 的 机会 就 越 多 。   二 、 接口类 代码 问题 1 、 对 函数参数 进行 有效性 检查 【 案例 2.1 . 1 】 【 案例 描述 】           某 交换 类产品 BAM 后台 管理系统 使用 了 注册表 存储 后台 系统 数据 自动 备份 时间 ； 在 对 数据 自动 备份 进行 系统 测试 时 考虑 到 注册表 中 数值 的 任意性 ， 很 有 可能 被 测系统 没有 对 注册表 中 存储 的 值作 相应 的 合法性 检测 ， 从而 有 可能 对系统 产生 不良影响 。 【 处理过程 】 通过审查 源程序 及 实际 验证 ， 发现 果然 存在 问题 。 BAM 有关 数据 自动 备份 程序 程序 在 得到 该项 值后 只 做 了 简单 处理 ， 没有 对 时间 进行 合法性 验证 。 若 自动 备份 操作 发生 在 前后 台 通讯 的 高峰期 或者 是 在 设置 数据 需要 对 数据库 进行 操作 时 ， 对系统 可能 会 产生 重大 影响 。 【 结     论 】 系统 使用 注册表 中 的 数据 同样 要 进行 各种 情况 下 的 测试 ， 包括 合法 的 和 不 合法 的 数据 设置 。 【 思考 与 启示 】 系统 的 数据 输入 有 多种 渠道 ， 不仅 包括 人机 命令 、 系统 INI 文件 ， 还 包括 注册表 等 其它 途径 ； 在 测试 时 对 各种 情况 都 要 进行 全方位 的 测试 ， 从而 保证系统 的 可靠性 。 【 案例 2.1 . 2 】 【 案例 描述 】 	 设计 规定 07 的 TSS 板 是 不 支持 数字 用户 内 ， 外线 强测 的 ， 在 对 数字 用户 内 ， 外线 测试 正常 后 ， 有意 强测 一 正在 通话 的 数字 用户 ， 却 发现 返回 报告 ： 用户 外线 测试 - - - - - - - - - - - -                                             测试 时间   =   1999 - 06 - 03   16 : 48 : 06                                                 号 首集   =   0                                             用户 号码   =   6540136                                       BAM 测试状态   =   正常                                     主机 测试状态   =   正常                                                     AVAG   =   0.08                                                           AVBG   =   0.29                                                           AVAB   =   - 0.21                                                         DVAG   =   0.62                                                           DVBG   =   0.62                                                           DVAB   =   0.00                                                             RAG   =   > 10M                                                       RBG   =   > 10M                                                       RAB   =   > 10M                                                         RL   =   > 10M                                                       CAG   =   0.001                                                         CBG   =   0.001                                                         CAB   =   0.001                                                       结论   =   断线 结论 断线 肯定 是 错误 的 ， 测试 期间 查询 TSS 状态 ， 显示 TSS 空闲 ， 可见 主机 返回 的 报告 是 错误 的 。 【 处理过程 】 	 修改 命令 ADD   RTSTI 对应 的 存储 过程 ， 问题 解决 。 【 结     论 】 	 用户 外线 测试主机 没有 判 用户 是否 为 数字 用户 。 【 思考 与 启示 】 	 测试 一项 功能 ， 既 要 测试 系统 提供 的 功能 要 满足要求 ， 系统 没有 提供 的 功能 看 是否 误 执行 了 ， 导致 错误 的 结论 。 【 案例 2.1 . 3 】 【 正                         文 】 	 一般 开发人员 认为 函数 的 参数 很 简单 ， 但 在 实际 设计 和 调用函数 时 ， 很 容易 犯 一些 参数 方面 的 错误 。 下面 就 一些 例子 进行 一些 分析 ， 希望 能 引起 大家 的 重视 。 	 1 、 函数 设计 中 ， 使用 函数 内 局部变量 保存 下次 函数 重新 调用 时 需要 的 保留值 。 void   SlaverDownLoadProc (   WORD   wMsgLength   ,   void   * pTempMsgAddr   ) { 	 void   * pTempTargetAddr   ; 	 SSLAVERLOADMSG   * pSTempSlaverLoadMsg   =   (   SSLAVERLOADMSG   *   ) pTempMsgAddr ; 	 	 	 if   (   COMMON _ BOARD _ LOAD _ PROGRAM   = =   pSTempSlaverLoadMsg - > m _ ucCmd   ) 	 	 pTempTargetAddr   =   (   void   *   ) SDRAM _ LOAD _ PROG _ START _ ADDR   ; # ifndef   MMX     / *   MMX 板 的 数据 不用 加载 ， 用 备份 方式 * / 	 else   if   (   COMMON _ BOARD _ LOAD _ FPGA   = =   pSTempSlaverLoadMsg - > m _ ucCmd   ) 	 	 pTempTargetAddr   =   (   void   *   ) SDRAM _ FPGA _ START _ ADDR   ;                             ...                                                 case   BEGIN _ LOAD   :               	 if   (     (   LOAD _ MIDDLE _ FRAME   = =   pSTempSlaverLoadMsg - > m _ ucLoadCmd   )   	         && (   (   dwRecFrameNum   %   0xFF   )   = =   pSTempSlaverLoadMsg - > m _ ucOrderNo   )       	       ) 	 { 	 / *   序号 和 帧 的 命令字 都 是 合法 的 ， 保存 BUFFER   * / 	 	 memcpy (   (   BYTE   *   ) pTempTargetAddr   ,   (   BYTE   *   ) pSTempSlaverLoadMsg   +   5   ,   wMsgLength   -   5   )   ; 	 / *   5   =   m _ ucBoardType   +   m _ ucCmd   +   m _ ucSerialNo   +   m _ ucLoadCmd   +   m _ ucOrderNo   * / 	 	 dwRecFrameNum   ++   ;                                 ...                 	 这里 每 收到 一帧 都 要 调用 此 函数 ， 而 每次 进入 时 ， 函数 将 pTempTargetAddr 赋值 为 两个 固定值 中 的 一个 ， 导致 收到 的 新 帧 将 上 一次 的 帧 数据 覆盖 。 显然 ， 函数 将 本应 作为 全局变量 的 参数 pTempTargetAddr 错误 地 定义 为 局部变量 。 	 2 、 当 函数 的 输入 参数 较 多 ， 并且 互相 之间 有 联系 时 ， 是 较易 出错 的 地方 。 	 在 测试 串口 任务 时 ， 我们 发现 一个 错误 ： 当 加入 新 用户 时 ， 当 用户名 输入 到 四十一个 字符 时 ， 程序 死 掉 。 经过 调试 跟踪 ， 发现 是 在 input 函数 中 调用 GetString ， 但是 在 对 第二个 参数 赋值 时 ， 没有 搞清楚 参数 之间 的 关系 。 第一个 参数 （ 传入 的 指针 ） 指向 一 长度 为 40 字符 的 字符串 ， 而 在 对 第二个 参数 时 ， 错误 地 将 字符串 长度 设置 为 41 。 导致 串口 接收 第 41 个字符 时 ， 程序 越界 操作 ， 导致 死机 。 下面 是 函数 GetString 的 声明 ： signed   long   GetString   (           char   *   szString ,                   / *   OUT :   字符串 指针   * /         WORD   wSize                         / *   IN :   指定 的 字符串 长度   * / ) 1 	 当然 有关 函数参数 的 错误 不止 这些 ， 例如 未 在 模块接口 函数 内部 检验 传入 参数 的 合法性 、 指针 参数 的 有效性 、 参数 未 赋值 就 使用 、 参数 类型 不 匹配 或 考虑不周 导致 上溢 下溢 等 。 这些 都 是 编程 者 容易 出错 的 地方 ， 亦 是 我们 大家 在 走读 代码 时 ， 需要 特别 注意 的 地方 。 【 案例 2.1 . 4 】 【 正                         文 】 	 在 交换机 的 V5 协议 测试 中 ， 有 一个 相当 常用 又 相当 简单 的 测试项目 ， “ 交换机 对 某个 V5 接口 发起 主备 倒换 命令 ” 。 这 在 所有 的 V5 测试 中 都 会 很 顺利 地 通过 的 项目 ， 在 以前 这个 项目 也 测试 过 许多次 ， 也 从来 没有 遇到 过 异常情况 。 	 可是 在 一次 测试 中 却 遇到 麻烦 ， 在 交换机 侧 输入 了 参数 “ 模块号 ” 、 “ V5 接口号 ” 、 “ 逻辑 C 通道 ID ” 之后 ， 发起 主备 链路 倒换 的 命令 ， 操作 的 结果 居然 是 “ 无效 的 V5 端口 ” 。 	 这种 提示 令人 感到 很 诧异 ， 因为 从 AN 侧 能够 正常 发起 主备 链路 倒换 ， 从 LE 侧 也 能 正常 发起 该 V5 端口 的 指定 链路 倒换 ， 而且 系统 也 完全 正常 ， 可见 数据 配置 并 没有 错误 。 排除 了 人为 的 错误 之后 ， 我 把 重点 放到 了 这 三个 输入 参数 上 ： “ 模块号 ” ， “ V5 接口号 ” 均 是 非常 常规 的 数值 ， 应该 没有 问题 ； “ 逻辑 C 通道 ID ” 数值 比较 大 ， 但是 仍然 在 协议 规定 的 65535 之内 ， 应该 为 有效值 。 想到 常规 配置 数据 时 “ 逻辑 C 通道 ID ” 值 一直 配 得 比较 小 ， 或许 问题 就 出 在 此 。 	 于是 把 “ 逻辑 C 通道 ID ” 值 改小 ， 再作 同样 的 操作 ， 操作 成功 。 到 此 很 显然 是 这个 参数 的 有效值 范围 定义 有误 ， 再 细细 检查 ， 发现 它 只 在 单字节 范围 内 有效 ， 必然 是 该 参数 定义 的 类型 有误 。 原因 是 ： 在 函数 OAM _ Swap _ Communication _ Link （ _ UC   v5 _ interface ， _ UC   logic _ c _ id ） 里 将 逻辑 C 通道 定义 为 字符 型 导致 ， 改为 _ US 型 即 解决 。 	 推而广之 ， 在 终端 的 功能测试 中 ， 对 输入 参数值 的 测试 ， 应该 尽量 覆盖 所有 的 有效值 。 在 正常 情况 下 ， 如果 输入 值 在 为 有效值 ， 则 应该 得出 正确 的 结果 ； 如果 输入 值为 非法 值 ， 则 系统 应该 给出 错误 提示 ， 并且 不予 执行 。   对于 参数值 有效性 的 判断 ， 特别 应该 注意 一些 特殊 值 和 临界值 ， 比如 在 字节 和 双 字节 处 等等 。 【 案例 2.1 . 5 】 现象 与 分析 ：                 在 回归 “ 载频 配置 表及 跳频 数据表 中有 零 频点 或 重复 频点 时 ， MA 编码 不 正确 ” 问题 单时 。 发现 当 载频 配置 表及 跳频 数据表 中有 重复 频点 或 零 频点 时 ， 带 跳频 的 呼叫 不 成功 。                   这时 首先 考虑 系统 消息 发 的 是否 正确 ， 观察 系统 消息 一 ， 发现 所带 的 CA 表 没有 错误 ， 已经 过滤 掉 了 重复 频点 和 零 频点 。                   在 考虑 指配 命令 所带 的 MA 值 是否 正确 ， 结果 发现 MA 编码 也 是 正确 的 ， 也 已经 过滤 掉 重复 频点 和 零 频点 。                           经过 以上 初步 分析 以后 ， 开始 怀疑 给 基站 下 配置 时 是否 也 正确 过滤 了 无效 频点 。 然后 查阅 代码 ， 发现 果然   BTSM 在 对 基站 初始化 设置 载频 属性 及 设置 信道 属性 时 ， 没有 对 载频 配置 表及 跳频 数据表 中频 点 的 有效性 做 检查 ， 以致于 表中 出现 非法 频点 时 跳频 呼叫 不 成功 。         回顾 与 反思 ：                     这个 问题 的 发现 并 没有 用 什么 特殊 的 分析方法 ， 只不过 是 一般 的 “ 排除法 ” ， 而且 这个 问题 也 不是 隐藏 的 非常 之深 ， 但是 我 觉得 这个 问题 的 发现 暴露 了 我们 在 开发 过程 中 的 一个 问题 。 那 就是 ： 如何 实现 各个 模块 之间 的 有效 沟通 ， 避免 因为 某一 模块 的 修改 而 引起 其他 模块 的 连锁 反映 。                 本来 RR 和 BTSM 都 没有 考虑 重复 频点 和 零 频点 的 情况 ， 大家 都 寄托 与 数据 配置 的 正确 ， 却 也 相安无事 。 RR 首先 增加 了 对 非法 频点 的 过滤 ， 本来 是 件 好事 ， 使 我们 的 系统 变 的 更加 坚强 ， 但是 BTSM 并不知道 这一 变化 ， 于是 在 错误 数据 面前 束手无策 ， 反而 起到 了 相反 的 效果 。                 公司 常说 “ 下 一道 工序 是 上 一道 工序 的 上帝 ” ， 是不是 可以 引申为 “ 其他 相关 模块 是 本 模块 的 上帝 ” 。 试想 如果 各个 模块 多 想想 自己 的 改动 是否 给 别人 带来 不良影响 ， 多 及时 了解 一下 其他 模块 的 最新进展 。 那么 此类 问题 将 不再 会 发生 。 【 案例 2.1 . 6 】 【 正                         文 】 现象 与 分析 ：                   在 动态数据 配置 测试 增加 小区 时 ， 发现 小区 不能 正常 初始化 。 观察 ABIS _ BTSM 接口 跟踪 窗口 ， 没有 关于 初始化 流程 的 相关 消息 。 经过 分析 发现 是 调用函数 。       BTSM _ make _ send _ site _ config ( _ UC   site _ no   ,   _ UC   ObjectClass   ,   _ US   BTS _ no   , _ UC   TRX _ no   ,   _ UC   OperMode ) {           … … …         / / 判断 合法性         if   ( ( site _ no   > =   MAX _ SITE _ NUM )                 | |   ( BTS _ no   > =   MAX _ BTS _ NUM )                 | |   ( TRX _ no   > =   MAX _ TRX _ A _ BTS ) )         {                   ASSERT ( FALSE ) ;                   return   ( FALSE ) ;         } 　 　 … … … } 由于 进行 小区 级 的 操作 调用 该 函数 时 ， TRX _ NO 以 0xFF 带入 ， 则 在 函数 合法性检查 时 就 会 返回 。 从而 引发 该 错误 。 回顾 与 反思 ：         这是 一个 比较 普通 的 错误 ， 但是 回顾 它 产生 和 解决 的 过程 ， 觉得很有 启发 ， 也 引起 了 我 对 编程 规范 的 一些 思考 。 	 可以 说 该 错误 的 引起 是 与 编程 规范 有关 , 本来 函数   BTSM _ make _ send _ site _ config ( ) 没有 对   BTS _ no 和 TRX _ no   的 合法性 判断 ， 在 代码 审查 时 ， 我们 考虑 到 这 不 符合 编程 规范 中 的 “ 检查 所有 参数 输入 的 有效性 ” 这 一条 ， 于是 提出 请 开发人员 增加 对 参数 的 有效性 检查 。                   但是 我们 和 开发人员 都 忽略 的 一个 问题 ， 那 就是 ， 该 函数 被 不同 级别 的 对象 调用 ， 当 进行 小区 级 操作 时 ， TRX _ NO 以 0xFF 带入 ， 则 在 函数 合法性检查 时 就 会 返回 ， 引起 上述 错误 。         让 我们 再 回头 看看 这个 函数 ， 发现 依然 不 符合 编程 规范 ， 至少 违反 了 “ 不要 设计 多用途 面面俱到 的 函数 ” 这 一条 。         查看 我们 的 代码 ， 类似 的 问题 还有 不少 ， 而且 诸如 ： 函数 入口 参数 不 加 有效性 检查 、 函数 返回值 不 加 处理 等 问题 也 可以 找到 。 这些 问题 就象 一颗颗 隐型 炸弹 ， 在 稍微 不 注意 时 就 会 带来 严重后果 。         正如 前 文 所述 ， 测试 和 开发人员 都 会 因为 “ 代码 熟悉 程度 ” 、 “ 代码 编制 时间 太久 有所 遗忘 ” 等 诸如此类 的 原因 而 忽略 一些 问题 。 这时 ， 良好 的 程序 风格 和 编程 规范 就 会 成为 一把 强有力 的 保护伞 。 试想 如果 本文 所 提到 的 函数 从 设计 到 开发 都 严格 按照 规范 来 进行 ， 那么 这个 问题 就 没有 产生 的 土壤 ， 如果 我们 的 每 一段 代码 的 编写 都 严格遵守 规范 ， 那么 我们 的 系统 将 变 的 有 多么 坚不可摧 。 2 、 注意 多 出口 函数 的 处理 【 案例 2.2 . 1 】 摘                         要 ： 如果 函数 存在 多个 出口 ， 应 注意 函数 对 各个 出口 的 处理 。               问题 描述 ： 根据 函数 功能 的 需求 ， 被测 函数 在 函数 体 开始 时 保存 了 当前 系统 任务 模式 ， 并 设置 新 的 任务 模式 为 不可 抢占 模式 ， 在 函数 返回 时 应该 恢复 任务 的 旧 模式 ， 否则 会 影响 整个 系统 功能 的 实现 。 可是 问题 就 出 在 这里 。 由于 函数 有 复杂 的 分支 结构 ， 有 多个 出口 ， 有 的 出口 对 任务 模式 进行 了 恢复 ， 有 的 出口 没有 恢复 ， 这样 就 可能 导致 函数 返回 后 系统 任务 模式 被 改变 的 问题 。                 问题 分析 ： 此 问题 出现 的 原因 在于 函数 有 多个 出口 ， 而 程序员 往往 注重 各个 分支 功能 的 实现 的 细节 ， 而 忽视 了 或者 是 忘记 了 在 函数 出口 应 做 的 收尾 工作 。 这 就 象 打 一场 战争 一样 ， 战争 胜利 了 ， 还要 打扫战场 ， 开 总结 大会 ， 否则 就会象 李自成 一样 ， 仗 打 完 了 就 开始 享受 了 ， 最后 前功尽弃 。 毛主席 说得好 ： “ 宜将 剩勇 追 穷寇 ， 不可 沽名 学 霸王 ” 。 所以 ， 函数 出口 的 处理 应 充分 重视 。                 案例 意义 ： 这 类 问题 很 常见 ， 对于 有 多个 出口 的 函数 ， 测试 时应 充分 构造 测试 例 ， 采用 分支 覆盖 的 测试方法 对 函数 各个 出口 的 环境 恢复 、 资源 释放 情况 进行 观察 。 对于 编程人员 来说 ， 如果 使 函数 有 统一 出口 ， 可 有效 避免 或 减少 类似 问题 。   三 、 维护 类 代码 问题 1 、   统一 枚举 类型 的 使用 【 案例 3.1 . 1 】 【 正                         文 】             在 对 基站 告警 屏蔽 的 测试 中 ， 偶尔 使用 一个 告警 ID 测试 ， 基站 出乎意料 地 报错 ： 消息 与 物理 位置 不 一致 ； 通过 跟踪 消息 ， 发现 主机 消息 中 使用 的 单板 类型 值 与 基站 的 不 一致 ； 查看 主机 程序 得知 ： 对 基站 的 单板 类型 （ TRX ） 的 定义 中 ： 告警 台 和 告警 屏蔽 使用 0X23 （ BCID _ CUI ） , 而据 基站 开发人员 称 ， 他们 使用 的 是 0X09 （ BCID _ TRX ） 。             该 问题 给 我们 的 启示 是 ： 测试 中 我们 应 尽可能 地 遍历 实际 可能 的 情况 ； 另外 希望 BTS 和 BSC 的 开发人员 间 的 协作 更加 精密 无懈可击 ！ 2 、   注释 量 至少 占 代码 总量 的 20 ％ 【 案例 3.2 . 1 】 对 XXX 产品 BAM 某 版本 部分 代码 注释 量 的 统计 	 	 	 	 	                       注释 比例 统计 	 	 	 	 	 	     比例 （ 按 字节 ） 	 	 比例 （ 按字 ） 	 	 比例 （ 按行 ） 	 	 	 文件名 = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = 0.000 (         0 /   2160 ) 	 	 0.000 (         0 /     352 ) 	 	 0.000 (         0 /       48 ) 	 	 hlr \ source \ include \ aa . h0 . 000 (         0 /   1317 ) 	 	 0.000 (         0 /     137 ) 	 	 0.000 (         0 /       64 ) 	 newalarm \ source \ include \ alarmerr . h0 . 080 (     228 /   2841 ) 	 	 0.115 (       49 /     426 ) 	 	 0.030 (         7 /     230 ) 	 newalarm \ source \ include \ alarmrec . h0 . 222 (     220 /     988 ) 	 	 0.213 (       37 /     173 ) 	 	 0.115 (       11 /       95 ) 	 newconfig \ src \ include \ alarmrec . h0 . 000 (         0 /     329 ) 	 	 0.000 (         0 /       27 ) 	 	 0.000 (         0 /       24 ) 	 newfhlr \ source \ include \ alarmrec . h0 . 151 (     691 /   4563 ) 	 	 0.242 (     128 /     528 ) 	 	 0.114 (       26 /     228 ) 	 hlr \ source \ assembler . c0 . 229 (     631 /   2748 ) 	 	 0.361 (     113 /     313 ) 	 	 0.160 (       22 /     137 ) 	 newalarm \ source \ assembler . c = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = 0.088 ( 213896 / 2423601 ) 	 0.122 ( 32953 / 268773 ) 	 0.082 ( 10475 / 127119 ) 	 总计 （ 整个 项目 ）             8 ％ 	 	 	 	 12 ％ 	 	 	 8 ％   四 、 产品 兼容性问题 1 、 系统配置 、 命令 方式 【 案例 4.1 . 1 】 事故 现象 ： 有时 RPU   A 不能 被 其他 网络设备 访问 ， 从 其他 主机 或 RPU 板上 PING   RPU   A ， 不通 。 RPU   A 自己 PING 自己 ， 也 不通 。 RPU 板 复位 后 ， 恢复正常 。 此 问题 偶然 出现 。 问题 分析 步骤 ： 首先 分析 造成 RPU 板 网络 不通 的 原因 通常 有 以下 几种 ： A )   物理 连接 的 问题 ( 如 网口 坏 ) ； B )   以太网 设置 为 自环 工作 方式 ； C )   以太网 链路层 协议 有误 ， Ethernet   II 、 SNAP 不 一致 ； D )   MAC 地址 非法 ( 如为 广播 地址 或 首位 不是 偶数 等 ) ； E )   MAC 或 IP地址 与 其它 网络设备 重复 ； F )   IP 协议 设置 为 不 转发 ； G )   设置 了 防火墙 ； 经过 检查 ， 可以 完全 排除 A 、 B 、 C 、 D 、 E 、 F 这 几种 原因 ， 而 以太网 口 也 没有 设置 任何 防火墙 规则 ， 默认 的 包 过滤 设置 为 允许 通过 。 但 不能 排除 是 防火墙 的 原因 。 为了 验证 是否是 防火墙 造成 的 ， 打开 RPU   A 的 防火墙 调试信息 。 果然 ， 发现 是 防火墙 有 限制 ， 采用 了 防火墙 规则 2 ， 该 规则 限制 访问 网络设备 。 可是 以太网 口 的 防火墙 没有 配置 任何 规则 ， 从 理论 上 来说 ， 它 应该 只 适用 规则 0 ， 即 默认 规则 。 是 什么 原因 使 以太网 口 采用 了 2 号 规则 呢 ？ 进一步 观察 调试信息 ， 发现 以太网 口 所 分配 的 内部 用户 号 为 49 ！ 这时 我们 想到 防火墙 所用 的 内部 用户 号 可能 与 DMU 通道 号 有 直接 对应 关系 。 经过 试验 ， 果然 发现 对应 普通 拨号 来说 ， 防火墙 内部 用户 号 就 等于 用户 所 占用 的 DMU 通道 号 。 这时 ， 把 RPU 板上 的 所有 DMU 通道 闭塞 ， 只 保留 49 号 DMU 通道 ， 用户 拨号上网 ， 让 它 占用 第 49 号 通道 ， 并 使 该 用户 采用 第 3 号 防火墙 规则 。 这是 ， 以太网 口 同样 也 该 为 收 第 3 号 防火墙 规则 限制 。 最后 ， 我们 从头 重复 一次 刚才 的 过程 ： 1 、 复位 RPU 板后 ， 用户 没有 拨号上网 ， RPU 板 以太网 口 所 采用 的 防火墙 的 内部 用户 号 为 49 ， 采用 第 0 号 防火墙 规则 。 2 、 第 49 号 MODEM 有 用户 上网 ， 且 该 用户 采用 的 防火墙 规则 为 X ( 0 < X < = 50 ) ， 则 以太网 口 防火墙 规则 也 相应 为 X 。 至此 ， 问题 已经 查明 ， 防火墙 对 以太网 口 处理不当 ， 不 应该 分配 内部 用户 号 为 49 给 以太网 口 ， 以致 与 第 49 号 DMU 通道 形成 不 应有 的 关联 。 这 给 系统 运行 带来 极大 隐患 。 【 案例 4.1 . 2 】 	 数据通信 某 产品 ， 在 进行 终端 并行 测试 的 过程 中 发现 一 很 奇怪 的 问题 。 先 通过 TELNET 或 NETTERM 登录 到 主机 系统 上 ， 然后 在 两个 TELNET 终端 同时 以 大包 PING 主机 ， PING   XXX 。 XXX 。 XXX 。 XXX     ， 包长 为 1000 个 Bytes ， 其中 一个 终端 收到 两个 应答 后 ， 不再 有 任何 反应 ， 另 一个 终端 收到 一个 应答 后 ， 显示 超时 ， 此后 不再 有 任何 反应 。 重新 TELNET 登录 ， 还 可以 登录 一个 TELNET 终端 ， 但 试图 再 登录 第二个 TELNET 终端 失败 （ 此 系统 共 支持 3 个 TELNET 终端 ） 。 测试人员 怀疑 此前 登录 的 两个 TELNET 任务 已经 死 掉 。 于是 通过 超级终端 登录 到 串口 ， 打开 TRACE 信息 ， TRACE 信息 显示 当前 已有 3 个 TELNET 任务 处于 运行 状态 ， 但 实际上 此时 已 只有 一个 TELNET 终端 可用 ， 另 两个 TELNET 终端 已经 没有 反应 了 ， 而且 确定 再 没有 其它 人 登录 到 此 交换机 系统 上 ， 至此 ， 确定 是 前述 两个 TELNET 任务 已经 死 掉 。 但是 ， 在 与 开发人员 一起 重现 此 问题 时 ， 奇怪 的 现象 发生 了 ， 在 有 的 机架 上 重复 上述 测试步骤 ， 问题 每次 都 能 重现 ， 而 在 有 的 机架 上 重复 上述 测试步骤 ， 却 非常 正常 ， 没有 任何 问题 。 开发人员 仔细检查 程序 也 无法 发现 问题 症结所在 。 此 问题 持续 多日 无法 解决 。 最后 ， 经众 开发人员 会诊 ， 怀疑 是 pSOS 系统配置 的 问题 ， 经 比较 两个 产生 不同 现象 的 机架 上 pSoS 系统 的 系统 配置文件 ， 发现 其中 关于 pNA + 的 Buffer 配置 部分 ， 某些 配置 不同 。 将 配置 改为 无 问题 的 机架 上 的 系统配置 后 ， 进行 测试 ， 问题 消失 。 若 恢复原 配置 则 问题 重现 。 因此 ， 此 问题 最后 确定 为 系统配置 有误 。 	 由此 案例 ， 我们 可 得到 一个 经验 ， 那 就是 ， 当 系统 在 不同 机架 上 运行 现象 不 同时 ， 除 考虑 其它 可能 原因 外 ， 还应 考虑 是否 操作系统 配置 不当 。 另外 ， 此 问题 还 带 出 了 一个 附加 的 问题 ， 那 就是 ， 我们 的 版本 管理 存在 较大 的 问题 ， 同 为 测试 机架 ， 但 不同 的 机架 上 运行 的 程序 版本 却 不 一样 。 2 、 设备 对接 【 案例 4.2 . 1 】 【 正                         文 】 测试环境 ：             A8010   Refiner 通过 中继线 与 Bell   1240 交换机 进行 对接 。                                       现象 描述 ：             从 Bell   1240 交换机 引出 PRI 中继线 接入 到 Refiner 的 E1 接 入口 上 ， 接通 后 看 Refiner   RPU 板 的 中继 灯为 灭 状态 ， 但用 电话 进行 测试 ， 线路 不通 为 忙音 。 原因 分析 ：         问题 的 原因 可能 有 两点 ：       1 、 Bell   1240 未送 主叫 与 被叫 号码 。       2 、 Bell   1240 交换机 PRI 选路 方式 与 Refiner 接入服务器 不同   。   解决办法 ：   ( 1 )   A8010   Refiner 配置 好 数据 后 , RPU 板 正常 运转 , 中继 显示 正常 ， 但用 电话拨号 后 为 忙音 ， 后用 Debug   进行 调试 发现 Bell   1240 交换机 未 将 用户 被叫 号码 送来 ， 而且 主叫 号码 也 不 对 ， 经 与 与 交换机 人员 联系 发现 对方 的 传送 的 主叫 全部 为 映射 的 虚拟 号码 ， 只有 将 接入服务器 的 主叫 号码 改为 此 虚拟 号码 才行 ， 被叫 配置 后 可 正常 传送 至 接入服务器 。 . ( 2 )   数据 配置 正常 后 ， 发现 DMU 可 进行 选路 但 一选 就 断开 ， 经 调试 发现 Bell   1240 交换机 的 PRI 选路 方式 为 Channel 方式 ， Refiner 接入服务器 的 默认 选路 方式 为 Ts - map 方式 ， 经 更改 配置 后 用户 可 正常 接入 。 启示 与 分析               由于 我们 自己 的 测试环境 一般 都 是 我们 的 交换机 ， 我们 的 接入服务器 ， 因此 我们 的 交换机 与 接入 设备 上 运行 ， 数据 都 是 配置 好 的 ， 环境 是 稳定 的 ， 到 了 与 不是 我们 的 设备 进行 对接 时才 发现 并不一定 别人 的 设备 都 与 我们 完全 兼容 ， 有 许多 东西 都 是 在 问题 发生 后 才 认识 到 的 ( 如 PRI 的 选路 方式 ) ， 以后 在 测试 中 一定 要 深入细致 的 测到 每 一个 细小 的 问题 ， 并且 要近 可能 的 与 其它 厂家 的 设备 进行 对接 测试 ， 只有 这样 才能 保证 我们 产品 在 卖 到 局方 后 的 正常 稳定 运行 。 3 、 其他 【 案例 4.3 . 1 】 【 正           文 】 	 负荷分担 的 基本 思想 是 通过 每个 链路 中 的 带宽 来 均匀分布 流量 ， 目前 还 没有 考虑 PMP ， 2M   UNI ， 34UNI ， 没有 考虑 优先级 和 百分比 ， 况且 对于 同一 局向 的 路由表 的 地址 长度 一定 要 相等 ， 目前 对于 BEST   EFFORT 呼叫 仅 分配 150K 的 带宽 （ UBR 业务 ） ， 此参数 可 在 static   void   GetBandwidth (   STraffic   * sTempTraffic ,   DWORD   * pdwBandwidth   ) 函数 细调 ， 为了 达到 统计 均匀 ， 此参数 要 合适 。 如 有 二条 负荷分担 路由 A 、 B ， A 中 已建 了 10M 的 PVC ， 如果 上述 参数 太 少 ， 则 所有 BEST   EFFORT 呼叫 都 在 B 上 ， 而 不会 到 A 上 ， 如果 选取 150K ， 则 在 B 上 有 70 个 呼叫 （ BEST   EFFORT ） 后 ， 就 在 A 、 B 上 同时 都 分担 呼叫 。 	 根据上述 负荷分担 的 基本 思想 进行 了 负荷分担   的 功能测试 。 测试 中 的 线路 连接 图 如下 图 所示 。   	 HP 测试仪 设置 Forword / Backword       Peak   Cell   Rate 为 1000cells / s ， 测试仪 的 3 口向 7 口 发起 呼叫 （ 信令 类型 为 UNI3 . 1 ） 。 在 没有 发起 呼叫 前 ， 将 交换机   1 、 2 的 5 、 7 和 8 口 的 ILMI 和 信令 均 激活 ， 这 三个 口 不 建立 与 其它 光口 的 链路 ， 此时 这 三个 口 的 已用 带宽 （ Used   Band - In / Out ） 为 2000cellsps   （ sh   port   可以 看到 已 用 带宽 为 信令 链路 所 占 ） 。 现在 由 测试仪 3 口 发起 一次 呼叫 ， sh   port   5 、 7 可以 看到 已 用 带宽 由 2000 变为 3000 ， 同时 建立 起 一条 5 口 和 7 口间 的 SVC 。 再 发起 第二次 呼叫 ， sh   port   8 可以 看到 已 用 带宽 由 2000 变为 3000 ， 而   5 口 的 已用 带宽 由 3000 变为 4000 ， 同时 增加 了 一条 5 口 和 8 口间 的 SVC 。 如此 不断 地 发起 呼叫 ， 可以 看到 7 口 和 8 口 的 已用 带宽 是 交替 在 增长 的 ， 这样 就 证明 了 负荷分担 功能 的 实现 。 Radium . MPU % sh   po   7Port   status                                   :   ActiveBand   width                               :   STM _ 1O / E   attribute                           :   OpticalClock   attribute                     :   Source   timingType                                                     :   UNILoopback   mode                 :   No   loopAlarm   status                             :   NODEFECTMax   Band - In                           :   353207Max   Band - Out                     :   353207Used   Band - In                         :   2000Used   Band - Out                   :   2000Max   VPCs                                   :   100Max   VCCs                                   :   1900Used   PVPs                                   :   0Used   PVCs                                   :   2Used   SVCs                                   :   331Test   mode                                       :   off 	 在 测试 的 过程 中 出现 了 如下 的 现象 ： 交换机 1 的 7 口 和 交换机 2 的 7 、 8 口 的 ILMI 注册 成功 ， 三个 口 都 获得 了 对 端的 网络 前缀 ， 只有 交换机 1 的 8 口 的 ILMI 状态 为 VERIFYING ， 却 没有 获得 对 端的 网络 前缀 ， 从 LOG 信息 看 ， 该口 的 ILMI 注册 过程 正确 。 经查 该口 的 ILMI 协议 版本 为 3.1 ， 信令 版本 为 UNI3 . 1 ， 而 其它 三个 口 的 ILMI 协议 版本 为 4.0 ，   信令 版本 为 IISP ， 发起 的 所有 呼叫 都 从 交换机 1 的 7 口中 继到 交换机 2 ， 8 口 没有 进行 分担 。 将 交换机 1 的 8 口 的 ILMI 协议 版本 设置 为 4.0 ， 8 口 即可 进行 负荷分担 。 这 说明 ILMI 协议 版本 没有 实现 自 适应 的 功能 。 后 与 开发人员 沟通 后 得知 ， 我们 交换机 的 ILMI4 . 0 版本 可以 自 适应 其它 厂家 的 ILMI3 . 1 版本 ， 但 不 自 适应 我们 自己 交换机 的 ILMI3 . 1 版本 ， 对 端网络 前缀 的 获得 也 仅限于 ILMI4 . 0   ， 并且 是非 协议 规定 的 ， 是 由 我们 自己 设计 的 ， 设计 中 没有 考虑 ILMI3 . 1   对 获得 对 端网络 前缀 的 支持 。 在 实际 开局 中 ， ILMI 是 不 激活 的 ， 信令 版本 是 由 手工 设置 为 IISP 的 ， 以 实现 与 其它 厂家 的 产品 的 互通 。 	 测试 结果 说明 负荷分担 功能 已经 正确 地 实现 了 ， 但 条件 是 ILMI 的 版本 必须 为 4.0 。   五 、 版本控制 问题 1 、 新老 代码 中 同一 全局变量 不 一致 【 案例 5.1 . 1 】 【 正                         文 】                           开始 时 ， RPU 板 的 网口 地址 为 202.2 . 68.56 ， 通过 以太网 口 对 RPU 板上 的 软件 和 数据 进行 加载 ， RPU 板 运行 正常 ， 程序 和 数据 全部 正确 ； 改变 RPU 板 的 地址 （ 10.2 . 68.56 ） ， 进行 用户 呼叫 接入 测试 ， 发现 用户 正确 输入 的 用户名 和 口令 不能 验证 通过 ， 在 RPU 板 的 telnet 窗口 中 打开 RADIUS 调试 开关 ， 显示 认证 请求 报文 和 计费 报文 发 往 正确 的 RADIUS 服务器 ， 但是 一直 没有 收到 应答 ， 局方 维护 人员 查看 RADIUS 服务器 ， 也 找 不到 任何 记录 ， 验证 和 计费 始终 不能 成功 。                 接下来 通过 以下 几个 途径 尝试 定位问题 ：                 1 、 在 另 一块 RPU 板上 加载 老 版本 的 程序 （ 注意 这块 RPU 板 的 地址 已经 是 10.2 . 68.57 ） ， 重新 测试 ， 认证 和 计费 正常 进行 ， 没有 出现 以上 问题 ， 可以 排除 对方 RADIUS 服务器 存在 问题 的 可能 。                 2 、 可能 出现 问题 的 地方 是 RADIUS 报文 的 发送 和 接受 ， 考虑 到 RADIUS 报文 是 以 UDP 包 的 方式 传送 ， 所以 在 RPU 的 telnet 中 打开 UDP 报文 的 调试 开关 ， 跟踪 RADIUS 报文 ， 发现 RADIUS 报文 已经 发送 ， 但是 在 其 填充 的 源地址 （ Source   IP   Address ） 字段 的 值 是 202.2 . 68.56 ， 由此 可以 定位问题 ， 是 RADIUS 模块 在 填充 发送 的 RADIUS 报文 的 源地址 时 仍然 用 RPU 板 改变 地址 前 的 老 地址 ， 导致 RADIUS 服务器发送 的 应答 报文 不能 正确 返回 。                 问题 已经 定位 ， 时间 紧迫 ， 不 可能 立即 修改 程序 ， 所以 只能 采取 重新 复位 所有 的 RPU 板 的 方法 来 暂时 回避 问题 再次发生 。 启     示 ：                 1 、 软件 全局变量 的 更改 ， 要 考虑 到 每 一个 模块 受其 影响 的 可能 ；                 2 、 测试人员 在 测试 中要 尽可能 地多 考虑 到 各种 情况 下 的 边缘 取值 。   六 、 可 测试 性 代码 问题 1 、 调试信息 / 打印信息 的 正确性 【 案例 6.1 . 1 】 【 正                         文 】 为 制作 软件 呼叫器 ， 对 SPT 板 的 放音 程序 进行 了 修改 ， 但是 调试 中 发现 进行 呼叫 后 一段时间 交换机 自动 重启 。 于是 在 修改 的 代码 开始 处 增加 了 打印消息 ， 跟踪 程序流程 。 程序结构 如下 ：   再次 跟踪 打印信息 ， 发现 消息 打印消息 1 开始 后 就 会 发生 重启 现象 ， 多次重 试 ， 发现 消息 1 的 结束 跟踪 打印 有时 有 有时 无 ， 而 消息 2 的 打印 一直 没有 跟踪 到 。 初步判断 程序 错误 发生 在 对 消息 1 的 处理 于是 集中力量 检查 对 消息 1 的 处理 ， 但 经过 长时间 的 检查 ， 并未 在 此 处理 流程 中 发现错误 。 于是 在 消息 1 的 开始 处 直接 RETURN ， 屏蔽掉 消息 1 的 处理 。 再次 测试 ， 发现 重启 现象 依旧 ， 偶尔 能够 看到 函数 入口处 的 打印消息 。 为什么 会 出现 这样 的 情况 呢 ？ 什么 情况 导致 重启 呢 ？ 从 修改 的 情况 看 ， 可能 的 地方 只有 此 两条 消息 处 ， 会 不会 是 第二条 消息 的 处理 造成 的 ？ 虽然 从 现象 看 不太可能 。 报着 试一试 的 想法 在 消息 2 的 入口处 也 加 了 一 RETURN ， 居然 重启 现象 不 重现 了 。 立即 检查 消息 2 的 处理 ， 很快 发现 在 处理 的 开始 由于 指针 使用 错误 导致 程序 死机 重启 。 错误 是 简单 的 ， 但是 根据 现象 却 使 人 得到 错误判断 。 为什么 消息 2 导致 死机 但 其前 的 打印消息 为什么 后台 看不见 呢 ？ 考虑一下 交换机 的 消息 打印 机制 ， 我们 会 发现 ， 在 程序 中 的 打印消息 并 不是 马上 在 后 台上 显示 ， 消息 从 主机 传到 后台 需要 一定 的 时间 。 如果 用 Printf 打印消息 不久 后 ， 程序 就 发生 严重错误 而 导致 程序 死机 ， 而 打印消息 还 没有 来得及 发送到 后台 ， 当然 就 不会 出现 我们 想 “ 应该 有 的 ” 打印消息 。 【 总结 】 1 、 由于 环境 的 特殊性 ， 我们 常常 认为 “ 应该 ” 的 事件 并 没有 发生 ， 导致 我们 对 问题 迷惑不解 ； 2 、 “ 表面现象 往往 是 骗人 的 ” ， 要 找到 问题 的 实质 可能 需要 绕过 明显 摆在 我们 面前 的 “ 表面现象 ” ， 从 另 一个 角度 考虑一下 ；   案例 与 练习 第二 部分   练习 	 用户 login 模块 的 编制 ： 首先 password . txt 记录 了 注册 用户 的 id 和 口令 ， password . txt 文件 每 一行 格式 为 ： Id % % % % Password 其中 ： Id :                                 ( 字母 + 数字 )     最多 16   字符 Password :         ( 字母 + 数字 )     最多 16 字符 要求 用户 输入 id / 口令 时 ， 程序 通过 查找 password . txt ， 检查用户 是否 存在 ， 是否 合法 ， 直接 输出 相应 结果 ； 当 用户 直接 回车 时 ， 程序 退出 。 要求 考虑 一般 的 异常 。 规则 ： 1 . 	 小组 来 完成 ； 2 . 	 首先 花 30 - - 40 分钟 画 流程图 ； 3 . 	 然后 30 － 40 分钟 编码 ， 用 C语言 ， 人人 都 编 ； 4 . 	 30 - 45 分钟 小组 内部 讨论 ， 选择 最有 代表性 的 ， 认为 比较 好 的 ， 先 自行 评点 ； 5 . 	 45 分钟 - - 1 小时 ， 集体 评审 ； 	   1 〕 不 符合规范 的 是 部分 - - - - - - 〉 集体 自醒 ； 	   2 〕 符合规范 的 - - - - - - - - - - - - - - - - 〉 加强 巩固 ； 6 . 	 要求 严格 按 软件 编程 规范 来 进行 编码 、 评审 ； 7 . 	 保留 代码 ， 下 一节 要 用 。 	 - - ※   来源 : · 日月 光华   bbs . fudan . edu . cn · HTTP   [ FROM :   10.11 . 12.192 ] - - ※   转载 : · 日月 光华   bbs . fudan . edu . cn · [ FROM :   10.100 . 131.108 ]   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - [ 返回 上 一页 ]   [ 本 讨论区 ]