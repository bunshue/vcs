 日月 光华   - -   Programming 精华区 文章 阅读 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -   发信人 :   freshbird   ( 真 菜鸟 ~ 快乐 的 愚人 ) ,   信 区 :   Programming 标     题 :   学习 Linux 网络 编程 ( 3 )   发信站 :   日月 光华 站   ( Mon   Apr     2   16 : 54 : 29   2001 )   ,   站 内 信件 学习 Linux 网络 编程 ( 3 ) 6 .   高级 套 接字 函数 在 前面 的 几个 部分 里面 , 我们 已经 学会 了 怎么样 从 网络 上 读写 信息 了 . 前面 的 一些 函数 ( read , write ) 是 网络 程序 里面 最 基本 的 函数 . 也 是 最 原始 的 通信 函数 . 在 这 一章 里面 , 我们 一 起来 学习 网络通信 的 高级 函数 . 这 一章 我们 学习 另外 几个 读写 函数 . 6.1   recv 和 sendrecv 和 send 函数 提供 了 和 read 和 write 差不多 的 功能 . 不过 它们 提供   了 第四个 参数 来 控制 读写操作 . int   recv ( int   sockfd , void   * buf , int   len , int   flags ) int   send ( int   sockfd , void   * buf , int   len , int   flags ) 前面 的 三个 参数 和 read , write 一样 , 第四个 参数 可以 是 0 或者 是 以下 的 组合 _______________________________________________________________ |   MSG _ DONTROUTE   |   不 查找 路由表   | |   MSG _ OOB   |   接受 或者 发送 带外 数据   | |   MSG _ PEEK   |   查看 数据 , 并 不 从 系统 缓冲区 移走 数据   | |   MSG _ WAITALL   |   等待 所有 数据   | | - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - | MSG _ DONTROUTE : 是 send 函数 使用 的 标志 . 这个 标志 告诉 IP 协议 . 目的 主机 在 本地网络 上面 , 没有 必要 查找 路由表 . 这个 标志 一般 用 网络 诊断 和 路由 程序 里面 . MSG _ OOB : 表示 可以 接收 和 发送 带外 的 数据 . 关于 带外 数据 我们 以后 会 解释 的 . MSG _ PEEK : 是 recv 函数 的 使用 标志 , 表示 只是 从 系统 缓冲区 中 读取 内容 , 而 不 清楚 系统 缓冲区 的 内容 . 这样 下次 读 的 时候 , 仍然 是 一样 的 内容 . 一般 在 有 多个 进程 读写 数据 时 可以 使用 这个 标志 . MSG _ WAITALL 是 recv 函数 的 使用 标志 , 表示 等到 所有 的 信息 到达 时才 返回 . 使用 这个 标志 的 时候 recv 回 一直 阻塞 , 直到 指定 的 条件 满足 , 或者 是 发生 了 错误 .   1 ) 当读 到 了 指定 的 字节 时 , 函数 正常 返回 . 返回值 等于 len   2 ) 当读 到 了 文件 的 结尾 时 , 函数 正常 返回 . 返回值 小于 len   3 ) 当 操作 发生 错误 时 , 返回 - 1 , 且 设置 错误 为 相应 的 错误 号 ( errno ) 如果 flags 为 0 , 则 和 read , write 一样 的 操作 . 还有 其它 的 几个 选项 , 不过 我们 实际上 用 的 很少 , 可以 查看   Linux   Programmers   Manual 得到 详细 解释 . 6.2   recvfrom 和 sendto 这 两个 函数 一般 用 在 非套 接字 的 网络 程序 当中 ( UDP ) , 我们 已经 在 前面 学会 了 . 6.3   recvmsg 和 sendmsgrecvmsg 和 sendmsg 可以 实现 前面 所有 的 读写 函数 的 功能 . int   recvmsg ( int   sockfd , struct   msghdr   * msg , int   flags ) int   sendmsg ( int   sockfd , struct   msghdr   * msg , int   flags ) struct   msghdr { void   * msg _ name ; int   msg _ namelen ; struct   iovec   * msg _ iov ; int   msg _ iovlen ; void   * msg _ control ; int   msg _ controllen ; int   msg _ flags ; } struct   iovec { void   * iov _ base ;   / *   缓冲区 开始 的 地址   * / size _ t   iov _ len ;   / *   缓冲区 的 长度   * / } msg _ name 和   msg _ namelen 当套 接字 是非 面向 连接 时 ( UDP ) , 它们 存储 接收 和 发送 方 的 地址 信息 . msg _ name 实际上 是 一个 指向 struct   sockaddr 的 指针 , msg _ name 是 结构 的 长度 . 当套 接字 是 面向 连接 时 , 这 两个 值应 设为 NULL .   msg _ iov 和 msg _ iovlen 指出 接受 和 发送 的 缓冲区 内容 . msg _ iov 是 一个 结构 指针 , msg _ iovlen 指出 这个 结构 数组 的 大小 .   msg _ control 和 msg _ controllen 这 两个 变量 是 用来 接收 和 发送 控制数据 时 的   msg _ flags 指定 接受 和 发送 的 操作 选项 . 和 recv , send 的 选项 一样 6.4   套 接字 的 关闭 关闭 套 接字 有 两个 函数 close 和 shutdown . 用 close 时 和 我们 关闭 文件 一样 . 6.5   shutdownint   shutdown ( int   sockfd , int   howto ) TCP 连接 是 双向 的 ( 是 可 读写 的 ) , 当 我们 使用 close 时 , 会 把 读写通道 都 关闭 , 有时 侯 我们 希望 只 关闭 一个 方向 , 这个 时候 我们 可以 使用 shutdown . 针对 不同 的 howto , 系统 回 采取 不同 的 关闭 方式 . howto = 0 这个 时候 系统 会 关闭 读 通道 . 但是 可以 继续 往 接字 描述符 写 . howto = 1 关闭 写 通道 , 和 上面 相反 , 着 时候 就 只 可以 读 了 . howto = 2 关闭 读写通道 , 和 close 一样   在 多 进程 程序 里面 , 如果 有 几个 子 进程 共享 一个套 接字 时 , 如果 我们 使用 shutdown ,   那么 所有 的 子 进程 都 不 能够 操作 了 , 这个 时候 我们 只 能够 使用 close 来 关闭 子 进程 的 套 接字 描述符 . 7 .   TCP / IP 协议 你 也许 听说 过 TCP / IP 协议 , 那么 你 知道 到底 什么 是 TCP , 什么 是 IP 吗 ? 在 这 一章 里面 , 我们 一 起来 学习 这个 目前 网络 上用 最 广泛 的 协议 . 7.1   网络 传输 分层 如果 你 考过 计算机 等级 考试 , 那么 你 就 应该 已经 知道 了 网络 传输 分层 这个 概念 . 在 网络 上 , 人们 为了 传输数据 时 的 方便 , 把 网络 的 传输 分为 7 个 层次 . 分别 是 : 应用层 , 表示层 , 会话层 , 传输层 , 网络层 , 数据 链路层 和 物理层 . 分好 了 层 以后 , 传输数据 时 , 上 一层 如果 要 数据 的话 , 就 可以 直接 向下 一层 要 了 , 而 不必要 管 数据传输 的 细节 . 下 一层 也 只 向 它 的 上 一层 提供数据 , 而 不要 去 管 其它 东西 了 . 如果 你 不想 考试 , 你 没有 必要 去 记 这些 东西 的 . 只要 知道 是 分层 的 , 而且 各层 的 作用 不同 . 7.2   IP 协议 IP 协议 是 在 网络层 的 协议 . 它 主要 完成 数据包 的 发送 作用 .   下面 这个 表是 IP4 的 数据包 格式 0   4   8   16   32 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - | 版本   | 首部 长度 | 服务类型 |   数据包 总长   | - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - |   标识   | DF   | MF |   碎片 偏移   | - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - |   生存 时间   |   协议   |   首部 较验 和   | - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - |   源 IP地址   | - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - |   目的 IP地址   | - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - |   选项   | = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = |   数据   | - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 下面 我们 看一看 IP 的 结构 定义 struct   ip { # if   __ BYTE _ ORDER   = =   __ LITTLE _ ENDIANunsigned   int   ip _ hl : 4 ;   / *   header   length   * / unsigned   int   ip _ v : 4 ;   / *   version   * / # endif # if   __ BYTE _ ORDER   = =   __ BIG _ ENDIANunsigned   int   ip _ v : 4 ;   / *   version   * / unsigned   int   ip _ hl : 4 ;   / *   header   length   * / # endifu _ int8 _ t   ip _ tos ;   / *   type   of   service   * / u _ short   ip _ len ;   / *   total   length   * / u _ short   ip _ id ;   / *   identification   * / u _ short   ip _ off ;   / *   fragment   offset   field   * / # define   IP _ RF   0x8000   / *   reserved   fragment   flag   * / # define   IP _ DF   0x4000   / *   dont   fragment   flag   * / # define   IP _ MF   0x2000   / *   more   fragments   flag   * / # define   IP _ OFFMASK   0x1fff   / *   mask   for   fragmenting   bits   * / u _ int8 _ t   ip _ ttl ;   / *   time   to   live   * / u _ int8 _ t   ip _ p ;   / *   protocol   * / u _ short   ip _ sum ;   / *   checksum   * / struct   in _ addr   ip _ src ,   ip _ dst ;   / *   source   and   dest   address   * / } ; ip _ vIP 协议 的 版本号 , 这里 是 4 , 现在 IPV6 已经 出来 了 ip _ hlIP 包 首部 长度 , 这个 值以 4 字节 为 单位 . IP 协议 首部 的 固定 长度 为 20 个 字节 , 如果 IP 包 没有 选项 , 那么 这个 值为 5 . ip _ tos 服务类型 , 说明 提供 的 优先权 . ip _ len 说明 IP 数据 的 长度 . 以 字节 为 单位 . ip _ id 标识 这个 IP 数据包 . ip _ off 碎片 偏移 , 这 和 上面 ID 一起 用来 重组 碎片 的 . ip _ ttl 生存 时间 . 没 经过 一个 路由 的 时候 减一 , 直到 为 0 时 被 抛弃 . ip _ p 协议 , 表示 创建 这个 IP 数据包 的 高层 协议 . 如 TCP , UDP 协议 . ip _ sum 首部 校验 和 , 提供 对 首部 数据 的 校验 . ip _ src , ip _ dst 发送者 和 接收者 的 IP地址 关于 IP 协议 的 详细情况 , 请 参考   RFC7917 . 3   ICMP 协议 ICMP 是 消息 控制协议 , 也 处于 网络层 . 在 网络 上 传递 IP 数据包 时 , 如果 发生 了 错误 , 那么 就会用 ICMP 协议 来 报告 错误 . ICMP 包 的 结构 如下 : 0   8   16   32 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - |   类型   |   代码   |   校验 和   | - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - |   数据   |   数据   | - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ICMP 在 中 的 定义 是 struct   icmphdr { u _ int8 _ t   type ;   / *   message   type   * / u _ int8 _ t   code ;   / *   type   sub - code   * / u _ int16 _ t   checksum ; union { struct { u _ int16 _ t   id ; u _ int16 _ t   sequence ; }   echo ;   / *   echo   datagram   * / u _ int32 _ t   gateway ;   / *   gateway   address   * / struct { u _ int16 _ t   __ unused ; u _ int16 _ t   mtu ; }   frag ;   / *   path   mtu   discovery   * / }   un ; } ; 关于 ICMP 协议 的 详细情况 可以 查看   RFC7927 . 4   UDP 协议 UDP 协议 是 建立 在 IP 协议 基础 之上 的 , 用 在 传输层 的 协议 . UDP 和 IP 协议 一样 是 不 可靠 的 数据 报 服务 . UDP 的 头 格式 为 : 0   16   32 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - |   UDP 源 端口   |   UDP 目的 端口   | - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - |   UDP 数据 报 长度   |   UDP 数据 报 校验   | - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - UDP 结构 在 中 的 定义 为 : struct   udphdr   { u _ int16 _ t   source ; u _ int16 _ t   dest ; u _ int16 _ t   len ; u _ int16 _ t   check ; } ; 关于 UDP 协议 的 详细情况 , 请 参考   RFC7687 . 5   TCPTCP 协议 也 是 建立 在 IP 协议 之上 的 , 不过 TCP 协议 是 可靠 的 . 按照 顺序 发送 的 . TCP 的 数据结构 比 前面 的 结构 都 要 复杂 . 0   4   8   10   16   24   32 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - |   源 端口   |   目的 端口   | - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - |   序列号   | - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - |   确认 号   | - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - |   |   | U | A | P | S | F |   | | 首部 长度 |   保留   | R | C | S | Y | I |   窗口   | |   |   | G | K | H | N | N |   | - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - |   校验 和   |   紧急 指针   | - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - |   选项   |   填充 字节   | - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - TCP 的 结构 在 中 定义 为 : struct   tcphdr { u _ int16 _ t   source ; u _ int16 _ t   dest ; u _ int32 _ t   seq ; u _ int32 _ t   ack _ seq ; # if   __ BYTE _ ORDER   = =   __ LITTLE _ ENDIANu _ int16 _ t   res1 : 4 ; u _ int16 _ t   doff : 4 ; u _ int16 _ t   fin : 1 ; u _ int16 _ t   syn : 1 ; u _ int16 _ t   rst : 1 ; u _ int16 _ t   psh : 1 ; u _ int16 _ t   ack : 1 ; u _ int16 _ t   urg : 1 ; u _ int16 _ t   res2 : 2 ; # elif   __ BYTE _ ORDER   = =   __ BIG _ ENDIANu _ int16 _ t   doff : 4 ; u _ int16 _ t   res1 : 4 ; u _ int16 _ t   res2 : 2 ; u _ int16 _ t   urg : 1 ; u _ int16 _ t   ack : 1 ; u _ int16 _ t   psh : 1 ; u _ int16 _ t   rst : 1 ; u _ int16 _ t   syn : 1 ; u _ int16 _ t   fin : 1 ; # endifu _ int16 _ t   window ; u _ int16 _ t   check ; u _ int16 _ t   urg _ prt ; } ; source 发送 TCP 数据 的 源 端口 dest 接受 TCP 数据 的 目的 端口 seq 标识 该 TCP 所 包含 的 数据 字节 的 开始 序列号 ack _ seq 确认 序列号 , 表示 接受方 下 一次 接受 的 数据 序列号 . doff 数据 首部 长度 . 和 IP 协议 一样 , 以 4 字节 为 单位 . 一般 的 时候 为 5urg 如果 设置 紧急 数据 指针 , 则 该位 为 1ack 如果 确认 号 正确 , 那么 为 1psh 如果 设置 为 1 , 那么 接收 方 收到 数据 后 , 立即 交给 上 一层 程序 rst 为 1 的 时候 , 表示 请求 重新 连接 syn 为 1 的 时候 , 表示 请求 建立 连接 fin 为 1 的 时候 , 表示 亲戚 关闭 连接 window 窗口 , 告诉 接收者 可以 接收 的 大小 check 对 TCP 数据 进行 较核 urg _ ptr 如果 urg = 1 , 那么 指出 紧急 数据 对于 历史数据 开始 的 序列号 的 偏移 值 关于 TCP 协议 的 详细情况 , 请 查看   RFC7937 . 6   TCP 连接 的 建立 TCP 协议 是 一种 可靠 的 连接 , 为了 保证 连接 的 可靠性 , TCP 的 连接 要 分为 几个 步骤 . 我们 把 这个 连接 过程 称为 " 三次 握手 " . 下面 我们 从 一个 实例 来 分析 建立 连接 的 过程 . 第一步 客户机 向 服务器发送 一个 TCP 数据包 , 表示 请求 建立 连接 .   为此 , 客户端 将 数据包 的 SYN 位 设置 为 1 , 并且 设置 序列号 seq = 1000 ( 我们 假设 为 1000 ) . 第二步 服务器 收到 了 数据包 , 并 从 SYN 位为 1 知道 这是 一个 建立 请求 的 连接 . 于是 服务器 也 向 客户端 发送 一个 TCP 数据包 . 因为 是 响应 客户机 的 请求 , 于是 服务器 设置 ACK 为 1 , sak _ seq = 1001 ( 1000 + 1 ) 同时 设置 自己 的 序列号 . seq = 2000 ( 我们 假设 为 2000 ) . 第三步 客户机 收到 了 服务器 的 TCP , 并 从 ACK 为 1 和 ack _ seq = 1001 知道 是从 服务器 来 的 确认 信息 . 于是 客户机 也 向 服务器发送 确认 信息 . 客户机 设置 ACK = 1 , 和 ack _ seq = 2001 , seq = 1001 , 发送给 服务器 . 至此 客户端 完成 连接 . 最后 一步 服务器 受到 确认 信息 , 也 完成 连接 . 通过 上面 几个 步骤 , 一个 TCP 连接 就 建立 了 . 当然 在 建立 过程 中 可能 出现 错误 , 不过 TCP 协议 可以 保证 自己 去 处理错误 的 . 说一说 其中 的 一种 错误 . 听说 过 DOS 吗 ? ( 可不是 操作系统 啊 ) . 今年春节 的 时候 , 美国 的 五大 网站 一起 受到 攻击 . 攻击者 用 的 就是 DOS ( 拒绝 式 服务 ) 方式 . 概括 的 说 一下 原理 . 客户机 先 进行 第一个 步骤 . 服务器 收到 后 , 进行 第二个 步骤 . 按照 正常 的 TCP 连接 , 客户机 应该 进行 第三个 步骤 . 不过 攻击者 实际上 并 不 进行 第三个 步骤 . 因为 客户端 在 进行 第一个 步骤 的 时候 , 修改 了 自己 的 IP地址 , 就是说 将 一个 实际上 不 存在 的 IP 填充 在 自己 IP 数据包 的 发送者 的 IP 一栏 . 这样 因为 服务器 发 的 IP地址 没有 人 接收 , 所以 服务端 会 收不到 第三个 步骤 的 确认 信号 , 这样 服务 务端 会 在 那边 一直 等待 , 直到 超时 . 这样 当有 大量 的 客户 发出请求 后 , 服务端 会 有 大量 等待 , 直到 所有 的 资源 被 用光 , 而 不能 再 接收 客户机 的 请求 . 这样 当 正常 的 用户 向 服务器 发出请求 时 , 由于 没有 了 资源 而 不能 成功 . 于是 就 出现 了 春节 时所 出现 的 情况 .     - - ※   来源 : · 日月 光华 站   bbs . fudan . edu . cn · [ FROM :   202.119 . 32.102 ]   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - [ 返回 上 一页 ]   [ 本 讨论区 ]