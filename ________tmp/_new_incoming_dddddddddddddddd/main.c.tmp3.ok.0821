

// *****************************************************
// Dependencies
// *****************************************************
#include <stdio.h>
#include <stdlib.h>
#include "xil_cache.h"
#include "platform.h"
#include "main.h"
#include "xuartps_hw.h"
#include "periphs.h"
#include "mixer.h"
#include "gpio.h"
#include "ulpi.h"
#include "gfx.h"

/* global timer registers*/
#define SCU_GLOBAL_TIMER_COUNT_L32	(XPAR_PS7_GLOBALTIMER_0_S_AXI_BASEADDR)
#define SCU_GLOBAL_TIMER_COUNT_U32	(XPAR_PS7_GLOBALTIMER_0_S_AXI_BASEADDR+0x04)
#define SCU_GLOBAL_TIMER_CONTROL	(XPAR_PS7_GLOBALTIMER_0_S_AXI_BASEADDR+0x08)
#define SCU_GLOBAL_TIMER_ISR		(XPAR_PS7_GLOBALTIMER_0_S_AXI_BASEADDR+0x0C)
#define SCU_GLOBAL_TIMER_COMP_L32	(XPAR_PS7_GLOBALTIMER_0_S_AXI_BASEADDR+0x10)
#define SCU_GLOBAL_TIMER_COMP_U32	(XPAR_PS7_GLOBALTIMER_0_S_AXI_BASEADDR+0x14)
#define SCU_GLOBAL_TIMER_AUTO_INC	(XPAR_PS7_GLOBALTIMER_0_S_AXI_BASEADDR+0x18)

static const char ims_logo[] = "ims-small-logo.png";
static const char step_1[] = "step1.png";
static const char step_2[] = "step2.png";
static const char step_3[] = "step3.png";
static const char chicken_3[] = "chicken.png";
static const char pic11[] = "pic1.png";
static const char pic22[] = "pic2.png";
static const char pic33[] = "pic3.png";
static const char pic44[] = "pic4.png";
static const char pic55[] = "pic5.png";
static const char pic66[] = "pic6.png";

void pixmap_draw(GDisplay* pixmap, pixel_t* surface, coord_t pm_width, coord_t pm_height, gdispImage *p_Image, uint32_t pm_sx, uint32_t pm_sy, uint32_t img_sx, uint32_t img_sy);


volatile uint32_t g_ms_uptime = 0;
volatile uint32_t g_ms_tick = 0;
uint32_t g_nn = 0;
uint32_t g_dongle_plugged = 0;
uint32_t g_camera_plugged = 0;

uint32_t g_conn_status = 2;

GListener	gl;
GHandle		ghLabel1, ghLabel2, ghLabel3, ghLabel4, ghLabel5, ghLabel6, ghLabel7;

uint32_t esc_mode = 0;

static gdispImage myImage;
static GDisplay* pixmap_1;
static pixel_t* surface_1;
static GDisplay* pixmap_2;
static pixel_t* surface_2;
//static GDisplay* pixmap_3;
//static pixel_t* surface_3;

// The handle for our console
static GHandle	GW;
GWindowInit		wic;

static void createWidgets(void);
static void createConsoleWidgets(void);
static void updateConsoleWidgets(void);
void main_loop(void);

void read_usb_registers(void);
void reset_usb(void);
void parse_uart_command(void);
void parse_uart_esc_command(void);
void get_system_up_time(void);

static const char last_command[] = "help";

// *****************************************************
// Main program entry point
// *****************************************************
int main()
{
	// Local variables
	int status = 0;
	coord_t swidth, sheight;
	gdispImage *p_Image;
	uint8_t *p_byte, byte;
	uint32_t i,j, Index;
	GEvent* pe;

	p_Image = &myImage;
	update_dongle_status = 0;
	update_usb_status = 0;

	// Setup UART and caches
    init_platform();

    xil_printf("Aries Main Program\n\r");

    // Initialize peripherals
    status = periphs_init
    (
    	&periphs_inst,
    	//XPAR_CONTROL_PATH_AXI_GPIO_0_DEVICE_ID,
    	//XPAR_CONTROL_PATH_AXI_IIC_0_BASEADDR,
		//XPAR_XIICPS_0_DEVICE_ID,
		XPAR_PS7_GPIO_0_DEVICE_ID,
		XPAR_VIDEO_PATH_VIDEO_OUT_VIDEO_LOCK_MONITOR_DEVICE_ID,
		XPAR_PS7_SCUGIC_0_DEVICE_ID,
		XPAR_PS7_SCUTIMER_0_DEVICE_ID,
		XPAR_PS7_UART_0_DEVICE_ID,
		//XPAR_VIDEO_PATH_CAMERA_IN_V_TC_VTD_DEVICE_ID,
    	//XPAR_VIDEO_PATH_TPG_OLD_TPG_OLD_DEVICE_ID,
		XPAR_VIDEO_PATH_V_TPG_0_DEVICE_ID,
		//XPAR_VIDEO_PATH_CAMERA_SCALER_V_PROC_SS_1_DEVICE_ID,
		XPAR_VIDEO_PATH_CAMERA_SCALER_FREEZE_V_PROC_SS_1_DEVICE_ID,
		XPAR_VIDEO_PATH_FRAMEBUFFER_AXI_VDMA_CAMERA_DEVICE_ID,
		XPAR_VIDEO_PATH_FRAMEBUFFER_AXI_VDMA_CAMERA_FREEZE_DEVICE_ID,
		//XPAR_VIDEO_PATH_FRAMEBUFFER_OUTPUT_AXI_VDMA_GUI_DEVICE_ID,
		XPAR_VIDEO_PATH_OUTPUT_MIXER_V_MIX_0_DEVICE_ID,
		XPAR_VIDEO_PATH_VIDEO_OUT_V_TC_TFP410_DEVICE_ID,
		XPAR_VIDEO_PATH_VIDEO_OUT_V_TC_CH7038_DEVICE_ID,
		XPAR_PS7_USB_0_DEVICE_ID,
    	FRAMEBUFFER_CAMERA_START_ADDR,
		FRAMEBUFFER_CAMERA_FREEZE_START_ADDR,
		FRAMEBUFFER_GUI_START_ADDR
    );
	if (status != 0)
	{
		xil_printf("Initialization failed.\n\r");
		return -1;
	}

	// Set up Mixer Layers
	//RunMixer(periphs_inst.p_vid_output_mixer_l2_inst);

    // Initialize uGFX
	//g_nn = 1;
    gfxInit();
    xil_printf("gfxInit() complete\r\n");
	// Background process
	xil_printf("Initialization complete. Switching to background process.\n\r");

	// Set up pixmap for layer 1
    pixmap_1 = gdispPixmapCreate(LAYER1_WIDTH, LAYER1_HEIGHT);
    surface_1 = gdispPixmapGetBits(pixmap_1);
    // Draw transparency required on layer 1
    pixmap_draw(pixmap_1, surface_1, LAYER1_WIDTH, LAYER1_HEIGHT, NULL, 0, 0, 0, 0);

	// Set up pixmap for layer 2
    pixmap_2 = gdispPixmapCreate(LAYER2_WIDTH, LAYER2_HEIGHT);
    surface_2 = gdispPixmapGetBits(pixmap_2);
    // Draw transparency required on layer 2
    pixmap_draw(pixmap_2, surface_2, LAYER2_WIDTH, LAYER2_HEIGHT, NULL, 0, 0, 0, 0);

	// Open image for layer 3
	// Get the display dimensions
	swidth = gdispGetWidth();
	xil_printf("swidth: %d\r\n", swidth);
	sheight = gdispGetHeight();
	xil_printf("sheight: %d\r\n", sheight);

	// Set up IO for our image
	//g_nn = 1;
	status = gdispImageOpenFile(p_Image, ims_logo);
	//xil_printf("status mainopen: %d\r\n", status);
//	p_byte = (uint8_t *)p_Image->priv;
//	xil_printf("status: %d\r\n", status);
//	xil_printf("p_Image->type: %d\r\n", p_Image->type);
//	xil_printf("p_Image->flags: %x\r\n", p_Image->flags);
//	xil_printf("p_Image->bgcolor: %x\r\n", p_Image->bgcolor);
//	xil_printf("p_Image->memused: %d\r\n", p_Image->memused);
//	xil_printf("p_Image->maxmemused: %d\r\n", p_Image->maxmemused);
//
//	xil_printf("p_Image->priv->flags: %x\r\n", p_byte[0]);
//	xil_printf("p_Image->priv->bitdepth: %x\r\n", p_byte[1]);
//	xil_printf("p_Image->priv->mode: %x\r\n", p_byte[2]);
//	xil_printf("p_Image->priv->bpp: %x\r\n", p_byte[3]);

	//g_nn = 1;
	status = gdispImageDraw(p_Image, swidth-p_Image->width-BORDER_X*2, sheight-p_Image->height-BORDER_Y*2, p_Image->width, p_Image->height, 0, 0);
	//g_nn = 0;
	//xil_printf("status maindraw: %d\r\n", status);
	gdispImageClose(p_Image);

	// Blit surface_1 to the real display at the new position
	//g_nn =1;
	gdispBlitArea(LAYER0_WIDTH-LAYER1_WIDTH-BORDER_X, BORDER_Y, LAYER1_WIDTH, LAYER1_HEIGHT, surface_1);

	// Blit surface_2 to the real display at the new position
	gdispBlitArea(BORDER_X, LAYER0_HEIGHT-LAYER2_HEIGHT-BORDER_Y, LAYER2_WIDTH, LAYER2_HEIGHT, surface_2);

	Xil_DCacheFlush();

	// Set up Mixer Layers
	RunMixer(periphs_inst.p_vid_output_mixer_l2_inst);

	// Set the widget defaults
	gwinSetDefaultFont(gdispOpenFont("*"));
	gwinSetDefaultStyle(&BlackWidgetStyle, FALSE);
	//gdispClear(White);

	// create the widget
	//g_nn =1;
	createWidgets();

//	// We want to listen for widget events
//	geventListenerInit(&gl);
//	gwinAttachListener(&gl);
//
//	while(1) {
//		// Get an Event
//		pe = geventEventWait(&gl, TIME_INFINITE);
//	}

	// Detect Dongle status and draw image
	g_conn_status = psuart0_dongle_ping();

	if(g_conn_status == 2)
	{
			xil_printf("no dongle or camera\n\r");
			// Set Flags
			g_dongle_plugged = 0;
			g_camera_plugged = 0;
			// Show Message
			p_Image = &myImage;
			status = gdispImageOpenFile(p_Image, step_1);
			pixmap_draw(pixmap_1, surface_1, LAYER1_WIDTH, LAYER1_HEIGHT, p_Image, 0, 0, 0, 0);
			gdispBlitArea(LAYER0_WIDTH-LAYER1_WIDTH-BORDER_X, BORDER_Y, LAYER1_WIDTH, LAYER1_HEIGHT, surface_1);
			gdispImageClose(p_Image);
	}
	else if (g_conn_status == 1){
			xil_printf("dongle only\n\r");
			// Set Flags
			g_dongle_plugged = 1;
			g_camera_plugged = 0;
			// Show Message
			p_Image = &myImage;
			status = gdispImageOpenFile(p_Image, step_2);
			pixmap_draw(pixmap_1, surface_1, LAYER1_WIDTH, LAYER1_HEIGHT, p_Image, 0, 0, 0, 0);
			gdispBlitArea(LAYER0_WIDTH-LAYER1_WIDTH-BORDER_X, BORDER_Y, LAYER1_WIDTH, LAYER1_HEIGHT, surface_1);
			gdispImageClose(p_Image);
	}
	else {
			xil_printf("dongle+camera\n\r");
			// Set Flags
			g_dongle_plugged = 1;
			g_camera_plugged = 1;
			// Show Message
			p_Image = &myImage;
			status = gdispImageOpenFile(p_Image, step_3);
			pixmap_draw(pixmap_1, surface_1, LAYER1_WIDTH, LAYER1_HEIGHT, p_Image, 0, 0, 0, 0);
			gdispBlitArea(LAYER0_WIDTH-LAYER1_WIDTH-BORDER_X, BORDER_Y, LAYER1_WIDTH, LAYER1_HEIGHT, surface_1);
			gdispImageClose(p_Image);
			XVMix_LayerEnable(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_1);
	}

	Xil_DCacheFlush();

	psuart0_exposure(3);

	// Set up Mixer Layers
	//RunMixer(periphs_inst.p_vid_output_mixer_l2_inst);

	// USB Init
	ulpi_init();
	ulpi_set_vbus(TRUE);

	tusb_init(); // initialize tinyusb stack

	keyboard_host_app_init(); // Keyboard Host Init
	//mouse_host_app_init(); // Mouse Host Init
	Xil_DCacheFlush(); // Flush DCache after USB Init();
	//Xil_DCacheInvalidate();
	Xil_DCacheDisable();

	// create the widget
	createConsoleWidgets();

	main_loop();

    cleanup_platform();
    return 0;
}

#define RELEASE_INFO "Insight Medical Solutions Inc., August-17-2018\n"
#define PROMPT "[aries@ims]# "
#define UART_BUFFER_LEN 10
u8 buffer[UART_BUFFER_LEN];
u8 esc_buffer[3];
u8 ptr = 0;
u8 esc_ptr = 0;
u8 length = 0;

void main_loop()
{
	// Local variables
	char c[1]  = {0};
	//int  ii = 0;
	//unsigned int status = 0;
	gdispImage *p_Image;
	uint32_t value = 0;
	int i;
	uint32_t status;


	// Main loop
	while (1)
	{

		//xil_printf("What would you like to do? Press 'p' to print available commands.\n\r");
		c[0] = XUartPs_RecvByte(XPAR_PS7_UART_1_BASEADDR);
		//XUartPs_Recv(g_psuart1_config->BaseAddress, &c[0], 1);
		

		if(update_dongle_status == 1)
		{
			update_dongle_status = 0;
		//xil_printf("ping.\n\r");
		g_conn_status = psuart0_dongle_ping();
		if(g_conn_status == 2) // Nothing is plugged in
		{
			if(g_procedure_started) { // Procedure not started

			}
			else {
				if(g_dongle_plugged || g_camera_plugged){
					// Update Flags
					g_dongle_plugged = 0;
					g_camera_plugged = 0;
					// Dongle unplugged
					xil_printf("no dongle or camera\n\r");
					// Show Message to plug in dongle
					XVMix_LayerDisable(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_1);
					p_Image = &myImage;
					status = gdispImageOpenFile(p_Image, step_1);
					pixmap_draw(pixmap_1, surface_1, LAYER1_WIDTH, LAYER1_HEIGHT, p_Image, 0, 0, 0, 0);
					gdispBlitArea(LAYER0_WIDTH-LAYER1_WIDTH-BORDER_X, BORDER_Y, LAYER1_WIDTH, LAYER1_HEIGHT, surface_1);
					Xil_DCacheFlush();
					gdispImageClose(p_Image);
				}
			}
		}
		else if(g_conn_status == 1){ // Only dongle is plugged in

			if(g_procedure_started){ // Procedure started

			}
			else { // Procedure hasn't started
				if(g_dongle_plugged == 0 || g_camera_plugged){
					// Update Flags
					g_dongle_plugged = 1;
					g_camera_plugged = 0;
					// Dongle plugged
					xil_printf("dongle plugged\n\r");
					XVMix_LayerDisable(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_1);
					p_Image = &myImage;
					status = gdispImageOpenFile(p_Image, step_2);
					pixmap_draw(pixmap_1, surface_1, LAYER1_WIDTH, LAYER1_HEIGHT, p_Image, 0, 0, 0, 0);
					gdispBlitArea(LAYER0_WIDTH-LAYER1_WIDTH-BORDER_X, BORDER_Y, LAYER1_WIDTH, LAYER1_HEIGHT, surface_1);
					Xil_DCacheFlush();
					gdispImageClose(p_Image);
				}
			}
		}
		else { // Everything is plugged in
			if(g_procedure_started) { // Procedure not started

			}
			else {
				if(g_dongle_plugged == 0 || g_camera_plugged == 0){
					// Update Flags
					g_dongle_plugged = 1;
					g_camera_plugged = 1;
					// Dongle plugged
					xil_printf("all plugged\n\r");
					XVMix_LayerEnable(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_1);
					p_Image = &myImage;
					status = gdispImageOpenFile(p_Image, step_3);
					pixmap_draw(pixmap_1, surface_1, LAYER1_WIDTH, LAYER1_HEIGHT, p_Image, 0, 0, 0, 0);
					gdispBlitArea(LAYER0_WIDTH-LAYER1_WIDTH-BORDER_X, BORDER_Y, LAYER1_WIDTH, LAYER1_HEIGHT, surface_1);
					Xil_DCacheFlush();
					gdispImageClose(p_Image);
				}

			}
		}

		if(g_updated) {
			g_updated = 0;
			if(g_procedure_started) { // Remove all pictures
				xil_printf("update remove picture\r\n");
				pixmap_draw(pixmap_1, surface_1, LAYER1_WIDTH, LAYER1_HEIGHT, NULL, 0, 0, 0, 0);
				gdispBlitArea(LAYER0_WIDTH-LAYER1_WIDTH-BORDER_X, BORDER_Y, LAYER1_WIDTH, LAYER1_HEIGHT, surface_1);
				Xil_DCacheFlush();
			}
			else { // Add back picture
				xil_printf("update add picture\r\n");
				p_Image = &myImage;
				status = gdispImageOpenFile(p_Image, step_3);
				pixmap_draw(pixmap_1, surface_1, LAYER1_WIDTH, LAYER1_HEIGHT, p_Image, 0, 0, 0, 0);
				gdispBlitArea(LAYER0_WIDTH-LAYER1_WIDTH-BORDER_X, BORDER_Y, LAYER1_WIDTH, LAYER1_HEIGHT, surface_1);
				gdispImageClose(p_Image);
				Xil_DCacheFlush();
			}
			psuart0_exposure(g_exposure);
		}
		}
		else if(update_usb_status == 1)
		{
			update_usb_status = 0;
			updateConsoleWidgets();
		}

		//  Run USB Host Task Handlers
		tusb_task_runner(); // USB House Keeping
	    keyboard_host_app_task(NULL); // Keyboard tasks
	    //mouse_host_app_task(NULL); // Mouse Tasks
		//Xil_DCacheFlush();

		if(c[0] == 0)
			continue;

		buffer[ptr] = c[0];
		esc_buffer[esc_ptr] = c[0];
		ptr++;

		if(c[0] == 0x0d)	//Enter
		{
			/*
			for(i=0;i<ptr;i++)
			{
				xil_printf("0x%x ", buffer[i]);
			}
			xil_printf("\n\r");
			*/

			length = ptr;
			ptr = 0;
			/*
			//for(i = 0 ; i < (length - 1); i++)
				//xil_printf("%c", 0x18);
			for(i = 0 ; i < (length - 1); i++)
				xil_printf("%c", 0x7F);
			xil_printf("---");
			*/
			parse_uart_command();
			xil_printf("\n\r%s", PROMPT);
		}
		else
		{
			if(c[0] == 0x1B)
			{
				esc_mode = 1;
				buffer[0] = c[0];
				ptr = 1;
				continue;
			}
			else if(c[0] == 0x7F)
			{
				if(ptr >= 2)
				{
					xil_printf("%c", 0x7F);
					//xil_printf(".");
					ptr -= 2;
				}
				else
					ptr--;

				continue;
			}

			if(esc_mode == 1)
			{
				if(ptr == 3)
				{
					//ptr = 0;
					parse_uart_esc_command();
					esc_mode = 0;
				}
				continue;
			}

			if(isprint(c[0]))
				xil_printf("%c", c[0]);
			else
				xil_printf("0x%x", c[0]);
		}


/*
		switch (c[0])
		{
			case 'p':
				xil_printf("\n\r");
				xil_printf("------------- Aries Demo -------------\n\r");
				xil_printf("'1' = Toggle Layer 1\n\r");
				xil_printf("'2' = Toggle Layer 2\n\r");
				xil_printf("'3' = Toggle Layer 3\n\r");
				xil_printf("'n' = Set to new scaler datapath\n\r");
//				xil_printf("'o' = Set to old scaler datapath\n\r");
				xil_printf("'t' = Enable/bypass camera TPG\n\r");
				xil_printf("'y' = Enable/bypass GUI TPG\n\r");
//				xil_printf("'d' = Detect or set input frame size\n\r");
				xil_printf("'u' = Park Camera Freeze VDMA\n\r");
				xil_printf("'s' = Set output frame size\n\r");
				xil_printf("'p' = Print this menu\n\r");
				xil_printf("---------------------------------------\n\r");
				xil_printf("\n\r");
				break;
			case '1':
				xil_printf("Enabling/bypassing Layer 1.\n\r");
				status = XVMix_IsLayerEnabled(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_1);
				if(status) { // Enabled
					XVMix_LayerDisable(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_1);
				} else {
					XVMix_LayerEnable(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_1);
				}
				break;
			case '2':
				xil_printf("Enabling/bypassing Layer 2.\n\r");
				status = XVMix_IsLayerEnabled(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_2);
				if(status) { // Enabled
					XVMix_LayerDisable(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_2);
				} else {
					XVMix_LayerEnable(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_2);
				}
				break;
			case '3':
				xil_printf("Enabling/bypassing Layer 3.\n\r");
				status = XVMix_IsLayerEnabled(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_3);
				if(status) { // Enabled
					XVMix_LayerDisable(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_3);
				} else {
					XVMix_LayerEnable(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_3);
				}
				break;
//			case 'n':
//				xil_printf("Using new VPSS-based scaler datapath.\n\r");
//				periphs_select_scaler(&periphs_inst, PERIPHS_SEL_NEW_SCALER);
//				break;
//			case 'o':
//				xil_printf("Using old scaler datapath.\n\r");
//				periphs_select_scaler(&periphs_inst, PERIPHS_SEL_OLD_SCALER);
//				break;


*/
/*
			case 't':
				xil_printf("Enabling/bypassing camera TPG.\n\r");
				//periphs_toggle_camera_tpg(&periphs_inst);
				break;
			case 'y':
				xil_printf("Enabling/bypassing GUI TPG.\n\r");
				periphs_toggle_GUI_tpg(&periphs_inst);
				break;
*/
/*

			case 'u':
				xil_printf("Park/Unpark Camera Freeze VDMA.\n\r");
				periphs_toggle_camera_freeze_vdma(&periphs_inst);
				// Determine if we're in TPG or passthrough mode
				if (periphs_inst.enable_camera_freeze_vdma == PERIPHS_SEL_ENABLE_PARK)
				{
					XVMix_LayerEnable(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_2);
				}
				else
				{
					XVMix_LayerDisable(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_2);
				}
				break;

			case 'r':
				read_usb_registers();
				break;
			case 'w':
				xil_printf("port_connect_status_change_isr\n\r");
				port_connect_status_change_isr(0);
				break;
			case 'q':
				//xil_printf("ulpi_WriteReg 0x24\n\r");

				value = ulpi_ReadReg(ULPI_FC_CTRL);	//0x16
				value |= 0x20;
				value = 0x60;
				ulpi_WriteReg(value, ULPI_FC_CTRL);	//0x16
				xil_printf("ulpi_WriteReg 0x%x\n\r", value);
				break;
			case 's':
				xil_printf("reset usb 3\n\r");
				psusb0_hal_controller_reset(0);
				break;
			case 'e':
				xil_printf("ulpi_init  will cause a crash\n\r");
				ulpi_init();
				break;
			case 't':
				xil_printf("tusb_init\n\r");
				tusb_init(); // initialize tinyusb stack
				break;
			case 'v':
				xil_printf("tusb_isr\n\r");
				// Handle USB Related Interrupts
				tusb_isr(0);
				break;
			case 'a':
				xil_printf("all\n\r");
				tusb_init(); // initialize tinyusb stack
				value = 0x60;
				ulpi_WriteReg(value, ULPI_FC_CTRL);	//0x16
				port_connect_status_change_isr(0);
				tusb_isr(0);
				break;
			case 'b':
				xil_printf("get usb data\n\r");
				get_usb_data();



				break;
//			case 'd':
//				if (periphs_get_fmc_status(&periphs_inst))
//				{
//					xil_printf("FMC IMAGEON card is connected. Detecting input frame size.\n\r");
//					//periphs_detect_input_fsize(&periphs_inst);
//				}
//				else
//				{
//					while (1)
//					{
//						xil_printf("FMC IMAGEON card is not connected. Using internal TPG as video source. Please select a resolution to set it to. Press 'p' to print available resolutions.\n\r");
//						c = XUartPs_RecvByte(XPAR_PS7_UART_1_BASEADDR);
//						if (c == 'p')
//						{
//							xil_printf("\n\r");
//							xil_printf("------------- Resolutions -------------\n\r");
//							for (ii = 0; ii < NUM_VIDEO_RESOLUTIONS; ii++)
//							{
//								xil_printf("%d = %s\n\r", ii, vres_get_name(ii));
//							}
//							xil_printf("'p' = Print this menu\n\r");
//							xil_printf("'q' = Quit\n\r");
//							xil_printf("---------------------------------------\n\r");
//							xil_printf("\n\r");
//						}
//						else if ((c == '0')||(c == '1')||(c == '2')||(c == '3')||(c == '4') ||
//								 (c == '5')||(c == '6')||(c == '7')||(c == '8'))
//						{
//							//periphs_set_input_fsize(&periphs_inst, (c-'0'));
//							break;
//						}
//						else if (c == 'q')
//						{
//							break;
//						}
//						else
//						{
//							xil_printf("ERROR! Illegal character. Try again.\n\r");
//						}
//					}
//					break;
//				}
//				break;
//			case 's':
//				while (1)
//				{
//					xil_printf("Setting output frame size. What resolution would you like? Press 'p' to print available resolutions.\n\r");
//					c = XUartPs_RecvByte(XPAR_PS7_UART_1_BASEADDR);
//
//					if (c == 'p')
//					{
//						xil_printf("\n\r");
//						xil_printf("------------- Resolutions -------------\n\r");
//						for (ii = 0; ii < NUM_VIDEO_RESOLUTIONS; ii++)
//						{
//							xil_printf("%d = %s\n\r", ii, vres_get_name(ii));
//						}
//						xil_printf("'p' = Print this menu\n\r");
//						xil_printf("'q' = Quit\n\r");
//						xil_printf("---------------------------------------\n\r");
//						xil_printf("\n\r");
//					}
//					else if ((c == '0')||(c == '1')||(c == '2')||(c == '3')||(c == '4') ||
//							 (c == '5')||(c == '6')||(c == '7')||(c == '8'))
//					{
//						//periphs_update_output_fsize(&periphs_inst, (c-'0'));
//						break;
//					}
//					else if (c == 'q')
//					{
//						break;
//					}
//					else
//					{
//						xil_printf("ERROR! Illegal character. Try again.\n\r");
//					}
//				}
//				break;

			case 0:
				break;
			case 0x0D:
			case ' ':
				xil_printf("\n\r\n\r\n\r\n\r");
				break;
			default:
				xil_printf("\n\r---- unknown ---- c[0] = 0x%x", c[0]);
				if(isprint(c[0]))
					xil_printf("\t%c\n\r", c[0]);
				else
					xil_printf("\n\r");

				//p_periphs_inst222 = &periphs_inst;
				//p_gpio = p_periphs_inst222->p_ps_gpio_inst;
				//DataRead = XGpioPs_Read(p_gpio, XGPIOPS_BANK2);	//read bank 2 data, seems useless
				//xil_printf("DataRead = 0x%x\n\r", DataRead);
				//usleep(200000);

				//xil_printf("ERROR! Illegal character. Try again.\n\r");
				break;

		}
*/
	}
}

int cnt = 0;

static void updateConsoleWidgets(void) {
	/* Set a font */
	gwinSetDefaultFont(gdispOpenFont("*"));

	/* create the console window */
	//GWindowInit		wic;


	uint8_t reg;
	uint8_t val = 0;
	int i;

	reg = ULPI_FC_CTRL;
	val = 0;
	val = ulpi_ReadReg(reg);
	//xil_printf("read value : %02X\n\r", val);

	//gwinPrintf(GW, "System up time : %d seconds\n", g_ms_uptime / 500);
	gwinPrintf(GW, "\nULPI_FC_CTRL : 0x%x", val);
	cnt++;
	if(cnt == 10)
	{
		cnt = 0;
		gwinSetColor(GW, Red);
		for(i = 0; i < 10; i++)
		{
			gwinPrintf(GW, "\nUSB FAIL, RESET USB");
			usleep(100000);
		}
		reset_usb();
		gwinSetColor(GW, White);
	}
}

static void createConsoleWidgets(void) {
	/* Set a font */
	gwinSetDefaultFont(gdispOpenFont("*"));

	/* create the console window */
	//GWindowInit		wic;

	gwinClearInit(&wic);
	wic.show = TRUE;
	wic.x = gdispGetWidth() / 2 - 250;
	wic.y = gdispGetHeight() - 140;
	wic.width = 800;
	wic.height = 120;

	xil_printf("W = %d, H = %d\n\r", wic.width, wic.height);
	GW = gwinConsoleCreate(0, &wic);

	/* Set the fore- and background colors for the console */
	gwinSetColor(GW, White);
	gwinSetBgColor(GW, Purple);
	gwinClear(GW);

	//gwinPrintf(GW, "gwinConsoleCreate size = %d X %d\n", wi.width, wi.height);

	gwinPrintf(GW, "Insight Medical Solutions Inc.\n");
	gwinPrintf(GW, "August-23-2018\n");
	gwinPrintf(GW, "CCCCCCCCCCCCCCCCCCC\n");
}

static void createWidgets(void) {
	GWidgetInit	wi;

	coord_t wide = 600;
	coord_t thick = 40;

	// Apply some default values for GWIN
	gwinWidgetClearInit(&wi);
	wi.g.show = TRUE;

	gwinSetDefaultFont(gdispOpenFont("iskpota232"));

	// Create label
	wi.g.width = wide; wi.g.height = thick; wi.g.x = BORDER_X, wi.g.y = BORDER_Y + thick * 0;
	wi.text = "ID NO:";
	ghLabel1 = gwinLabelCreate(0, &wi);

	// Create label
	wi.g.width = wide; wi.g.height = thick; wi.g.x = BORDER_X, wi.g.y = BORDER_Y + thick * 1;
	wi.text = "NAME:";
	ghLabel2 = gwinLabelCreate(0, &wi);

	// Create label
	wi.g.width = wide; wi.g.height = thick; wi.g.x = BORDER_X, wi.g.y = BORDER_Y + thick * 3;
	wi.text = "SEX:";
	ghLabel3 = gwinLabelCreate(0, &wi);

	// Create label
	wi.g.width = wide; wi.g.height = thick; wi.g.x = BORDER_X, wi.g.y = BORDER_Y + thick * 4;
	wi.text = "AGE:";
	ghLabel4 = gwinLabelCreate(0, &wi);

	// Create label
	wi.g.width = wide; wi.g.height = thick; wi.g.x = BORDER_X, wi.g.y = BORDER_Y + thick * 5;
	wi.text = "D.O.BIRTH:";
	ghLabel5 = gwinLabelCreate(0, &wi);

	// Create label
	wi.g.width = wide; wi.g.height = thick; wi.g.x = BORDER_X, wi.g.y = BORDER_Y + thick * 7;
	wi.text = "06/03/2017";
	ghLabel4 = gwinLabelCreate(0, &wi);

	// Create label
	wi.g.width = wide; wi.g.height = thick; wi.g.x = BORDER_X, wi.g.y = BORDER_Y + thick * 8;
	wi.text = "00:00:00";
	ghLabel5 = gwinLabelCreate(0, &wi);


	/*
	// Create label
	wi.g.width = wide; wi.g.height = thick; wi.g.x = 1920/6, wi.g.y =600;
	wi.text = "XXXXXXXXXXXXXXXXXXXXXxx";
	ghLabel5 = gwinLabelCreate(0, &wi);
	*/




}

void pixmap_draw(GDisplay* pixmap, pixel_t* surface, coord_t pm_width, coord_t pm_height, gdispImage *p_Image, uint32_t pm_sx, uint32_t pm_sy, uint32_t img_sx, uint32_t img_sy)
{
	uint32_t i, j, status;
	color_t color = 0;

	//xil_printf("enter pixmap_draw\r\n");
	// Clear pixmap with 0
	memset(surface, 0, pm_width*pm_height*4); // Clear buffer

	// Overlay file is necessary
	if(p_Image != NULL) {
		// Load image
		status = gdispGImageDraw(pixmap, p_Image, (pm_width-p_Image->width) >> 1, (pm_height-p_Image->height) >> 1, p_Image->width, p_Image->height, 0, 0);
		//xil_printf("status draw: %d\r\n", status);
	}

    // Draw transparency required on layer 1
    for(j = 0; j < pm_height; j++) {
    	for(i = 0; i < pm_width; i++) {

    		if((j > (1.5*(pm_height >> 3)-1)) && (j < (pm_height-1.5*(pm_height >> 3)))) {
    			//color = gdisp_lld_get_pixel_color(pixmap);
    			//xil_printf("color: %x\r\n", color);
    			if(surface[j*pm_width + i] == 0) {
    				surface[j*pm_width + i] = ABGR2COLOR(0x00, 0x00, 0x00, 0x00);
    			}
//    			else {
    				//surface[j*pm_width + i] = ABGR2COLOR(0x00, 0x00, 0x00, 0x00);
    			//}

    		}
    		else {

				if(j < 1.5*(pm_height >> 3)) { // Top lines

					if (  (i < (1.5*(pm_height >> 3)-j)) || (i > ((pm_width-1.5*(pm_height >> 3))-1+j)    )  ) {
    					surface[j*pm_width + i] = ABGR2COLOR(0x80, 0xff, 0xff, 0xff);
    					//xil_printf("c: %x\r\n", surface_1[j*PIXMAP_WIDTH_1 + i]);
    				}
    				else {
    	    			//if(surface[j*pm_width + i] == 0) {
    	    				surface[j*pm_width + i] = ABGR2COLOR(0x00, 0x00, 0x00, 0x00);
    	    			//}
    				}

				}
				else { // Bottom lines

					if( (i < (j+1.5*(pm_height >> 3)-pm_height) ) || i > ((pm_width-(1.5*(pm_height >> 3)-(pm_height-j)))-1) ){
						surface[j*pm_width + i] = ABGR2COLOR(0x80, 0xff, 0xff, 0xff);
					}
					else {
    	    			if(surface[j*pm_width + i] == 0) {
    	    				surface[j*pm_width + i] = ABGR2COLOR(0x00, 0x00, 0x00, 0x00);
    	    			}
					}
				}
     		}
    	}
    }
}

///* Global timer set up*/
//
///* start timer */
// void gtimer_start_clock(void)
//{
//	*(volatile unsigned int*)SCU_GLOBAL_TIMER_CONTROL = ((1 << 0) | // Timer Enable
//														 (1 << 1) | // Comparator Comparison Enable
//						      	  	  	  	  	  	  	 (1 << 3) | // Auto-increment
//														 (0 << 8) 	// Pre-scale
//	);
//}
//
///* stop timer and reset timer count regs */
// void gtimer_reset_clock(void)
//{
//	gtimer_disable_clock();
//	*(volatile unsigned int*)SCU_GLOBAL_TIMER_COUNT_L32 = 0; // Reset Clock
//	*(volatile unsigned int*)SCU_GLOBAL_TIMER_COUNT_U32 = 0;
//}
//
// /* Set Comparator values */
//  void gtimer_set_comparator(uint32_t L32, uint32_t U32)
// {
// 	*(volatile unsigned int*)SCU_GLOBAL_TIMER_COMP_L32 = L32;
// 	*(volatile unsigned int*)SCU_GLOBAL_TIMER_COMP_U32 = U32;
// }
//
///* stop timer */
// void gtimer_disable_clock(void)
//{
//	*(volatile unsigned int*)SCU_GLOBAL_TIMER_CONTROL = 0;
//}
//
///* Compute mask for given delay in miliseconds*/
//int get_number_of_cycles_for_delay(unsigned int delay)
//{
//  // GTC is always clocked at 1/2 of the CPU frequency (CPU_3x2x)
//  return (XPAR_PS7_CORTEXA9_0_CPU_CLK_FREQ_HZ*delay/(2*1000));
//
//}
//
//void gtimer_reset_and_start_timer()
//{
//  	    gtimer_reset_clock();
//	    gtimer_start_clock();
//}

// uGFX SystemTick
systemticks_t gfxSystemTicks(void)
{
	return g_ms_tick;
}

systemticks_t gfxMillisecondsToTicks(delaytime_t ms)
{
	return ms;
}
/////////////////////////////////////

uint32_t tusb_tick_get(void)
{
  //return system_ticks;
  return g_ms_tick;
}

void tick_get(void)
{
	xil_printf("t=%d\n\r", g_ms_tick);
}

void tick_set(uint32_t tick)
{
	g_ms_tick = tick;
}

void reset_usb(void)
{
	uint8_t reg;
	uint8_t val = 0;

	xil_printf("usb reset\n\r");
	reg = ULPI_OTG_CTRL;
	val = 0;
	val = ulpi_ReadReg(reg);
	xil_printf("read value : %02X\n\r", val);

	val &= 0xDF;
	xil_printf("set value : %02X\n\r", val);
	ulpi_WriteReg(val, reg);

	usleep(500000);

	val |= 0x20;
	xil_printf("set value : %02X\n\r", val);
	ulpi_WriteReg(val, reg);
}

void read_usb_registers(void)
{
	uint32_t value = 0;
	uint8_t i;

	xil_printf("\n\rRead usb registers\n\r");
	value = XUsbPs_ReadReg(XPAR_XUSBPS_0_BASEADDR, 0);xil_printf("%08X ", value);
	value = XUsbPs_ReadReg(XPAR_XUSBPS_0_BASEADDR, 4);xil_printf("%08X ", value);
	value = XUsbPs_ReadReg(XPAR_XUSBPS_0_BASEADDR, 8);xil_printf("%08X ", value);
	value = XUsbPs_ReadReg(XPAR_XUSBPS_0_BASEADDR, 0xc);xil_printf("%08X ", value);
	value = XUsbPs_ReadReg(XPAR_XUSBPS_0_BASEADDR, 0x10);xil_printf("%08X ", value);
	value = XUsbPs_ReadReg(XPAR_XUSBPS_0_BASEADDR, 0x14);xil_printf("%08X\n\r", value);

	xil_printf("\n\rRead ulpi registers\n\r");
	/*
	for(i = 0; i < 8; i++)
	{
		xil_printf("0x%02X ", i);
	}
	xil_printf("\n");
	*/

	for(i = 0; i < 64; i++)
	{
		value = ulpi_ReadReg(i);	//0x16
		xil_printf("%02X", value);
		if((i%8) == 7)
			xil_printf("\n\r");
		else
			xil_printf("  ");
	}
	xil_printf("\n\r");
	xil_printf("\n\r");
}

void parse_uart_esc_command(void)
{
	int i;
	if((buffer[0] == 0x1B)&&(buffer[1] == '[')&&(buffer[2] == 'A'))
	{
		//xil_printf("Up\t");
		xil_printf("\r%s", PROMPT);
		xil_printf("%s", last_command);
		ptr = sizeof(last_command) - 1;
		for(i = 0; i < ptr; i++)
		{
			buffer[i] = last_command[i];
		}
	}
	else if((buffer[0] == 0x1B)&&(buffer[1] == '[')&&(buffer[2] == 'B'))
	{
		//xil_printf("Down\t");
		xil_printf("\r%s", PROMPT);
		xil_printf("%s", last_command);
		ptr = sizeof(last_command) - 1;
		for(i = 0; i < ptr; i++)
		{
			buffer[i] = last_command[i];
		}
	}
	else if((buffer[0] == 0x1B)&&(buffer[1] == '[')&&(buffer[2] == 'C'))
	{
		//xil_printf("Right\t");
		xil_printf("\r%s", PROMPT);
		xil_printf("%s", last_command);
		ptr = sizeof(last_command) - 1;
		for(i = 0; i < ptr; i++)
		{
			buffer[i] = last_command[i];
		}
	}
	else if((buffer[0] == 0x1B)&&(buffer[1] == '[')&&(buffer[2] == 'D'))
	{
		//xil_printf("Left\t");
		// not very good
		if(ptr >= 2)
		{
			xil_printf("%c", 0x08);
			//xil_printf(".");
			ptr -= 2;
		}
		else
			ptr--;
	}
	else if((buffer[0] == 0x1B)&&(buffer[1] == '[')&&(buffer[2] == 0x35))
	{
		xil_printf("PageUp\t");
	}
	else if((buffer[0] == 0x1B)&&(buffer[1] == '[')&&(buffer[2] == 0x5B))
	{
		xil_printf("PageDown\t");
	}
	else if((buffer[0] == 0x1B)&&(buffer[1] == '[')&&(buffer[2] == 0x31))
	{
		xil_printf("Home\t");
	}
	else if((buffer[0] == 0x1B)&&(buffer[1] == '[')&&(buffer[2] == 0x32))
	{
		xil_printf("Insert\t");
	}
	else if((buffer[0] == 0x1B)&&(buffer[1] == '[')&&(buffer[2] == 0x33))
	{
		xil_printf("Delete\t");
	}
	else if((buffer[0] == 0x1B)&&(buffer[1] == '[')&&(buffer[2] == 0x34))
	{
		xil_printf("End\t");
	}
	else
	{
		xil_printf("XXXX\t");
		for( i = 0; i<3; i++)
		{
			xil_printf("0x%x ", buffer[i]);
		}
		xil_printf("\t");
	}
}


void parse_uart_command(void)
{
	int status;
	int i;
	uint32_t value = 0;
	uint8_t reg;
	uint8_t val = 0;

	if(length == 8)
	{
		if((buffer[0] == 'c')&&(buffer[1] == 'o')&&(buffer[2] == 'n')&&(buffer[3] == 's')&&(buffer[4] == 'o')&&(buffer[5] == 'l')&&(buffer[6] == 'e'))
		{
			/* initialize and clear the display */
			//gfxInit();

			/* Set a font */
			gwinSetDefaultFont(gdispOpenFont("*"));

			/* create the console window */
			GWindowInit		wi;

			gwinClearInit(&wi);
			wi.show = TRUE;
			wi.x = gdispGetWidth() / 2 - 200;
			wi.y = gdispGetHeight()-140;
			wi.width = 600;
			wi.height = 120;

			xil_printf("W = %d, H = %d\n\r", wi.width, wi.height);
			GW = gwinConsoleCreate(0, &wi);

			/* Set the fore- and background colors for the console */
			gwinSetColor(GW, White);
			gwinSetBgColor(GW, Purple);
			gwinClear(GW);

			gwinPrintf(GW, "gwinConsoleCreate size = %d X %d\n", wi.width, wi.height);

			gwinPrintf(GW, "AAAAAAAAAAAAAAA\n");
			gwinPrintf(GW, "BBBBBBBBBBBBBBBB\n");
			gwinPrintf(GW, "\n");

			for(i = 0; i < 25 ; i++)
			{
				gwinPrintf(GW, "CCCCCCCCCCCCC %2d\n", i);
				sleep(1);
			}

		}
		else if((buffer[0] == 't')&&(buffer[1] == ' '))
		{
		}
	}
	else if(length == 7)
	{
		if((buffer[0] == 'u')&&(buffer[1] == 'p')&&(buffer[2] == 't')&&(buffer[3] == 'i')&&(buffer[4] == 'm')&&(buffer[5] == 'e'))
		{
			//Get System Up time
			get_system_up_time();
		}
		else if((buffer[0] == 's')&&(buffer[1] == 'e')&&(buffer[2] == 'n')&&(buffer[3] == 's')&&(buffer[4] == 'o')&&(buffer[5] == 'r'))
		{
		}
		else if((buffer[0] == 't')&&(buffer[1] == ' '))
		{
		}
	}
	else if(length == 6)
	{
		if((buffer[0] == 'c')&&(buffer[1] == 'l')&&(buffer[2] == 'o')&&(buffer[3] == 'c')&&(buffer[4] == 'k'))
		{
		}
		else if((buffer[0] == 'p')&&(buffer[1] == 'r')&&(buffer[2] == 'i')&&(buffer[3] == 'n')&&(buffer[4] == 't'))
		{
			xil_printf("ABCDEFGHIJKLMNOPQ");
			sleep(3);
			xil_printf("%c", 0x08);
			xil_printf("%c", 0x08);
			xil_printf("%c", 0x08);
			xil_printf("%c", 0x08);
			xil_printf("%c", 0x08);
			xil_printf("%c", 0x08);
			xil_printf("%c", 0x08);
			xil_printf("%c", 0x08);
			xil_printf("%c", 0x08);
			xil_printf("%c", 0x08);
			xil_printf("abcdefg");
			sleep(3);
			xil_printf("\r");
			xil_printf("-------");

		}
		else if((buffer[0] == 'b')&&(buffer[1] == 'r')&&(buffer[2] == 'a')&&(buffer[3] == 'k')&&(buffer[4] == 'e'))
		{
		}
		else if((buffer[0] == 't')&&(buffer[1] == ' '))
		{
		}
	}
	else if(length == 5)
	{
		if((buffer[0] == 'h')&&(buffer[1] == 'e')&&(buffer[2] == 'l')&&(buffer[3] == 'p'))
		{
			xil_printf("\n\rIMS command prompt, ");
			xil_printf(RELEASE_INFO);
			xil_printf("\n\r");
			xil_printf("------------- Aries Demo -------------\n\r");
			xil_printf("1:\tToggle Layer 1\n\r");
			xil_printf("2:\tToggle Layer 2\n\r");
			xil_printf("3:\tToggle Layer 3\n\r");
			//xil_printf("'n' = Set to new scaler datapath\n\r");
			xil_printf("t:\tEnable/bypass camera TPG\n\r");
			xil_printf("y:\tEnable/bypass GUI TPG\n\r");
			xil_printf("u:\tPark Camera Freeze VDMA\n\r");
			//xil_printf("'s' = Set output frame size\n\r");
			//xil_printf("'p' = Print this menu\n\r");
			xil_printf("usb:\tread USB registers\n\r");
			xil_printf("usbr:\tUSB reset\n\r");
			xil_printf("dd:\tDCache Disable\n\r");
			xil_printf("de:\tDCache Enable\n\r");
			xil_printf("help:\thelp menu\n\r");
			xil_printf("---------------------------------------\n\r");
		}
		else if((buffer[0] == 'u')&&(buffer[1] == 's')&&(buffer[2] == 'b')&&(buffer[3] == 'r'))
		{
			xil_printf("usb reset\n\r");
			tusb_init(); // initialize tinyusb stack
			value = 0x60;
			ulpi_WriteReg(value, ULPI_FC_CTRL);	//0x16
			port_connect_status_change_isr(0);
			tusb_isr(0);
		}
		else if((buffer[0] == 's')&&(buffer[1] == 'l')&&(buffer[2] == 'o')&&(buffer[3] == 'w'))
		{
		}
		else if((buffer[0] == 'l')&&(buffer[1] == 'o')&&(buffer[2] == 'c')&&(buffer[3] == 'k'))
		{
		}
		else if((buffer[0] == 's')&&(buffer[1] == ' '))
		{
			if((buffer[2] < 0x30) || (buffer[2] > 0x39) || (buffer[3] < 0x30) || (buffer[3] > 0x39))
			{
				xil_printf("\nIllegal parameters.\n");
				return;
			}
			//PWM_start_duty = (buffer[2] - 0x30) * 10 + (buffer[3] - 0x30);
			//xil_printf("\nPWM_start_duty: ");printd(PWM_start_duty);xil_printf("\n\r");
		}
		else if((buffer[0] == 'd')&&(buffer[1] == ' '))
		{
			if((buffer[2] < 0x30) || (buffer[2] > 0x39) || (buffer[3] < 0x30) || (buffer[3] > 0x39))
			{
				xil_printf("\nIllegal parameters.\n");
				return;
			}
			//PWM_duty = (buffer[2] - 0x30) * 10 + (buffer[3] - 0x30);
			//xil_printf("\nPWM_duty: ");printd(PWM_duty);xil_printf("\n\r");
		}
		else if((buffer[0] == 't')&&(buffer[1] == ' '))
		{
			if((buffer[2] < 0x30) || (buffer[2] > 0x39) || (buffer[3] < 0x30) || (buffer[3] > 0x39))
			{
				xil_printf("\nIllegal parameters.\n\r");
				return;
			}
			//target_speed_tmp = (buffer[2] - 0x30) * 10 + (buffer[3] - 0x30);
			//SETUP_target_speed(target_speed_tmp);
			//xil_printf("\nTarget_speed: ");printd(target_speed);xil_printf("\n\r");
		}
	}
	else if(length == 4)
	{
		if((buffer[0] == 'u')&&(buffer[1] == 's')&&(buffer[2] == 'b'))
		{
			read_usb_registers();
		}
		else if((buffer[0] == 't')&&(buffer[1] == 'i')&&(buffer[2] == 'c'))
		{
			g_ms_tick = 0;
		}
		else if((buffer[0] == 't')&&(buffer[1] == 'o')&&(buffer[2] == 'c'))
		{
			uint32_t tt = g_ms_tick;
			uint32_t hh;
			uint32_t mm;
			uint32_t ss;
			uint32_t dd;

			dd = tt % 500 * 2;
			ss = (tt / 500) % 60;
			mm = ((tt / 500) / 60) % 60;
			hh = ((tt / 500) / 60) / 60;

			xil_printf("\n\rElasped time is %02d:%02d:%02d.%03d\n\r", hh, mm, ss, dd);
		}
		else if((buffer[0] == 'i')&&(buffer[1] == 'f')&&(buffer[2] == 'b'))
		{

		}
	}
	else if(length == 3)
	{
		if(((buffer[0] == 'l')&&(buffer[1] == 's'))||(buffer[0] == 'l')&&(buffer[1] == 'l'))
		{
			xil_printf("\n\r");
			xil_printf("Type `help' to see help list.\n\r");
		}
		else if((buffer[0] == 'd')&&(buffer[1] == 'e'))
		{
			xil_printf("Xil_DCacheEnable()\n\r");
			Xil_DCacheEnable();
		}
		else if((buffer[0] == 'd')&&(buffer[1] == 'd'))
		{
			xil_printf("Xil_DCacheDisable()\n\r");
			Xil_DCacheDisable();
		}
		else if((buffer[0] == 't')&&(buffer[1] == '1'))
		{
			xil_printf("test 1\n\r");
			reg = ULPI_OTG_CTRL;
			val = 0;
			val = ulpi_ReadReg(reg);
			xil_printf("read value : %02X\n\r", val);

			sleep(1);

			val &= 0xDF;
			xil_printf("set value : %02X\n\r", val);
			ulpi_WriteReg(val, reg);

			sleep(1);

			val = 0;
			val = ulpi_ReadReg(reg);
			xil_printf("read value : %02X\n\r", val);
		}
		else if((buffer[0] == 't')&&(buffer[1] == '2'))
		{
			xil_printf("test 2\n\r");
			reg = ULPI_OTG_CTRL;
			val = 0;
			val = ulpi_ReadReg(reg);
			xil_printf("read value : %02X\n\r", val);

			sleep(1);

			val |= 0x20;
			xil_printf("set value : %02X\n\r", val);
			ulpi_WriteReg(val, reg);

			sleep(1);

			val = 0;
			val = ulpi_ReadReg(reg);
			xil_printf("read value : %02X\n\r", val);
		}

	}
	else if(length == 2)
	{
		xil_printf("\n\r");
		if(buffer[0] == 'p')
		{
			xil_printf("show picture_old\n\r");
			gdispImage *p_Image;
			p_Image = &myImage;
			status = gdispImageOpenFile(p_Image, step_3);
			pixmap_draw(pixmap_1, surface_1, LAYER1_WIDTH, LAYER1_HEIGHT, p_Image, 0, 0, 0, 0);
			gdispBlitArea(LAYER0_WIDTH-LAYER1_WIDTH-BORDER_X, BORDER_Y, LAYER1_WIDTH, LAYER1_HEIGHT, surface_1);
			gdispImageClose(p_Image);
			Xil_DCacheFlush();
		}
		else if(buffer[0] == 'q')
		{
			xil_printf("show picture_new\n\r");
			XVMix_LayerDisable(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_1);
			gdispImage *p_Image;
			p_Image = &myImage;
			status = gdispImageOpenFile(p_Image, chicken_3);
			pixmap_draw(pixmap_1, surface_1, LAYER1_WIDTH, LAYER1_HEIGHT, p_Image, 0, 0, 0, 0);
			gdispBlitArea(LAYER0_WIDTH-LAYER1_WIDTH-BORDER_X, BORDER_Y, LAYER1_WIDTH, LAYER1_HEIGHT, surface_1);
			Xil_DCacheFlush();
			gdispImageClose(p_Image);
		}
		else if(buffer[0] == 's')
		{
			xil_printf("show picture_new my png\n\r");

			gdispImage *p_Image;

			XVMix_LayerDisable(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_1);
			p_Image = &myImage;
			status = gdispImageOpenFile(p_Image, pic11);
			pixmap_draw(pixmap_1, surface_1, LAYER1_WIDTH, LAYER1_HEIGHT, p_Image, 0, 0, 0, 0);
			gdispBlitArea(LAYER0_WIDTH-LAYER1_WIDTH-BORDER_X, BORDER_Y, LAYER1_WIDTH, LAYER1_HEIGHT, surface_1);
			Xil_DCacheFlush();
			gdispImageClose(p_Image);

			sleep(1);

			XVMix_LayerDisable(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_1);
			p_Image = &myImage;
			status = gdispImageOpenFile(p_Image, pic22);
			pixmap_draw(pixmap_1, surface_1, LAYER1_WIDTH, LAYER1_HEIGHT, p_Image, 0, 0, 0, 0);
			gdispBlitArea(LAYER0_WIDTH-LAYER1_WIDTH-BORDER_X, BORDER_Y, LAYER1_WIDTH, LAYER1_HEIGHT, surface_1);
			Xil_DCacheFlush();
			gdispImageClose(p_Image);

			sleep(1);


			XVMix_LayerDisable(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_1);
			p_Image = &myImage;
			status = gdispImageOpenFile(p_Image, pic33);
			pixmap_draw(pixmap_1, surface_1, LAYER1_WIDTH, LAYER1_HEIGHT, p_Image, 0, 0, 0, 0);
			gdispBlitArea(LAYER0_WIDTH-LAYER1_WIDTH-BORDER_X, BORDER_Y, LAYER1_WIDTH, LAYER1_HEIGHT, surface_1);
			Xil_DCacheFlush();
			gdispImageClose(p_Image);

			sleep(1);


			XVMix_LayerDisable(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_1);
			status = gdispImageOpenFile(p_Image, pic44);
			pixmap_draw(pixmap_1, surface_1, LAYER1_WIDTH, LAYER1_HEIGHT, p_Image, 0, 0, 0, 0);
			gdispBlitArea(LAYER0_WIDTH-LAYER1_WIDTH-BORDER_X, BORDER_Y, LAYER1_WIDTH, LAYER1_HEIGHT, surface_1);
			Xil_DCacheFlush();
			gdispImageClose(p_Image);

			sleep(1);


			XVMix_LayerDisable(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_1);
			p_Image = &myImage;
			status = gdispImageOpenFile(p_Image, pic55);
			pixmap_draw(pixmap_1, surface_1, LAYER1_WIDTH, LAYER1_HEIGHT, p_Image, 0, 0, 0, 0);
			gdispBlitArea(LAYER0_WIDTH-LAYER1_WIDTH-BORDER_X, BORDER_Y, LAYER1_WIDTH, LAYER1_HEIGHT, surface_1);
			Xil_DCacheFlush();
			gdispImageClose(p_Image);

			sleep(1);


			XVMix_LayerDisable(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_1);
			p_Image = &myImage;
			status = gdispImageOpenFile(p_Image, pic66);
			pixmap_draw(pixmap_1, surface_1, LAYER1_WIDTH, LAYER1_HEIGHT, p_Image, 0, 0, 0, 0);
			gdispBlitArea(LAYER0_WIDTH-LAYER1_WIDTH-BORDER_X, BORDER_Y, LAYER1_WIDTH, LAYER1_HEIGHT, surface_1);
			Xil_DCacheFlush();
			gdispImageClose(p_Image);


		}

		else if(buffer[0] == '1')
		{
			xil_printf("Enabling/bypassing Layer 1.\n\r");
			status = XVMix_IsLayerEnabled(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_1);
			if(status) { // Enabled
				XVMix_LayerDisable(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_1);
			} else {
				XVMix_LayerEnable(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_1);
			}
		}
		else if(buffer[0] == '2')
		{
			xil_printf("Enabling/bypassing Layer 2.\n\r");
			status = XVMix_IsLayerEnabled(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_2);
			if(status) { // Enabled
				XVMix_LayerDisable(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_2);
			} else {
				XVMix_LayerEnable(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_2);
			}
		}
		else if(buffer[0] == '3')
		{
			xil_printf("Enabling/bypassing Layer 3.\n\r");
			status = XVMix_IsLayerEnabled(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_3);
			if(status) { // Enabled
				XVMix_LayerDisable(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_3);
			} else {
				XVMix_LayerEnable(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_3);
			}
		}
		else if(buffer[0] == 't')
		{
			xil_printf("Enabling/bypassing camera TPG.\n\r");
			periphs_toggle_camera_tpg(&periphs_inst);
		}
		else if(buffer[0] == 'y')
		{
			xil_printf("Enabling/bypassing GUI TPG.\n\r");
			periphs_toggle_GUI_tpg(&periphs_inst);
		}
		else if(buffer[0] == 'u')
		{
			xil_printf("Park/Unpark Camera Freeze VDMA.\n\r");
			periphs_toggle_camera_freeze_vdma(&periphs_inst);
			// Determine if we're in TPG or passthrough mode
			if (periphs_inst.enable_camera_freeze_vdma == PERIPHS_SEL_ENABLE_PARK)
			{
				XVMix_LayerEnable(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_2);
			}
			else
			{
				XVMix_LayerDisable(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_2);
			}
		}
		else if(buffer[0] == 'r')
		{
			read_usb_registers();
		}
		else if(buffer[0] == 'd')
		{
			xil_printf("david debug\n\r");

			xil_printf("size of last_command is %d\n\r", sizeof(last_command));
		}
		else
		{
			xil_printf("Invalid command : %c\n\r", buffer[0]);
		}
	}
	length = 0;
}

void get_system_up_time(void)
{
	uint32_t tt = g_ms_uptime;
	uint32_t hh;
	uint32_t mm;
	uint32_t ss;
	uint32_t dd;

	dd = tt % 500 * 2;
	ss = (tt / 500) % 60;
	mm = ((tt / 500) / 60) % 60;
	hh = ((tt / 500) / 60) / 60;

	xil_printf("\n\rSystem up time is %02d:%02d:%02d.%03d\n\r", hh, mm, ss, dd);
}


