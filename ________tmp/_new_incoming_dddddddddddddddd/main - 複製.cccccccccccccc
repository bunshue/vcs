

// *****************************************************
// Dependencies
// *****************************************************
#include <stdio.h>
#include <stdlib.h>
#include "xil_cache.h"
#include "platform.h"
#include "main.h"
#include "xuartps_hw.h"
#include "periphs.h"
#include "mixer.h"
#include "gpio.h"
#include "ulpi.h"
#include "gfx.h"

/* global timer registers*/
#define SCU_GLOBAL_TIMER_COUNT_L32	(XPAR_PS7_GLOBALTIMER_0_S_AXI_BASEADDR)
#define SCU_GLOBAL_TIMER_COUNT_U32	(XPAR_PS7_GLOBALTIMER_0_S_AXI_BASEADDR+0x04)
#define SCU_GLOBAL_TIMER_CONTROL	(XPAR_PS7_GLOBALTIMER_0_S_AXI_BASEADDR+0x08)
#define SCU_GLOBAL_TIMER_ISR		(XPAR_PS7_GLOBALTIMER_0_S_AXI_BASEADDR+0x0C)
#define SCU_GLOBAL_TIMER_COMP_L32	(XPAR_PS7_GLOBALTIMER_0_S_AXI_BASEADDR+0x10)
#define SCU_GLOBAL_TIMER_COMP_U32	(XPAR_PS7_GLOBALTIMER_0_S_AXI_BASEADDR+0x14)
#define SCU_GLOBAL_TIMER_AUTO_INC	(XPAR_PS7_GLOBALTIMER_0_S_AXI_BASEADDR+0x18)

static const char ims_logo[] = "ims-small-logo.png";
static const char step_1[] = "step1.png";
static const char step_2[] = "step2.png";
static const char step_3[] = "step3.png";
static const char chicken_3[] = "chicken.png";
static const char pic11[] = "pic1.png";
static const char pic22[] = "pic2.png";
static const char pic33[] = "pic3.png";
static const char pic44[] = "pic4.png";
static const char pic55[] = "pic5.png";
static const char pic66[] = "pic6.png";

void pixmap_draw(GDisplay* pixmap, pixel_t* surface, coord_t pm_width, coord_t pm_height, gdispImage *p_Image, uint32_t pm_sx, uint32_t pm_sy, uint32_t img_sx, uint32_t img_sy);


volatile uint32_t g_ms_uptime = 0;
volatile uint32_t g_ms_tick = 0;
volatile uint32_t g_ms_tick_wait = 0;
uint32_t g_nn = 0;
uint32_t g_dongle_plugged = 0;
uint32_t g_camera_plugged = 0;

uint32_t g_conn_status = 2;

GListener	gl;
GHandle		ghLabel1, ghLabel2, ghLabel3, ghLabel4, ghLabel5, ghLabel6, ghLabel7;

uint32_t esc_mode = 0;

static gdispImage myImage;
static GDisplay* pixmap_1;
static pixel_t* surface_1;
static GDisplay* pixmap_2;
static pixel_t* surface_2;
//static GDisplay* pixmap_3;
//static pixel_t* surface_3;

// The handle for our console
static GHandle	GW;
GWindowInit		wic;


static void createWidgets(void);
static void createConsoleWidgets(void);
static void updateConsoleWidgets(void);
void main_loop(void);
void get_usb_descriptor(void);
void read_usb_registers(void);
void parse_uart_command(void);
void parse_uart_esc_command(void);
void get_system_up_time(void);

static const char last_command[] = "help";

int flag_get_usb_descriptor_done = 0;

// *****************************************************
// Main program entry point
// *****************************************************
int main()
{
	// Local variables
	int status = 0;
	coord_t swidth, sheight;
	gdispImage *p_Image;
	uint8_t *p_byte, byte;
	uint32_t i,j, Index;
	GEvent* pe;

	p_Image = &myImage;
	update_dongle_status = 0;
	update_usb_status = 0;
	update_usb_descriptor_status = 0;
	usb_reset_status = 0;
	usb_reset_status_old = 0;
	flag_updateConsoleWidgets = 1;
	flag_is_keyboard_mounted = 0;
	vendor_id_tmp = 0;
	product_id_tmp = 0;

	// Setup UART and caches
    init_platform();

    usleep(200000);usleep(200000);usleep(200000);usleep(200000);usleep(200000);usleep(200000);

    //xil_printf("\n\n\n\nAries Main Program %s:%s(%d) ST\n\r",__FILE__,__func__,__LINE__);
    xil_printf("\n\n\n\nAries Main Program\n\r");
    xil_printf("Compiled time: %s %s\n\r", __DATE__, __TIME__);
    xil_printf("%s:%s(%d)\n\r\n\r",__FILE__,__func__,__LINE__);



    read_usb_status();

    // Initialize peripherals
    status = periphs_init
    (
    	&periphs_inst,
    	//XPAR_CONTROL_PATH_AXI_GPIO_0_DEVICE_ID,
    	//XPAR_CONTROL_PATH_AXI_IIC_0_BASEADDR,
		//XPAR_XIICPS_0_DEVICE_ID,
		XPAR_PS7_GPIO_0_DEVICE_ID,
		XPAR_VIDEO_PATH_VIDEO_OUT_VIDEO_LOCK_MONITOR_DEVICE_ID,
		XPAR_PS7_SCUGIC_0_DEVICE_ID,
		XPAR_PS7_SCUTIMER_0_DEVICE_ID,
		XPAR_PS7_UART_0_DEVICE_ID,
		//XPAR_VIDEO_PATH_CAMERA_IN_V_TC_VTD_DEVICE_ID,
    	//XPAR_VIDEO_PATH_TPG_OLD_TPG_OLD_DEVICE_ID,
		XPAR_VIDEO_PATH_V_TPG_0_DEVICE_ID,
		//XPAR_VIDEO_PATH_CAMERA_SCALER_V_PROC_SS_1_DEVICE_ID,
		XPAR_VIDEO_PATH_CAMERA_SCALER_FREEZE_V_PROC_SS_1_DEVICE_ID,
		XPAR_VIDEO_PATH_FRAMEBUFFER_AXI_VDMA_CAMERA_DEVICE_ID,
		XPAR_VIDEO_PATH_FRAMEBUFFER_AXI_VDMA_CAMERA_FREEZE_DEVICE_ID,
		//XPAR_VIDEO_PATH_FRAMEBUFFER_OUTPUT_AXI_VDMA_GUI_DEVICE_ID,
		XPAR_VIDEO_PATH_OUTPUT_MIXER_V_MIX_0_DEVICE_ID,
		XPAR_VIDEO_PATH_VIDEO_OUT_V_TC_TFP410_DEVICE_ID,
		XPAR_VIDEO_PATH_VIDEO_OUT_V_TC_CH7038_DEVICE_ID,
		XPAR_PS7_USB_0_DEVICE_ID,
    	FRAMEBUFFER_CAMERA_START_ADDR,
		FRAMEBUFFER_CAMERA_FREEZE_START_ADDR,
		FRAMEBUFFER_GUI_START_ADDR
    );
	if (status != 0)
	{
		xil_printf("Initialization failed.\n\r");
		return -1;
	}

	// Set up Mixer Layers
	//RunMixer(periphs_inst.p_vid_output_mixer_l2_inst);

    // Initialize uGFX
	//g_nn = 1;
    gfxInit();
    xil_printf("gfxInit() complete\r\n");
	// Background process
	xil_printf("Initialization complete. Switching to background process.\n\r");

	// Set up pixmap for layer 1
    pixmap_1 = gdispPixmapCreate(LAYER1_WIDTH, LAYER1_HEIGHT);
    surface_1 = gdispPixmapGetBits(pixmap_1);
    // Draw transparency required on layer 1
    pixmap_draw(pixmap_1, surface_1, LAYER1_WIDTH, LAYER1_HEIGHT, NULL, 0, 0, 0, 0);

	// Set up pixmap for layer 2
    pixmap_2 = gdispPixmapCreate(LAYER2_WIDTH, LAYER2_HEIGHT);
    surface_2 = gdispPixmapGetBits(pixmap_2);
    // Draw transparency required on layer 2
    pixmap_draw(pixmap_2, surface_2, LAYER2_WIDTH, LAYER2_HEIGHT, NULL, 0, 0, 0, 0);

	// Open image for layer 3
	// Get the display dimensions
	swidth = gdispGetWidth();
	xil_printf("swidth: %d\r\n", swidth);
	sheight = gdispGetHeight();
	xil_printf("sheight: %d\r\n", sheight);

	// Set up IO for our image
	//g_nn = 1;
	status = gdispImageOpenFile(p_Image, ims_logo);
	//xil_printf("status mainopen: %d\r\n", status);
//	p_byte = (uint8_t *)p_Image->priv;
//	xil_printf("status: %d\r\n", status);
//	xil_printf("p_Image->type: %d\r\n", p_Image->type);
//	xil_printf("p_Image->flags: %x\r\n", p_Image->flags);
//	xil_printf("p_Image->bgcolor: %x\r\n", p_Image->bgcolor);
//	xil_printf("p_Image->memused: %d\r\n", p_Image->memused);
//	xil_printf("p_Image->maxmemused: %d\r\n", p_Image->maxmemused);
//
//	xil_printf("p_Image->priv->flags: %x\r\n", p_byte[0]);
//	xil_printf("p_Image->priv->bitdepth: %x\r\n", p_byte[1]);
//	xil_printf("p_Image->priv->mode: %x\r\n", p_byte[2]);
//	xil_printf("p_Image->priv->bpp: %x\r\n", p_byte[3]);

	//g_nn = 1;
	status = gdispImageDraw(p_Image, swidth-p_Image->width-BORDER_X*2, sheight-p_Image->height-BORDER_Y*2, p_Image->width, p_Image->height, 0, 0);
	//g_nn = 0;
	//xil_printf("status maindraw: %d\r\n", status);
	gdispImageClose(p_Image);

	// Blit surface_1 to the real display at the new position
	//g_nn =1;
	gdispBlitArea(LAYER0_WIDTH-LAYER1_WIDTH-BORDER_X, BORDER_Y, LAYER1_WIDTH, LAYER1_HEIGHT, surface_1);

	// Blit surface_2 to the real display at the new position
	gdispBlitArea(BORDER_X, LAYER0_HEIGHT-LAYER2_HEIGHT-BORDER_Y, LAYER2_WIDTH, LAYER2_HEIGHT, surface_2);

	Xil_DCacheFlush();

	// Set up Mixer Layers
	RunMixer(periphs_inst.p_vid_output_mixer_l2_inst);

	// Set the widget defaults
	gwinSetDefaultFont(gdispOpenFont("*"));
	gwinSetDefaultStyle(&BlackWidgetStyle, FALSE);
	//gdispClear(White);

	// create the widget
	//g_nn =1;
	createWidgets();

//	// We want to listen for widget events
//	geventListenerInit(&gl);
//	gwinAttachListener(&gl);
//
//	while(1) {
//		// Get an Event
//		pe = geventEventWait(&gl, TIME_INFINITE);
//	}

	// Detect Dongle status and draw image
	xil_printf("david0823: %s:%s(%d) ST 1111\r\n",__FILE__,__func__,__LINE__);
	g_conn_status = psuart0_dongle_ping();
	xil_printf("david0823: %s:%s(%d) ST 2222\r\n",__FILE__,__func__,__LINE__);

	if(g_conn_status == 2)
	{
			xil_printf("no dongle or camera\n\r");
			// Set Flags
			g_dongle_plugged = 0;
			g_camera_plugged = 0;
			// Show Message
			p_Image = &myImage;
			status = gdispImageOpenFile(p_Image, step_1);
			pixmap_draw(pixmap_1, surface_1, LAYER1_WIDTH, LAYER1_HEIGHT, p_Image, 0, 0, 0, 0);
			gdispBlitArea(LAYER0_WIDTH-LAYER1_WIDTH-BORDER_X, BORDER_Y, LAYER1_WIDTH, LAYER1_HEIGHT, surface_1);
			gdispImageClose(p_Image);
	}
	else if (g_conn_status == 1){
			xil_printf("dongle only\n\r");
			// Set Flags
			g_dongle_plugged = 1;
			g_camera_plugged = 0;
			// Show Message
			p_Image = &myImage;
			status = gdispImageOpenFile(p_Image, step_2);
			pixmap_draw(pixmap_1, surface_1, LAYER1_WIDTH, LAYER1_HEIGHT, p_Image, 0, 0, 0, 0);
			gdispBlitArea(LAYER0_WIDTH-LAYER1_WIDTH-BORDER_X, BORDER_Y, LAYER1_WIDTH, LAYER1_HEIGHT, surface_1);
			gdispImageClose(p_Image);
	}
	else {
			xil_printf("dongle+camera\n\r");
			// Set Flags
			g_dongle_plugged = 1;
			g_camera_plugged = 1;
			// Show Message
			p_Image = &myImage;
			status = gdispImageOpenFile(p_Image, step_3);
			pixmap_draw(pixmap_1, surface_1, LAYER1_WIDTH, LAYER1_HEIGHT, p_Image, 0, 0, 0, 0);
			gdispBlitArea(LAYER0_WIDTH-LAYER1_WIDTH-BORDER_X, BORDER_Y, LAYER1_WIDTH, LAYER1_HEIGHT, surface_1);
			gdispImageClose(p_Image);
			XVMix_LayerEnable(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_1);
	}

	Xil_DCacheFlush();

	psuart0_exposure(3);

	// Set up Mixer Layers
	//RunMixer(periphs_inst.p_vid_output_mixer_l2_inst);

	// USB Init
	ulpi_init();
	ulpi_set_vbus(TRUE);


	tusb_init(); // initialize tinyusb stack

	keyboard_host_app_init(); // Keyboard Host Init

	//mouse_host_app_init(); // Mouse Host Init
	Xil_DCacheFlush(); // Flush DCache after USB Init();
	//Xil_DCacheInvalidate();
	Xil_DCacheDisable();

	// create the widget
	createConsoleWidgets();

	main_loop();

    cleanup_platform();
    return 0;
}

#define RELEASE_INFO "Insight Medical Solutions Inc., August-17-2018\n"
#define PROMPT "[aries@ims]# "
#define UART_BUFFER_LEN 10
u8 buffer[UART_BUFFER_LEN];
u8 esc_buffer[3];
u8 ptr = 0;
u8 esc_ptr = 0;
u8 length = 0;






void main_loop()
{
	// Local variables
	char c[1]  = {0};
	//int  ii = 0;
	//unsigned int status = 0;
	gdispImage *p_Image;
	uint32_t value = 0;
	int i;
	uint32_t status;
	uint32_t skip_usb_check_cnt = 0;

	// Main loop
	while (1)
	{

		//xil_printf("What would you like to do? Press 'p' to print available commands.\n\r");
		c[0] = XUartPs_RecvByte(XPAR_PS7_UART_1_BASEADDR);
		//XUartPs_Recv(g_psuart1_config->BaseAddress, &c[0], 1);
		

		if(update_dongle_status == 1)
		{
			update_dongle_status = 0;
		//xil_printf("ping.\n\r");
		g_conn_status = psuart0_dongle_ping();
		if(g_conn_status == 2) // Nothing is plugged in
		{
			if(g_procedure_started) { // Procedure not started

			}
			else {
				if(g_dongle_plugged || g_camera_plugged){
					// Update Flags
					g_dongle_plugged = 0;
					g_camera_plugged = 0;
					// Dongle unplugged
					xil_printf("no dongle or camera\n\r");
					// Show Message to plug in dongle
					XVMix_LayerDisable(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_1);
					p_Image = &myImage;
					status = gdispImageOpenFile(p_Image, step_1);
					pixmap_draw(pixmap_1, surface_1, LAYER1_WIDTH, LAYER1_HEIGHT, p_Image, 0, 0, 0, 0);
					gdispBlitArea(LAYER0_WIDTH-LAYER1_WIDTH-BORDER_X, BORDER_Y, LAYER1_WIDTH, LAYER1_HEIGHT, surface_1);
					Xil_DCacheFlush();
					gdispImageClose(p_Image);
				}
			}
		}
		else if(g_conn_status == 1){ // Only dongle is plugged in

			if(g_procedure_started){ // Procedure started

			}
			else { // Procedure hasn't started
				if(g_dongle_plugged == 0 || g_camera_plugged){
					// Update Flags
					g_dongle_plugged = 1;
					g_camera_plugged = 0;
					// Dongle plugged
					xil_printf("dongle plugged\n\r");
					XVMix_LayerDisable(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_1);
					p_Image = &myImage;
					status = gdispImageOpenFile(p_Image, step_2);
					pixmap_draw(pixmap_1, surface_1, LAYER1_WIDTH, LAYER1_HEIGHT, p_Image, 0, 0, 0, 0);
					gdispBlitArea(LAYER0_WIDTH-LAYER1_WIDTH-BORDER_X, BORDER_Y, LAYER1_WIDTH, LAYER1_HEIGHT, surface_1);
					Xil_DCacheFlush();
					gdispImageClose(p_Image);
				}
			}
		}
		else { // Everything is plugged in
			if(g_procedure_started) { // Procedure not started

			}
			else {
				if(g_dongle_plugged == 0 || g_camera_plugged == 0){
					// Update Flags
					g_dongle_plugged = 1;
					g_camera_plugged = 1;
					// Dongle plugged
					xil_printf("all plugged\n\r");
					XVMix_LayerEnable(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_1);
					p_Image = &myImage;
					status = gdispImageOpenFile(p_Image, step_3);
					pixmap_draw(pixmap_1, surface_1, LAYER1_WIDTH, LAYER1_HEIGHT, p_Image, 0, 0, 0, 0);
					gdispBlitArea(LAYER0_WIDTH-LAYER1_WIDTH-BORDER_X, BORDER_Y, LAYER1_WIDTH, LAYER1_HEIGHT, surface_1);
					Xil_DCacheFlush();
					gdispImageClose(p_Image);
				}

			}
		}



		if(g_updated) {
			g_updated = 0;
			if(g_procedure_started) { // Remove all pictures
				xil_printf("update remove picture\r\n");
				pixmap_draw(pixmap_1, surface_1, LAYER1_WIDTH, LAYER1_HEIGHT, NULL, 0, 0, 0, 0);
				gdispBlitArea(LAYER0_WIDTH-LAYER1_WIDTH-BORDER_X, BORDER_Y, LAYER1_WIDTH, LAYER1_HEIGHT, surface_1);
				Xil_DCacheFlush();
			}
			else { // Add back picture
				xil_printf("update add picture\r\n");
				p_Image = &myImage;
				status = gdispImageOpenFile(p_Image, step_3);
				pixmap_draw(pixmap_1, surface_1, LAYER1_WIDTH, LAYER1_HEIGHT, p_Image, 0, 0, 0, 0);
				gdispBlitArea(LAYER0_WIDTH-LAYER1_WIDTH-BORDER_X, BORDER_Y, LAYER1_WIDTH, LAYER1_HEIGHT, surface_1);
				gdispImageClose(p_Image);
				Xil_DCacheFlush();
			}
			psuart0_exposure(g_exposure);
		}
		}
		else if(update_usb_status == 1)
		{
			update_usb_status = 0;

			//xil_printf("david0823: %s:%s(%d) ST usb_reset_status = %d\r\n",__FILE__,__func__,__LINE__,usb_reset_status);

			if((usb_reset_status_old == 0) && (usb_reset_status == 1))
			{
				skip_usb_check_cnt++;
				g_ms_tick_wait = g_ms_tick;
				usb_reset_status_old = 1;
			}
			else if((usb_reset_status_old == 1) && (usb_reset_status == 1))
			{
				skip_usb_check_cnt++;
				//xil_printf("david0823: %s:%s(%d) wait %d\r\n",__FILE__,__func__,__LINE__,skip_usb_check_cnt);
				if(skip_usb_check_cnt > 10)
				{
					//xil_printf("david0823: %s:%s(%d) OK\r\n",__FILE__,__func__,__LINE__);
					skip_usb_check_cnt = 0;
					usb_reset_status = 0;
					usb_reset_status_old = 0;
				}
			}
			else
			{
				updateConsoleWidgets();
			}
		}
		else if((flag_is_keyboard_mounted == 1) && (flag_get_usb_descriptor_done == 0))
		{
			//First time get usb descriptor
			xil_printf("1111\r\n");
			flag_get_usb_descriptor_done = 1;
			//get_usb_descriptor();
		}
		else if((update_usb_descriptor_status == 1) && (flag_get_usb_descriptor_done == 1))
		{
			//Get usb descriptor when keyboard is mounted
			//xil_printf("2222\r\n");
			update_usb_descriptor_status = 0;
			//get_usb_descriptor();
		}
		else if((update_usb_descriptor_status == 1) && (flag_is_keyboard_mounted == 0) && (g_ms_tick > 6000))
		{
			//Get usb descriptor when keyboard is un-mounted
			//xil_printf("\n\r3333\t");
			update_usb_descriptor_status = 0;
			//get_usb_descriptor();
		}
		else if(flag_is_keyboard_mounted == 0)
		{
			flag_get_usb_descriptor_done = 0;
		}

		//  Run USB Host Task Handlers
		tusb_task_runner(); // USB House Keeping
	    keyboard_host_app_task(NULL); // Keyboard tasks
	    //mouse_host_app_task(NULL); // Mouse Tasks
		//Xil_DCacheFlush();

		if(c[0] == 0)
			continue;


		buffer[ptr] = c[0];
		esc_buffer[esc_ptr] = c[0];
		ptr++;

		if(c[0] == 0x0d)	//Enter
		{
			/*
			for(i=0;i<ptr;i++)
			{
				xil_printf("0x%x ", buffer[i]);
			}
			xil_printf("\n\r");
			*/

			length = ptr;
			ptr = 0;
			/*
			//for(i = 0 ; i < (length - 1); i++)
				//xil_printf("%c", 0x18);
			for(i = 0 ; i < (length - 1); i++)
				xil_printf("%c", 0x7F);
			xil_printf("---");
			*/
			parse_uart_command();
			xil_printf("\n\r%s", PROMPT);
		}
		else
		{
			if(c[0] == 0x1B)
			{
				esc_mode = 1;
				buffer[0] = c[0];
				ptr = 1;
				continue;
			}
			else if(c[0] == 0x7F)
			{
				if(ptr >= 2)
				{
					xil_printf("%c", 0x7F);
					//xil_printf(".");
					ptr -= 2;
				}
				else
					ptr--;

				continue;
			}

			if(esc_mode == 1)
			{
				if(ptr == 3)
				{
					//ptr = 0;
					parse_uart_esc_command();
					esc_mode = 0;
				}
				continue;
			}

			if(isprint(c[0]))
				xil_printf("%c", c[0]);
			else
				xil_printf("0x%x", c[0]);
		}

/*
		switch (c[0])
		{
			case 'p':
				xil_printf("\n\r");
				xil_printf("------------- Aries Demo -------------\n\r");
				xil_printf("'1' = Toggle Layer 1\n\r");
				xil_printf("'2' = Toggle Layer 2\n\r");
				xil_printf("'3' = Toggle Layer 3\n\r");
				xil_printf("'n' = Set to new scaler datapath\n\r");
//				xil_printf("'o' = Set to old scaler datapath\n\r");
				xil_printf("'t' = Enable/bypass camera TPG\n\r");
				xil_printf("'y' = Enable/bypass GUI TPG\n\r");
//				xil_printf("'d' = Detect or set input frame size\n\r");
				xil_printf("'u' = Park Camera Freeze VDMA\n\r");
				xil_printf("'s' = Set output frame size\n\r");
				xil_printf("'p' = Print this menu\n\r");
				xil_printf("---------------------------------------\n\r");
				xil_printf("\n\r");
				break;
			case '1':
				xil_printf("Enabling/bypassing Layer 1.\n\r");
				status = XVMix_IsLayerEnabled(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_1);
				if(status) { // Enabled
					XVMix_LayerDisable(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_1);
				} else {
					XVMix_LayerEnable(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_1);
				}
				break;
			case '2':
				xil_printf("Enabling/bypassing Layer 2.\n\r");
				status = XVMix_IsLayerEnabled(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_2);
				if(status) { // Enabled
					XVMix_LayerDisable(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_2);
				} else {
					XVMix_LayerEnable(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_2);
				}
				break;
			case '3':
				xil_printf("Enabling/bypassing Layer 3.\n\r");
				status = XVMix_IsLayerEnabled(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_3);
				if(status) { // Enabled
					XVMix_LayerDisable(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_3);
				} else {
					XVMix_LayerEnable(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_3);
				}
				break;
//			case 'n':
//				xil_printf("Using new VPSS-based scaler datapath.\n\r");
//				periphs_select_scaler(&periphs_inst, PERIPHS_SEL_NEW_SCALER);
//				break;
//			case 'o':
//				xil_printf("Using old scaler datapath.\n\r");
//				periphs_select_scaler(&periphs_inst, PERIPHS_SEL_OLD_SCALER);
//				break;


*/
/*
			case 't':
				xil_printf("Enabling/bypassing camera TPG.\n\r");
				//periphs_toggle_camera_tpg(&periphs_inst);
				break;
			case 'y':
				xil_printf("Enabling/bypassing GUI TPG.\n\r");
				periphs_toggle_GUI_tpg(&periphs_inst);
				break;
*/
/*

			case 'u':
				xil_printf("Park/Unpark Camera Freeze VDMA.\n\r");
				periphs_toggle_camera_freeze_vdma(&periphs_inst);
				// Determine if we're in TPG or passthrough mode
				if (periphs_inst.enable_camera_freeze_vdma == PERIPHS_SEL_ENABLE_PARK)
				{
					XVMix_LayerEnable(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_2);
				}
				else
				{
					XVMix_LayerDisable(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_2);
				}
				break;

			case 'r':
				read_usb_registers();
				break;
			case 'w':
				xil_printf("port_connect_status_change_isr\n\r");
				port_connect_status_change_isr(0);
				break;
			case 'q':
				//xil_printf("ulpi_WriteReg 0x24\n\r");

				value = ulpi_ReadReg(ULPI_FC_CTRL);	//0x16
				value |= 0x20;
				value = 0x60;
				ulpi_WriteReg(value, ULPI_FC_CTRL);	//0x16
				xil_printf("ulpi_WriteReg 0x%x\n\r", value);
				break;
			case 's':
				xil_printf("reset usb 3\n\r");
				psusb0_hal_controller_reset(0);
				break;
			case 'e':
				xil_printf("ulpi_init  will cause a crash\n\r");
				ulpi_init();
				break;
			case 't':
				xil_printf("tusb_init\n\r");
				tusb_init(); // initialize tinyusb stack
				break;
			case 'v':
				xil_printf("tusb_isr\n\r");
				// Handle USB Related Interrupts
				tusb_isr(0);
				break;
			case 'a':
				xil_printf("all\n\r");
				tusb_init(); // initialize tinyusb stack
				value = 0x60;
				ulpi_WriteReg(value, ULPI_FC_CTRL);	//0x16
				port_connect_status_change_isr(0);
				tusb_isr(0);
				break;
			case 'b':
				xil_printf("get usb data\n\r");
				get_usb_data();



				break;
//			case 'd':
//				if (periphs_get_fmc_status(&periphs_inst))
//				{
//					xil_printf("FMC IMAGEON card is connected. Detecting input frame size.\n\r");
//					//periphs_detect_input_fsize(&periphs_inst);
//				}
//				else
//				{
//					while (1)
//					{
//						xil_printf("FMC IMAGEON card is not connected. Using internal TPG as video source. Please select a resolution to set it to. Press 'p' to print available resolutions.\n\r");
//						c = XUartPs_RecvByte(XPAR_PS7_UART_1_BASEADDR);
//						if (c == 'p')
//						{
//							xil_printf("\n\r");
//							xil_printf("------------- Resolutions -------------\n\r");
//							for (ii = 0; ii < NUM_VIDEO_RESOLUTIONS; ii++)
//							{
//								xil_printf("%d = %s\n\r", ii, vres_get_name(ii));
//							}
//							xil_printf("'p' = Print this menu\n\r");
//							xil_printf("'q' = Quit\n\r");
//							xil_printf("---------------------------------------\n\r");
//							xil_printf("\n\r");
//						}
//						else if ((c == '0')||(c == '1')||(c == '2')||(c == '3')||(c == '4') ||
//								 (c == '5')||(c == '6')||(c == '7')||(c == '8'))
//						{
//							//periphs_set_input_fsize(&periphs_inst, (c-'0'));
//							break;
//						}
//						else if (c == 'q')
//						{
//							break;
//						}
//						else
//						{
//							xil_printf("ERROR! Illegal character. Try again.\n\r");
//						}
//					}
//					break;
//				}
//				break;
//			case 's':
//				while (1)
//				{
//					xil_printf("Setting output frame size. What resolution would you like? Press 'p' to print available resolutions.\n\r");
//					c = XUartPs_RecvByte(XPAR_PS7_UART_1_BASEADDR);
//
//					if (c == 'p')
//					{
//						xil_printf("\n\r");
//						xil_printf("------------- Resolutions -------------\n\r");
//						for (ii = 0; ii < NUM_VIDEO_RESOLUTIONS; ii++)
//						{
//							xil_printf("%d = %s\n\r", ii, vres_get_name(ii));
//						}
//						xil_printf("'p' = Print this menu\n\r");
//						xil_printf("'q' = Quit\n\r");
//						xil_printf("---------------------------------------\n\r");
//						xil_printf("\n\r");
//					}
//					else if ((c == '0')||(c == '1')||(c == '2')||(c == '3')||(c == '4') ||
//							 (c == '5')||(c == '6')||(c == '7')||(c == '8'))
//					{
//						//periphs_update_output_fsize(&periphs_inst, (c-'0'));
//						break;
//					}
//					else if (c == 'q')
//					{
//						break;
//					}
//					else
//					{
//						xil_printf("ERROR! Illegal character. Try again.\n\r");
//					}
//				}
//				break;

			case 0:
				break;
			case 0x0D:
			case ' ':
				xil_printf("\n\r\n\r\n\r\n\r");
				break;
			default:
				xil_printf("\n\r---- unknown ---- c[0] = 0x%x", c[0]);
				if(isprint(c[0]))
					xil_printf("\t%c\n\r", c[0]);
				else
					xil_printf("\n\r");

				//p_periphs_inst222 = &periphs_inst;
				//p_gpio = p_periphs_inst222->p_ps_gpio_inst;
				//DataRead = XGpioPs_Read(p_gpio, XGPIOPS_BANK2);	//read bank 2 data, seems useless
				//xil_printf("DataRead = 0x%x\n\r", DataRead);
				//usleep(200000);

				//xil_printf("ERROR! Illegal character. Try again.\n\r");
				break;

		}
*/
	}
}

static void updateConsoleWidgets(void) {
	/* Set a font */
	gwinSetDefaultFont(gdispOpenFont("*"));

	/* create the console window */
	//GWindowInit		wic;

	uint8_t reg;
	uint8_t val0 = 0;
	uint8_t val1 = 0;
	uint8_t val2 = 0;
	uint8_t val3 = 0;
	uint8_t val4 = 0;
	uint8_t val5 = 0;
	uint8_t val6 = 0;
	uint8_t val7 = 0;
	uint8_t val8 = 0;
	uint8_t val9 = 0;
	int i;

	reg = ULPI_FC_CTRL;					val0 = ulpi_ReadReg(reg);
	reg = ULPI_IFC_CTRL;				val1 = ulpi_ReadReg(reg);
	reg = ULPI_OTG_CTRL;				val2 = ulpi_ReadReg(reg);
	reg = ULPI_USB_INT_EN_RISE;			val3 = ulpi_ReadReg(reg);
	reg = ULPI_USB_INT_EN_FALL;			val4 = ulpi_ReadReg(reg);

	reg = ULPI_USB_INT_STS;				val5 = ulpi_ReadReg(reg);
	reg = ULPI_USB_INT_LATCH;			val6 = ulpi_ReadReg(reg);
	reg = ULPI_HS_TX_BOOST;				val7 = ulpi_ReadReg(reg);
	reg = ULPI_VENDOR_RID_CONVERSION;	val8 = ulpi_ReadReg(reg);
	reg = ULPI_USB_IO_POWER_MAN;		val9 = ulpi_ReadReg(reg);

	//xil_printf("read value : %02X\n\r", val0);

	//get_usb_descriptor();

	if(flag_updateConsoleWidgets == 1)
	{
		//gwinPrintf(GW, "System up time : %d seconds\n", g_ms_uptime / 500);
		gwinSetBgColor(GW, Purple);
		gwinPrintf(GW, "\n%02X  %02X  %02X  %02X  %02X  %02X  %02X  %02X  %02X  %02X   %d   %04X %04X", val0, val1, val2, val3, val4, val5, val6, val7, val8, val9, flag_is_keyboard_mounted,vendor_id_tmp, product_id_tmp);
	}

	/*
	if(val0 != 0x40)
	{
		gwinSetColor(GW, Red);
		for(i = 0; i < 10; i++)
		{
			gwinPrintf(GW, "\nUSB FAIL, RESET USB");
			usleep(100000);
		}
		reset_usb();
		gwinSetColor(GW, White);
		gwinSetBgColor(GW, Black);
		gwinClear(GW);
	}
	*/
}

static void createConsoleWidgets(void) {
	/* Set a font */
	gwinSetDefaultFont(gdispOpenFont("*"));

	/* create the console window */
	//GWindowInit		wic;

	gwinClearInit(&wic);
	wic.show = TRUE;
	wic.x = gdispGetWidth() / 2 - 250;
	wic.y = gdispGetHeight() - 140;
	wic.width = 850;
	wic.height = 120;

	xil_printf("W = %d, H = %d\n\r", wic.width, wic.height);
	GW = gwinConsoleCreate(0, &wic);

	/* Set the fore- and background colors for the console */
	gwinSetColor(GW, White);
	//gwinSetBgColor(GW, Purple);
	gwinSetBgColor(GW, Black);
	gwinClear(GW);

	//gwinPrintf(GW, "gwinConsoleCreate size = %d X %d\n", wi.width, wi.height);
	/*
	gwinPrintf(GW, "Insight Medical Solutions Inc.\n");
	gwinPrintf(GW, "August-23-2018\n");
	gwinPrintf(GW, "----------------------------------\n");
	*/
}

static void createWidgets(void) {
	GWidgetInit	wi;

	coord_t wide = 600;
	coord_t thick = 40;

	// Apply some default values for GWIN
	gwinWidgetClearInit(&wi);
	wi.g.show = TRUE;

	gwinSetDefaultFont(gdispOpenFont("iskpota232"));

	// Create label
	wi.g.width = wide; wi.g.height = thick; wi.g.x = BORDER_X, wi.g.y = BORDER_Y + thick * 0;
	wi.text = "ID NO:";
	ghLabel1 = gwinLabelCreate(0, &wi);

	// Create label
	wi.g.width = wide; wi.g.height = thick; wi.g.x = BORDER_X, wi.g.y = BORDER_Y + thick * 1;
	wi.text = "NAME:";
	ghLabel2 = gwinLabelCreate(0, &wi);

	// Create label
	wi.g.width = wide; wi.g.height = thick; wi.g.x = BORDER_X, wi.g.y = BORDER_Y + thick * 3;
	wi.text = "SEX:";
	ghLabel3 = gwinLabelCreate(0, &wi);

	// Create label
	wi.g.width = wide; wi.g.height = thick; wi.g.x = BORDER_X, wi.g.y = BORDER_Y + thick * 4;
	wi.text = "AGE:";
	ghLabel4 = gwinLabelCreate(0, &wi);

	// Create label
	wi.g.width = wide; wi.g.height = thick; wi.g.x = BORDER_X, wi.g.y = BORDER_Y + thick * 5;
	wi.text = "D.O.BIRTH:";
	ghLabel5 = gwinLabelCreate(0, &wi);

	// Create label
	wi.g.width = wide; wi.g.height = thick; wi.g.x = BORDER_X, wi.g.y = BORDER_Y + thick * 7;
	wi.text = "08/23/2018";
	ghLabel4 = gwinLabelCreate(0, &wi);

	// Create label
	wi.g.width = wide; wi.g.height = thick; wi.g.x = BORDER_X, wi.g.y = BORDER_Y + thick * 8;
	wi.text = "00:00:00";
	ghLabel5 = gwinLabelCreate(0, &wi);


	/*
	// Create label
	wi.g.width = wide; wi.g.height = thick; wi.g.x = 1920/6, wi.g.y =600;
	wi.text = "XXXXXXXXXXXXXXXXXXXXXxx";
	ghLabel5 = gwinLabelCreate(0, &wi);
	*/




}

void pixmap_draw(GDisplay* pixmap, pixel_t* surface, coord_t pm_width, coord_t pm_height, gdispImage *p_Image, uint32_t pm_sx, uint32_t pm_sy, uint32_t img_sx, uint32_t img_sy)
{
	uint32_t i, j, status;
	color_t color = 0;

	//xil_printf("enter pixmap_draw\r\n");
	// Clear pixmap with 0
	memset(surface, 0, pm_width*pm_height*4); // Clear buffer

	// Overlay file is necessary
	if(p_Image != NULL) {
		// Load image
		status = gdispGImageDraw(pixmap, p_Image, (pm_width-p_Image->width) >> 1, (pm_height-p_Image->height) >> 1, p_Image->width, p_Image->height, 0, 0);
		//xil_printf("status draw: %d\r\n", status);
	}

    // Draw transparency required on layer 1
    for(j = 0; j < pm_height; j++) {
    	for(i = 0; i < pm_width; i++) {

    		if((j > (1.5*(pm_height >> 3)-1)) && (j < (pm_height-1.5*(pm_height >> 3)))) {
    			//color = gdisp_lld_get_pixel_color(pixmap);
    			//xil_printf("color: %x\r\n", color);
    			if(surface[j*pm_width + i] == 0) {
    				surface[j*pm_width + i] = ABGR2COLOR(0x00, 0x00, 0x00, 0x00);
    			}
//    			else {
    				//surface[j*pm_width + i] = ABGR2COLOR(0x00, 0x00, 0x00, 0x00);
    			//}

    		}
    		else {

				if(j < 1.5*(pm_height >> 3)) { // Top lines

					if (  (i < (1.5*(pm_height >> 3)-j)) || (i > ((pm_width-1.5*(pm_height >> 3))-1+j)    )  ) {
    					surface[j*pm_width + i] = ABGR2COLOR(0x80, 0xff, 0xff, 0xff);
    					//xil_printf("c: %x\r\n", surface_1[j*PIXMAP_WIDTH_1 + i]);
    				}
    				else {
    	    			//if(surface[j*pm_width + i] == 0) {
    	    				surface[j*pm_width + i] = ABGR2COLOR(0x00, 0x00, 0x00, 0x00);
    	    			//}
    				}

				}
				else { // Bottom lines

					if( (i < (j+1.5*(pm_height >> 3)-pm_height) ) || i > ((pm_width-(1.5*(pm_height >> 3)-(pm_height-j)))-1) ){
						surface[j*pm_width + i] = ABGR2COLOR(0x80, 0xff, 0xff, 0xff);
					}
					else {
    	    			if(surface[j*pm_width + i] == 0) {
    	    				surface[j*pm_width + i] = ABGR2COLOR(0x00, 0x00, 0x00, 0x00);
    	    			}
					}
				}
     		}
    	}
    }
}

///* Global timer set up*/
//
///* start timer */
// void gtimer_start_clock(void)
//{
//	*(volatile unsigned int*)SCU_GLOBAL_TIMER_CONTROL = ((1 << 0) | // Timer Enable
//														 (1 << 1) | // Comparator Comparison Enable
//						      	  	  	  	  	  	  	 (1 << 3) | // Auto-increment
//														 (0 << 8) 	// Pre-scale
//	);
//}
//
///* stop timer and reset timer count regs */
// void gtimer_reset_clock(void)
//{
//	gtimer_disable_clock();
//	*(volatile unsigned int*)SCU_GLOBAL_TIMER_COUNT_L32 = 0; // Reset Clock
//	*(volatile unsigned int*)SCU_GLOBAL_TIMER_COUNT_U32 = 0;
//}
//
// /* Set Comparator values */
//  void gtimer_set_comparator(uint32_t L32, uint32_t U32)
// {
// 	*(volatile unsigned int*)SCU_GLOBAL_TIMER_COMP_L32 = L32;
// 	*(volatile unsigned int*)SCU_GLOBAL_TIMER_COMP_U32 = U32;
// }
//
///* stop timer */
// void gtimer_disable_clock(void)
//{
//	*(volatile unsigned int*)SCU_GLOBAL_TIMER_CONTROL = 0;
//}
//
///* Compute mask for given delay in miliseconds*/
//int get_number_of_cycles_for_delay(unsigned int delay)
//{
//  // GTC is always clocked at 1/2 of the CPU frequency (CPU_3x2x)
//  return (XPAR_PS7_CORTEXA9_0_CPU_CLK_FREQ_HZ*delay/(2*1000));
//
//}
//
//void gtimer_reset_and_start_timer()
//{
//  	    gtimer_reset_clock();
//	    gtimer_start_clock();
//}

// uGFX SystemTick
systemticks_t gfxSystemTicks(void)
{
	return g_ms_tick;
}

systemticks_t gfxMillisecondsToTicks(delaytime_t ms)
{
	return ms;
}
/////////////////////////////////////

uint32_t tusb_tick_get(void)
{
  //return system_ticks;
  return g_ms_tick;
}

void tick_get(void)
{
	xil_printf("t=%d\n\r", g_ms_tick);
}

void tick_set(uint32_t tick)
{
	g_ms_tick = tick;
}

void reset_usb(void)
{
	uint8_t reg;
	uint8_t val = 0;

	usb_reset_status = 1;
	usb_reset_status_old = 0;
	//xil_printf("david0823: %s:%s(%d) ST usb_reset_status = %d\r\n",__FILE__,__func__,__LINE__,usb_reset_status);

	xil_printf("usb reset\n\r");
	reg = ULPI_OTG_CTRL;
	val = 0;
	val = ulpi_ReadReg(reg);
	xil_printf("read value : %02X\n\r", val);

	val &= 0xDF;
	xil_printf("set value : %02X\n\r", val);
	ulpi_WriteReg(val, reg);

	usleep(500000);

	val |= 0x20;
	xil_printf("set value : %02X\n\r", val);
	ulpi_WriteReg(val, reg);
}

void get_usb_descriptor(void)
{
	//xil_printf("\n\rGet usb descriptor\n\r");
	uint16_t vid_tmp = 0;
	uint16_t pid_tmp = 0;
	uint8_t ret = 0;

	xil_printf("\n\r READ \t");

	ret = enumeration_body_subtask2(&vid_tmp, &pid_tmp);

	//xil_printf("Get usb descriptor vid = 0x%x = %d pid = 0x%x = %d\n\r", vid_tmp, vid_tmp, pid_tmp, pid_tmp);


	if(ret == 0)
	{
		vendor_id_tmp = vid_tmp;
		product_id_tmp = pid_tmp;
		xil_printf("OK\n\r");
	}
	else if(ret == 2)
	{
		xil_printf("\n\rusb HW reset\n\r");
		reset_usb();
		sleep(1);
		xil_printf("\n\rusb SW reset\n\r");
		tusb_init(); // initialize tinyusb stack
		ulpi_WriteReg(0x60, ULPI_FC_CTRL);	//0x16
		port_connect_status_change_isr(0);
		tusb_isr(0);
	}
	else
		xil_printf("fail\n\r");
}


typedef volatile struct {
  union {
    uint32_t usb_cmd                  ; ///< The Command Register indicates the command to be executed by the serial bus host controller. Writing to the register causes a command to be executed
    struct {
      uint32_t run_stop               : 1 ; ///< Default 0b. 1=Run. 0=Stop. When set to a 1, the Host Controller proceeds with execution of the schedule. The Host Controller continues execution as long as this bit is set to a 1. When this bit is set to 0, the Host Controller completes the current and any actively pipelined transactions on the USB and then halts. The Host Controller must halt within 16 micro-frames after software clears the Run bit. The HC Halted bit in the status register indicates when the Host Controller has finished its pending pipelined transactions and has entered the stopped state. Software must not write a one to this field unless the host controller is in the Halted state (i.e. HCHaltedin the USBSTS register is a one). Doing so will yield undefined results.
      uint32_t reset                  : 1 ; ///< his control bit is used by software to reset the host controller. The effects of this on Root Hub registers are similar to a Chip Hardware Reset. When software writes a one to this bit, the Host Controller resets its internal pipelines, timers, counters, state machines, etc. to their initial value. Any transaction currently in progress on USB is immediately terminated. A USB reset is not driven on downstream ports.This bit is set to zero by the Host Controller when the reset process is complete. Software cannot terminate the reset process early by writing a zero to this register. Software should not set this bit to a one when the HCHaltedbit in the USBSTS register is a zero. Attempting to reset an actively running host controller will result in undefined behavior.
      uint32_t framelist_size         : 2 ; ///< This field is R/W only if Programmable Frame List Flagin the HCCPARAMS registers is set to a one. This field specifies the size of the frame list.00b  1024 elements (4096 bytes) Default value 01b  512 elements (2048 bytes) 10b 256 elements (1024 bytes)
      uint32_t periodic_enable        : 1 ; ///< This bit controls whether the host controller skips processing the Periodic Schedule. Values mean: 0b Do not process the Periodic Schedule 1b Use the PERIODICLISTBASE register to access the Periodic Schedule.
      uint32_t async_enable           : 1 ; ///< This bit controls whether the host controller skips processing the Asynchronous Schedule. Values mean: 0b Do not process the Asynchronous Schedule 1b Use the ASYNCLISTADDR register to access the Asynchronous Schedule.
      uint32_t advacne_async          : 1 ; ///< This bit is used as a doorbell by software to tell the host controller to issue an interrupt the next time it advances asynchronous schedule. Software must write a 1 to this bit to ringthe doorbell. When the host controller has evicted all appropriate cached schedule state, it sets the Interrupt on Async Advancestatus bit in the USBSTS register. If the Interrupt on Async Advance Enablebit in the USBINTR register is a one then the host controller will assert an interrupt at the next interrupt threshold. See Section 4.8.2 for operational details. The host controller sets this bit to a zero after it has set the Interrupt on Async Advance status bit in the USBSTS register to a one. Software should not write a one to this bit when the asynchronous schedule is disabled. Doing so will yield undefined results.
      uint32_t light_reset            : 1 ; ///< This control bit is not required. If implemented, it allows the driver to reset the EHCI controller without affecting the state of the ports or the relationship to the companion host controllers. For example, the PORSTC registers should not be reset to their default values and the CF bit setting should not go to zero (retaining port ownership relationships). A host software read of this bit as zero indicates the Light Host Controller Reset has completed and it is safe for host software to re-initialize the host controller. A host software read of this bit as a one indicates the Light Host Controller Reset has not yet completed.
      uint32_t async_park             : 2 ; ///< It contains a count of the number of successive transactions the host controller is allowed to execute from a high-speed queue head on the Asynchronous schedule before continuing traversal of the Asynchronous schedule. See Section 4.10.3.2 for full operational details. Valid values are 1h to 3h. Software must not write a zero to this bit when Park Mode Enableis a one as this will result in undefined behavior.
      uint32_t                        : 1 ; ///< reserved
      uint32_t async_park_enable      : 1 ; ///< Software uses this bit to enable or disable Park mode. When this bit is one, Park mode is enabled. When this bit is a zero, Park mode is disabled.
      uint32_t                        : 3 ; ///< reserved
      uint32_t nxp_framelist_size_msb : 1 ; ///< NXP customized : Bit 2 of the Frame List Size bits \n 011b: 128 elements \n 100b: 64 elements \n 101b: 32 elements \n 110b: 16 elements \n 111b: 8 elements
      uint32_t int_threshold          : 8 ; ///< Default 08h. This field is used by system software to select the maximum rate at which the host controller will issue interrupts. The only valid values are defined below. If software writes an invalid value to this register, the results are undefined. Value Maximum Interrupt Interval 00h Reserved 01h 1 micro-frame 02h 2 micro-frames 04h 4 micro-frames 08h 8 micro-frames (default, equates to 1 ms) 10h 16 micro-frames (2 ms) 20h 32 micro-frames (4 ms) 40h 64 micro-frames (8 ms) Refer to Section 4.15 for interrupts affected by this register. Any other value in this register yields undefined results. Software modifications to this bit while HCHalted bit is equal to zero results in undefined behavior.
      uint32_t                        : 0 ; // padding to the boundary of storage unit
    }usb_cmd_bit;
  };

  union {
    uint32_t usb_sts            ; ///< This register indicates pending interrupts and various states of the Host Controller. The status resulting from a transaction on the serial bus is not indicated in this register. Software sets a bit to 0 in this register by writing a 1 to it. See Section 4.15 for additional information concerning USB interrupt conditions.
    struct {
      uint32_t usb                    : 1  ; ///< R/WC The Host Controller sets this bit to 1 on the completion of a USB transaction, which results in the retirement of a Transfer Descriptor that had its IOC bit set. \n The Host Controller also sets this bit to 1 when a short packet is detected (actual number of bytes received was less than the expected number of bytes).
      uint32_t usb_error              : 1  ; ///< R/WC The Host Controller sets this bit to 1 when completion of a USB transaction results in an error condition (e.g., error counter underflow). If the TD on which the error interrupt occurred also had its IOC bit set, both this bit and USBINT bit are set. See Section 4.15.1 for a list of the USB errors that will result in this bit being set to a one.
      uint32_t port_change_detect     : 1  ; ///< R/WC The Host Controller sets this bit to a one when any port for which the Port Ownerbit is set to zero (see Section 2.3.9) has a change bit transition from a zero to a one or a Force Port Resumebit transition from a zero to a one as a result of a J-K transition detected on a suspended port.
      uint32_t framelist_rollover     : 1  ; ///< R/WC The Host Controller sets this bit to a one when the Frame List Index(see Section 2.3.4) rolls over from its maximum value to zero. The exact value at which the rollover occurs depends on the frame list size. For example, if the frame list size (as programmed in the Frame List Sizefield of the USBCMD register) is 1024, the Frame Index Registerrolls over every time FRINDEX[13] toggles. Similarly, if the size is 512, the Host Controller sets this bit to a one every time FRINDEX[12] toggles.
      uint32_t pci_host_system_error  : 1  ; ///< R/WC (not used by NXP) The Host Controller sets this bit to 1 when a serious error occurs during a host system access involving the Host Controller module. In a PCI system, conditions that set this bit to 1 include PCI Parity error, PCI Master Abort, and PCI Target Abort. When this error occurs, the Host Controller clears the Run/Stop bit in the Command register to prevent further execution of the scheduled TDs.
      uint32_t async_advance          : 1  ; ///< R/WC 0=Default. System software can force the host controller to issue an interrupt the next time the host controller advances the asynchronous schedule by writing a one to the Interrupt on Async Advance Doorbell bit in the USBCMD register. This status bit indicates the assertion of that interrupt source.
      uint32_t                        : 1  ; ///< These bits are reserved and should be set to zero.
      uint32_t nxp_int_sof            : 1  ; ///< R/WC NXP customized:  this bit will be set every 125us and can be used by host controller driver as a time base.
      uint32_t                        : 4  ; ///< These bits are reserved and should be set to zero.
      uint32_t hc_halted              : 1  ; ///< Read-Only 1=Default. This bit is a zero whenever the Run/Stop bit is a one. The Host Controller sets this bit to one after it has stopped executing as a result of the Run/Stop bit being set to 0, either by software or by the Host Controller hardware (e.g. internal error).
      uint32_t reclamation            : 1  ; ///< Read-Only 0=Default. This is a read-only status bit, which is used to detect an empty asynchronous schedule. The operational model of empty schedule detection is described in Section 4.8.3. The valid transitions for this bit are described in Section 4.8.6.
      uint32_t period_schedule_status : 1  ; ///< Read-Only The bit reports the current real status of the Periodic Schedule. If this bit is a zero then the status of the Periodic Schedule is disabled. If this bit is a one then the status of the Periodic Schedule is enabled
      uint32_t async_schedule_status  : 1  ; ///< Read-Only 0=Default. The bit reports the current real status of the Asynchronous Schedule. If this bit is a zero then the status of the Asynchronous Schedule is disabled. If this bit is a one then the status of the Asynchronous Schedule is enabled.
      uint32_t                        : 2  ; ///< reseved
      uint32_t nxp_int_async          : 1  ; ///< R/WC NXP customized: This bit is set by the Host Controller when the cause of an interrupt is a completion of a USB transaction where the Transfer Descriptor (TD) has an interrupt on complete (IOC) bit set andthe TD was from the asynchronous schedule. This bit is also set by the Host when a short packet is detected andthe packet is on the asynchronous schedule.
      uint32_t nxp_int_period         : 1  ; ///< R/WC NXP customized: This bit is set by the Host Controller when the cause of an interrupt is a completion of a USB transaction where the Transfer Descriptor (TD) has an interrupt on complete (IOC) bit set andthe TD was from the periodic schedule.
      uint32_t                        : 12 ; ///< reserved
      uint32_t                        : 0  ; // padding to the boundary of storage unit
    }usb_sts_bit;
  };

  union{
    uint32_t usb_int_enable     ; ///< This register enables and disables reporting of the corresponding interrupt to the software. When a bit is set and the corresponding interrupt is active, an interrupt is generated to the host. Interrupt sources that are disabled in this register still appear in the USBSTS to allow the software to poll for events.
    struct {
      uint32_t usb                   : 1  ; ///< When this bit is a one, and the USBINT bit in the USBSTS register is a one, the host controller will issue an interrupt at the next interrupt threshold. The interrupt is acknowledged by software clearing the USBINTbit.
      uint32_t usb_error             : 1  ; ///< When this bit is a one, and the USBERRINT bit in the USBSTS register is a one, the host controller will issue an interrupt at the next interrupt threshold. The interrupt is acknowledged by software clearing the USBERRINTbit.
      uint32_t port_change_detect    : 1  ; ///< When this bit is a one, and the Port Change Detect bit in the USBSTS register is a one, the host controller will issue an interrupt. The interrupt is acknowledged by software clearing the Port Change Detectbit.
      uint32_t framelist_rollover    : 1  ; ///< When this bit is a one, and the Frame List Rolloverbit in the USBSTS register is a one, the host controller will issue an interrupt. The interrupt is acknowledged by software clearing the Frame List Rollover bit.
      uint32_t pci_host_system_error : 1  ; ///< (not used by NXP) When this bit is a one, and the Host System Error Statusbit in the USBSTS register is a one, the host controller will issue an interrupt. The interrupt is acknowledged by software clearing the Host System Error bit.
      uint32_t async_advance         : 1  ; ///< When this bit is a one, and the Interrupt on Async Advancebit in the USBSTS register is a one, the host controller will issue an interrupt at the next interrupt threshold. The interrupt is acknowledged by software clearing the Interrupt on Async Advancebit.
      uint32_t                       : 1  ; ///< reserved
      uint32_t nxp_int_sof           : 1  ; ///< NXP customized: if this bit is one and the SRI bit in the USBSTS register is one, the host controller will issue an interrupt. In host mode, the SRI bit will be set every 125 micro sec and can be used by the host controller as a time base. The interrupt is acknowledged by software clearing the SRI bit in the USBSTS register.
      uint32_t                       : 10 ; ///< reserved
      uint32_t nxp_int_async         : 1  ; ///< NXP customized: When this bit is a one, and the USBHSTASYNCINT bit in the USBSTS register is a one, the host controller will issue an interrupt at the next interrupt threshold. The interrupt is acknowledged by software clearing the USBHSTASYNCINT bit.
      uint32_t nxp_int_period        : 1  ; ///< NXP customized: When this bit is a one, and the USBHSTPERINT bit in the USBSTS register is a one, the host controller will issue an interrupt at the next interrupt threshold. The interrupt is acknowledged by software clearing the USBHSTPERINT bit.
      uint32_t                       : 12 ; ///< reserved
      uint32_t                       : 0  ; // padding to the boundary of storage unit
    }usb_int_enable_bit;
  };

  /*
  uint32_t frame_index        ; ///< This register is used by the host controller to index into the periodic frame list. The register updates every 125 microseconds (once each micro-frame). Bits [N:3] are used to select a particular entry in the Periodic Frame List during periodic schedule execution. The number of bits used for the index depends on the size of the frame list as set by system software in the Frame List Sizefield in the USBCMD register
  uint32_t ctrl_ds_seg        ; ///< (not used by NXP) This 32-bit register corresponds to the most significant address bits [63:32] for all EHCI data structures. If the 64-bit Addressing Capabilityfield in HCCPARAMS is a zero, then this register is not used
  uint32_t periodic_list_base ; ///< This 32-bit register contains the beginning address of the Periodic Frame List in the system memory. System software loads this register prior to starting the schedule execution by the Host Controller (see 4.1). The memory structure referenced by this physical memory pointer is assumed to be 4-Kbyte aligned. The contents of this register are combined with the Frame Index Register (FRINDEX) to enable the Host Controller to step through the Periodic Frame List in sequence.
  uint32_t async_list_base    ; ///< This 32-bit register contains the address of the next asynchronous queue head to be executed. Bits [4:0] of this register cannot be modified by system software and will always return a zero when read. The memory structure referenced by this physical memory pointer is assumed to be 32-byte (cache line) aligned
  uint32_t tt_control         ; ///< nxp embedded transaction translator (reserved by EHCI specs)
  uint32_t reserved[8]        ; ///< reserved by EHCI specs
  uint32_t config_flag        ; ///< (not used by NXP) configured flag register
  */

  union {
    uint32_t portsc             ; ///< port status and control
    struct {
      uint32_t current_connect_status      : 1; ///< RO 1=Device is present on port. 0=No device is present. Default = 0. This value reflects the current state of the port, and may not correspond directly to the event that caused the Connect Status Change bit (Bit 1) to be set. This field is zero if Port Power is zero.
      uint32_t connect_status_change       : 1; ///< R/WC 1=Change in Current Connect Status. 0=No change. Default = 0. Indicates a change has occurred in the port's Current Connect Status. The host controller sets this bit for all changes to the port device connect status, even if system software has not cleared an existing connect status change. For example, the insertion status changes twice before system software has cleared the changed condition, hub hardware will be "setting" an already-set bit (i.e., the bit will remain set). Software sets this bit to 0 by writing a 1 to it. This field is zero if Port Power is zero.
      uint32_t port_enable                 : 1; ///< 1=Enable. 0=Disable. Default = 0. Ports can only be enabled by the host controller as a part of the reset and enable. Software cannot enable a port by writing a one to this field. The host controller will only set this bit to a one when the reset sequence determines that the attached device is a high-speed device. Ports can be disabled by either a fault condition (disconnect event or other fault condition) or by host software. Note that the bit status does not change until the port state actually changes.
      uint32_t port_enable_change          : 1; ///< R/WC 1=Port enabled/disabled status has changed. 0=No change. Default = 0. For the root hub, this bit gets set to a one only when a port is disabled due to the appropriate conditions existing at the EOF2 point (See Chapter 11 of the USB Specification for the definition of a Port Error). Software clears this bit by writing a 1 to it. This field is zero if Port Power is zero.
      uint32_t over_current_active         : 1; ///< RO Default = 0. 1=This port currently has an over-current condition. 0=This port does not have an over-current condition. This bit will automatically transition from a one to a zero when the over current condition is removed.
      uint32_t over_current_change         : 1; ///< R/WC Default = 0. 1=This bit gets set to a one when there is a change to Over-current Active. Software clears this bit by writing a one to this bit position.
      uint32_t force_port_resume           : 1; ///< 1= Resume detected/driven on port. 0=No resume (K-state) detected/driven on port. Default = 0. This functionality defined for manipulating this bit depends on the value of the Suspendbit. For example, if the port is not suspended (Suspendand Enabledbits are a one) and software transitions this bit to a one, then the effects on the bus are undefined. Software sets this bit to a 1 to drive resume signaling. The Host Controller sets this bit to a 1 if a J-to-K transition is detected while the port is in the Suspend state. When this bit transitions to a one because a J-to-K transition is detected, the Port Change Detectbit in the USBSTS register is also set to a one. If software sets this bit to a one, the host controller must not set the Port Change Detectbit.
      uint32_t suspend                     : 1; ///< 1=Port in suspend state. 0=Port not in suspend state. Default = 0. Port Enabled Bit and Suspend bit of this register define the port states as follows: Bits [Port Enabled, Suspend] Port State 0X Disable 10 Enable 11 Suspend When in suspend state, downstream propagation of data is blocked on this port, except for port reset. The blocking occurs at the end of the current transaction, if a transaction was in progress when this bit was written to 1. In the suspend state, the port is sensitive to resume detection. Note that the bit status does not change until the port is suspended and that there may be a delay in suspending a port if there is a transaction currently in progress on the USB. A write of zero to this bit is ignored by the host controller. The host controller will unconditionally set this bit to a zero when: Software sets the Force Port Resumebit to a zero (from a one). Software sets the Port Resetbit to a one (from a zero).
      uint32_t port_reset                  : 1; ///< 1=Port is in Reset. 0=Port is not in Reset. Default = 0. When software writes a one to this bit (from a zero)
      uint32_t nxp_highspeed_status        : 1; ///< NXP customized: 0=connected to the port is not in High-speed mode, 1=connected to the port is in High-speed mode
      uint32_t line_status                 : 2; ///< hese bits reflect the current logical levels of the D+ (bit 11) and D- (bit 10) signal lines. These bits are used for detection of low-speed USB devices prior to the port reset and enable sequence. This field is valid only when the port enable bit is zero and the current connect status bit is set to a one. The encoding of the bits are: 00b SE0, 10b J-state, 01b K-state, 11b undefined
      uint32_t port_power                  : 1; ///< 0= power off, 1= power on, Host/OTG controller requires port power control switches. This bit represents the current setting of the switch (0=off, 1=on). When power is not available on a port (i.e. PP equals a 0), the port is non-functional and will not report attaches, detaches, etc. When an over-current condition is detected on a powered port and PPC is a one, the PP bit in each affected port may be transitioned by the host controller driver from a one to a zero (removing power from the port).
      uint32_t port_owner                  : 1; ///< (not used by NXP)
      uint32_t port_indicator_control      : 2; ///< Writing to this field effects the value of the pins USB0_IND1 and USB0_IND0. 00b: Port indication is off, 01b: Amber, 10b: green, 11b: undefined
      uint32_t port_test_control           : 4; ///< When this field is zero, the port is NOT operating in a test mode. A non-zero value indicates that it is operating in test mode
      uint32_t wake_on_connect_enable      : 1; ///< Default = 0b. Writing this bit to a one enables the port to be sensitive to device connects as wake-up events. See Section 4.3 for effects of this bit on resume event behavior. Refer to Section 4.3.1 for operational model.
      uint32_t wake_on_disconnect_enable   : 1; ///<  Default = 0b. Writing this bit to a one enables the port to be sensitive to device disconnects as wake-up events. See Section 4.3 for effects of this bit on resume event behavior. Refer to Section 4.3.1 for operational model.
      uint32_t wake_on_over_current_enable : 1; ///< Default = 0b. Writing this bit to a one enables the port to be sensitive to over-current conditions as wake-up events. See Section 4.3 for effects of this bit on resume event behavior. Refer to Section 4.3.1 for operational model.
      uint32_t nxp_phy_clock_disable       : 1; ///< NXP customized: the PHY can be put into Low Power Suspend Clock Disable when the downstream device has been put into suspend mode or when no downstream device is connected. Low power suspend is completely under the control of software. 0: enable PHY clock, 1: disable PHY clock
      uint32_t nxp_port_force_fullspeed    : 1; ///< NXP customized: Writing this bit to a 1 will force the port to only connect at Full Speed. It disables the chirp sequence that allowsthe port to identify itself as High Speed. This is useful for testing FS configurations with a HS host, hub or device.
      uint32_t                             : 1;
      uint32_t nxp_port_speed              : 2; ///< NXP customized: This register field indicates the speed atwhich the port is operating. For HS mode operation in the host controllerand HS/FS operation in the device controller the port routing steers data to the Protocol engine. For FS and LS mode operation in the host controller, the port routing steers data to the Protocol Engine w/ Embedded Transaction Translator. 0x0: Fullspeed, 0x1: Lowspeed, 0x2: Highspeed
      uint32_t                             : 0; // padding to the boundary of storage unit
    }portsc_bit;
  };
}ehci_registers_ta;

INLINE_ ehci_registers_ta* get_operational_registera(void)
{
  //xil_printf("ehci get_operation_register\r\n");
  return (ehci_registers_ta*) (XPAR_XUSBPS_0_BASEADDR+XUSBPS_CMD_OFFSET);
}



void read_usb_status(void)
{
	xil_printf("\n\rRead usb status\n\r");

	bool ret1;
	bool ret2;
	bool ret3;
	ret1 = get_operational_registera()->portsc_bit.current_connect_status;
	ret2 = get_operational_registera()->portsc_bit.connect_status_change;
	ret3 = get_operational_registera()->portsc_bit.port_enable;

	//ret = get_operational_registera();
	xil_printf("david0824: %s:%s(%d) ret1 = %d ret2 = %d ret3 = %d\r\n",__FILE__,__func__,__LINE__,ret1, ret2, ret3);

	u32 value;

	value = Xil_In32(XPAR_XUSBPS_0_BASEADDR + 0);
	xil_printf("david0824: %s:%s(%d) register 0 value = 0x%08X\r\n",__FILE__,__func__,__LINE__,value);

	value = Xil_In32(XPAR_XUSBPS_0_BASEADDR + 4);
	xil_printf("david0824: %s:%s(%d) register 4 value = 0x%08X\r\n",__FILE__,__func__,__LINE__,value);

	value = Xil_In32(XPAR_XUSBPS_0_BASEADDR + 8);
	xil_printf("david0824: %s:%s(%d) register 8 value = 0x%08X\r\n",__FILE__,__func__,__LINE__,value);

	value = Xil_In32(XPAR_XUSBPS_0_BASEADDR + 0xC);
	xil_printf("david0824: %s:%s(%d) register 0xC value = 0x%08X\r\n",__FILE__,__func__,__LINE__,value);

	value = Xil_In32(XPAR_XUSBPS_0_BASEADDR + 0x10);
	xil_printf("david0824: %s:%s(%d) register 0x10 value = 0x%08X\r\n",__FILE__,__func__,__LINE__,value);

	value = Xil_In32(XPAR_XUSBPS_0_BASEADDR + 0x14);
	xil_printf("david0824: %s:%s(%d) register 0x14 value = 0x%08X\r\n",__FILE__,__func__,__LINE__,value);

	xil_printf("david0824: %s:%s(%d) sizeof(ehci_registers_ta) = %d\r\n",__FILE__,__func__,__LINE__,sizeof(ehci_registers_ta));
	xil_printf("david0824: %s:%s(%d) sizeof(uint32_t) = %d\r\n",__FILE__,__func__,__LINE__,sizeof(uint32_t));

	value = Xil_In32(XPAR_XUSBPS_0_BASEADDR + XUSBPS_CMD_OFFSET);
	xil_printf("david0824: %s:%s(%d) register value = 0x%08X\r\n",__FILE__,__func__,__LINE__,value);

	/*
	ret1 = get_operational_registera()->portsc_bit.current_connect_status;
	ret2 = get_operational_registera()->portsc_bit.connect_status_change;
	ret3 = get_operational_registera()->portsc_bit.port_enable;
	*/

	xil_printf("usb_cmd\trun_stop = %d\r\n", get_operational_registera()->usb_cmd_bit.run_stop );
	xil_printf("usb_cmd\treset = %d\r\n", get_operational_registera()->usb_cmd_bit.reset );
	xil_printf("usb_cmd\tframelist_size = %d\r\n", get_operational_registera()->usb_cmd_bit.framelist_size );
	xil_printf("usb_cmd\tperiodic_enable = %d\r\n", get_operational_registera()->usb_cmd_bit.periodic_enable );
	xil_printf("usb_cmd\tasync_enable = %d\r\n", get_operational_registera()->usb_cmd_bit.async_enable );
	xil_printf("usb_cmd\tadvacne_async = %d\r\n", get_operational_registera()->usb_cmd_bit.advacne_async );
	xil_printf("usb_cmd\tlight_reset = %d\r\n", get_operational_registera()->usb_cmd_bit.light_reset );
	xil_printf("usb_cmd\tasync_park = %d\r\n", get_operational_registera()->usb_cmd_bit.async_park );
	xil_printf("usb_cmd\tasync_park_enable = %d\r\n", get_operational_registera()->usb_cmd_bit.async_park_enable );
	xil_printf("usb_cmd\tnxp_framelist_size_msb = %d\r\n", get_operational_registera()->usb_cmd_bit.nxp_framelist_size_msb );
	xil_printf("usb_cmd\tint_threshold = %d\r\n", get_operational_registera()->usb_cmd_bit.int_threshold );

	xil_printf("usb_sts\tusb = %d\r\n", get_operational_registera()->usb_sts_bit.usb );
	xil_printf("usb_sts\tusb_error = %d\r\n", get_operational_registera()->usb_sts_bit.usb_error );
	xil_printf("usb_sts\tport_change_detect = %d\r\n", get_operational_registera()->usb_sts_bit.port_change_detect );
	xil_printf("usb_sts\tframelist_rollover = %d\r\n", get_operational_registera()->usb_sts_bit.framelist_rollover );
	xil_printf("usb_sts\tpci_host_system_error = %d\r\n", get_operational_registera()->usb_sts_bit.pci_host_system_error );
	xil_printf("usb_sts\tasync_advance = %d\r\n", get_operational_registera()->usb_sts_bit.async_advance );
	xil_printf("usb_sts\tnxp_int_sof = %d\r\n", get_operational_registera()->usb_sts_bit.nxp_int_sof );
	xil_printf("usb_sts\thc_halted = %d\r\n", get_operational_registera()->usb_sts_bit.hc_halted );
	xil_printf("usb_sts\treclamation = %d\r\n", get_operational_registera()->usb_sts_bit.reclamation );
	xil_printf("usb_sts\tperiod_schedule_status = %d\r\n", get_operational_registera()->usb_sts_bit.period_schedule_status );
	xil_printf("usb_sts\tasync_schedule_status = %d\r\n", get_operational_registera()->usb_sts_bit.async_schedule_status );
	xil_printf("usb_sts\tnxp_int_async = %d\r\n", get_operational_registera()->usb_sts_bit.nxp_int_async );
	xil_printf("usb_sts\tnxp_int_period = %d\r\n", get_operational_registera()->usb_sts_bit.nxp_int_period );

	xil_printf("usb_int\tusb = %d\r\n", get_operational_registera()->usb_int_enable_bit.usb );
	xil_printf("usb_int\tusb_error = %d\r\n", get_operational_registera()->usb_int_enable_bit.usb_error );
	xil_printf("usb_int\tport_change_detect = %d\r\n", get_operational_registera()->usb_int_enable_bit.port_change_detect );
	xil_printf("usb_int\tframelist_rollover = %d\r\n", get_operational_registera()->usb_int_enable_bit.framelist_rollover );
	xil_printf("usb_int\tpci_host_system_error = %d\r\n", get_operational_registera()->usb_int_enable_bit.pci_host_system_error );
	xil_printf("usb_int\tasync_advance = %d\r\n", get_operational_registera()->usb_int_enable_bit.async_advance );
	xil_printf("usb_int\tnxp_int_sof = %d\r\n", get_operational_registera()->usb_int_enable_bit.nxp_int_sof );
	xil_printf("usb_int\tnxp_int_async = %d\r\n", get_operational_registera()->usb_int_enable_bit.nxp_int_async );
	xil_printf("usb_int\tnxp_int_period = %d\r\n", get_operational_registera()->usb_int_enable_bit.nxp_int_period );


	xil_printf("portsc\tcurrent_connect_status = %d\r\n", get_operational_registera()->portsc_bit.current_connect_status);
	xil_printf("portsc\tconnect_status_change = %d\r\n", get_operational_registera()->portsc_bit.connect_status_change);
	xil_printf("portsc\tport_enable = %d\r\n", get_operational_registera()->portsc_bit.port_enable);
	xil_printf("portsc\tport_enable_change = %d\r\n", get_operational_registera()->portsc_bit.port_enable_change);
	xil_printf("portsc\tover_current_active = %d\r\n", get_operational_registera()->portsc_bit.over_current_active);
	xil_printf("portsc\tover_current_change = %d\r\n", get_operational_registera()->portsc_bit.over_current_change);
	xil_printf("portsc\tforce_port_resume = %d\r\n", get_operational_registera()->portsc_bit.force_port_resume);
	xil_printf("portsc\tsuspend = %d\r\n", get_operational_registera()->portsc_bit.suspend);
	xil_printf("portsc\tport_reset = %d\r\n", get_operational_registera()->portsc_bit.port_reset);
	xil_printf("portsc\tnxp_highspeed_status = %d\r\n", get_operational_registera()->portsc_bit.nxp_highspeed_status);
	xil_printf("portsc\tline_status = %d\r\n", get_operational_registera()->portsc_bit.line_status);
	xil_printf("portsc\tport_power = %d\r\n", get_operational_registera()->portsc_bit.port_power);
	xil_printf("portsc\tport_owner = %d\r\n", get_operational_registera()->portsc_bit.port_owner);
	xil_printf("portsc\tport_indicator_control = %d\r\n", get_operational_registera()->portsc_bit.port_indicator_control);
	xil_printf("portsc\tport_test_control = %d\r\n", get_operational_registera()->portsc_bit.port_test_control);
	xil_printf("portsc\twake_on_connect_enable = %d\r\n", get_operational_registera()->portsc_bit.wake_on_connect_enable);
	xil_printf("portsc\twake_on_disconnect_enable = %d\r\n", get_operational_registera()->portsc_bit.wake_on_disconnect_enable);
	xil_printf("portsc\twake_on_over_current_enable = %d\r\n", get_operational_registera()->portsc_bit.wake_on_over_current_enable);
	xil_printf("portsc\tnxp_phy_clock_disable = %d\r\n", get_operational_registera()->portsc_bit.nxp_phy_clock_disable);
	xil_printf("portsc\tnxp_port_force_fullspeed = %d\r\n", get_operational_registera()->portsc_bit.nxp_port_force_fullspeed);
	xil_printf("portsc\tnxp_port_speed = %d\r\n", get_operational_registera()->portsc_bit.nxp_port_speed);





}

void read_usb_registers(void)
{
	uint32_t value = 0;
	uint8_t i;

	xil_printf("\n\rRead usb registers\n\r");
	value = XUsbPs_ReadReg(XPAR_XUSBPS_0_BASEADDR, 0);xil_printf("%08X ", value);
	value = XUsbPs_ReadReg(XPAR_XUSBPS_0_BASEADDR, 4);xil_printf("%08X ", value);
	value = XUsbPs_ReadReg(XPAR_XUSBPS_0_BASEADDR, 8);xil_printf("%08X ", value);
	value = XUsbPs_ReadReg(XPAR_XUSBPS_0_BASEADDR, 0xc);xil_printf("%08X ", value);
	value = XUsbPs_ReadReg(XPAR_XUSBPS_0_BASEADDR, 0x10);xil_printf("%08X ", value);
	value = XUsbPs_ReadReg(XPAR_XUSBPS_0_BASEADDR, 0x14);xil_printf("%08X\n\r", value);

	xil_printf("\n\rRead ulpi registers\n\r");
	/*
	for(i = 0; i < 8; i++)
	{
		xil_printf("0x%02X ", i);
	}
	xil_printf("\n");
	*/

	for(i = 0; i < 64; i++)
	{
		value = ulpi_ReadReg(i);	//0x16
		xil_printf("%02X", value);
		if((i%8) == 7)
			xil_printf("\n\r");
		else
			xil_printf("  ");
	}
	xil_printf("\n\r");
	xil_printf("\n\r");

	xil_printf("Keyboard : ");
	if(flag_is_keyboard_mounted == 1)
	{
		xil_printf("mounted\n\r");
	}
	else
	{
		xil_printf("unmounted\n\r");
	}
	xil_printf("\n\r");
}

void parse_uart_esc_command(void)
{
	int i;
	if((buffer[0] == 0x1B)&&(buffer[1] == '[')&&(buffer[2] == 'A'))
	{
		//xil_printf("Up\t");
		xil_printf("\r%s", PROMPT);
		xil_printf("%s", last_command);
		ptr = sizeof(last_command) - 1;
		for(i = 0; i < ptr; i++)
		{
			buffer[i] = last_command[i];
		}
	}
	else if((buffer[0] == 0x1B)&&(buffer[1] == '[')&&(buffer[2] == 'B'))
	{
		//xil_printf("Down\t");
		xil_printf("\r%s", PROMPT);
		xil_printf("%s", last_command);
		ptr = sizeof(last_command) - 1;
		for(i = 0; i < ptr; i++)
		{
			buffer[i] = last_command[i];
		}
	}
	else if((buffer[0] == 0x1B)&&(buffer[1] == '[')&&(buffer[2] == 'C'))
	{
		//xil_printf("Right\t");
		xil_printf("\r%s", PROMPT);
		xil_printf("%s", last_command);
		ptr = sizeof(last_command) - 1;
		for(i = 0; i < ptr; i++)
		{
			buffer[i] = last_command[i];
		}
	}
	else if((buffer[0] == 0x1B)&&(buffer[1] == '[')&&(buffer[2] == 'D'))
	{
		//xil_printf("Left\t");
		// not very good
		if(ptr >= 2)
		{
			xil_printf("%c", 0x08);
			//xil_printf(".");
			ptr -= 2;
		}
		else
			ptr--;
	}
	else if((buffer[0] == 0x1B)&&(buffer[1] == '[')&&(buffer[2] == 0x35))
	{
		xil_printf("PageUp\t");
	}
	else if((buffer[0] == 0x1B)&&(buffer[1] == '[')&&(buffer[2] == 0x5B))
	{
		xil_printf("PageDown\t");
	}
	else if((buffer[0] == 0x1B)&&(buffer[1] == '[')&&(buffer[2] == 0x31))
	{
		xil_printf("Home\t");
	}
	else if((buffer[0] == 0x1B)&&(buffer[1] == '[')&&(buffer[2] == 0x32))
	{
		xil_printf("Insert\t");
	}
	else if((buffer[0] == 0x1B)&&(buffer[1] == '[')&&(buffer[2] == 0x33))
	{
		xil_printf("Delete\t");
	}
	else if((buffer[0] == 0x1B)&&(buffer[1] == '[')&&(buffer[2] == 0x34))
	{
		xil_printf("End\t");
	}
	else
	{
		xil_printf("XXXX\t");
		for( i = 0; i<3; i++)
		{
			xil_printf("0x%x ", buffer[i]);
		}
		xil_printf("\t");
	}
}


void parse_uart_command(void)
{
	int status;
	int i;
	uint32_t value = 0;
	uint8_t reg;
	uint8_t val = 0;

	if(length == 8)
	{
		if((buffer[0] == 'c')&&(buffer[1] == 'o')&&(buffer[2] == 'n')&&(buffer[3] == 's')&&(buffer[4] == 'o')&&(buffer[5] == 'l')&&(buffer[6] == 'e'))
		{
			/* initialize and clear the display */
			//gfxInit();

			/* Set a font */
			gwinSetDefaultFont(gdispOpenFont("*"));

			/* create the console window */
			GWindowInit		wi;

			gwinClearInit(&wi);
			wi.show = TRUE;
			wi.x = gdispGetWidth() / 2 - 200;
			wi.y = gdispGetHeight()-140;
			wi.width = 600;
			wi.height = 120;

			xil_printf("W = %d, H = %d\n\r", wi.width, wi.height);
			GW = gwinConsoleCreate(0, &wi);

			/* Set the fore- and background colors for the console */
			gwinSetColor(GW, White);
			gwinSetBgColor(GW, Purple);
			gwinClear(GW);

			gwinPrintf(GW, "gwinConsoleCreate size = %d X %d\n", wi.width, wi.height);

			gwinPrintf(GW, "AAAAAAAAAAAAAAA\n");
			gwinPrintf(GW, "BBBBBBBBBBBBBBBB\n");
			gwinPrintf(GW, "\n");

			for(i = 0; i < 25 ; i++)
			{
				gwinPrintf(GW, "CCCCCCCCCCCCC %2d\n", i);
				sleep(1);
			}

		}
		else if((buffer[0] == 't')&&(buffer[1] == ' '))
		{
		}
	}
	else if(length == 7)
	{
		if((buffer[0] == 'u')&&(buffer[1] == 'p')&&(buffer[2] == 't')&&(buffer[3] == 'i')&&(buffer[4] == 'm')&&(buffer[5] == 'e'))
		{
			//Get System Up time
			get_system_up_time();
		}
		else if((buffer[0] == 's')&&(buffer[1] == 'e')&&(buffer[2] == 'n')&&(buffer[3] == 's')&&(buffer[4] == 'o')&&(buffer[5] == 'r'))
		{
		}
		else if((buffer[0] == 't')&&(buffer[1] == ' '))
		{
		}
	}
	else if(length == 6)
	{
		if((buffer[0] == 'c')&&(buffer[1] == 'l')&&(buffer[2] == 'o')&&(buffer[3] == 'c')&&(buffer[4] == 'k'))
		{
		}
		else if((buffer[0] == 'p')&&(buffer[1] == 'r')&&(buffer[2] == 'i')&&(buffer[3] == 'n')&&(buffer[4] == 't'))
		{
			xil_printf("ABCDEFGHIJKLMNOPQ");
			sleep(3);
			xil_printf("%c", 0x08);
			xil_printf("%c", 0x08);
			xil_printf("%c", 0x08);
			xil_printf("%c", 0x08);
			xil_printf("%c", 0x08);
			xil_printf("%c", 0x08);
			xil_printf("%c", 0x08);
			xil_printf("%c", 0x08);
			xil_printf("%c", 0x08);
			xil_printf("%c", 0x08);
			xil_printf("abcdefg");
			sleep(3);
			xil_printf("\r");
			xil_printf("-------");

		}
		else if((buffer[0] == 'u')&&(buffer[1] == 's')&&(buffer[2] == 'b')&&(buffer[3] == 'r')&&(buffer[4] == '1'))
		{
			xil_printf("\n\rusb HW reset\n\r");
			reset_usb();
		}
		else if((buffer[0] == 'u')&&(buffer[1] == 's')&&(buffer[2] == 'b')&&(buffer[3] == 'r')&&(buffer[4] == '2'))
		{
			xil_printf("\n\rusb SW reset\n\r");
			tusb_init(); // initialize tinyusb stack
			value = 0x60;
			ulpi_WriteReg(value, ULPI_FC_CTRL);	//0x16
			port_connect_status_change_isr(0);
			tusb_isr(0);
		}
		else if((buffer[0] == 't')&&(buffer[1] == ' '))
		{
		}
	}
	else if(length == 5)
	{
		if((buffer[0] == 'h')&&(buffer[1] == 'e')&&(buffer[2] == 'l')&&(buffer[3] == 'p'))
		{
			xil_printf("\n\rIMS command prompt, ");
			xil_printf(RELEASE_INFO);
			xil_printf("\n\r");
			xil_printf("------------- Aries Demo -------------\n\r");
			xil_printf("1:\tToggle Layer 1\n\r");
			xil_printf("2:\tToggle Layer 2\n\r");
			xil_printf("3:\tToggle Layer 3\n\r");
			//xil_printf("'n' = Set to new scaler datapath\n\r");
			xil_printf("t:\tEnable/bypass camera TPG\n\r");
			xil_printf("y:\tEnable/bypass GUI TPG\n\r");
			xil_printf("u:\tPark Camera Freeze VDMA\n\r");
			//xil_printf("'s' = Set output frame size\n\r");
			//xil_printf("'p' = Print this menu\n\r");
			xil_printf("usb:\tread USB registers\n\r");
			xil_printf("r:\tread USB registers\n\r");
			xil_printf("usbr1:\tUSB HW reset\n\r");
			xil_printf("usbr2:\tUSB SW reset\n\r");
			xil_printf("dd:\tDCache Disable\n\r");
			xil_printf("de:\tDCache Enable\n\r");
			xil_printf("help:\thelp menu\n\r");
			xil_printf("---------------------------------------\n\r");
		}
		else if((buffer[0] == 'u')&&(buffer[1] == 's')&&(buffer[2] == 'b')&&(buffer[3] == 'r'))
		{
			xil_printf("\n\rPlease use 'usbr1' or 'usbr2'\n\r");
		}
		else if((buffer[0] == 't')&&(buffer[1] == 'i')&&(buffer[2] == 'm')&&(buffer[3] == 'e'))
		{
		}
		else if((buffer[0] == 'l')&&(buffer[1] == 'o')&&(buffer[2] == 'c')&&(buffer[3] == 'k'))
		{
		}
		else if((buffer[0] == 's')&&(buffer[1] == ' '))
		{
			if((buffer[2] < 0x30) || (buffer[2] > 0x39) || (buffer[3] < 0x30) || (buffer[3] > 0x39))
			{
				xil_printf("\nIllegal parameters.\n");
				return;
			}
			//PWM_start_duty = (buffer[2] - 0x30) * 10 + (buffer[3] - 0x30);
			//xil_printf("\nPWM_start_duty: ");printd(PWM_start_duty);xil_printf("\n\r");
		}
		else if((buffer[0] == 'd')&&(buffer[1] == ' '))
		{
			if((buffer[2] < 0x30) || (buffer[2] > 0x39) || (buffer[3] < 0x30) || (buffer[3] > 0x39))
			{
				xil_printf("\nIllegal parameters.\n");
				return;
			}
			//PWM_duty = (buffer[2] - 0x30) * 10 + (buffer[3] - 0x30);
			//xil_printf("\nPWM_duty: ");printd(PWM_duty);xil_printf("\n\r");
		}
		else if((buffer[0] == 't')&&(buffer[1] == ' '))
		{
			if((buffer[2] < 0x30) || (buffer[2] > 0x39) || (buffer[3] < 0x30) || (buffer[3] > 0x39))
			{
				xil_printf("\nIllegal parameters.\n\r");
				return;
			}
			//target_speed_tmp = (buffer[2] - 0x30) * 10 + (buffer[3] - 0x30);
			//SETUP_target_speed(target_speed_tmp);
			//xil_printf("\nTarget_speed: ");printd(target_speed);xil_printf("\n\r");
		}
	}
	else if(length == 4)
	{
		if((buffer[0] == 'u')&&(buffer[1] == 's')&&(buffer[2] == 'b'))
		{
			read_usb_registers();
		}
		else if((buffer[0] == 't')&&(buffer[1] == 'i')&&(buffer[2] == 'c'))
		{
			g_ms_tick = 0;
		}
		else if((buffer[0] == 't')&&(buffer[1] == 'o')&&(buffer[2] == 'c'))
		{
			uint32_t tt = g_ms_tick;
			uint32_t hh;
			uint32_t mm;
			uint32_t ss;
			uint32_t dd;

			dd = tt % 500 * 2;
			ss = (tt / 500) % 60;
			mm = ((tt / 500) / 60) % 60;
			hh = ((tt / 500) / 60) / 60;

			xil_printf("\n\rElasped time is %02d:%02d:%02d.%03d\n\r", hh, mm, ss, dd);
		}
		else if((buffer[0] == 'i')&&(buffer[1] == 'f')&&(buffer[2] == 'b'))
		{

		}
	}
	else if(length == 3)
	{
		if(((buffer[0] == 'l')&&(buffer[1] == 's'))||(buffer[0] == 'l')&&(buffer[1] == 'l'))
		{
			xil_printf("\n\r");
			xil_printf("Type `help' to see help list.\n\r");
		}
		else if((buffer[0] == 'd')&&(buffer[1] == 'e'))
		{
			xil_printf("Xil_DCacheEnable()\n\r");
			Xil_DCacheEnable();
		}
		else if((buffer[0] == 'd')&&(buffer[1] == 'd'))
		{
			xil_printf("Xil_DCacheDisable()\n\r");
			Xil_DCacheDisable();
		}
		else if((buffer[0] == 't')&&(buffer[1] == '1'))
		{
			xil_printf("test 1\n\r");
			reg = ULPI_OTG_CTRL;
			val = 0;
			val = ulpi_ReadReg(reg);
			xil_printf("read value : %02X\n\r", val);

			sleep(1);

			val &= 0xDF;
			xil_printf("set value : %02X\n\r", val);
			ulpi_WriteReg(val, reg);

			sleep(1);

			val = 0;
			val = ulpi_ReadReg(reg);
			xil_printf("read value : %02X\n\r", val);
		}
		else if((buffer[0] == 't')&&(buffer[1] == '2'))
		{
			xil_printf("test 2\n\r");
			reg = ULPI_OTG_CTRL;
			val = 0;
			val = ulpi_ReadReg(reg);
			xil_printf("read value : %02X\n\r", val);

			sleep(1);

			val |= 0x20;
			xil_printf("set value : %02X\n\r", val);
			ulpi_WriteReg(val, reg);

			sleep(1);

			val = 0;
			val = ulpi_ReadReg(reg);
			xil_printf("read value : %02X\n\r", val);
		}

	}
	else if(length == 2)
	{
		xil_printf("\n\r");
		if(buffer[0] == 'p')
		{
			xil_printf("show picture_old\n\r");
			gdispImage *p_Image;
			p_Image = &myImage;
			status = gdispImageOpenFile(p_Image, step_3);
			pixmap_draw(pixmap_1, surface_1, LAYER1_WIDTH, LAYER1_HEIGHT, p_Image, 0, 0, 0, 0);
			gdispBlitArea(LAYER0_WIDTH-LAYER1_WIDTH-BORDER_X, BORDER_Y, LAYER1_WIDTH, LAYER1_HEIGHT, surface_1);
			gdispImageClose(p_Image);
			Xil_DCacheFlush();
		}
		else if(buffer[0] == 'q')
		{
			xil_printf("show picture_new\n\r");
			XVMix_LayerDisable(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_1);
			gdispImage *p_Image;
			p_Image = &myImage;
			status = gdispImageOpenFile(p_Image, chicken_3);
			pixmap_draw(pixmap_1, surface_1, LAYER1_WIDTH, LAYER1_HEIGHT, p_Image, 0, 0, 0, 0);
			gdispBlitArea(LAYER0_WIDTH-LAYER1_WIDTH-BORDER_X, BORDER_Y, LAYER1_WIDTH, LAYER1_HEIGHT, surface_1);
			Xil_DCacheFlush();
			gdispImageClose(p_Image);
		}
		else if(buffer[0] == 's')
		{
			xil_printf("show picture_new my png\n\r");

			gdispImage *p_Image;

			XVMix_LayerDisable(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_1);
			p_Image = &myImage;
			status = gdispImageOpenFile(p_Image, pic11);
			pixmap_draw(pixmap_1, surface_1, LAYER1_WIDTH, LAYER1_HEIGHT, p_Image, 0, 0, 0, 0);
			gdispBlitArea(LAYER0_WIDTH-LAYER1_WIDTH-BORDER_X, BORDER_Y, LAYER1_WIDTH, LAYER1_HEIGHT, surface_1);
			Xil_DCacheFlush();
			gdispImageClose(p_Image);

			sleep(1);

			XVMix_LayerDisable(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_1);
			p_Image = &myImage;
			status = gdispImageOpenFile(p_Image, pic22);
			pixmap_draw(pixmap_1, surface_1, LAYER1_WIDTH, LAYER1_HEIGHT, p_Image, 0, 0, 0, 0);
			gdispBlitArea(LAYER0_WIDTH-LAYER1_WIDTH-BORDER_X, BORDER_Y, LAYER1_WIDTH, LAYER1_HEIGHT, surface_1);
			Xil_DCacheFlush();
			gdispImageClose(p_Image);

			sleep(1);


			XVMix_LayerDisable(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_1);
			p_Image = &myImage;
			status = gdispImageOpenFile(p_Image, pic33);
			pixmap_draw(pixmap_1, surface_1, LAYER1_WIDTH, LAYER1_HEIGHT, p_Image, 0, 0, 0, 0);
			gdispBlitArea(LAYER0_WIDTH-LAYER1_WIDTH-BORDER_X, BORDER_Y, LAYER1_WIDTH, LAYER1_HEIGHT, surface_1);
			Xil_DCacheFlush();
			gdispImageClose(p_Image);

			sleep(1);


			XVMix_LayerDisable(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_1);
			status = gdispImageOpenFile(p_Image, pic44);
			pixmap_draw(pixmap_1, surface_1, LAYER1_WIDTH, LAYER1_HEIGHT, p_Image, 0, 0, 0, 0);
			gdispBlitArea(LAYER0_WIDTH-LAYER1_WIDTH-BORDER_X, BORDER_Y, LAYER1_WIDTH, LAYER1_HEIGHT, surface_1);
			Xil_DCacheFlush();
			gdispImageClose(p_Image);

			sleep(1);


			XVMix_LayerDisable(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_1);
			p_Image = &myImage;
			status = gdispImageOpenFile(p_Image, pic55);
			pixmap_draw(pixmap_1, surface_1, LAYER1_WIDTH, LAYER1_HEIGHT, p_Image, 0, 0, 0, 0);
			gdispBlitArea(LAYER0_WIDTH-LAYER1_WIDTH-BORDER_X, BORDER_Y, LAYER1_WIDTH, LAYER1_HEIGHT, surface_1);
			Xil_DCacheFlush();
			gdispImageClose(p_Image);

			sleep(1);


			XVMix_LayerDisable(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_1);
			p_Image = &myImage;
			status = gdispImageOpenFile(p_Image, pic66);
			pixmap_draw(pixmap_1, surface_1, LAYER1_WIDTH, LAYER1_HEIGHT, p_Image, 0, 0, 0, 0);
			gdispBlitArea(LAYER0_WIDTH-LAYER1_WIDTH-BORDER_X, BORDER_Y, LAYER1_WIDTH, LAYER1_HEIGHT, surface_1);
			Xil_DCacheFlush();
			gdispImageClose(p_Image);


		}

		else if(buffer[0] == '1')
		{
			xil_printf("Enabling/bypassing Layer 1.\n\r");
			status = XVMix_IsLayerEnabled(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_1);
			if(status) { // Enabled
				XVMix_LayerDisable(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_1);
			} else {
				XVMix_LayerEnable(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_1);
			}
		}
		else if(buffer[0] == '2')
		{
			xil_printf("Enabling/bypassing Layer 2.\n\r");
			status = XVMix_IsLayerEnabled(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_2);
			if(status) { // Enabled
				XVMix_LayerDisable(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_2);
			} else {
				XVMix_LayerEnable(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_2);
			}
		}
		else if(buffer[0] == '3')
		{
			xil_printf("Enabling/bypassing Layer 3.\n\r");
			status = XVMix_IsLayerEnabled(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_3);
			if(status) { // Enabled
				XVMix_LayerDisable(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_3);
			} else {
				XVMix_LayerEnable(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_3);
			}
		}
		else if(buffer[0] == 't')
		{
			xil_printf("Enabling/bypassing camera TPG.\n\r");
			periphs_toggle_camera_tpg(&periphs_inst);
		}
		else if(buffer[0] == 'y')
		{
			xil_printf("Enabling/bypassing GUI TPG.\n\r");
			periphs_toggle_GUI_tpg(&periphs_inst);
		}
		else if(buffer[0] == 'u')
		{
			xil_printf("Park/Unpark Camera Freeze VDMA.\n\r");
			periphs_toggle_camera_freeze_vdma(&periphs_inst);
			// Determine if we're in TPG or passthrough mode
			if (periphs_inst.enable_camera_freeze_vdma == PERIPHS_SEL_ENABLE_PARK)
			{
				XVMix_LayerEnable(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_2);
			}
			else
			{
				XVMix_LayerDisable(periphs_inst.p_vid_output_mixer_l2_inst, XVMIX_LAYER_2);
			}
		}
		else if(buffer[0] == 'r')
		{
			//read_usb_registers();

			//read_usb_status();
			test_read_usb_descriptor();
		}
		else if(buffer[0] == 'g')
		{
			get_usb_descriptor();
		}
		else if(buffer[0] == 'd')
		{
			xil_printf("david debug\n\r");

			xil_printf("size of last_command is %d\n\r", sizeof(last_command));
		}
		else
		{
			xil_printf("Invalid command : %c\n\r", buffer[0]);
		}
	}
	length = 0;
}

void get_system_up_time(void)
{
	uint32_t tt = g_ms_uptime;
	uint32_t hh;
	uint32_t mm;
	uint32_t ss;
	uint32_t dd;

	dd = tt % 500 * 2;
	ss = (tt / 500) % 60;
	mm = ((tt / 500) / 60) % 60;
	hh = ((tt / 500) / 60) / 60;

	xil_printf("\n\rSystem up time is %02d:%02d:%02d.%03d\n\r", hh, mm, ss, dd);
}


