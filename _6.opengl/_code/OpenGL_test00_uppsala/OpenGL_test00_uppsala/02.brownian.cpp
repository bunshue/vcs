/***************************************************************************************
 * brownian.c                                                                          *
 *                                                                                     *
 *    This program draws a fractal line generated by one-dimensional Brownian motion.  *
 * Gaussian random numbers are summed to simulate the Brownian motion.                 *
 ***************************************************************************************/

#include "../../Common.h"

#include <math.h>
#include <time.h>
#include <stdlib.h>

#define POINTS     200
#define WINDOWSIZE 400

#define SEED srand
#define RANDNUM rand
#define RANDMAX RAND_MAX

typedef GLfloat point[2];

point points[POINTS];
int Arand, Nrand;
double GaussAdd, GaussFac, winLimit;

void InitGauss(int seed)
/* Routine for initializing the Gaussian random number generator. This is an
 * implementation of algorithm InitGauss on page 77 of "The Science of Fractal Images".
 */
{
    Nrand = 4;
    Arand = RANDMAX;
    GaussAdd = sqrt(3.0 * (double)Nrand);
    GaussFac = 2.0 * GaussAdd / ((double)Nrand * (double)Arand);
    SEED(seed);
}

double Gauss()
/* Routine to generate a Gaussian random number. This is an implementation of
 * algorithm Gauss on page 77 of "The Science of Fractal Images."
 */
{
    double sum;
    int i;

    sum = 0.0;
    for (i = 1; i <= Nrand; i++) sum += (double)RANDNUM();
    return (GaussFac * sum - GaussAdd);
}

void gfxinit()
/* This is the routine that generates the image to be displayed. */
{
    int i;

    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluOrtho2D(0.0, (double)(POINTS - 1), -winLimit, winLimit);
    glClearColor(1.0, 1.0, 1.0, 0.0); /* Make the background white.         */
    glColor3f(0.0, 0.0, 0.0);         /* Draw in black.                     */
    glNewList(1, GL_COMPILE);
    glBegin(GL_LINE_STRIP);        /* Draw a line defined by some points.*/
    for (i = 0; i < POINTS; i++) glVertex2fv(points[i]);
    glEnd();
    glEndList();
}

void display(void)
{
    glClear(GL_COLOR_BUFFER_BIT);
    glCallList(1);
    glFlush();
}

int main(int argc, char** argv)
{
    float displacement;
    int i;

    // Begin by computing the vertices for the line as the sum of Gaussian random variables.

    InitGauss((int)time(NULL));
    displacement = 0.0f;
    points[0][0] = points[0][1] = 0.0;
    for (i = 1; i < POINTS; i++)
    {
        displacement += (float)Gauss();
        points[i][0] = (float)i;
        points[i][1] = displacement;
    }
    winLimit = 2.0 * sqrt((double)POINTS);

    /* Set graphics window parameters. */

    glutInit(&argc, argv);
    glutInitWindowSize(WINDOWSIZE, WINDOWSIZE);
    glutInitWindowPosition(200, 200);
    glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);

    glutCreateWindow("Brownian Motion");

    glutDisplayFunc(display);   //設定callback function
    glutReshapeFunc(reshape0);   //設定callback function
    glutKeyboardFunc(keyboard0); //設定callback function

    gfxinit();

    glutMainLoop();	//開始主循環繪製

    return 0;
}

